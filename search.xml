<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>UE4-使用UMG的用户界面</title>
      <link href="/2022/05/10/UE4-%E4%BD%BF%E7%94%A8UMG%E7%9A%84%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2/"/>
      <url>/2022/05/10/UE4-%E4%BD%BF%E7%94%A8UMG%E7%9A%84%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="这是啥？"><a href="#这是啥？" class="headerlink" title="这是啥？"></a>这是啥？</h1><p>这就是UI界面，也就是登录界面，属性面板等等界面</p><h1 id="设置UMG的模块依赖性"><a href="#设置UMG的模块依赖性" class="headerlink" title="设置UMG的模块依赖性"></a>设置UMG的模块依赖性</h1><p>将.build.cs文件修改为以下样子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnrealBuildTool;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HowTo_UMG</span> : ModuleRules</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HowTo_UMG</span><span class="params">(ReadOnlyTargetRules Target)</span> : base(Target)</span></span><br><span class="line"><span class="function">    &#123;</span></span><br><span class="line">        PublicDependencyModuleNames.<span class="built_in">AddRange</span>(<span class="keyword">new</span> string[] &#123; <span class="string">&quot;Core&quot;</span>, <span class="string">&quot;CoreUObject&quot;</span>, <span class="string">&quot;Engine&quot;</span>, <span class="string">&quot;InputCore&quot;</span>, <span class="string">&quot;UMG&quot;</span> &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//PrivateDependencyModuleNames.AddRange(new string[] &#123;  &#125;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如使用Slate UI，则取消注释</span></span><br><span class="line">        PrivateDependencyModuleNames.<span class="built_in">AddRange</span>(<span class="keyword">new</span> string[] &#123; <span class="string">&quot;Slate&quot;</span>, <span class="string">&quot;SlateCore&quot;</span> &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如使用在线功能，则取消注释</span></span><br><span class="line">        <span class="comment">// PrivateDependencyModuleNames.Add(&quot;OnlineSubsystem&quot;);</span></span><br><span class="line">        <span class="comment">// if ((Target.Platform == UnrealTargetPlatform.Win32) || (Target.Platform == UnrealTargetPlatform.Win64))</span></span><br><span class="line">        <span class="comment">// &#123;</span></span><br><span class="line">        <span class="comment">//      if (UEBuildConfiguration.bCompileSteamOSS == true)</span></span><br><span class="line">        <span class="comment">//      &#123;</span></span><br><span class="line">        <span class="comment">//          DynamicallyLoadedModuleNames.Add(&quot;OnlineSubsystemSteam&quot;);</span></span><br><span class="line">        <span class="comment">//      &#125;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="扩展游戏模式"><a href="#扩展游戏模式" class="headerlink" title="扩展游戏模式"></a>扩展游戏模式</h1><h2 id="HowTo-UMGGameModeBase-h"><a href="#HowTo-UMGGameModeBase-h" class="headerlink" title="HowTo_UMGGameModeBase.h"></a>HowTo_UMGGameModeBase.h</h2><p>声明默认游戏菜单，变换游戏菜单两个函数，以及一个用作菜单的控件实例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CoreMinimal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GameFramework/GameModeBase.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Blueprint/UserWidget.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;HowTo_UMGGameModeBase.generated.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HOWTO_UMG_API</span> AHowTo_UMGGameMode : <span class="keyword">public</span> AGameModeBase</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** 移除当前菜单控件，并在指定类（如有）中新建控件。*/</span></span><br><span class="line">    <span class="built_in">UFUNCTION</span>(BlueprintCallable, Category = <span class="string">&quot;UMG Game&quot;</span>)</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">ChangeMenuWidget</span><span class="params">(TSubclassOf&lt;UUserWidget&gt; NewWidgetClass)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">/** 游戏开始时调用。*/</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BeginPlay</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 游戏开始时，用作菜单的控件类。*/</span></span><br><span class="line">    <span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadOnly, Category = <span class="string">&quot;UMG Game&quot;</span>)</span><br><span class="line">        TSubclassOf&lt;UUserWidget&gt; StartingWidgetClass;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 用作菜单的控件实例。*/</span></span><br><span class="line">    <span class="built_in">UPROPERTY</span>()</span><br><span class="line">        UUserWidget* CurrentWidget;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>TSubclassOf&lt;&gt;()</p><p>以&lt;&gt;内的参数为父类，创建一个对象</p><h2 id="HowTo-UMGGameModeBase-cpp"><a href="#HowTo-UMGGameModeBase-cpp" class="headerlink" title="HowTo_UMGGameModeBase.cpp"></a>HowTo_UMGGameModeBase.cpp</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;HowTo_UMG.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;HowTo_UMGGameModeBase.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AHowTo_UMGGameMode::BeginPlay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">BeginPlay</span>();</span><br><span class="line">    <span class="built_in">ChangeMenuWidget</span>(StartingWidgetClass);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AHowTo_UMGGameMode::ChangeMenuWidget</span><span class="params">(TSubclassOf&lt;UUserWidget&gt; NewWidgetClass)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (CurrentWidget != <span class="literal">nullptr</span>)<span class="comment">//如果存在当前菜单</span></span><br><span class="line">    &#123;</span><br><span class="line">        CurrentWidget-&gt;<span class="built_in">RemoveFromViewport</span>();<span class="comment">//将当前菜单从当前视口移除</span></span><br><span class="line">        CurrentWidget = <span class="literal">nullptr</span>;<span class="comment">//将当前菜单赋值为空</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (NewWidgetClass != <span class="literal">nullptr</span>)<span class="comment">//如果要转变的菜单不为空</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//将根据要转变的菜单创建一个菜单，并赋值给当前菜单</span></span><br><span class="line">        CurrentWidget = <span class="built_in">CreateWidget</span>&lt;UUserWidget&gt;(<span class="built_in">GetWorld</span>(), NewWidgetClass);</span><br><span class="line">        <span class="keyword">if</span> (CurrentWidget != <span class="literal">nullptr</span>)<span class="comment">//赋值成功</span></span><br><span class="line">        &#123;</span><br><span class="line">            CurrentWidget-&gt;<span class="built_in">AddToViewport</span>();<span class="comment">//将当前菜单添加到视口中</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ChangeMenuWidget()函数思路</p><ol><li><p>先搞清楚CurrentWidget是否为空，不为空，则代表视口内有菜单</p></li><li><p>将视口内的菜单移除</p></li><li><p>根据NewWidgetClass创建新的菜单，赋值给CurrentWidget</p></li><li><p>将CurrentWidget添加到视口内</p></li></ol><h2 id="HowTo-UMGPlayerController-h"><a href="#HowTo-UMGPlayerController-h" class="headerlink" title="HowTo_UMGPlayerController.h"></a>HowTo_UMGPlayerController.h</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GameFramework/PlayerController.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;HowTo_UMGPlayerController.generated.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HOWTO_UMG_API</span> AHowTo_UMGPlayerController : <span class="keyword">public</span> APlayerController</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BeginPlay</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>声明，以便重载BeginPlay()函数</p><h2 id="HowTo-UMGPlayerController-cpp"><a href="#HowTo-UMGPlayerController-cpp" class="headerlink" title="HowTo_UMGPlayerController.cpp"></a>HowTo_UMGPlayerController.cpp</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;HowTo_UMG.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;HowTo_UMGPlayerController.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AHowTo_UMGPlayerController::BeginPlay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">BeginPlay</span>();</span><br><span class="line">    <span class="built_in">SetInputMode</span>(<span class="built_in">FInputModeGameAndUI</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置输入模式为FInputModeGameAndUI()</p><h1 id="创建菜单控件蓝图"><a href="#创建菜单控件蓝图" class="headerlink" title="创建菜单控件蓝图"></a>创建菜单控件蓝图</h1><p>这个就相对简单了</p><p>首先右键内容浏览器-&gt;用户界面-&gt;空间蓝图 创建MainMenu和NewGameMenu两个菜单界面</p><p>分别表示主菜单和新游戏菜单</p><p>用Button和Text进行合理布局</p><p>为Button添加点击事件</p><p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/UMG/OnClicked_NewGame.jpg" alt="OnClicked_NewGame.png"></p><p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/UMG/OnClicked_Quit.jpg" alt="OnClicked_Quit.png"></p><p>这就涉及到蓝图的类型转换和Actor通信问题了</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul><li><p>将点击事件的类型转换为HowTo_UMGGameMode</p></li><li><p>如果转换成功，则访问Change Menu Widget函数</p></li><li><p>将New Widget Class设定为New Game Menu</p></li></ul><h1 id="配置游戏模式"><a href="#配置游戏模式" class="headerlink" title="配置游戏模式"></a>配置游戏模式</h1><p>基于项目的 <strong>GameMode</strong>，在 <strong>内容浏览器</strong> 中添加 <strong>蓝图类</strong>.利用此操作，可将这两个类上的公开变量设为需要的值。为此，需：</p><ul><li>在 <strong>内容浏览器</strong> 中点击的 <strong>添加</strong> 按钮。</li></ul><p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/UMG/AddNewBPClass.jpg" alt="AddNewBPClass.png"></p><ul><li>选择 <strong>HowTo_UMGGameMode</strong> 作为父类。其将被列入 <strong>所有类（All Classes）</strong> 部分。</li></ul><p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/UMG/PickParentClassForGameModeBP.jpg" alt="PickParentClassForGameModeBP.png"></p><ol><li><p>将得到的蓝图资源命名为MenuGameMode。</p></li><li><p>为使游戏光标出现在游戏中，需进行GameMode中的相同操作，创建 <strong>PlayerController</strong> 的蓝图。</p><ul><li><p>在 <strong>内容浏览器</strong> 中再次点击 <strong>添加</strong> 按钮。</p></li><li><p>在 <strong>常用类（Common Classes）</strong> 部分选择 <strong>玩家控制器</strong>。</p></li><li><p>将该蓝图命名为MenuPlayerController。</p></li></ul></li><li><p>编辑MenuPlayerController。</p><ul><li>勾选 <strong>显示鼠标光标（Show Mouse Cursor）</strong> 复选框。</li></ul></li></ol><p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/UMG/GamePlayerController.jpg" alt="GamePlayerController.png"></p><p>编辑MenuGameMode。</p><ul><li><p>须将 <strong>启动控件类（Starting Widget Class）</strong> 设为MainMenu资源，以便在游戏开始时打开菜单。</p></li><li><p>应将 <strong>默认Pawn类（Default Pawn Class）</strong> 设为 <strong>Pawn</strong> 而非 <strong>DefaultPawn</strong>，玩家便不会在菜单中乱飞。</p></li><li><p>应将 <strong>玩家控制器类</strong> 设为创建的MenuPlayerController资源，以便在游戏中显示鼠标光标。</p></li></ul><p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/UMG/ConfigureGameMode.jpg" alt="ConfigureGameMode.png"></p><p>为使用蓝图，必返回 <strong>关卡编辑器</strong> 窗口，并通过 <strong>设置</strong> 按钮修改当前 <strong>关卡</strong> 的 <strong>场景设置</strong>。</p><ol><li><strong>地图和模式</strong> 部分的 <strong>项目设置</strong></li></ol><p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/UMG/WorldSettings.webp" alt="WorldSettings.png"></p><p>将打开 <strong>场景设置面板</strong>。其将默认与 <strong>细节面板</strong> 停靠，但也可将其移动到其他位置。需将 <strong>游戏模式覆盖（Game Mode Override）</strong> 字段设为MenuGameMode资源。</p><p>自定义GameMode资源现已在关卡上生效，并被配置以加载主菜单，同时使用显示鼠标光标的玩家控制器。如现在运行游戏，退出按钮将预期生效，使用新游戏按钮将进入空白菜单。将在下一步中设置新游戏菜单。</p><h1 id="构建二级菜单"><a href="#构建二级菜单" class="headerlink" title="构建二级菜单"></a>构建二级菜单</h1><p>在NewGameMenu中合理设置按钮和文本布局</p><p>为确保仅在文本框非空白时启用按钮，可将文本框中的文本转换为字符串，然后检查其长度是否大于零。以下为此逻辑的显示方式：</p><ul><li>注意：哪个粉色的节点名称为”为文本”</li></ul><p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/UMG/PlayGameButtonEnableFunction.jpg" alt="PlayGameButtonEnableFunction.png"></p><p>再次添加 <strong>OnClicked</strong> 事件，向新按钮添加脚本。主菜单按钮将简单重加载主菜单控件，在 <strong>ChangeMenuWidget</strong> 函数的调用中不提供新控件，开始游戏按钮将停止菜单。显示短语 <strong>选择类</strong> 而非实际类或资产的命名，可对此进行显示。</p><p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/UMG/NewGameButtonBPs.jpg" alt="NewGameButtonBPs.png"></p><p>这个就根前文解释过的逻辑相同，此处不再赘述</p>]]></content>
      
      
      <categories>
          
          <category> unreal engine </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UE4-HowTo_PlayerInput</title>
      <link href="/2022/05/09/UE4-HowTo-PlayerInput/"/>
      <url>/2022/05/09/UE4-HowTo-PlayerInput/</url>
      
        <content type="html"><![CDATA[<h1 id="Fu-k-you-unreal-engine-filer"><a href="#Fu-k-you-unreal-engine-filer" class="headerlink" title="Fu*k you unreal engine filer!!!"></a>Fu*k you unreal engine filer!!!</h1><p>气死了兄弟们，官方案例《玩家输入和Pawn》里面的第一段——自定义Pawn</p><p>我真的是服了，上一章节是头文件名写错了，这一节干脆不写头文件名了，无语。</p><p>报错还奇奇怪怪的，虽然也猜到了是头文件的问题，我一开始还以为又是头文件名写错了，结果排查了半天，发现是这家伙根本没写，也是我学艺不精，竟然没有第一时间找到问题所在，总之是花费了大量时间在这个无聊的问题上！中途UE4还崩了一次！可恶啊！</p><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>首先这个功能其实并不难，在之前的第一人称FPS中我们已经实现了移动等功能，在此处新增的放大缩小功能，类比跳跃功能也非常好理解！</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>创建一个Actor为父类的C++类</p><ol><li><p>我们要控制这个Actor，所以我们需要将玩家默认控制设置一下</p></li><li><p>我们创建一个根组件，用来更新</p></li><li><p>然后需要创建一个可见的对象和一个摄像机</p></li><li><p>摄像机和可见组件都附加到根组件上</p></li><li><p>配置游戏输入</p></li><li><p>声明和定义游戏操作</p></li></ol><p>看起来一点也不难，如果理解了前面章节的内容的话，实际上也是如此。</p><h1 id="自定义Actor"><a href="#自定义Actor" class="headerlink" title="自定义Actor"></a>自定义Actor</h1><p>首先，最重要的是，我们在创建一个组件之前，一定要考虑清楚，需不需要额外引入头文件！比如说Camera组件！</p><p>官方代码运行不起来，不用管。在这里我就直接放修改好的代码了！</p><h2 id="MyPawn-h"><a href="#MyPawn-h" class="headerlink" title="MyPawn.h"></a>MyPawn.h</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CoreMinimal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GameFramework/Pawn.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Camera/CameraComponent.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyPawn.generated.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HOWTO_PLAYERINPUT_API</span> AMyPawn : <span class="keyword">public</span> APawn</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// Sets default values for this pawn&#x27;s properties</span></span><br><span class="line"><span class="built_in">AMyPawn</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="comment">// Called when the game starts or when spawned</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BeginPlay</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// Called every frame</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Tick</span><span class="params">(<span class="type">float</span> DeltaTime)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Called to bind functionality to input</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SetupPlayerInputComponent</span><span class="params">(<span class="keyword">class</span> UInputComponent* PlayerInputComponent)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line">USceneComponent* OurVisibleComponent;</span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line">UCameraComponent* OurCamera;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>.h部分主要注意的是头文件的引用</p><p>还有就是，声明部分一定要放在.h文件中，别学官方案例放在.cpp里面，到时候纠错都不好找地儿！</p><h2 id="MyPawn-cpp"><a href="#MyPawn-cpp" class="headerlink" title="MyPawn.cpp"></a>MyPawn.cpp</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyPawn.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Sets default values</span></span><br><span class="line">AMyPawn::<span class="built_in">AMyPawn</span>()</span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">// Set this pawn to call Tick() every frame.  You can turn this off to improve performance if you don&#x27;t need it.</span></span><br><span class="line">PrimaryActorTick.bCanEverTick = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// 将该Pawn设为由最小编号玩家控制</span></span><br><span class="line">AutoPossessPlayer = EAutoReceiveInput::Player0;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建可附加内容的虚拟根组件。</span></span><br><span class="line">RootComponent = <span class="built_in">CreateDefaultSubobject</span>&lt;USceneComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;RootComponent&quot;</span>));</span><br><span class="line"><span class="comment">// 创建相机和可见对象</span></span><br><span class="line">OurCamera = <span class="built_in">CreateDefaultSubobject</span>&lt;UCameraComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;OurCamera&quot;</span>));</span><br><span class="line">OurVisibleComponent = <span class="built_in">CreateDefaultSubobject</span>&lt;UStaticMeshComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;OurVisibleComponent&quot;</span>));</span><br><span class="line"><span class="comment">// 将相机和可见对象附加到根组件。偏移并旋转相机。</span></span><br><span class="line">OurCamera-&gt;<span class="built_in">SetupAttachment</span>(RootComponent);</span><br><span class="line">OurCamera-&gt;<span class="built_in">SetRelativeLocation</span>(<span class="built_in">FVector</span>(<span class="number">-250.0f</span>, <span class="number">0.0f</span>, <span class="number">250.0f</span>));</span><br><span class="line">OurCamera-&gt;<span class="built_in">SetRelativeRotation</span>(<span class="built_in">FRotator</span>(<span class="number">-45.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>));</span><br><span class="line">OurVisibleComponent-&gt;<span class="built_in">SetupAttachment</span>(RootComponent);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Called when the game starts or when spawned</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMyPawn::BeginPlay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Super::<span class="built_in">BeginPlay</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Called every frame</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMyPawn::Tick</span><span class="params">(<span class="type">float</span> DeltaTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Super::<span class="built_in">Tick</span>(DeltaTime);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Called to bind functionality to input</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMyPawn::SetupPlayerInputComponent</span><span class="params">(UInputComponent* PlayerInputComponent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Super::<span class="built_in">SetupPlayerInputComponent</span>(PlayerInputComponent);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里很简单，和前面章节的操作基本一致，根官方案例对比起来。</p><p>其实就是我把OurCamera的声明放进.h文件中去了，结构看起来更清晰。</p><h1 id="配置游戏输入"><a href="#配置游戏输入" class="headerlink" title="配置游戏输入"></a>配置游戏输入</h1><p>这个就按照官网的来吧，没啥太多需要注意的</p><p>唯一注意的是，映射名称一定要能望文生义，与后面声明定义的移动，放大函数名相同。</p><h1 id="编写和绑定游戏操作"><a href="#编写和绑定游戏操作" class="headerlink" title="编写和绑定游戏操作"></a>编写和绑定游戏操作</h1><p>这个步骤无非就是，先声明及定义函数，然后再将函数在<code>AMyPawn::SetupPlayerInputComponent</code>中用<code>BindAction</code>和<code>BindAxis</code>进行绑定</p><p>最后在<code>AMyPawn::Tick</code>实时更新放大缩小的效果以及移动</p><h2 id="编写函数"><a href="#编写函数" class="headerlink" title="编写函数"></a>编写函数</h2><p>首先在.h文件中声明函数和变量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输入函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Move_XAxis</span><span class="params">(<span class="type">float</span> AxisValue)</span></span>;<span class="comment">//前进后退</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Move_YAxis</span><span class="params">(<span class="type">float</span> AxisValue)</span></span>;<span class="comment">//左右移动</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">StartGrowing</span><span class="params">()</span></span>;<span class="comment">//开始变大</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">StopGrowing</span><span class="params">()</span></span>;<span class="comment">//停止变大</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//输入变量</span></span><br><span class="line">    FVector CurrentVelocity;<span class="comment">//当前速度</span></span><br><span class="line">    <span class="type">bool</span> bGrowing;<span class="comment">//是否变大</span></span><br></pre></td></tr></table></figure><p>然后在.cpp文件中定义函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMyPawn::Move_XAxis</span><span class="params">(<span class="type">float</span> AxisValue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 以100单位/秒的速度向前或向后移动</span></span><br><span class="line">    CurrentVelocity.X = FMath::<span class="built_in">Clamp</span>(AxisValue, <span class="number">-1.0f</span>, <span class="number">1.0f</span>) * <span class="number">100.0f</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMyPawn::Move_YAxis</span><span class="params">(<span class="type">float</span> AxisValue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 以100单位/秒的速度向右或向左移动</span></span><br><span class="line">    CurrentVelocity.Y = FMath::<span class="built_in">Clamp</span>(AxisValue, <span class="number">-1.0f</span>, <span class="number">1.0f</span>) * <span class="number">100.0f</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMyPawn::StartGrowing</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bGrowing = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMyPawn::StopGrowing</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bGrowing = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里实现Actor移动的方式还挺别致的，是创建一个FVector来实现移动的，同时我们也可以采取另一种思路来实现移动</p><p>以下是第一人称FPS案例中实现移动的方法：</p><ul><li><p>首先获取玩家方向</p></li><li><p>然后调用AddMovementInput来进行移动</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::MoveForward</span><span class="params">(<span class="type">float</span> Value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 找出&quot;前进&quot;方向，并记录玩家想向该方向移动。</span></span><br><span class="line">    FVector Direction = <span class="built_in">FRotationMatrix</span>(Controller-&gt;<span class="built_in">GetControlRotation</span>()).<span class="built_in">GetScaledAxis</span>(EAxis::X);</span><br><span class="line">    <span class="built_in">AddMovementInput</span>(Direction, Value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::MoveRight</span><span class="params">(<span class="type">float</span> Value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 找出&quot;右侧&quot;方向，并记录玩家想向该方向移动。</span></span><br><span class="line">    FVector Direction = <span class="built_in">FRotationMatrix</span>(Controller-&gt;<span class="built_in">GetControlRotation</span>()).<span class="built_in">GetScaledAxis</span>(EAxis::Y);</span><br><span class="line">    <span class="built_in">AddMovementInput</span>(Direction, Value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来在<strong>AMyPawn::SetupPlayerInputComponent</strong> 中绑定映射</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在按下或松开&quot;Grow&quot;键时做出响应。</span></span><br><span class="line">InputComponent-&gt;<span class="built_in">BindAction</span>(<span class="string">&quot;Grow&quot;</span>, IE_Pressed, <span class="keyword">this</span>, &amp;AMyPawn::StartGrowing);</span><br><span class="line">InputComponent-&gt;<span class="built_in">BindAction</span>(<span class="string">&quot;Grow&quot;</span>, IE_Released, <span class="keyword">this</span>, &amp;AMyPawn::StopGrowing);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对两个移动轴&quot;MoveX&quot;和&quot;MoveY&quot;的值逐帧反应。</span></span><br><span class="line">InputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="string">&quot;MoveX&quot;</span>, <span class="keyword">this</span>, &amp;AMyPawn::Move_XAxis);</span><br><span class="line">InputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="string">&quot;MoveY&quot;</span>, <span class="keyword">this</span>, &amp;AMyPawn::Move_YAxis);</span><br></pre></td></tr></table></figure><p>最后在<strong>AMyPawn::Tick</strong>中实时更新Actor的大小和移动</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据&quot;Grow&quot;操作处理增长和缩减</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> CurrentScale = OurVisibleComponent-&gt;<span class="built_in">GetComponentScale</span>().X;</span><br><span class="line">    <span class="keyword">if</span> (bGrowing)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 一秒内增长到两倍大小</span></span><br><span class="line">        CurrentScale += DeltaTime;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 以增长速度缩减一半</span></span><br><span class="line">        CurrentScale -= (DeltaTime * <span class="number">0.5f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 确保不会降至初始大小以下，或者增至两倍大小以上。</span></span><br><span class="line">    CurrentScale = FMath::<span class="built_in">Clamp</span>(CurrentScale, <span class="number">1.0f</span>, <span class="number">2.0f</span>);</span><br><span class="line">    OurVisibleComponent-&gt;<span class="built_in">SetWorldScale3D</span>(<span class="built_in">FVector</span>(CurrentScale));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据&quot;MoveX&quot;和&quot;MoveY&quot;轴处理移动</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!CurrentVelocity.<span class="built_in">IsZero</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        FVector NewLocation = <span class="built_in">GetActorLocation</span>() + (CurrentVelocity * DeltaTime);</span><br><span class="line">        <span class="built_in">SetActorLocation</span>(NewLocation);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> unreal engine </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UE4-蓝图-钥匙开门</title>
      <link href="/2022/05/06/UE4-%E8%93%9D%E5%9B%BE-%E9%92%A5%E5%8C%99%E5%BC%80%E9%97%A8/"/>
      <url>/2022/05/06/UE4-%E8%93%9D%E5%9B%BE-%E9%92%A5%E5%8C%99%E5%BC%80%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p>这一节是根据<a href="https://space.bilibili.com/31898841">谌嘉诚</a>的蓝图教程进行整理的！</p><p>在前面我们制作了自动门，按键开门这两种门，其实还有升降电梯等案例，但是其实与开门的蓝图类差不太多，顶多就是修改一下更新的不是按轴旋转，而是直接更改相对位置了。</p><p>接下来的是拾取钥匙开门，这涉及到了蓝图Actor之间的通信</p><h1 id="门蓝图"><a href="#门蓝图" class="headerlink" title="门蓝图"></a>门蓝图</h1><p>主体蓝图部分和开门没有区别，唯一需要修改的地方是</p><ul><li><p>创建一个bool类型变量，命名为IsKey，默认设置为false</p></li><li><p>沿着IsKey拖出一条引线，创建一个名为”分支”的结点</p></li><li><p>将键盘E拖出一个结点，连接上分支结点</p></li><li><p>True输出链接Gate的Open</p></li><li><p>False输出链接一个“打印字符串”节点</p></li></ul><h1 id="钥匙蓝图"><a href="#钥匙蓝图" class="headerlink" title="钥匙蓝图"></a>钥匙蓝图</h1><p>前部分的蓝图与普通门蓝图一致，需要注意的是Gate之后的节点</p><ul><li><p>Gate输出创建一个“获取类的所有Actor”节点，顾名思义，可以选择一个类，获取其下所有的actor</p></li><li><p>在Actor Class选项中选择BP_KeyDoor（门的类名）</p></li><li><p>Out Actor输出创建一个Get（复制）节点【获取数组中下标为i的元素】</p></li><li><p>接着从Get节点输出一个Set IsKey节点，在这个节点内就可改变IsKey的值</p></li><li><p>将获取类的所有actor输出与set节点的输入连接上</p></li><li><p>最后我们需要销毁钥匙，于是在set输出链接一个“销毁Actor”节点</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> unreal engine </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 蓝图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UE4-Player-Controlled Cameras</title>
      <link href="/2022/05/06/UE4-Player-Controlled-Cameras/"/>
      <url>/2022/05/06/UE4-Player-Controlled-Cameras/</url>
      
        <content type="html"><![CDATA[<p>今天是官方案例<a href="(https://docs.unrealengine.com/4.27/zh-CN/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/PlayerCamera/">Player-Controlled Cameras</a></p><h1 id="给我整无语了"><a href="#给我整无语了" class="headerlink" title="给我整无语了"></a>给我整无语了</h1><p>我现在使用的是4.27的版本文档，我是真的服了官方写这个文档的家伙了，咱作为萌新吧，看这玩意，学习顺序安排得不合理就算了，很多项目拿着官方给出的代码都运行不出来，真的是太无语了。</p><p>这一节最明显的一个错误——<code># include &quot;Camera/Component.h&quot;</code>根本没这个头文件啊！兄弟！真的无语了，头文件都打错了，原本的头文件名为<code># include &quot;Camera/CameraComponent.h&quot;</code>!</p><p>可恶！负责官方文档编写的人得扣工资，你说这种问题，是一个正常程序员能犯得错误嘛？</p><p>tnnd，跟我玩阴的是吧？你爹我是来学习的还是来给你纠错的？f**k u！</p><p>除了以上错误，还有别的我没发现的，我估摸着可能是头文件的问题，但是也懒得找了。</p><p>我就单分析代码实现当中的API和一些实现逻辑好了。</p><h1 id="摄像机连接到Pawn"><a href="#摄像机连接到Pawn" class="headerlink" title="摄像机连接到Pawn"></a>摄像机连接到Pawn</h1><p>直接上代码</p><h2 id="PawnWithCamera-h"><a href="#PawnWithCamera-h" class="headerlink" title="PawnWithCamera.h"></a>PawnWithCamera.h</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CoreMinimal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GameFramework/Pawn.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;PawnWithCamera.generated.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HOWTO_PLAYERCAMERA_API</span> APawnWithCamera : <span class="keyword">public</span> APawn</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 为Pawn的属性设置默认值</span></span><br><span class="line">    <span class="built_in">APawnWithCamera</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// 游戏开始时或对象生成时调用</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BeginPlay</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 每帧调用</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Tick</span><span class="params">( <span class="type">float</span> DeltaSeconds )</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于绑定功能和输入</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SetupPlayerInputComponent</span><span class="params">(<span class="keyword">class</span> UInputComponent* InputComponent)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">USpringArmComponent</span>* SpringArmComp;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">UCameraComponent</span>* CameraComp;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line">    UStaticMeshComponent* StaticMeshComp;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>头文件的变化仅在于声明了弹簧臂组件类和摄像机组件类以及一个静态网格体组件</p><h2 id="PawnWithCamera-cpp"><a href="#PawnWithCamera-cpp" class="headerlink" title="PawnWithCamera.cpp"></a>PawnWithCamera.cpp</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;HowTo_PlayerCamera.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;PawnWithCamera.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GameFramework/SpringArmComponent.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Camera/CameraComponent.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置默认值</span></span><br><span class="line">APawnWithCamera::<span class="built_in">APawnWithCamera</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 让这个Pawn每帧调用Tick()。如不需要，你可以关闭这个函数以便提升性能。</span></span><br><span class="line">    PrimaryActorTick.bCanEverTick = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建组件</span></span><br><span class="line">    RootComponent = <span class="built_in">CreateDefaultSubobject</span>&lt;USceneComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;RootSceneComponent&quot;</span>));</span><br><span class="line">    StaticMeshComp = CreateDefaultSubobject &lt;UStaticMeshComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;StaticMeshComponent&quot;</span>));</span><br><span class="line">    SpringArmComp = <span class="built_in">CreateDefaultSubobject</span>&lt;USpringArmComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;SpringArmComponent&quot;</span>));</span><br><span class="line">    CameraComp = <span class="built_in">CreateDefaultSubobject</span>&lt;UCameraComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;CameraComponent&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定组件</span></span><br><span class="line">    StaticMeshComp-&gt;<span class="built_in">SetupAttachment</span>(RootComponent);</span><br><span class="line">    SpringArmComp-&gt;<span class="built_in">SetupAttachment</span>(StaticMeshComp);</span><br><span class="line">    CameraComp-&gt;<span class="built_in">SetupAttachment</span>(SpringArmComp,USpringArmComponent::SocketName);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为SpringArm类的变量赋值</span></span><br><span class="line">    SpringArmComp-&gt;<span class="built_in">SetRelativeLocationAndRotation</span>(<span class="built_in">FVector</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">50.0f</span>), <span class="built_in">FRotator</span>(<span class="number">-60.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>));</span><br><span class="line">    SpringArmComp-&gt;TargetArmLength = <span class="number">400.f</span>;</span><br><span class="line">    SpringArmComp-&gt;bEnableCameraLag = <span class="literal">true</span>;</span><br><span class="line">    SpringArmComp-&gt;CameraLagSpeed = <span class="number">3.0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 控制默认玩家</span></span><br><span class="line">    AutoPossessPlayer = EAutoReceiveInput::Player0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 游戏开始时或对象生成时调用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">APawnWithCamera::BeginPlay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">BeginPlay</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每帧调用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">APawnWithCamera::Tick</span><span class="params">( <span class="type">float</span> DeltaTime )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">Tick</span>( DeltaTime );</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于绑定功能和输入</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">APawnWithCamera::SetupPlayerInputComponent</span><span class="params">(<span class="keyword">class</span> UInputComponent* InputComponent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">SetupPlayerInputComponent</span>(InputComponent);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="首先创建组件"><a href="#首先创建组件" class="headerlink" title="首先创建组件"></a>首先创建组件</h3><ul><li>根组件，静态网格体组件，弹簧臂组件，摄像机组件</li></ul><h3 id="然后绑定组件"><a href="#然后绑定组件" class="headerlink" title="然后绑定组件"></a>然后绑定组件</h3><ul><li><p>将静态网格体组件绑定在根组件之下，保证更新的是静态网格体</p></li><li><p>将弹簧臂组件绑定在静态网格体之下</p></li><li><p>再将摄像机插入弹簧臂的插槽上</p></li></ul><h3 id="接下来设置弹簧臂类的变量值"><a href="#接下来设置弹簧臂类的变量值" class="headerlink" title="接下来设置弹簧臂类的变量值"></a>接下来设置弹簧臂类的变量值</h3><ul><li><p>首先设置相对位置和角度</p></li><li><p>弹簧臂长度</p></li><li><p>启用弹簧臂平滑切换</p></li><li><p>设置平滑切换时间</p></li></ul><h3 id="最后是将默认玩家设置一下"><a href="#最后是将默认玩家设置一下" class="headerlink" title="最后是将默认玩家设置一下"></a>最后是将默认玩家设置一下</h3><p>单人的话，默认玩家编号为Player0</p><h1 id="定义输入函数和绑定操作"><a href="#定义输入函数和绑定操作" class="headerlink" title="定义输入函数和绑定操作"></a>定义输入函数和绑定操作</h1><p>前面的配置输入我就不讲了，之前的博客里面讲的很详细，或者去官网看看也可以，基本上没啥错误。这里直接过一下绑定输入操作。</p><h2 id="声明成员变量和成员函数"><a href="#声明成员变量和成员函数" class="headerlink" title="声明成员变量和成员函数"></a>声明成员变量和成员函数</h2><p>首先我们需要定义一些成员变量来存储接收到的输入数据</p><ul><li><p>在帧更新的时候，我们需要获取移动数据和鼠标轴的移动方向数据，这都是二维向量类型的数值</p></li><li><p>还有摄像机画面是要放大还是缩小，以及摄像机当前状态距离到达这两种状态还有多少距离</p></li></ul><p>所以我们在.h文件的protected:下定义以下代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输入变量</span></span><br><span class="line">FVector2D MovementInput;<span class="comment">//移动数据</span></span><br><span class="line">FVector2D CameraInput;<span class="comment">//鼠标轴的移动方向数据</span></span><br><span class="line"><span class="type">float</span> ZoomFactor;<span class="comment">//距离放大缩小还有多远</span></span><br><span class="line"><span class="type">bool</span> bZoomingIn;<span class="comment">//放大还是缩小</span></span><br></pre></td></tr></table></figure><p>还需要创建函数来跟踪输入，所以我们在.h中声明以下函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输入函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MoveForward</span><span class="params">(<span class="type">float</span> AxisValue)</span></span>;<span class="comment">//前后移动</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MoveRight</span><span class="params">(<span class="type">float</span> AxisValue)</span></span>;<span class="comment">//左右移动</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PitchCamera</span><span class="params">(<span class="type">float</span> AxisValue)</span></span>;<span class="comment">//绕Y轴旋转（上下颠簸）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">YawCamera</span><span class="params">(<span class="type">float</span> AxisValue)</span></span>;<span class="comment">//绕Z轴旋转（左右拐弯）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ZoomIn</span><span class="params">()</span></span>;<span class="comment">//放大</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ZoomOut</span><span class="params">()</span></span>;<span class="comment">//缩小</span></span><br></pre></td></tr></table></figure><p>1 Roll 是自身旋转<br>2 Yaw 是左右拐弯<br>3 pitch 是上下颠动</p><h2 id="定义成员函数"><a href="#定义成员函数" class="headerlink" title="定义成员函数"></a>定义成员函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输入函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">APawnWithCamera::MoveForward</span><span class="params">(<span class="type">float</span> AxisValue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MovementInput.X = FMath::<span class="built_in">Clamp</span>&lt;<span class="type">float</span>&gt;(AxisValue, <span class="number">-1.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">APawnWithCamera::MoveRight</span><span class="params">(<span class="type">float</span> AxisValue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MovementInput.Y = FMath::<span class="built_in">Clamp</span>&lt;<span class="type">float</span>&gt;(AxisValue, <span class="number">-1.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">APawnWithCamera::PitchCamera</span><span class="params">(<span class="type">float</span> AxisValue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CameraInput.Y = AxisValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">APawnWithCamera::YawCamera</span><span class="params">(<span class="type">float</span> AxisValue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CameraInput.X = AxisValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">APawnWithCamera::ZoomIn</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bZoomingIn = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">APawnWithCamera::ZoomOut</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bZoomingIn = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得一提的是<code>Clamp&lt;float&gt;(AxisValue, -1.0f, 1.0f);</code>在前面的章节中我讲得不清楚，现在终于弄明白了！</p><p>&lt;&gt;内是参数类型，</p><p><code>Clamp(const FVector4 &amp; VectorToClamp, float Min, float Max)</code>是其函数原型</p><ul><li><p>这个Clamp其实看作是一种运算，可以把它看成一个一元一次方程</p></li><li><p>VectorToClamp就是这个方程的X，最后得出的Y</p></li><li><p>MIN 和MAX是设定的最大值和最小值</p></li><li><p>Y一定在MIN和MAX之间</p></li></ul><h2 id="绑定轴映射事件和按键映射事件"><a href="#绑定轴映射事件和按键映射事件" class="headerlink" title="绑定轴映射事件和按键映射事件"></a>绑定轴映射事件和按键映射事件</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 绑定&quot;ZoomIn&quot;的事件</span></span><br><span class="line">InputComponent-&gt;<span class="built_in">BindAction</span>(<span class="string">&quot;ZoomIn&quot;</span>, IE_Pressed, <span class="keyword">this</span>, &amp;APawnWithCamera::ZoomIn);</span><br><span class="line">InputComponent-&gt;<span class="built_in">BindAction</span>(<span class="string">&quot;ZoomIn&quot;</span>, IE_Released, <span class="keyword">this</span>, &amp;APawnWithCamera::ZoomOut);</span><br><span class="line"></span><br><span class="line"><span class="comment">//为四条轴绑定事件（每帧调用）</span></span><br><span class="line">InputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="string">&quot;MoveForward&quot;</span>, <span class="keyword">this</span>, &amp;APawnWithCamera::MoveForward);</span><br><span class="line">InputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="string">&quot;MoveRight&quot;</span>, <span class="keyword">this</span>, &amp;APawnWithCamera::MoveRight);</span><br><span class="line">InputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="string">&quot;CameraPitch&quot;</span>, <span class="keyword">this</span>, &amp;APawnWithCamera::PitchCamera);</span><br><span class="line">InputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="string">&quot;CameraYaw&quot;</span>, <span class="keyword">this</span>, &amp;APawnWithCamera::YawCamera);</span><br></pre></td></tr></table></figure><p>这个在之前博客里已经讲得很详细了，就不再赘述。</p><h2 id="在Tick事件内绑定放大缩小"><a href="#在Tick事件内绑定放大缩小" class="headerlink" title="在Tick事件内绑定放大缩小"></a>在Tick事件内绑定放大缩小</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">APawnWithCamera::Tick</span><span class="params">( <span class="type">float</span> DeltaTime )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">Tick</span>(DeltaTime);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按下ZoomIn按钮时进行放大，否则恢复正常</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (bZoomingIn)<span class="comment">//按下按钮事件</span></span><br><span class="line">        &#123;</span><br><span class="line">            ZoomFactor += DeltaTime / <span class="number">0.5f</span>;<span class="comment">//放大0.5秒以上</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//松开按钮事件</span></span><br><span class="line">        &#123;</span><br><span class="line">            ZoomFactor -= DeltaTime / <span class="number">0.25f</span>;<span class="comment">//缩小0.25秒以上</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        ZoomFactor = FMath::<span class="built_in">Clamp</span>&lt;<span class="type">float</span>&gt;(ZoomFactor, <span class="number">0.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">        <span class="comment">// 基于ZoomFactor设置摄像机的视野（范围）和SpringArm的长度 （范围）</span></span><br><span class="line">        CameraComp-&gt;FieldOfView = FMath::<span class="built_in">Lerp</span>&lt;<span class="type">float</span>&gt;(<span class="number">90.0f</span>, <span class="number">60.0f</span>, ZoomFactor);</span><br><span class="line">        SpringArmComp-&gt;TargetArmLength = FMath::<span class="built_in">Lerp</span>&lt;<span class="type">float</span>&gt;(<span class="number">400.0f</span>, <span class="number">300.0f</span>, ZoomFactor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 旋转Actor的偏转角度，由于摄像机与Actor相互绑定，因此摄像机也会偏转</span></span><br><span class="line">    &#123;</span><br><span class="line">        FRotator NewRotation = <span class="built_in">GetActorRotation</span>();</span><br><span class="line">        NewRotation.Yaw += CameraInput.X;</span><br><span class="line">        <span class="built_in">SetActorRotation</span>(NewRotation);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 旋转摄像机的俯仰角度，但对其进行限制，确保我们始终朝下看</span></span><br><span class="line">    &#123;</span><br><span class="line">        FRotator NewRotation = SpringArmComp-&gt;<span class="built_in">GetComponentRotation</span>();</span><br><span class="line">        NewRotation.Pitch = FMath::<span class="built_in">Clamp</span>(NewRotation.Pitch + CameraInput.Y, <span class="number">-80.0f</span>, <span class="number">-15.0f</span>);</span><br><span class="line">        SpringArmComp-&gt;<span class="built_in">SetWorldRotation</span>(NewRotation);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据&quot;MoveX&quot;和&quot;MoveY&quot;的处理移动</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!MovementInput.<span class="built_in">IsZero</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//把移动轴的输入数值放大100倍</span></span><br><span class="line">            MovementInput = MovementInput.<span class="built_in">SafeNormal</span>() * <span class="number">100.0f</span>;</span><br><span class="line">            FVector NewLocation = <span class="built_in">GetActorLocation</span>();</span><br><span class="line">            NewLocation += <span class="built_in">GetActorForwardVector</span>() * MovementInput.X * DeltaTime;</span><br><span class="line">            NewLocation += <span class="built_in">GetActorRightVector</span>() * MovementInput.Y * DeltaTime;</span><br><span class="line">            <span class="built_in">SetActorLocation</span>(NewLocation);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Lerp<float>(MAX,MIN,float Alpha)</p><p>Alpha在通过Lerp运算后，得到的结果在MAX和MIN之间</p><h3 id="代码逻辑"><a href="#代码逻辑" class="headerlink" title="代码逻辑"></a>代码逻辑</h3><ul><li><p>首先我们根据按钮的按下或者松开来对ZoomFactor这个变量进行增加或者减小</p></li><li><p>然后根据ZoomFactor带入到Clamp来保证其值大于0，小于1</p></li><li><p>接下来将ZoomFactor带入到Lerp中设置摄像机的视野和弹簧臂的长度（均设置范围）</p></li><li><p>直接设置Actor的旋转角度，因为摄像机与其绑定，所以会连带着摄像机一同旋转</p></li><li><p>限定弹簧臂的俯仰角度，确保我们对其一直是俯视状态</p><ul><li>注意：设置弹簧臂的旋转角度的时候一定要是世界坐标内的旋转角度</li></ul></li><li><p>再就是设置X与Y轴的移动变化</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> unreal engine </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一些鸡汤</title>
      <link href="/2022/05/05/%E4%B8%80%E4%BA%9B%E9%B8%A1%E6%B1%A4/"/>
      <url>/2022/05/05/%E4%B8%80%E4%BA%9B%E9%B8%A1%E6%B1%A4/</url>
      
        <content type="html"><![CDATA[<p>这是一篇写给自己看的流水账。</p><p>距离上一次靠文字排解自己的心情，已经过了一个月。</p><p>在这一个月的时间里面，我过得真的挺充实的，算法的学习完成了一个小的阶段，同时也开始了unreal engine 的学习，上午算法，下午unreal engine，晚上健身和娱乐。每天做着大体相同的事情，但每天都有不同的收获。</p><p>相比之前的基础性知识的积累，现在的unreal engine给到我的正向反馈，让我学习兴趣大大增加，也报了<a href="https://space.bilibili.com/31898841">谌嘉诚</a>的虚幻课程，这个月底就要开始正式进行一个完整的项目了，这让我对未来充满了信心。</p><p>再就是健身，这一个月以来，每天坚持健身，特别是每次在镜子里看到我的肌肉线条慢慢明显的时候，就很开心——我要变成猛男了哈哈哈！</p><p>虽然也有苦恼的，就是右臂肌肉比左臂大一倍，这一点目前还没有什么很好解决的办法。</p><p>偶尔晚上健身完之后我会试试正念冥想——虽然还没有感受到实质性的好处，但是我是在冥想结束后动了写下这篇文字的念头的——这样想来，也许冥想能让我沉静下来，将我原本并未意识到的需求在这时告诉我。</p><p>再来说一说社交情况，实话实说，目前为止我基本已经停止了大部分社交活动，也不再出席任何社交场合，室友去图书馆备战考研，我就在寝室自己学自己的，我们一天也见不了几面，晚上回来和我的交流兴许也是寥寥几句。现在我的社交完全就是靠着和高中同学以及发小的吹牛打屁撑着的。本来我以为我会在某一刻崩掉，但是到目前为止，我的状态还算ok。哦，还有一件事，有个高中同学前几天跟对象掰了。来找我倾诉，我能有啥立场？自然是跟他穿一条裤子呗。他可能觉得，我这会是听他倾诉了，他觉得我很铁，但不完全是，我心态没崩可能也和他有关，他在我要崩的那个临界点出现了。也算是相互拉了一把。</p><p>还有每天都会在网上看各种各样的美女，因为听说看美女能够益寿延年。</p><p>哈哈，果然只有当人处于悲伤的状态下才会文思泉涌，我现在就完全没话说了。</p><p>那，就这样吧！</p>]]></content>
      
      
      <categories>
          
          <category> 梦游笔谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嬉荒杂录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UE4-蓝图-开关门</title>
      <link href="/2022/05/03/UE4-%E8%93%9D%E5%9B%BE-%E5%BC%80%E5%85%B3%E9%97%A8/"/>
      <url>/2022/05/03/UE4-%E8%93%9D%E5%9B%BE-%E5%BC%80%E5%85%B3%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p>本博客是根据哔哩哔哩UP主<a href="https://space.bilibili.com/31898841">谌嘉诚</a>出品的<a href="https://www.bilibili.com/video/BV164411Y732?p=28">UE4初学者系列教程合集-全中文新手入门教程</a>进行整理的，他把基础部分和蓝图部分讲解地非常细致而且通俗易懂，有兴趣的可以去看看。</p><h1 id="按E键实现开关门"><a href="#按E键实现开关门" class="headerlink" title="按E键实现开关门"></a>按E键实现开关门</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul><li><p>我们根据碰撞盒子（box collision）来判断啥时候可以按E开门，也就是进入到这个碰撞盒子的范围的时候，我们就可以按E了</p></li><li><p>我们在组件面板里面添加一个box collision，然后左键选中它，添加两个碰撞事件——开始重叠和离开重叠</p></li><li><p>然后我们要明确一点——输入E是要启用输入的！于是创建enable input结点和disable input两个结点来启用和禁用输入，在这个节点上会有player controller这个东西，那就创建一个get palyer controller结点连接上即可！</p></li><li><p>接下来是流程控制结点gate，启用输入连接到open，禁用输入连接到close，把按键E链接到Enter</p></li><li><p>后面是另一个流程控制结点——Filp Flop这个东西的意思是，第一次执行则从A点输出，第二次执行则从B点输出，以此往复，后面就可以将AB分别连接到时间轴的play和reverse上，即可实现正向开门和关门了</p></li><li><p>创建时间轴——创建一个时间轴，双击编辑他并创建一个浮点型轨道“开关门时间轴”，在这里要注意的是——浮点型轨道的长度必须是最后一个关键帧结束的位置</p><ul><li><p>创建开始结点和结束结点</p></li><li><p>开始节点时间为0，值为0</p></li><li><p>结束结点时间为2，值为门旋转的角度</p></li><li><p>然后右键结点点击自动，让曲线变得平滑</p></li></ul></li><li><p>退出之后，我们可以开到在时间轴结点的右下角多了一个“开关门时间轴”的点</p></li><li><p>设置相对旋转，目标为门，把时间轴的update连接上，并且将xyz中的z轴连接到“关门时间轴”点上</p></li></ul><h2 id="知识点小结"><a href="#知识点小结" class="headerlink" title="知识点小结"></a>知识点小结</h2><p>流程控制：</p><ul><li><p>启用输入和禁用输入</p></li><li><p>获取玩家控制器</p></li><li><p>Gate：启用输入时Open，禁用输入时Close，Enter为按键输入</p></li><li><p>Flip Flop：第一次输入执行A，第二次输入执行B</p></li><li><p>时间轴：浮点型轨道的长度要注意</p></li><li><p>设置相对旋转：与时间旋转不同</p></li></ul><h1 id="鼠标点击实现开关门"><a href="#鼠标点击实现开关门" class="headerlink" title="鼠标点击实现开关门"></a>鼠标点击实现开关门</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>其实跟按E键实现开关门差不多，区别就在于要设置玩家控制器</p><p>世界场景设置-&gt;游戏模式-&gt;选中的游戏模式-&gt;玩家控制器类-&gt;新建一个-&gt;启用点击事件</p><p>然后在编辑-&gt;项目设置-&gt;地图和模式-&gt;默认玩家控制器-&gt;旋转刚刚创建的那个蓝图类</p><p>在“获取玩家控制器”的</p>]]></content>
      
      
      <categories>
          
          <category> unreal engine </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 蓝图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UE4-第一人称FPS-思路小结</title>
      <link href="/2022/05/03/UE4-%E7%AC%AC%E4%B8%80%E4%BA%BA%E7%A7%B0FPS-%E6%80%9D%E8%B7%AF%E5%B0%8F%E7%BB%93/"/>
      <url>/2022/05/03/UE4-%E7%AC%AC%E4%B8%80%E4%BA%BA%E7%A7%B0FPS-%E6%80%9D%E8%B7%AF%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>之前的都是讲解官方文档的代码，属于是微观层面的分析。</p><p>现在我们已经跟着官方文档做出了一个简单的第一人称FPS，如果我们要跳出官方的引导，自己做一个的话，从宏观层面的思路分析就很有必要了！</p><p>在这里，我基于官方文档的开发流程，将大致思路整理一下</p><h1 id="建立项目"><a href="#建立项目" class="headerlink" title="建立项目"></a>建立项目</h1><p>这就很好理解，建立一个空项目嘛！</p><h1 id="添加日志信息"><a href="#添加日志信息" class="headerlink" title="添加日志信息"></a>添加日志信息</h1><p>就是在屏幕上打印出日志信息</p><h2 id="重载StartPlay"><a href="#重载StartPlay" class="headerlink" title="重载StartPlay()"></a>重载StartPlay()</h2><p>在头文件中声明StartPlay()</p><p>然后再cpp文件中使用AddOnScreenDebugMessage()定义</p><h1 id="将C-游戏模式类扩展到蓝图"><a href="#将C-游戏模式类扩展到蓝图" class="headerlink" title="将C++游戏模式类扩展到蓝图"></a>将C++游戏模式类扩展到蓝图</h1><p>基于<strong>FPSProjectGameModeBase</strong>创建蓝图类<strong>BP_FPSGameModeBase</strong></p><h1 id="修改游戏默认模式"><a href="#修改游戏默认模式" class="headerlink" title="修改游戏默认模式"></a>修改游戏默认模式</h1><p>将<strong>BP_FPSGameModeBase</strong>设置为默认游戏模式</p><h1 id="创建角色"><a href="#创建角色" class="headerlink" title="创建角色"></a>创建角色</h1><p>基于Character创建一个C++类</p><p>在BeginPlay()函数中添加AddOnScreenDebugMessage()函数来确认正在使用FPSCharacter</p><h1 id="扩展C-FPS角色类到蓝图"><a href="#扩展C-FPS角色类到蓝图" class="headerlink" title="扩展C++FPS角色类到蓝图"></a>扩展C++FPS角色类到蓝图</h1><p>将<strong>FPSCharacter</strong>扩展为<strong>BP_FPSCharacter</strong></p><p>编辑-&gt;项目设置-&gt;地图和模式-&gt;默认Pawn类</p><p>设置为<strong>BP_FPSCharacter</strong></p><h1 id="设置映射"><a href="#设置映射" class="headerlink" title="设置映射"></a>设置映射</h1><p>编辑-&gt;项目设置-&gt;输入-&gt;绑定-&gt;轴映射&#x2F;按键映射</p><h1 id="实现映射"><a href="#实现映射" class="headerlink" title="实现映射"></a>实现映射</h1><p>在头文件中声明移动函数，变量为映射输入值，也就是Value</p><p>然后在cpp文件最下方定义函数</p><p>需要注意的是，实现跳跃的函数在内置文件中已经存在，我们只需要确定StartJump和StopJump即可</p><h1 id="绑定映射"><a href="#绑定映射" class="headerlink" title="绑定映射"></a>绑定映射</h1><p>在cpp文件中的<code>SetupPlayerInputComponent</code>函数内使用BindAxis()和BindAction()实现绑定映射</p><h1 id="导入网格体"><a href="#导入网格体" class="headerlink" title="导入网格体"></a>导入网格体</h1><p>打开<strong>BP_FPSCharacter</strong>图标，组件选项卡中点击网格体组件，细节面板中添加刚刚角色的网格体文件。</p><p>修改网格体位置，使得与胶囊体组件契合。</p><h1 id="更改摄像机视角"><a href="#更改摄像机视角" class="headerlink" title="更改摄像机视角"></a>更改摄像机视角</h1><p>添加摄像机与胶囊提组件头文件</p><p>头文件中声明，cpp中定义</p><ul><li><p>创建第一人称摄像机组件后，将其附加到胶囊体组件上</p></li><li><p>更改摄像机位置（SetRelativeLocation()），启用Pawn控制摄像机旋转（bUsePawnControlRotation）</p></li></ul><h1 id="添加第一人称网格体"><a href="#添加第一人称网格体" class="headerlink" title="添加第一人称网格体"></a>添加第一人称网格体</h1><p>头文件中声明FPSMesh</p><p>cpp文件中在构造函数内</p><ul><li><p>创建FPSMesh组件</p></li><li><p>设置仅所属玩家可以看见此网格体</p></li><li><p>将FPS网格体附加到FPS摄像机</p></li><li><p>禁用某些环境阴影，让地上的影子看不到这个第一人称手臂</p></li><li><p>隐藏所属角色的现有第三人称网格体</p></li></ul><p>最后在蓝图组件的细节面板中添加第一人称手臂资源，再适当地修改位置和旋转角度</p><h1 id="添加设计操作映射"><a href="#添加设计操作映射" class="headerlink" title="添加设计操作映射"></a>添加设计操作映射</h1><p>绑定操作映射</p><h1 id="添加发射物类"><a href="#添加发射物类" class="headerlink" title="添加发射物类"></a>添加发射物类</h1><p>以Actor为父类创建C++类</p><h1 id="添加USpere组件"><a href="#添加USpere组件" class="headerlink" title="添加USpere组件"></a>添加USpere组件</h1><ul><li><p>在头文件中添加#include “Components&#x2F;SphereComponent.h”</p></li><li><p>在头文件中声明球体碰撞组件</p></li><li><p>在cpp文件中定义碰撞组件</p><ul><li><p>创建为场景组件类型的根组件</p></li><li><p>创建球体碰撞组件</p></li><li><p>设置球体的碰撞半径</p></li><li><p>将根组件设置为碰撞组件</p></li></ul></li></ul><h1 id="添加发射物移动组件"><a href="#添加发射物移动组件" class="headerlink" title="添加发射物移动组件"></a>添加发射物移动组件</h1><ul><li><p>在头文件中添加#include “GameFramework&#x2F;ProjectileMovementComponent.h”</p></li><li><p>在头文件中声明发射物移动组件</p></li><li><p>在cpp文件中定义发射物移动组件</p><ul><li><p>创建移动组件</p></li><li><p>将移动组件的更新组件设置为之前定义好的碰撞组件</p></li><li><p>初始化移动组件速度</p></li><li><p>初始化移动组件最大速度</p></li><li><p>打开沿某方向高速旋转开关bRotationFollowsVelocity&#x3D;true</p></li><li><p>打开允许反弹开关bShouldBounce&#x3D;true</p></li><li><p>设置弹力大小Bounciness&#x3D;0.3f</p></li><li><p>设置发射物受到的重力大小ProjectileGravityScale&#x3D;0.0</p></li></ul></li></ul><h1 id="设置发射物初始方向"><a href="#设置发射物初始方向" class="headerlink" title="设置发射物初始方向"></a>设置发射物初始方向</h1><p>在头文件中声明初始化发射方向的函数</p><p>在cpp文件中定义该函数</p><p><code>ProjectileMovementComponent-&gt;Velocity = ShootDirection * ProjectileMovementComponent-&gt;InitialSpeed;</code></p><p>此处的Velocity可以看作是一个合成力，由方向和速度一同定义</p><h1 id="绑定发射输入操作"><a href="#绑定发射输入操作" class="headerlink" title="绑定发射输入操作"></a>绑定发射输入操作</h1><p>在FPSCharacter.h中声明Fire()</p><p>在cpp文件中绑定输入操作，并且定义该函数</p><p>{在这里可以先不写函数体，因为还没有定义发射物生成位置}</p><h1 id="定义发射物生成位置"><a href="#定义发射物生成位置" class="headerlink" title="定义发射物生成位置"></a>定义发射物生成位置</h1><p>在FPSCharacter.h中声明枪口相对于摄像机位置的偏移函数MuzzleOffset</p><p>在FPSCharacter.h中protected:下声明要生成的发射物类{TSubclassOf&lt;父类&gt;类名}</p><h1 id="实现射击函数"><a href="#实现射击函数" class="headerlink" title="实现射击函数"></a>实现射击函数</h1><p>将FPSCharacter.h中引用FPSProjectile.h文件</p><p>在cpp文件中定义Fire()函数</p><ul><li><p>生成一个发射物类</p><ul><li><p>获取摄像机位置，将MuzzleOffset位置设置在摄像机前方一点</p></li><li><p>将MuzzleOffset的相对位置转换成世界位置FTransform().TransformVector()</p></li><li><p>动态更新摄像机的Pitch角度，看起来就像后坐力一样</p></li><li><p>获取当前世界</p></li><li><p>设置一个FActorSpawnParameters</p></li><li><p>在世界内生成新的Actor（发射物）</p></li><li><p>设置发射物的初始轨迹</p></li></ul></li></ul><h1 id="添加发射物网格体及其材质"><a href="#添加发射物网格体及其材质" class="headerlink" title="添加发射物网格体及其材质"></a>添加发射物网格体及其材质</h1><p>导入网格体资源后</p><p>在FPSProjectile.h中声明发射物网格体以及其发射材质</p><p>在cpp文件中定义发射物网格体以及其材质</p><p>后面还要将网格体和材质的相对路径给填写进去</p><h1 id="设置发射物的碰撞和声明周期"><a href="#设置发射物的碰撞和声明周期" class="headerlink" title="设置发射物的碰撞和声明周期"></a>设置发射物的碰撞和声明周期</h1><p>在FPSProjectile.cpp中设置发射物生命周期</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">InitialLifeSpan = <span class="number">3.0f</span>;</span><br></pre></td></tr></table></figure><h1 id="编辑发射物的碰撞设置"><a href="#编辑发射物的碰撞设置" class="headerlink" title="编辑发射物的碰撞设置"></a>编辑发射物的碰撞设置</h1><p>编辑-&gt;项目设置-&gt;引擎-&gt;碰撞-&gt;展开预设</p><p>在对象通道中新建对象通道，将默认相应设置为Block</p><h1 id="使用新碰撞通道的设置"><a href="#使用新碰撞通道的设置" class="headerlink" title="使用新碰撞通道的设置"></a>使用新碰撞通道的设置</h1><p>在FPSProjectile.cpp的构造函数中添加</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将球体的碰撞配置文件名称设置为&quot;Projectile&quot;。</span></span><br><span class="line">CollisionComponent-&gt;BodyInstance.<span class="built_in">SetCollisionProfileName</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;Projectile&quot;</span>));</span><br></pre></td></tr></table></figure><h1 id="使发射物对碰撞做出相应"><a href="#使发射物对碰撞做出相应" class="headerlink" title="使发射物对碰撞做出相应"></a>使发射物对碰撞做出相应</h1><p>在FPSProjectile.h中声明放发射物击中物体时会调用的函数</p><p>参数为</p><p><code>void OnHit(UPrimitiveComponent* HitComponent, AActor* OtherActor, UPrimitiveComponent* OtherComponent, FVector NormalImpulse, const FHitResult&amp; Hit)</code></p><p>在cpp文件中定义函数</p><ul><li><p>如果另一个actor不是本身且另一个组件实现模拟物理的话</p></li><li><p>另一个组件调用AddImpulseAtLocation(ProjectileMovementComponent-&gt;Velocity * 100.0f, Hit.ImpactPoint)</p></li><li><p>然后Destroy()</p></li><li><p>在 <code>FPSProjectile</code> 构造函数中，将以下代码行添加到 <code>BodyInstance.SetCollisionProfileName</code> 下方：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 组件击中某物时调用的事件。</span></span><br><span class="line">CollisionComponent-&gt;OnComponentHit.<span class="built_in">AddDynamic</span>(<span class="keyword">this</span>, &amp;AFPSProjectile::OnHit);</span><br></pre></td></tr></table></figure></li></ul><h1 id="添加十字准星"><a href="#添加十字准星" class="headerlink" title="添加十字准星"></a>添加十字准星</h1><p>导入十字准星资产，基于HUD创建C++类</p><ol><li><p><code>FPSHUD.h</code>，添加以下受保护的变量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">   <span class="comment">// 将被绘制在屏幕中心。</span></span><br><span class="line">   <span class="built_in">UPROPERTY</span>(EditDefaultsOnly)</span><br><span class="line">   UTexture2D* CrosshairTexture;</span><br></pre></td></tr></table></figure></li><li><p>在 <code>FPSHUD.h</code> 中添加以下函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="comment">// HUD绘制的主要调用。</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">DrawHUD</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>将以下头文件添加到FPSHUD.h中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Engine/Canvas.h&quot;</span> </span></span><br></pre></td></tr></table></figure></li><li><p>在cpp中实现DrawHUD函数</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSHUD::DrawHUD</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">DrawHUD</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (CrosshairTexture)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 找出我们的画布的中心点。</span></span><br><span class="line">        <span class="function">FVector2D <span class="title">Center</span><span class="params">(Canvas-&gt;ClipX * <span class="number">0.5f</span>, Canvas-&gt;ClipY * <span class="number">0.5f</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 偏移纹理大小的一半，以便纹理中心与画布中心对齐。</span></span><br><span class="line">        <span class="function">FVector2D <span class="title">CrossHairDrawPosition</span><span class="params">(Center.X - (CrosshairTexture-&gt;GetSurfaceWidth() * <span class="number">0.5f</span>), Center.Y - (CrosshairTexture-&gt;GetSurfaceHeight() * <span class="number">0.5f</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在中心点绘制十字准星。</span></span><br><span class="line">        <span class="function">FCanvasTileItem <span class="title">TileItem</span><span class="params">(CrossHairDrawPosition, CrosshairTexture-&gt;Resource, FLinearColor::White)</span></span>;</span><br><span class="line">        TileItem.BlendMode = SE_BLEND_Translucent;</span><br><span class="line">        Canvas-&gt;<span class="built_in">DrawItem</span>(TileItem);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="设置默认的HUD"><a href="#设置默认的HUD" class="headerlink" title="设置默认的HUD"></a>设置默认的HUD</h1><p>扩展HUD类到蓝图类中后</p><p>编辑-&gt;项目设置-&gt;地图和模式-&gt;默认HUD</p><p>选择蓝图HUD</p><p>打开HUD蓝图，选择导入的十字准星纹理资产</p>]]></content>
      
      
      <categories>
          
          <category> unreal engine </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UE4-第一人称FPS-代码讲解（二）</title>
      <link href="/2022/05/02/UE4-%E7%AC%AC%E4%B8%80%E4%BA%BA%E7%A7%B0FPS-%E4%BB%A3%E7%A0%81%E8%AE%B2%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2022/05/02/UE4-%E7%AC%AC%E4%B8%80%E4%BA%BA%E7%A7%B0FPS-%E4%BB%A3%E7%A0%81%E8%AE%B2%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>此部分主要讲解如何给角色添加动画，依旧是官方案例。</p><p>这段说是代码讲解，但其实是蓝图讲解了。</p><p>没关系，蓝图是可视化编程，也算是代码哈哈哈！</p><p>ok话不多说，我们开始！</p><h1 id="设置事件图表"><a href="#设置事件图表" class="headerlink" title="设置事件图表"></a>设置事件图表</h1><p>在事件图表中添加两个新的bool型变量IsRunning和IsFalling之后，我们编辑动画的事件图标，来保证我们的动画过度变量在游戏运行时能被正确触发</p><h2 id="Event-Blueprint-Update-Animation"><a href="#Event-Blueprint-Update-Animation" class="headerlink" title="Event Blueprint Update Animation"></a>Event Blueprint Update Animation</h2><p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/4/EventBlueprintUpdateAnimationNode.jpg" alt="EventBlueprintUpdateAnimationNode.png"></p><p>这玩意在4.27.2版本中是有中文名称的，当然，直接搜索英文名也是可以直接得到的</p><p>中文名称是<strong>事件蓝图更新动画</strong></p><p>这玩意有啥用呢？</p><p><strong>事件蓝图更新动画：用于在每次更新动画时更新我们的状态变量（IsRunning和IsFalling），使变量和游戏状态同步。</strong></p><p>简单来说就是，这是一个函数，参数是动画的更新（从走变成跑），返回值是状态变量（IsRunning和IsFalling）</p><h2 id="Try-Get-Pawn-Owner"><a href="#Try-Get-Pawn-Owner" class="headerlink" title="Try Get Pawn Owner"></a>Try Get Pawn Owner</h2><p>同样，在4.27.2版本中的中文名是尝试获取Pawn拥有者</p><p>获取拥有这个动画实例的Pawn</p><ol><li>先获取到动画蓝图所属的组件（<code>OwnerComponent</code>）</li><li>然后再获取<code>OwnerComponent</code>的所属<code>OwnerActor</code></li><li>最后还要把<code>OwnerActor</code>(<code>AActor</code>类型)向下强制类型转换成<code>APawn</code>。</li></ol><h2 id="Cast-to-Character"><a href="#Cast-to-Character" class="headerlink" title="Cast to Character"></a>Cast to Character</h2><p>强制转换类型为Character</p><h2 id="Get-Character-Movement"><a href="#Get-Character-Movement" class="headerlink" title="Get Character Movement"></a>Get Character Movement</h2><p>获取角色运动情况</p><h2 id="Get-Movement-Mode"><a href="#Get-Movement-Mode" class="headerlink" title="Get Movement Mode"></a>Get Movement Mode</h2><p>获取角色运动状态</p><h2 id="Equal-enum"><a href="#Equal-enum" class="headerlink" title="Equal(enum)"></a>Equal(enum)</h2><p>查询角色移动状态（下拉菜单中可选择具体移动状态）</p><p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/4/SelectFalling.jpg" alt="SelectFalling.png"></p><h2 id="Get-Velocity"><a href="#Get-Velocity" class="headerlink" title="Get Velocity"></a>Get Velocity</h2><p>中文为获取速度</p><h2 id="VectorLength"><a href="#VectorLength" class="headerlink" title="VectorLength"></a>VectorLength</h2><p>获取向量长度，就是这东西可以获取速度（力，加速度）的具体数值</p><p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/4/VectorLength.jpg" alt="VectorLength.png"></p><h2 id="gt-float"><a href="#gt-float" class="headerlink" title="&gt;(float)"></a>&gt;(float)</h2><p>一个判断语句，看从前一个结点获取的数值是否大于某个设置的常量（这里常量是0）</p><p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/4/ConnectedIsRunning.jpg" alt="ConnectedIsRunning.png"></p><h1 id="添加动画状态机"><a href="#添加动画状态机" class="headerlink" title="添加动画状态机"></a>添加动画状态机</h1><h2 id="Add-State"><a href="#Add-State" class="headerlink" title="Add State"></a>Add State</h2><p>就是像图表中添加状态，分别命名为Idle，Run，JumpStart，JumpEnd，JumpLoop</p><p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/4/AnimationSMGraph.jpg" alt="AnimationSMGraph.png"></p><p>双击进各个状态内后开始编辑它们</p><p>在里面右键-&gt;<strong>play 动画名称</strong></p><p>中文标识是播放 <strong>动画名称</strong></p><p>将其连接到Output Animation Pose上，也就是表现为这个动画状态</p><p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/4/ConnectedIdleNode.jpg" alt="ConnectedIdleNode.png"></p><p>现在从entry中拖出引线连接到idle（因为初始状态是待机状态嘛）</p><p>然后根据逻辑尝试，把剩下的几个状态连接起来</p><p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/4/JumpEndtoIdle.jpg" alt="JumpEndtoIdle.png"></p><p>最后是这个效果</p><h1 id="添加过度"><a href="#添加过度" class="headerlink" title="添加过度"></a>添加过度</h1><p>双击那个圆球，就可以编辑两个状态的过度了</p><p>其中的逻辑很简单</p><h2 id="待机切换到奔跑状态"><a href="#待机切换到奔跑状态" class="headerlink" title="待机切换到奔跑状态"></a>待机切换到奔跑状态</h2><p>只需要把之前我们已经定义了的变量Is Running（值为true）拖入其中，然后在讲其脱出引线连接到result上即可</p><p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/4/IsRunningtoResult.jpg" alt="IsRunningtoResult.png"></p><h2 id="奔跑状态切换到待机状态"><a href="#奔跑状态切换到待机状态" class="headerlink" title="奔跑状态切换到待机状态"></a>奔跑状态切换到待机状态</h2><p>这个和上一个差不多，不过我们需要将Is Running判断一下为false再输出到result</p><p>所以，我们将Is Running拖出一条引线，然后创建一个<strong>Not Boolean</strong>结点判断这个bool变量是否为false，如果成立，则将其输出为result</p><p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/4/IsNotRunningtoResult.jpg" alt="IsNotRunningtoResult.png"></p><h2 id="奔跑状态切换到跳跃开始"><a href="#奔跑状态切换到跳跃开始" class="headerlink" title="奔跑状态切换到跳跃开始"></a>奔跑状态切换到跳跃开始</h2><p>我们输入的bool变量为Is falling，为啥呢？因为起跳到跳到顶点的这个过程，其实还是受到重力的影响的吧？重力还是会拖拽着你falling，只不过是被你的弹跳力抵消成为一个向上的合力了，本质上你还是falling的状态</p><p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/4/IsFallingtoResult.jpg" alt="IsFallingtoResult.png"></p><h2 id="跳跃开始到跳跃循环"><a href="#跳跃开始到跳跃循环" class="headerlink" title="跳跃开始到跳跃循环"></a>跳跃开始到跳跃循环</h2><p>我们需要判断跳跃开始动画的剩余时间，如果该时间小于0.1，则我们输出result，也就是进入到跳跃循环的动画当中。</p><p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/4/TimeRemaining.jpg" alt="TimeRemaining.png"></p><p>接下来就是关联动画蓝图和角色蓝图了，按照官网的步骤一点点来就完事了，我这里就不做过多赘述了。</p><p>另外提一嘴，这动画效果是真的细微啊，不仔细看还真看不出来。</p>]]></content>
      
      
      <categories>
          
          <category> unreal engine </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有关算法中的动态规划（二）</title>
      <link href="/2022/05/01/%E6%9C%89%E5%85%B3%E7%AE%97%E6%B3%95%E4%B8%AD%E7%9A%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2022/05/01/%E6%9C%89%E5%85%B3%E7%AE%97%E6%B3%95%E4%B8%AD%E7%9A%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>由于动态规划的例题过多，于是多开一章！</p><h1 id="零钱兑换"><a href="#零钱兑换" class="headerlink" title="零钱兑换"></a><a href="https://leetcode-cn.com/problems/coin-change/">零钱兑换</a></h1><p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p><p>你可以认为每种硬币的数量是无限的。</p><p>示例 1： 输入：coins &#x3D; [1, 2, 5], amount &#x3D; 11 输出：3 解释：11 &#x3D; 5 + 5 + 1</p><p>示例 2： 输入：coins &#x3D; [2], amount &#x3D; 3 输出：-1</p><p>示例 3： 输入：coins &#x3D; [1], amount &#x3D; 0 输出：0</p><p>示例 4： 输入：coins &#x3D; [1], amount &#x3D; 1 输出：1</p><p>示例 5： 输入：coins &#x3D; [1], amount &#x3D; 2 输出：2</p><p>提示：</p><ul><li>1 &lt;&#x3D; coins.length &lt;&#x3D; 12</li><li>1 &lt;&#x3D; coins[i] &lt;&#x3D; 2^31 - 1</li><li>0 &lt;&#x3D; amount &lt;&#x3D; 10^4</li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题目中说每种硬币的数量是无限的，可以看出是典型的完全背包问题。</p><p>动规五部曲分析如下：</p><ol><li>确定dp数组以及下标的含义</li></ol><p><strong>dp[j]：凑足总额为j所需钱币的最少个数为dp[j]</strong></p><ol start="2"><li>确定递推公式</li></ol><p>得到dp[j]（考虑coins[i]），只有一个来源，dp[j - coins[i]]（没有考虑coins[i]）。</p><p>凑足总额为j - coins[i]的最少个数为dp[j - coins[i]]，那么只需要加上一个钱币coins[i]即dp[j - coins[i]] + 1就是dp[j]（考虑coins[i]）</p><p>所以dp[j] 要取所有 dp[j - coins[i]] + 1 中最小的。</p><p>递推公式：<strong>dp[j] &#x3D; min(dp[j - coins[i]] + 1, dp[j]);</strong></p><ol start="3"><li>dp数组如何初始化</li></ol><p>首先凑足总金额为0所需钱币的个数一定是0，那么dp[0] &#x3D; 0;</p><p>其他下标对应的数值呢？</p><p>考虑到递推公式的特性，dp[j]<strong>必须初始化为一个最大的数</strong>，否则就会在min(dp[j - coins[i]] + 1, dp[j])比较的过程中被初始值覆盖。</p><p>所以下标非0的元素都是应该是最大值。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(amount + <span class="number">1</span>, INT_MAX)</span></span>;</span><br><span class="line">dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><ol start="4"><li>确定遍历顺序</li></ol><p>本题求钱币最小个数，<strong>那么钱币有顺序和没有顺序都可以，都不影响钱币的最小个数</strong>。</p><p>所以本题并不强调集合是组合还是排列。</p><p><strong>如果求组合数就是外层for循环遍历物品，内层for遍历背包</strong>。</p><p><strong>如果求排列数就是外层for遍历背包，内层for循环遍历物品</strong>。</p><p>在动态规划专题我们讲过了求组合数是<a href="https://programmercarl.com/0518.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2II.html">动态规划：518.零钱兑换II</a>，求排列数是<a href="https://programmercarl.com/0377.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%E2%85%A3.html">动态规划：377. 组合总和 Ⅳ </a>。</p><p><strong>所以本题的两个for循环的关系是：外层for循环遍历物品，内层for遍历背包或者外层for遍历背包，内层for循环遍历物品都是可以的！</strong></p><p>那么我采用coins放在外循环，target在内循环的方式。</p><p>本题钱币数量可以无限使用，那么是完全背包。所以遍历的内循环是正序</p><p>综上所述，遍历顺序为：coins（物品）放在外循环，target（背包）在内循环。且内循环正序。</p><ol start="5"><li>举例推导dp数组</li></ol><p>以输入：coins &#x3D; [1, 2, 5], amount &#x3D; 5为例</p><p><img src="https://img-blog.csdnimg.cn/20210201111833906.jpg" alt="322.零钱兑换"></p><p>dp[amount]为最终结果。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(amount + <span class="number">1</span>, INT_MAX)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; coins.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = coins[i]; j &lt;= amount; j++) &#123; <span class="comment">// 遍历背包</span></span><br><span class="line">                <span class="keyword">if</span> (dp[j - coins[i]] != INT_MAX) &#123; <span class="comment">// 如果dp[j - coins[i]]是初始值则跳过</span></span><br><span class="line">                    dp[j] = <span class="built_in">min</span>(dp[j - coins[i]] + <span class="number">1</span>, dp[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dp[amount] == INT_MAX) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a href="https://programmercarl.com/0518.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2II.html">动态规划：518.零钱兑换II </a>中求的是组合数，<a href="https://programmercarl.com/0377.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%E2%85%A3.html">动态规划：377. 组合总和 Ⅳ</a>中求的是排列数。</p><p><strong>而本题是要求最少硬币数量，硬币是组合数还是排列数都无所谓！所以两个for循环先后顺序怎样都可以！</strong></p><h1 id="完全平方数"><a href="#完全平方数" class="headerlink" title="完全平方数"></a><a href="https://leetcode-cn.com/problems/perfect-squares/">完全平方数</a></h1><p>给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。</p><p>给你一个整数 n ，返回和为 n 的完全平方数的 最少数量 。</p><p>完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。</p><p>示例 1： 输入：n &#x3D; 12 输出：3 解释：12 &#x3D; 4 + 4 + 4</p><p>示例 2： 输入：n &#x3D; 13 输出：2 解释：13 &#x3D; 4 + 9</p><p>提示：</p><ul><li>1 &lt;&#x3D; n &lt;&#x3D; 10^4</li></ul><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>可能刚看这种题感觉没啥思路，又平方和的，又最小数的。</p><p><strong>我来把题目翻译一下：完全平方数就是物品（可以无限件使用），凑个正整数n就是背包，问凑满这个背包最少有多少物品？</strong></p><p>感受出来了没，这么浓厚的完全背包氛围，而且和昨天的题目<a href="https://programmercarl.com/0322.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2.html">动态规划：322. 零钱兑换 </a>就是一样一样的！</p><p>动规五部曲分析如下：</p><ol><li>确定dp数组（dp table）以及下标的含义</li></ol><p><strong>dp[j]：和为j的完全平方数的最少数量为dp[j]</strong></p><ol start="2"><li>确定递推公式</li></ol><p>dp[j] 可以由dp[j - i * i]推出， dp[j - i * i] + 1 便可以凑成dp[j]。</p><p>此时我们要选择最小的dp[j]，所以递推公式：dp[j] &#x3D; min(dp[j - i * i] + 1, dp[j]);</p><ol start="3"><li>dp数组如何初始化</li></ol><p>dp[0]表示 和为0的完全平方数的最小数量，那么dp[0]一定是0。</p><p>有同学问题，那0 * 0 也算是一种啊，为啥dp[0] 就是 0呢？</p><p>看题目描述，找到若干个完全平方数（比如 1, 4, 9, 16, …），题目描述中可没说要从0开始，dp[0]&#x3D;0完全是为了递推公式。</p><p>非0下标的dp[j]应该是多少呢？</p><p>从递归公式dp[j] &#x3D; min(dp[j - i * i] + 1, dp[j]);中可以看出每次dp[j]都要选最小的，<strong>所以非0下标的dp[j]一定要初始为最大值，这样dp[j]在递推的时候才不会被初始值覆盖</strong>。</p><ol start="4"><li>确定遍历顺序</li></ol><p>我们知道这是完全背包，</p><p>如果求组合数就是外层for循环遍历物品，内层for遍历背包。</p><p>如果求排列数就是外层for遍历背包，内层for循环遍历物品。</p><p>在<a href="https://programmercarl.com/0322.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2.html">动态规划：322. 零钱兑换 </a>中我们就深入探讨了这个问题，本题也是一样的，是求最小数！</p><p><strong>所以本题外层for遍历背包，内层for遍历物品，还是外层for遍历物品，内层for遍历背包，都是可以的！</strong></p><p>我这里先给出外层遍历背包，内层遍历物品的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, INT_MAX)</span></span>;</span><br><span class="line">dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123; <span class="comment">// 遍历背包</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j * j &lt;= i; j++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">        dp[i] = <span class="built_in">min</span>(dp[i - j * j] + <span class="number">1</span>, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><ol start="5"><li>举例推导dp数组</li></ol><p>已输入n为5例，dp状态图如下：</p><p><img src="https://img-blog.csdnimg.cn/20210202112617341.jpg" alt="279.完全平方数"></p><p>dp[0] &#x3D; 0 dp[1] &#x3D; min(dp[0] + 1) &#x3D; 1 dp[2] &#x3D; min(dp[1] + 1) &#x3D; 2 dp[3] &#x3D; min(dp[2] + 1) &#x3D; 3 dp[4] &#x3D; min(dp[3] + 1, dp[0] + 1) &#x3D; 1 dp[5] &#x3D; min(dp[4] + 1, dp[1] + 1) &#x3D; 2</p><p>最后的dp[n]为最终结果。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numSquares</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, INT_MAX)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123; <span class="comment">// 遍历背包</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j * j &lt;= i; j++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">                dp[i] = <span class="built_in">min</span>(dp[i - j * j] + <span class="number">1</span>, dp[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="单词拆分"><a href="#单词拆分" class="headerlink" title="单词拆分"></a><a href="https://leetcode-cn.com/problems/word-break/">单词拆分</a></h1><p>给定一个非空字符串 s 和一个包含非空单词的列表 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。</p><p>说明：</p><p>拆分时可以重复使用字典中的单词。</p><p>你可以假设字典中没有重复的单词。</p><p>示例 1： </p><p>输入: s &#x3D; “leetcode”, wordDict &#x3D; [“leet”, “code”] </p><p>输出: true </p><p>解释: 返回 true 因为 “leetcode” 可以被拆分成 “leet code”。</p><p>示例 2： </p><p>输入: s &#x3D; “applepenapple”, wordDict &#x3D; [“apple”, “pen”] </p><p>输出: true </p><p>解释: 返回 true 因为 “applepenapple” 可以被拆分成 “apple pen apple”。   </p><p>注意你可以重复使用字典中的单词。</p><p>示例 3： </p><p>输入: s &#x3D; “catsandog”, wordDict &#x3D; [“cats”, “dog”, “sand”, “and”, “cat”] </p><p>输出: false</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><h3 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h3><p>看到这道题目的时候，大家应该回想起我们之前讲解回溯法专题的时候，讲过的一道题目<a href="https://programmercarl.com/0131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.html">回溯算法：分割回文串 </a>，就是枚举字符串的所有分割情况。</p><p><a href="https://programmercarl.com/0131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.html">回溯算法：分割回文串 </a>：是枚举分割后的所有子串，判断是否回文。</p><p>本道是枚举分割所有字符串，判断是否在字典里出现过。</p><p>那么这里我也给出回溯法C++代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">backtracking</span> <span class="params">(<span class="type">const</span> string&amp; s, <span class="type">const</span> unordered_set&lt;string&gt;&amp; wordSet, <span class="type">int</span> startIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (startIndex &gt;= s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            string word = s.<span class="built_in">substr</span>(startIndex, i - startIndex + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (wordSet.<span class="built_in">find</span>(word) != wordSet.<span class="built_in">end</span>() &amp;&amp; <span class="built_in">backtracking</span>(s, wordSet, i + <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">wordBreak</span><span class="params">(string s, vector&lt;string&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="function">unordered_set&lt;string&gt; <span class="title">wordSet</span><span class="params">(wordDict.begin(), wordDict.end())</span></span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">backtracking</span>(s, wordSet, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>单词就是物品，字符串s就是背包，单词能否组成字符串s，就是问物品能不能把背包装满。</p><p>拆分时可以重复使用字典中的单词，说明就是一个完全背包！</p><p>动规五部曲分析如下：</p><ol><li>确定dp数组以及下标的含义</li></ol><p><strong>dp[i] : 字符串长度为i的话，dp[i]为true，表示可以拆分为一个或多个在字典中出现的单词</strong></p><ol start="2"><li>确定递推公式</li></ol><p>如果确定dp[j] 是true，且 [j, i] 这个区间的子串出现在字典里，那么dp[i]一定是true。（j &lt; i ）。</p><p>所以递推公式是 if([j, i] 这个区间的子串出现在字典里 &amp;&amp; dp[j]是true) 那么 dp[i] &#x3D; true。</p><ol start="3"><li>dp数组如何初始化</li></ol><p>从递归公式中可以看出，dp[i] 的状态依靠 dp[j]是否为true，那么dp[0]就是递归的根基，dp[0]一定要为true，否则递归下去后面都都是false了。</p><p>那么dp[0]有没有意义呢？</p><p>dp[0]表示如果字符串为空的话，说明出现在字典里。</p><p>但题目中说了“给定一个非空字符串 s” 所以测试数据中不会出现i为0的情况，那么dp[0]初始为true完全就是为了推导公式。</p><p>下标非0的dp[i]初始化为false，只要没有被覆盖说明都是不可拆分为一个或多个在字典中出现的单词。</p><ol start="4"><li>确定遍历顺序</li></ol><p>题目中说是拆分为一个或多个在字典中出现的单词，所以这是完全背包。</p><p>还要讨论两层for循环的前后循序。</p><p><strong>如果求组合数就是外层for循环遍历物品，内层for遍历背包</strong>。</p><p><strong>如果求排列数就是外层for遍历背包，内层for循环遍历物品</strong>。</p><p>对这个结论还有疑问的同学可以看这篇<a href="https://programmercarl.com/%E5%91%A8%E6%80%BB%E7%BB%93/20210204%E5%8A%A8%E8%A7%84%E5%91%A8%E6%9C%AB%E6%80%BB%E7%BB%93.html">本周小结！（动态规划系列五）</a>，这篇本周小节中，我做了如下总结：</p><p>求组合数：<a href="https://programmercarl.com/0518.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2II.html">动态规划：518.零钱兑换II</a>求排列数：<a href="https://programmercarl.com/0377.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C.html">动态规划：377. 组合总和 Ⅳ</a>、<a href="https://programmercarl.com/0070.%E7%88%AC%E6%A5%BC%E6%A2%AF%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E7%89%88%E6%9C%AC.html">动态规划：70. 爬楼梯进阶版（完全背包）</a>求最小数：<a href="https://programmercarl.com/0322.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2.html">动态规划：322. 零钱兑换</a>、<a href="https://programmercarl.com/0279.%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0.html">动态规划：279.完全平方数</a></p><p>本题最终要求的是是否都出现过，所以对出现单词集合里的元素是组合还是排列，并不在意！</p><p><strong>那么本题使用求排列的方式，还是求组合的方式都可以</strong>。</p><p>即：外层for循环遍历物品，内层for遍历背包 或者 外层for遍历背包，内层for循环遍历物品 都是可以的。</p><p>但本题还有特殊性，因为是要求子串，最好是遍历背包放在外循环，将遍历物品放在内循环。</p><p>如果要是外层for循环遍历物品，内层for遍历背包，就需要把所有的子串都预先放在一个容器里。（如果不理解的话，可以自己尝试这么写一写就理解了）</p><p><strong>所以最终我选择的遍历顺序为：遍历背包放在外循环，将遍历物品放在内循环。内循环从前到后</strong>。</p><ol start="5"><li>举例推导dp[i]</li></ol><p>以输入: s &#x3D; “leetcode”, wordDict &#x3D; [“leet”, “code”]为例，dp状态如图：</p><p><img src="https://img-blog.csdnimg.cn/20210202162652727.jpg" alt="139.单词拆分"></p><p>dp[s.size()]就是最终结果。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">wordBreak</span><span class="params">(string s, vector&lt;string&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="function">unordered_set&lt;string&gt; <span class="title">wordSet</span><span class="params">(wordDict.begin(), wordDict.end())</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">dp</span><span class="params">(s.size() + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= s.<span class="built_in">size</span>(); i++) &#123;   <span class="comment">// 遍历背包</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;       <span class="comment">// 遍历物品</span></span><br><span class="line">                string word = s.<span class="built_in">substr</span>(j, i - j); <span class="comment">//substr(起始位置，截取的个数)</span></span><br><span class="line">                <span class="keyword">if</span> (wordSet.<span class="built_in">find</span>(word) != wordSet.<span class="built_in">end</span>() &amp;&amp; dp[j]) &#123;</span><br><span class="line">                    dp[i] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="多重背包理论基础"><a href="#多重背包理论基础" class="headerlink" title="多重背包理论基础"></a>多重背包理论基础</h1><p>对于多重背包，我在力扣上还没发现对应的题目，所以这里就做一下简单介绍，大家大概了解一下。</p><p>有N种物品和一个容量为V 的背包。<strong>第i种物品最多有Mi件可用</strong>，每件耗费的空间是Ci ，价值是Wi 。求解将哪些物品装入背包可使这些物品的耗费的空间 总和不超过背包容量，且价值总和最大。</p><p>多重背包和01背包是非常像的， 为什么和01背包像呢？</p><p>每件物品最多有Mi件可用，把Mi件摊开，其实就是一个01背包问题了。</p><p>例如：</p><p>背包最大重量为10。</p><p>物品为：</p><table><thead><tr><th></th><th>重量</th><th>价值</th><th>数量</th></tr></thead><tbody><tr><td>物品0</td><td>1</td><td>15</td><td>2</td></tr><tr><td>物品1</td><td>3</td><td>20</td><td>3</td></tr><tr><td>物品2</td><td>4</td><td>30</td><td>2</td></tr></tbody></table><p>问背包能背的物品最大价值是多少？</p><p>和如下情况有区别么？</p><table><thead><tr><th></th><th>重量</th><th>价值</th><th>数量</th></tr></thead><tbody><tr><td>物品0</td><td>1</td><td>15</td><td>1</td></tr><tr><td>物品0</td><td>1</td><td>15</td><td>1</td></tr><tr><td>物品1</td><td>3</td><td>20</td><td>1</td></tr><tr><td>物品1</td><td>3</td><td>20</td><td>1</td></tr><tr><td>物品1</td><td>3</td><td>20</td><td>1</td></tr><tr><td>物品2</td><td>4</td><td>30</td><td>1</td></tr><tr><td>物品2</td><td>4</td><td>30</td><td>1</td></tr></tbody></table><p>毫无区别，这就转成了一个01背包问题了，且每个物品只用一次。</p><p>这种方式来实现多重背包的代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_multi_pack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; weight = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; value = &#123;<span class="number">15</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="type">int</span> bagWeight = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (nums[i] &gt; <span class="number">1</span>) &#123; <span class="comment">// nums[i]保留到1，把其他物品都展开</span></span><br><span class="line">            weight.<span class="built_in">push_back</span>(weight[i]);</span><br><span class="line">            value.<span class="built_in">push_back</span>(value[i]);</span><br><span class="line">            nums[i]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(bagWeight + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; weight.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = bagWeight; j &gt;= weight[i]; j--) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">            dp[j] = <span class="built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= bagWeight; j++) &#123;</span><br><span class="line">            cout &lt;&lt; dp[j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[bagWeight] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test_multi_pack</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(m × n × k)，m：物品种类个数，n背包容量，k单类物品数量</li></ul><p>也有另一种实现方式，就是把每种商品遍历的个数放在01背包里面在遍历一遍。</p><p>代码如下：（详看注释）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_multi_pack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; weight = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; value = &#123;<span class="number">15</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="type">int</span> bagWeight = <span class="number">10</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(bagWeight + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; weight.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = bagWeight; j &gt;= weight[i]; j--) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">            <span class="comment">// 以上为01背包，然后加一个遍历个数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= nums[i] &amp;&amp; (j - k * weight[i]) &gt;= <span class="number">0</span>; k++) &#123; <span class="comment">// 遍历个数</span></span><br><span class="line">                dp[j] = <span class="built_in">max</span>(dp[j], dp[j - k * weight[i]] + k * value[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 打印一下dp数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= bagWeight; j++) &#123;</span><br><span class="line">            cout &lt;&lt; dp[j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[bagWeight] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test_multi_pack</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(m × n × k)，m：物品种类个数，n背包容量，k单类物品数量</li></ul><p>从代码里可以看出是01背包里面在加一个for循环遍历一个每种商品的数量。 和01背包还是如出一辙的。</p><p>当然还有那种二进制优化的方法，其实就是把每种物品的数量，打包成一个个独立的包。</p><p>和以上在循环遍历上有所不同，因为是分拆为各个包最后可以组成一个完整背包，具体原理我就不做过多解释了，大家了解一下就行，面试的话基本不会考完这个深度了，感兴趣可以自己深入研究一波。</p><h1 id="打家劫舍"><a href="#打家劫舍" class="headerlink" title="打家劫舍"></a><a href="https://leetcode-cn.com/problems/house-robber/">打家劫舍</a></h1><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p><p>示例 1：</p><p>输入：[1,2,3,1] </p><p>输出：4 </p><p>解释：偷窃 1 号房屋 (金额 &#x3D; 1) ，然后偷窃 3 号房屋 (金额 &#x3D; 3)。   偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 </p><p>示例 2： </p><p>输入：[2,7,9,3,1] </p><p>输出：12 </p><p>解释：偷窃 1 号房屋 (金额 &#x3D; 2), 偷窃 3 号房屋 (金额 &#x3D; 9)，接着偷窃 5 号房屋 (金额 &#x3D; 1)。   偷窃到的最高金额 &#x3D; 2 + 9 + 1 &#x3D; 12 。</p><p>提示：</p><ul><li>0 &lt;&#x3D; nums.length &lt;&#x3D; 100</li><li>0 &lt;&#x3D; nums[i] &lt;&#x3D; 400</li></ul><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>打家劫舍是dp解决的经典问题，动规五部曲分析如下：</p><ol><li>确定dp数组（dp table）以及下标的含义</li></ol><p>**dp[i]：考虑下标i（包括i）以内的房屋，最多可以偷窃的金额为dp[i]**。</p><ol start="2"><li>确定递推公式</li></ol><p>决定dp[i]的因素就是第i房间偷还是不偷。</p><p>如果偷第i房间，那么dp[i] &#x3D; dp[i - 2] + nums[i] ，即：第i-1房一定是不考虑的，找出 下标i-2（包括i-2）以内的房屋，最多可以偷窃的金额为dp[i-2] 加上第i房间偷到的钱。</p><p>如果不偷第i房间，那么dp[i] &#x3D; dp[i - 1]，即考虑i-1房，（<strong>注意这里是考虑，并不是一定要偷i-1房，这是很多同学容易混淆的点</strong>）</p><p>然后dp[i]取最大值，即dp[i] &#x3D; max(dp[i - 2] + nums[i], dp[i - 1]);</p><ol start="3"><li>dp数组如何初始化</li></ol><p>从递推公式dp[i] &#x3D; max(dp[i - 2] + nums[i], dp[i - 1]);可以看出，递推公式的基础就是dp[0] 和 dp[1]</p><p>从dp[i]的定义上来讲，dp[0] 一定是 nums[0]，dp[1]就是nums[0]和nums[1]的最大值即：dp[1] &#x3D; max(nums[0], nums[1]);</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">dp[<span class="number">1</span>] = <span class="built_in">max</span>(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure><ol start="4"><li>确定遍历顺序</li></ol><p>dp[i] 是根据dp[i - 2] 和 dp[i - 1] 推导出来的，那么一定是从前到后遍历！</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    dp[i] = <span class="built_in">max</span>(dp[i - <span class="number">2</span>] + nums[i], dp[i - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>举例推导dp数组</li></ol><p>以示例二，输入[2,7,9,3,1]为例。</p><p><img src="https://img-blog.csdnimg.cn/20210221170954115.jpg" alt="198.打家劫舍"></p><p>红框dp[nums.size() - 1]为结果。</p><p>以上分析完毕，C++代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="built_in">max</span>(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(dp[i - <span class="number">2</span>] + nums[i], dp[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[nums.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="打家劫舍II"><a href="#打家劫舍II" class="headerlink" title="打家劫舍II"></a>打家劫舍II</h1><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，能够偷窃到的最高金额。</p><p>示例 1：</p><p>输入：nums &#x3D; [2,3,2] 输出：3 解释：你不能先偷窃 1 号房屋（金额 &#x3D; 2），然后偷窃 3 号房屋（金额 &#x3D; 2）, 因为他们是相邻的。</p><p>示例 2： 输入：nums &#x3D; [1,2,3,1] 输出：4 解释：你可以先偷窃 1 号房屋（金额 &#x3D; 1），然后偷窃 3 号房屋（金额 &#x3D; 3）。偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。</p><p>示例 3： 输入：nums &#x3D; [0] 输出：0</p><p>提示：</p><ul><li>1 &lt;&#x3D; nums.length &lt;&#x3D; 100</li><li>0 &lt;&#x3D; nums[i] &lt;&#x3D; 1000</li></ul><h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>这道题目和<a href="https://programmercarl.com/0198.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D.html">198.打家劫舍 </a>是差不多的，唯一区别就是成环了。</p><p>对于一个数组，成环的话主要有如下三种情况：</p><ul><li>情况一：考虑不包含首尾元素</li></ul><p><img src="https://img-blog.csdnimg.cn/20210129160748643.jpg" alt="213.打家劫舍II"></p><ul><li>情况二：考虑包含首元素，不包含尾元素</li></ul><p><img src="https://img-blog.csdnimg.cn/20210129160821374.jpg" alt="213.打家劫舍II1"></p><ul><li>情况三：考虑包含尾元素，不包含首元素</li></ul><p><img src="https://img-blog.csdnimg.cn/20210129160842491.jpg" alt="213.打家劫舍II2"></p><p>**注意我这里用的是”考虑”**，例如情况三，虽然是考虑包含尾元素，但不一定要选尾部元素！ 对于情况三，取nums[1] 和 nums[3]就是最大的。</p><p><strong>而情况二 和 情况三 都包含了情况一了，所以只考虑情况二和情况三就可以了</strong>。</p><p>分析到这里，本题其实比较简单了。 剩下的和<a href="https://programmercarl.com/0198.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D.html">198.打家劫舍</a>就是一样的了。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意注释中的情况二情况三，以及把198.打家劫舍的代码抽离出来了</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> result1 = <span class="built_in">robRange</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">2</span>); <span class="comment">// 情况二</span></span><br><span class="line">        <span class="type">int</span> result2 = <span class="built_in">robRange</span>(nums, <span class="number">1</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>); <span class="comment">// 情况三</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(result1, result2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 198.打家劫舍的逻辑</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">robRange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (end == start) <span class="keyword">return</span> nums[start];</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">        dp[start] = nums[start];</span><br><span class="line">        dp[start + <span class="number">1</span>] = <span class="built_in">max</span>(nums[start], nums[start + <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = start + <span class="number">2</span>; i &lt;= end; i++) &#123;</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(dp[i - <span class="number">2</span>] + nums[i], dp[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[end];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="打家劫舍-III"><a href="#打家劫舍-III" class="headerlink" title="打家劫舍 III"></a><a href="https://leetcode-cn.com/problems/house-robber-iii/">打家劫舍 III</a></h1><p>在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。</p><p>计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。</p><p><img src="https://img-blog.csdnimg.cn/20210223173849619.png" alt="337.打家劫舍III"></p><h2 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h2><p><strong>本题一定是要后序遍历，因为通过递归函数的返回值来做下一步计算</strong>。</p><p>与198.打家劫舍，213.打家劫舍II一样，关键是要讨论当前节点抢还是不抢。</p><p>如果抢了当前节点，两个孩子就不能动，如果没抢当前节点，就可以考虑抢左右孩子（<strong>注意这里说的是“考虑”</strong>）</p><p>动态规划其实就是使用状态转移容器来记录状态的变化，这里可以使用一个长度为2的数组，记录当前节点偷与不偷所得到的的最大金钱。</p><p><strong>这道题目算是树形dp的入门题目，因为是在树上进行状态转移，我们在讲解二叉树的时候说过递归三部曲，那么下面我以递归三部曲为框架，其中融合动规五部曲的内容来进行讲解</strong>。</p><ol><li>确定递归函数的参数和返回值</li></ol><p>这里我们要求一个节点 偷与不偷的两个状态所得到的金钱，那么返回值就是一个长度为2的数组。</p><p>参数为当前节点，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">robTree</span><span class="params">(TreeNode* cur)</span> </span>&#123;</span><br></pre></td></tr></table></figure><p>其实这里的返回数组就是dp数组。</p><p>所以dp数组（dp table）以及下标的含义：下标为0记录不偷该节点所得到的的最大金钱，下标为1记录偷该节点所得到的的最大金钱。</p><p><strong>所以本题dp数组就是一个长度为2的数组！</strong></p><p>那么有同学可能疑惑，长度为2的数组怎么标记树中每个节点的状态呢？</p><p><strong>别忘了在递归的过程中，系统栈会保存每一层递归的参数</strong>。</p><p>如果还不理解的话，就接着往下看，看到代码就理解了哈。</p><ol start="2"><li>确定终止条件</li></ol><p>在遍历的过程中，如果遇到空节点的话，很明显，无论偷还是不偷都是0，所以就返回</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt;&#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br></pre></td></tr></table></figure><p>这也相当于dp数组的初始化</p><ol start="3"><li>确定遍历顺序</li></ol><p>首先明确的是使用后序遍历。 因为通过递归函数的返回值来做下一步计算。</p><p>通过递归左节点，得到左节点偷与不偷的金钱。</p><p>通过递归右节点，得到右节点偷与不偷的金钱。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下标0：不偷，下标1：偷</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; left = <span class="built_in">robTree</span>(cur-&gt;left); <span class="comment">// 左</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; right = <span class="built_in">robTree</span>(cur-&gt;right); <span class="comment">// 右</span></span><br><span class="line"><span class="comment">// 中</span></span><br></pre></td></tr></table></figure><ol start="4"><li>确定单层递归的逻辑</li></ol><p>如果是偷当前节点，那么左右孩子就不能偷，val1 &#x3D; cur-&gt;val + left[0] + right[0]; （<strong>如果对下标含义不理解就在回顾一下dp数组的含义</strong>）</p><p>如果不偷当前节点，那么左右孩子就可以偷，至于到底偷不偷一定是选一个最大的，所以：val2 &#x3D; max(left[0], left[1]) + max(right[0], right[1]);</p><p>最后当前节点的状态就是{val2, val1}; 即：{不偷当前节点得到的最大金钱，偷当前节点得到的最大金钱}</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; left = <span class="built_in">robTree</span>(cur-&gt;left); <span class="comment">// 左</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; right = <span class="built_in">robTree</span>(cur-&gt;right); <span class="comment">// 右</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 偷cur</span></span><br><span class="line"><span class="type">int</span> val1 = cur-&gt;val + left[<span class="number">0</span>] + right[<span class="number">0</span>];</span><br><span class="line"><span class="comment">// 不偷cur</span></span><br><span class="line"><span class="type">int</span> val2 = <span class="built_in">max</span>(left[<span class="number">0</span>], left[<span class="number">1</span>]) + <span class="built_in">max</span>(right[<span class="number">0</span>], right[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">return</span> &#123;val2, val1&#125;;</span><br></pre></td></tr></table></figure><ol start="5"><li>举例推导dp数组</li></ol><p>以示例1为例，dp数组状态如下：（<strong>注意用后序遍历的方式推导</strong>）</p><p><img src="https://code-thinking.cdn.bcebos.com/pics/337.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DIII.jpg" alt="337.打家劫舍III"></p><p><strong>最后头结点就是 取下标0 和 下标1的最大值就是偷得的最大金钱</strong>。</p><p>递归三部曲与动规五部曲分析完毕，C++代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result = <span class="built_in">robTree</span>(root);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(result[<span class="number">0</span>], result[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 长度为2的数组，0：不偷，1：偷</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">robTree</span><span class="params">(TreeNode* cur)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt;&#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; left = <span class="built_in">robTree</span>(cur-&gt;left);</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; right = <span class="built_in">robTree</span>(cur-&gt;right);</span><br><span class="line">        <span class="comment">// 偷cur</span></span><br><span class="line">        <span class="type">int</span> val1 = cur-&gt;val + left[<span class="number">0</span>] + right[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 不偷cur</span></span><br><span class="line">        <span class="type">int</span> val2 = <span class="built_in">max</span>(left[<span class="number">0</span>], left[<span class="number">1</span>]) + <span class="built_in">max</span>(right[<span class="number">0</span>], right[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> &#123;val2, val1&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：$O(n)$，每个节点只遍历了一次</li><li>空间复杂度：$O(\log n)$，算上递推系统栈的空间</li></ul><h1 id="买卖股票的最佳时机"><a href="#买卖股票的最佳时机" class="headerlink" title="买卖股票的最佳时机"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">买卖股票的最佳时机</a></h1><p>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。</p><p>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p><p>示例 1：<br>输入：[7,1,5,3,6,4]<br>输出：5<br>解释：在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出，最大利润 &#x3D; 6-1 &#x3D; 5 。注意利润不能是 7-1 &#x3D; 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</p><p>示例 2：<br>输入：prices &#x3D; [7,6,4,3,1]<br>输出：0<br>解释：在这种情况下, 没有交易完成, 所以最大利润为 0。</p><h2 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h2><p>动规五部曲分析如下：</p><ol><li>确定dp数组（dp table）以及下标的含义</li></ol><p>dp[i][0] 表示第i天持有股票所得最多现金 ，<strong>这里可能有同学疑惑，本题中只能买卖一次，持有股票之后哪还有现金呢？</strong></p><p>其实一开始现金是0，那么加入第i天买入股票现金就是 -prices[i]， 这是一个负数。</p><p>dp[i][1] 表示第i天不持有股票所得最多现金</p><p><strong>注意这里说的是“持有”，“持有”不代表就是当天“买入”！也有可能是昨天就买入了，今天保持持有的状态</strong></p><p>很多同学把“持有”和“买入”没分区分清楚。</p><p>在下面递推公式分析中，我会进一步讲解。</p><ol start="2"><li>确定递推公式</li></ol><p>如果第i天持有股票即dp[i][0]， 那么可以由两个状态推出来</p><ul><li>第i-1天就持有股票，那么就保持现状，所得现金就是昨天持有股票的所得现金 即：dp[i - 1][0]</li><li>第i天买入股票，所得现金就是买入今天的股票后所得现金即：-prices[i]</li></ul><p>那么dp[i][0]应该选所得现金最大的，所以<strong>dp[i][0] &#x3D; max(dp[i - 1][0], -prices[i])</strong>;</p><p>如果第i天不持有股票即dp[i][1]， 也可以由两个状态推出来</p><ul><li>第i-1天就不持有股票，那么就保持现状，所得现金就是昨天不持有股票的所得现金 即：dp[i - 1][1]</li><li>第i天卖出股票，所得现金就是按照今天股票佳价格卖出后所得现金即：prices[i] + dp[i - 1][0]</li></ul><p>同样dp[i][1]取最大的，<strong>dp[i][1] &#x3D; max(dp[i - 1][1], prices[i] + dp[i - 1][0])</strong>;</p><p>这样递归公式我们就分析完了</p><ol start="3"><li>dp数组如何初始化</li></ol><p>由递推公式 dp[i][0] &#x3D; max(dp[i - 1][0], -prices[i]); 和 dp[i][1] &#x3D; max(dp[i - 1][1], prices[i] + dp[i - 1][0]);可以看出</p><p>其基础都是要从dp[0][0]和dp[0][1]推导出来。</p><p>那么dp[0][0]表示第0天持有股票，此时的持有股票就一定是买入股票了，因为不可能有前一天推出来，所以dp[0][0] -&#x3D; prices[0];</p><p>dp[0][1]表示第0天不持有股票，不持有股票那么现金就是0，所以dp[0][1] &#x3D; 0;</p><ol start="4"><li>确定遍历顺序</li></ol><p>从递推公式可以看出dp[i]都是有dp[i - 1]推导出来的，那么一定是从前向后遍历。</p><ol start="5"><li>举例推导dp数组</li></ol><p>以示例1，输入：[7,1,5,3,6,4]为例，dp数组状态如下：</p><p><img src="https://img-blog.csdnimg.cn/20210224225642465.png" alt="121.买卖股票的最佳时机"></p><p>dp[5][1]就是最终结果。</p><p>为什么不是dp[5][0]呢？</p><p><strong>因为本题中不持有股票状态所得金钱一定比持有股票状态得到的多！</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 版本一</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(len, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] -= prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>], -prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>], prices[i] + dp[i - <span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="买卖股票的最佳时机II"><a href="#买卖股票的最佳时机II" class="headerlink" title="买卖股票的最佳时机II"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">买卖股票的最佳时机II</a></h1><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p>示例 1:<br>输入: [7,1,5,3,6,4]<br>输出: 7<br>解释: 在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 3 天（股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5-1 &#x3D; 4。随后，在第 4 天（股票价格 &#x3D; 3）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出, 这笔交易所能获得利润 &#x3D; 6-3 &#x3D; 3 。</p><p>示例 2:<br>输入: [1,2,3,4,5]<br>输出: 4<br>解释: 在第 1 天（股票价格 &#x3D; 1）的时候买入，在第 5 天 （股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5-1 &#x3D; 4 。注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</p><p>示例 3:<br>输入: [7,6,4,3,1]<br>输出: 0<br>解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</p><p>提示：</p><ul><li>1 &lt;&#x3D; prices.length &lt;&#x3D; 3 * 10 ^ 4</li><li>0 &lt;&#x3D; prices[i] &lt;&#x3D; 10 ^ 4</li></ul><h1 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h1><p>本题和<a href="https://programmercarl.com/0121.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA.html">121. 买卖股票的最佳时机</a>的唯一区别本题股票可以买卖多次了（注意只有一只股票，所以再次购买前要出售掉之前的股票）</p><p>在动规五部曲中，这个区别主要是体现在递推公式上，其他都和<a href="https://programmercarl.com/0121.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA.html">121. 买卖股票的最佳时机 </a>一样一样的。</p><p>所以我们重点讲一讲递推公式。</p><p>这里重申一下dp数组的含义：</p><ul><li>dp[i][0] 表示第i天持有股票所得现金。</li><li>dp[i][1] 表示第i天不持有股票所得最多现金</li></ul><p>如果第i天持有股票即dp[i][0]， 那么可以由两个状态推出来</p><ul><li>第i-1天就持有股票，那么就保持现状，所得现金就是昨天持有股票的所得现金 即：dp[i - 1][0]</li><li>第i天买入股票，所得现金就是昨天不持有股票的所得现金减去 今天的股票价格 即：dp[i - 1][1] - prices[i]</li></ul><p>注意这里和<a href="https://programmercarl.com/0121.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA.html">121. 买卖股票的最佳时机 </a>唯一不同的地方，就是推导dp[i][0]的时候，第i天买入股票的情况。</p><p>在<a href="https://programmercarl.com/0121.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA.html">121. 买卖股票的最佳时机</a>中，因为股票全程只能买卖一次，所以如果买入股票，那么第i天持有股票即dp[i][0]一定就是 -prices[i]。</p><p>而本题，因为一只股票可以买卖多次，所以当第i天买入股票的时候，所持有的现金可能有之前买卖过的利润。</p><p>那么第i天持有股票即dp[i][0]，如果是第i天买入股票，所得现金就是昨天不持有股票的所得现金 减去 今天的股票价格 即：dp[i - 1][1] - prices[i]。</p><p>在来看看如果第i天不持有股票即dp[i][1]的情况， 依然可以由两个状态推出来</p><ul><li>第i-1天就不持有股票，那么就保持现状，所得现金就是昨天不持有股票的所得现金 即：dp[i - 1][1]</li><li>第i天卖出股票，所得现金就是按照今天股票佳价格卖出后所得现金即：prices[i] + dp[i - 1][0]</li></ul><p><strong>注意这里和<a href="https://programmercarl.com/0121.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA.html">121. 买卖股票的最佳时机 </a>就是一样的逻辑，卖出股票收获利润（可能是负值）天经地义！</strong></p><p>代码如下：（注意代码中的注释，标记了和121.买卖股票的最佳时机唯一不同的地方）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = prices.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(len, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] -= prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] - prices[i]); <span class="comment">// 注意这里是和121. 买卖股票的最佳时机唯一不同的地方。</span></span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="买卖股票的最佳时机III"><a href="#买卖股票的最佳时机III" class="headerlink" title="买卖股票的最佳时机III"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/">买卖股票的最佳时机III</a></h1><p>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p>示例 1: 输入：prices &#x3D; [3,3,5,0,0,3,1,4] 输出：6 解释：在第 4 天（股票价格 &#x3D; 0）的时候买入，在第 6 天（股票价格 &#x3D; 3）的时候卖出，这笔交易所能获得利润 &#x3D; 3-0 &#x3D; 3 。随后，在第 7 天（股票价格 &#x3D; 1）的时候买入，在第 8 天 （股票价格 &#x3D; 4）的时候卖出，这笔交易所能获得利润 &#x3D; 4-1 &#x3D; 3。</p><p>示例 2： 输入：prices &#x3D; [1,2,3,4,5] 输出：4 解释：在第 1 天（股票价格 &#x3D; 1）的时候买入，在第 5 天 （股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5-1 &#x3D; 4。注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</p><p>示例 3： 输入：prices &#x3D; [7,6,4,3,1] 输出：0 解释：在这个情况下, 没有交易完成, 所以最大利润为0。</p><p>示例 4： 输入：prices &#x3D; [1] 输出：0</p><p>提示：</p><ul><li>1 &lt;&#x3D; prices.length &lt;&#x3D; 10^5</li><li>0 &lt;&#x3D; prices[i] &lt;&#x3D; 10^5</li></ul><h2 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h2><p>这道题目相对 <a href="https://programmercarl.com/0121.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA.html">121.买卖股票的最佳时机 </a>和 <a href="https://programmercarl.com/0122.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII.html">122.买卖股票的最佳时机II </a>难了不少。</p><p>关键在于至多买卖两次，这意味着<strong>可以买卖一次，可以买卖两次，也可以不买卖</strong>。</p><p>接来下我用动态规划五部曲详细分析一下：</p><ol><li>确定dp数组以及下标的含义</li></ol><p>一天一共就有五个状态，</p><ol start="0"><li>没有操作</li><li>第一次买入</li><li>第一次卖出</li><li>第二次买入</li><li>第二次卖出</li></ol><p>dp[i][j]中 i表示第i天，j为 [0 - 4] 五个状态，dp[i][j]表示第i天状态j所剩最大现金。</p><ol start="2"><li>确定递推公式</li></ol><p>需要注意：dp[i][1]，<strong>表示的是第i天，买入股票的状态，并不是说一定要第i天买入股票，这是很多同学容易陷入的误区</strong>。</p><p>达到dp[i][1]状态，有两个具体操作：</p><ul><li>操作一：第i天买入股票了，那么dp[i][1] &#x3D; dp[i-1][0] - prices[i]</li><li>操作二：第i天没有操作，而是沿用前一天买入的状态，即：dp[i][1] &#x3D; dp[i - 1][1]</li></ul><p>那么dp[i][1]究竟选 dp[i-1][0] - prices[i]，还是dp[i - 1][1]呢？</p><p>一定是选最大的，所以 dp[i][1] &#x3D; max(dp[i-1][0] - prices[i], dp[i - 1][1]);</p><p>同理dp[i][2]也有两个操作：</p><ul><li>操作一：第i天卖出股票了，那么dp[i][2] &#x3D; dp[i - 1][1] + prices[i]</li><li>操作二：第i天没有操作，沿用前一天卖出股票的状态，即：dp[i][2] &#x3D; dp[i - 1][2]</li></ul><p>所以dp[i][2] &#x3D; max(dp[i - 1][1] + prices[i], dp[i - 1][2])</p><p>同理可推出剩下状态部分：</p><p>dp[i][3] &#x3D; max(dp[i - 1][3], dp[i - 1][2] - prices[i]);</p><p>dp[i][4] &#x3D; max(dp[i - 1][4], dp[i - 1][3] + prices[i]);</p><ol start="3"><li>dp数组如何初始化</li></ol><p>第0天没有操作，这个最容易想到，就是0，即：dp[0][0] &#x3D; 0;</p><p>第0天做第一次买入的操作，dp[0][1] &#x3D; -prices[0];</p><p>第0天做第一次卖出的操作，这个初始值应该是多少呢？</p><p>首先卖出的操作一定是收获利润，整个股票买卖最差情况也就是没有盈利即全程无操作现金为0，</p><p>从递推公式中可以看出每次是取最大值，那么既然是收获利润如果比0还小了就没有必要收获这个利润了。</p><p>所以dp[0][2] &#x3D; 0;</p><p>第0天第二次买入操作，初始值应该是多少呢？应该不少同学疑惑，第一次还没买入呢，怎么初始化第二次买入呢？</p><p>第二次买入依赖于第一次卖出的状态，其实相当于第0天第一次买入了，第一次卖出了，然后在买入一次（第二次买入），那么现在手头上没有现金，只要买入，现金就做相应的减少。</p><p>所以第二次买入操作，初始化为：dp[0][3] &#x3D; -prices[0];</p><p>同理第二次卖出初始化dp[0][4] &#x3D; 0;</p><ol start="4"><li>确定遍历顺序</li></ol><p>从递归公式其实已经可以看出，一定是从前向后遍历，因为dp[i]，依靠dp[i - 1]的数值。</p><ol start="5"><li>举例推导dp数组</li></ol><p>以输入[1,2,3,4,5]为例</p><p><img src="https://img-blog.csdnimg.cn/20201228181724295.png" alt="123.买卖股票的最佳时机III"></p><p>大家可以看到红色框为最后两次卖出的状态。</p><p>现在最大的时候一定是卖出的状态，而两次卖出的状态现金最大一定是最后一次卖出。</p><p>所以最终最大利润是dp[4][4]</p><p>以上五部都分析完了，不难写出如下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(prices.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">5</span>, <span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">3</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">            dp[i][<span class="number">2</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">2</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i][<span class="number">3</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">3</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>] - prices[i]);</span><br><span class="line">            dp[i][<span class="number">4</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">4</span>], dp[i - <span class="number">1</span>][<span class="number">3</span>] + prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[prices.<span class="built_in">size</span>() - <span class="number">1</span>][<span class="number">4</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="买卖股票的最佳时机IV"><a href="#买卖股票的最佳时机IV" class="headerlink" title="买卖股票的最佳时机IV"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/">买卖股票的最佳时机IV</a></h1><p>给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p>示例 1： 输入：k &#x3D; 2, prices &#x3D; [2,4,1] 输出：2 解释：在第 1 天 (股票价格 &#x3D; 2) 的时候买入，在第 2 天 (股票价格 &#x3D; 4) 的时候卖出，这笔交易所能获得利润 &#x3D; 4-2 &#x3D; 2。</p><p>示例 2： 输入：k &#x3D; 2, prices &#x3D; [3,2,6,5,0,3] 输出：7 解释：在第 2 天 (股票价格 &#x3D; 2) 的时候买入，在第 3 天 (股票价格 &#x3D; 6) 的时候卖出, 这笔交易所能获得利润 &#x3D; 6-2 &#x3D; 4。随后，在第 5 天 (股票价格 &#x3D; 0) 的时候买入，在第 6 天 (股票价格 &#x3D; 3) 的时候卖出, 这笔交易所能获得利润 &#x3D; 3-0 &#x3D; 3 。</p><p>提示：</p><ul><li>0 &lt;&#x3D; k &lt;&#x3D; 100</li><li>0 &lt;&#x3D; prices.length &lt;&#x3D; 1000</li><li>0 &lt;&#x3D; prices[i] &lt;&#x3D; 1000</li></ul><h2 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h2><p>这道题目可以说是<a href="https://programmercarl.com/0123.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIII.html">动态规划：123.买卖股票的最佳时机III</a>的进阶版，这里要求至多有k次交易。</p><p>动规五部曲，分析如下：</p><ol><li>确定dp数组以及下标的含义</li></ol><p>在<a href="https://programmercarl.com/0123.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIII.html">动态规划：123.买卖股票的最佳时机III </a>中，我是定义了一个二维dp数组，本题其实依然可以用一个二维dp数组。</p><p>使用二维数组 dp[i][j] ：第i天的状态为j，所剩下的最大现金是dp[i][j]</p><p>j的状态表示为：</p><ul><li>0 表示不操作</li><li>1 第一次买入</li><li>2 第一次卖出</li><li>3 第二次买入</li><li>4 第二次卖出</li><li>…..</li></ul><p><strong>大家应该发现规律了吧 ，除了0以外，偶数就是卖出，奇数就是买入</strong>。</p><p>题目要求是至多有K笔交易，那么j的范围就定义为 2 * k + 1 就可以了。</p><p>所以二维dp数组的C++定义为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(prices.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span> * k + <span class="number">1</span>, <span class="number">0</span>));</span><br></pre></td></tr></table></figure><ol start="2"><li>确定递推公式</li></ol><p>还要强调一下：dp[i][1]，<strong>表示的是第i天，买入股票的状态，并不是说一定要第i天买入股票，这是很多同学容易陷入的误区</strong>。</p><p>达到dp[i][1]状态，有两个具体操作：</p><ul><li>操作一：第i天买入股票了，那么dp[i][1] &#x3D; dp[i - 1][0] - prices[i]</li><li>操作二：第i天没有操作，而是沿用前一天买入的状态，即：dp[i][1] &#x3D; dp[i - 1][1]</li></ul><p>选最大的，所以 dp[i][1] &#x3D; max(dp[i - 1][0] - prices[i], dp[i - 1][1]);</p><p>同理dp[i][2]也有两个操作：</p><ul><li>操作一：第i天卖出股票了，那么dp[i][2] &#x3D; dp[i - 1][1] + prices[i]</li><li>操作二：第i天没有操作，沿用前一天卖出股票的状态，即：dp[i][2] &#x3D; dp[i - 1][2]</li></ul><p>所以dp[i][2] &#x3D; max(dp[i - 1][1] + prices[i], dp[i - 1][2])</p><p>同理可以类比剩下的状态，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span> * k - <span class="number">1</span>; j += <span class="number">2</span>) &#123;</span><br><span class="line">    dp[i][j + <span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j + <span class="number">1</span>], dp[i - <span class="number">1</span>][j] - prices[i]);</span><br><span class="line">    dp[i][j + <span class="number">2</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j + <span class="number">2</span>], dp[i - <span class="number">1</span>][j + <span class="number">1</span>] + prices[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本题和<a href="https://programmercarl.com/0123.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIII.html">动态规划：123.买卖股票的最佳时机III</a>最大的区别就是这里要类比j为奇数是买，偶数是卖的状态。</p><ol start="3"><li>dp数组如何初始化</li></ol><p>第0天没有操作，这个最容易想到，就是0，即：dp[0][0] &#x3D; 0;</p><p>第0天做第一次买入的操作，dp[0][1] &#x3D; -prices[0];</p><p>第0天做第一次卖出的操作，这个初始值应该是多少呢？</p><p>首先卖出的操作一定是收获利润，整个股票买卖最差情况也就是没有盈利即全程无操作现金为0，</p><p>从递推公式中可以看出每次是取最大值，那么既然是收获利润如果比0还小了就没有必要收获这个利润了。</p><p>所以dp[0][2] &#x3D; 0;</p><p>第0天第二次买入操作，初始值应该是多少呢？</p><p>不用管第几次，现在手头上没有现金，只要买入，现金就做相应的减少。</p><p>第二次买入操作，初始化为：dp[0][3] &#x3D; -prices[0];</p><p><strong>所以同理可以推出dp[0][j]当j为奇数的时候都初始化为 -prices[0]</strong></p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; <span class="number">2</span> * k; j += <span class="number">2</span>) &#123;</span><br><span class="line">    dp[<span class="number">0</span>][j] = -prices[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在初始化的地方同样要类比j为偶数是卖、奇数是买的状态</strong>。</p><ol start="4"><li>确定遍历顺序</li></ol><p>从递归公式其实已经可以看出，一定是从前向后遍历，因为dp[i]，依靠dp[i - 1]的数值。</p><ol start="5"><li>举例推导dp数组</li></ol><p>以输入[1,2,3,4,5]，k&#x3D;2为例。</p><p><img src="https://img-blog.csdnimg.cn/20201229100358221.png" alt="188.买卖股票的最佳时机IV"></p><p>最后一次卖出，一定是利润最大的，dp[prices.size() - 1][2 * k]即红色部分就是最后求解。</p><p>以上分析完毕，C++代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(<span class="type">int</span> k, vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (prices.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(prices.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span> * k + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; <span class="number">2</span> * k; j += <span class="number">2</span>) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = -prices[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt; prices.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span> * k - <span class="number">1</span>; j += <span class="number">2</span>) &#123;</span><br><span class="line">                dp[i][j + <span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j + <span class="number">1</span>], dp[i - <span class="number">1</span>][j] - prices[i]);</span><br><span class="line">                dp[i][j + <span class="number">2</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j + <span class="number">2</span>], dp[i - <span class="number">1</span>][j + <span class="number">1</span>] + prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[prices.<span class="built_in">size</span>() - <span class="number">1</span>][<span class="number">2</span> * k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="最佳买卖股票时机含冷冻期"><a href="#最佳买卖股票时机含冷冻期" class="headerlink" title="最佳买卖股票时机含冷冻期"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/">最佳买卖股票时机含冷冻期</a></h1><p>给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。</p><p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p><ul><li>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</li><li>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</li></ul><p>示例: 输入: [1,2,3,0,2] 输出: 3 解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]</p><h2 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h2><p>相对于<a href="https://programmercarl.com/0122.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89.html">动态规划：122.买卖股票的最佳时机II </a>，本题加上了一个冷冻期</p><p>在<a href="https://programmercarl.com/0122.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89.html">动态规划：122.买卖股票的最佳时机II </a>中有两个状态，持有股票后的最多现金，和不持有股票的最多现金。</p><p>动规五部曲，分析如下：</p><ol><li>确定dp数组以及下标的含义</li></ol><p>dp[i][j]，第i天状态为j，所剩的最多现金为dp[i][j]。</p><p><strong>其实本题很多同学搞的比较懵，是因为出现冷冻期之后，状态其实是比较复杂度</strong>，例如今天买入股票、今天卖出股票、今天是冷冻期，都是不能操作股票的。 具体可以区分出如下四个状态：</p><ul><li>状态一：买入股票状态（今天买入股票，或者是之前就买入了股票然后没有操作）</li><li>卖出股票状态，这里就有两种卖出股票状态<ul><li>状态二：两天前就卖出了股票，度过了冷冻期，一直没操作，今天保持卖出股票状态</li><li>状态三：今天卖出了股票</li></ul></li><li>状态四：今天为冷冻期状态，但冷冻期状态不可持续，只有一天！</li></ul><p>j的状态为：</p><ul><li>0：状态一</li><li>1：状态二</li><li>2：状态三</li><li>3：状态四</li></ul><p>很多题解为什么讲的比较模糊，是因为把这四个状态合并成三个状态了，其实就是把状态二和状态四合并在一起了。</p><p>从代码上来看确实可以合并，但从逻辑上分析合并之后就很难理解了，所以我下面的讲解是按照这四个状态来的，把每一个状态分析清楚。</p><p><strong>注意这里的每一个状态，例如状态一，是买入股票状态并不是说今天已经就买入股票，而是说保存买入股票的状态即：可能是前几天买入的，之后一直没操作，所以保持买入股票的状态</strong>。</p><ol start="2"><li>确定递推公式</li></ol><p>达到买入股票状态（状态一）即：dp[i][0]，有两个具体操作：</p><ul><li>操作一：前一天就是持有股票状态（状态一），dp[i][0] &#x3D; dp[i - 1][0]</li><li>操作二：今天买入了，有两种情况<ul><li>前一天是冷冻期（状态四），dp[i - 1][3] - prices[i]</li><li>前一天是保持卖出股票状态（状态二），dp[i - 1][1] - prices[i]</li></ul></li></ul><p>所以操作二取最大值，即：max(dp[i - 1][3], dp[i - 1][1]) - prices[i]</p><p>那么dp[i][0] &#x3D; max(dp[i - 1][0], max(dp[i - 1][3], dp[i - 1][1]) - prices[i]);</p><p>达到保持卖出股票状态（状态二）即：dp[i][1]，有两个具体操作：</p><ul><li>操作一：前一天就是状态二</li><li>操作二：前一天是冷冻期（状态四）</li></ul><p>dp[i][1] &#x3D; max(dp[i - 1][1], dp[i - 1][3]);</p><p>达到今天就卖出股票状态（状态三），即：dp[i][2] ，只有一个操作：</p><ul><li>操作一：昨天一定是买入股票状态（状态一），今天卖出</li></ul><p>即：dp[i][2] &#x3D; dp[i - 1][0] + prices[i];</p><p>达到冷冻期状态（状态四），即：dp[i][3]，只有一个操作：</p><ul><li>操作一：昨天卖出了股票（状态三）</li></ul><p>dp[i][3] &#x3D; dp[i - 1][2];</p><p>综上分析，递推代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>], <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">3</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>]) - prices[i]);</span><br><span class="line">dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">3</span>]);</span><br><span class="line">dp[i][<span class="number">2</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i];</span><br><span class="line">dp[i][<span class="number">3</span>] = dp[i - <span class="number">1</span>][<span class="number">2</span>];</span><br></pre></td></tr></table></figure><ol start="3"><li>dp数组如何初始化</li></ol><p>这里主要讨论一下第0天如何初始化。</p><p>如果是持有股票状态（状态一）那么：dp[0][0] &#x3D; -prices[0]，买入股票所剩现金为负数。</p><p>保持卖出股票状态（状态二），第0天没有卖出dp[0][1]初始化为0就行，</p><p>今天卖出了股票（状态三），同样dp[0][2]初始化为0，因为最少收益就是0，绝不会是负数。</p><p>同理dp[0][3]也初始为0。</p><ol start="4"><li>确定遍历顺序</li></ol><p>从递归公式上可以看出，dp[i] 依赖于 dp[i-1]，所以是从前向后遍历。</p><ol start="5"><li>举例推导dp数组</li></ol><p>以 [1,2,3,0,2] 为例，dp数组如下：</p><p><img src="https://img-blog.csdnimg.cn/2021032317451040.png" alt="309.最佳买卖股票时机含冷冻期"></p><p>最后结果是取 状态二，状态三，和状态四的最大值，不少同学会把状态四忘了，状态四是冷冻期，最后一天如果是冷冻期也可能是最大值。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">4</span>, <span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] -= prices[<span class="number">0</span>]; <span class="comment">// 持股票</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>], <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">3</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>]) - prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">3</span>]);</span><br><span class="line">            dp[i][<span class="number">2</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i];</span><br><span class="line">            dp[i][<span class="number">3</span>] = dp[i - <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp[n - <span class="number">1</span>][<span class="number">3</span>],<span class="built_in">max</span>(dp[n - <span class="number">1</span>][<span class="number">1</span>], dp[n - <span class="number">1</span>][<span class="number">2</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="买卖股票的最佳时机含手续费"><a href="#买卖股票的最佳时机含手续费" class="headerlink" title="买卖股票的最佳时机含手续费"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">买卖股票的最佳时机含手续费</a></h1><p>给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。</p><p>你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</p><p>返回获得利润的最大值。</p><p>注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。</p><p>示例 1: 输入: prices &#x3D; [1, 3, 2, 8, 4, 9], fee &#x3D; 2 输出: 8</p><p>解释: 能够达到的最大利润: 在此处买入 prices[0] &#x3D; 1 在此处卖出 prices[3] &#x3D; 8 在此处买入 prices[4] &#x3D; 4 在此处卖出 prices[5] &#x3D; 9 总利润: ((8 - 1) - 2) + ((9 - 4) - 2) &#x3D; 8.</p><p>注意:</p><ul><li>0 &lt; prices.length &lt;&#x3D; 50000.</li><li>0 &lt; prices[i] &lt; 50000.</li><li>0 &lt;&#x3D; fee &lt; 50000.</li></ul><h2 id="思路-11"><a href="#思路-11" class="headerlink" title="思路"></a>思路</h2><p>在讲解贪心专题的时候，我们已经讲过本题了<a href="https://programmercarl.com/0714.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9.html">贪心算法：买卖股票的最佳时机含手续费</a></p><p>使用贪心算法，的性能是：</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><p>那么我们再来看看是使用动规的方法如何解题。</p><p>相对于<a href="https://programmercarl.com/0122.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89.html">动态规划：122.买卖股票的最佳时机II </a>，本题只需要在计算卖出操作的时候减去手续费就可以了，代码几乎是一样的。</p><p>唯一差别在于递推公式部分，所以本篇也就不按照动规五部曲详细讲解了，主要讲解一下递推公式部分。</p><p>这里重申一下dp数组的含义：</p><p>dp[i][0] 表示第i天持有股票所省最多现金。 dp[i][1] 表示第i天不持有股票所得最多现金</p><p>如果第i天持有股票即dp[i][0]， 那么可以由两个状态推出来</p><ul><li>第i-1天就持有股票，那么就保持现状，所得现金就是昨天持有股票的所得现金 即：dp[i - 1][0]</li><li>第i天买入股票，所得现金就是昨天不持有股票的所得现金减去 今天的股票价格 即：dp[i - 1][1] - prices[i]</li></ul><p>所以：dp[i][0] &#x3D; max(dp[i - 1][0], dp[i - 1][1] - prices[i]);</p><p>在来看看如果第i天不持有股票即dp[i][1]的情况， 依然可以由两个状态推出来</p><ul><li>第i-1天就不持有股票，那么就保持现状，所得现金就是昨天不持有股票的所得现金 即：dp[i - 1][1]</li><li>第i天卖出股票，所得现金就是按照今天股票价格卖出后所得现金，<strong>注意这里需要有手续费了</strong>即：dp[i - 1][0] + prices[i] - fee</li></ul><p>所以：dp[i][1] &#x3D; max(dp[i - 1][1], dp[i - 1][0] + prices[i] - fee);</p><p>本题和<a href="https://programmercarl.com/0122.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89.html">动态规划：122.买卖股票的最佳时机II </a>的区别就是这里需要多一个减去手续费的操作。</p><p>以上分析完毕，C++代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices, <span class="type">int</span> fee)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] -= prices[<span class="number">0</span>]; <span class="comment">// 持股票</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] - prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i] - fee);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp[n - <span class="number">1</span>][<span class="number">0</span>], dp[n - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>声明：</p><p>本博客整理主要参考《代码随想录》，题目来自leetcode</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UE4-第一人称FPS-代码讲解（一）</title>
      <link href="/2022/04/29/UE4-%E7%AC%AC%E4%B8%80%E4%BA%BA%E7%A7%B0FPS-%E4%BB%A3%E7%A0%81%E8%AE%B2%E8%A7%A3%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2022/04/29/UE4-%E7%AC%AC%E4%B8%80%E4%BA%BA%E7%A7%B0FPS-%E4%BB%A3%E7%A0%81%E8%AE%B2%E8%A7%A3%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>案例是来自官方文档的<a href="https://docs.unrealengine.com/4.27/zh-CN/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/1/">第一人称射击游戏教程</a>，详细实施步骤可以看我之前的博客，或者直接取官网查看，此处仅仅讲解实现项目的代码</p><h1 id="添加日志消息"><a href="#添加日志消息" class="headerlink" title="添加日志消息"></a>添加日志消息</h1><h2 id="FPSProjectGameMode-h"><a href="#FPSProjectGameMode-h" class="headerlink" title="FPSProjectGameMode.h"></a>FPSProjectGameMode.h</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CoreMinimal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GameFramework/GameModeBase.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;FPSProjectGameModeBase.generated.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FPSPROJECT_API</span> AFPSProjectGameModeBase : <span class="keyword">public</span> AGameModeBase</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于重载StartPlay()函数</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">StartPlay</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这一段没啥好说的，唯一修改的地方就是在此声明StartPlay()函数，使我们可以将其重载</p><h2 id="FPSProjectGameModeBase-cpp"><a href="#FPSProjectGameModeBase-cpp" class="headerlink" title="FPSProjectGameModeBase.cpp"></a>FPSProjectGameModeBase.cpp</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Epic Games, Inc版权所有。保留所有权利。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;FPSProjectGameMode.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSProjectGameModeBase::StartPlay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Super::<span class="built_in">StartPlay</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">check</span>(GEngine != <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示调试消息五秒。 </span></span><br><span class="line"><span class="comment">// -1&quot;键&quot;值参数防止该消息被更新或刷新。</span></span><br><span class="line">GEngine-&gt;<span class="built_in">AddOnScreenDebugMessage</span>(<span class="number">-1</span>, <span class="number">5.0f</span>, FColor::Yellow, <span class="built_in">TEXT</span>(<span class="string">&quot;Hello World, this is FPSGameModeBase!&quot;</span>));</span><br></pre></td></tr></table></figure><h3 id="check"><a href="#check" class="headerlink" title="check()"></a><a href="https://docs.unrealengine.com/5.0/zh-CN/asserts-in-unreal-engine/">check()</a></h3><p>check()为断言</p><p>在C和C++编程中，<code>assert</code> 可在开发期间帮助检测和诊断不正常或无效的运行时条件。</p><p>这些条件通常检查是否指针为非空、除数为非零、函数并非递归运行，或代码要求的其他重要假设。但每次检查会使得效率十分低下。某些情况下，<code>assert</code> 会在延迟崩溃发生之前发现导致该崩溃的bug，例如删除未来tick所需的对象，协助开发人员发现引起崩溃的根本原因。</p><p><code>assert</code> 的关键特性之一是不存在于发布代码中，这意味着不但不会影响发布产品的性能，也没有任何副作用。对 <code>assert</code> 最简单的理解就是：**”断言”必须一律为true，否则程序会停止运行**。</p><p>虚幻引擎4（UE4）提供 <code>assert</code> 等同项的三个不同族系：<code>check</code>、<code>verify</code> 和 <code>ensure</code>。各个功能的行为略有不同，但它们都是开发期间使用的诊断工具，目标大致相同。</p><p>Check族系最接近基础 <code>assert</code>，因为当第一个参数得出的值为false时，此族系的成员会停止执行，且默认不会在发布版本中运行。以下Check宏可用：</p><table><thead><tr><th>宏</th><th>参数</th><th>行为</th></tr></thead><tbody><tr><td><code>check</code> 或 <code>checkSlow</code></td><td><code>Expression</code></td><td>若 <code>Expression</code> 为false，停止执行</td></tr><tr><td><code>checkf</code> 或 <code>checkfSlow</code></td><td><code>Expression</code>、<code>FormattedText</code>、<code>...</code></td><td>若 <code>Expression</code> 为false，则停止执行并将 <code>FormattedText</code> 输出到日志</td></tr><tr><td><code>checkCode</code></td><td><code>Code</code></td><td>在运行一次的do-while循环结构中执行 <code>Code</code>；主要用于准备另一个Check所需的信息</td></tr><tr><td><code>checkNoEntry</code></td><td>（无）</td><td>若此行被hit，则停止执行，类似于 <code>check(false)</code>，但主要用于应不可到达的代码路径</td></tr><tr><td><code>checkNoReentry</code></td><td>（无）</td><td>若此行被hit超过一次，则停止执行</td></tr><tr><td><code>checkNoRecursion</code></td><td>（无）</td><td>若此行被hit超过一次而未离开作用域，则停止执行</td></tr><tr><td><code>unimplemented</code></td><td>（无）</td><td>若此行被hit，则停止执行，类似于 <code>check(false)</code>，但主要用于应被覆盖而不会被调用的虚拟函数</td></tr></tbody></table><h3 id="GEngine"><a href="#GEngine" class="headerlink" title="GEngine"></a>GEngine</h3><p>看作一个全局指针，并且是只读的。</p><p>其经常使用为拿到当前的World: </p><ul><li><p>使用的成员方法为:GetWorldFromContextObject</p></li><li><p>参数为World的一个Uobject</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!GEngine || !GEngine-&gt;<span class="built_in">UseSound</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">UWorld* ThisWorld = GEngine-&gt;<span class="built_in">GetWorldFromContextObject</span>(WorldContextObject, EGetWorldErrorMode::L</span><br></pre></td></tr></table></figure><h2 id="AddOnScreenDebugMessage"><a href="#AddOnScreenDebugMessage" class="headerlink" title="AddOnScreenDebugMessage()"></a>AddOnScreenDebugMessage()</h2><p>在屏幕上打印试错信息</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GEngine-&gt;<span class="built_in">AddOnScreenDebugMessage</span>(<span class="number">-1</span>, <span class="number">5.0f</span>, FColor::Yellow, <span class="built_in">TEXT</span>(<span class="string">&quot;Hello World, this is FPSGameMode!&quot;</span>));</span><br></pre></td></tr></table></figure><p><code>AddOnScreenDebugMessage(uint64 Key, float TimeToDisplay, FColor DisplayColor, const FString&amp; DebugMessage, bool bNewerOnTop, const FVector2D&amp; TextScale)</code></p><ul><li><p>第一个参数默认为-1</p></li><li><p>第二个参数是debug显示时间</p></li><li><p>第三个参数是显示颜色</p></li><li><p>第四个参数是显示信息</p></li><li><p>第五个参数是是否在上面显示更新的消息（可不填）</p></li><li><p>第六个是显示字体大小（可不填）</p></li></ul><h1 id="实现角色移动"><a href="#实现角色移动" class="headerlink" title="实现角色移动"></a>实现角色移动</h1><h2 id="FPSCharacter-h"><a href="#FPSCharacter-h" class="headerlink" title="FPSCharacter.h"></a>FPSCharacter.h</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CoreMinimal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GameFramework/Character.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;FPSCharacter.generated.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FPSPROJECT_API</span> AFPSCharacter : <span class="keyword">public</span> ACharacter</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 为此角色的属性设置默认值</span></span><br><span class="line">    <span class="built_in">AFPSCharacter</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// 当游戏开始或重生（Spawn）时被调用</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BeginPlay</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 每一帧都被调用</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Tick</span><span class="params">( <span class="type">float</span> DeltaTime )</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 被调用，将功能与输入绑定</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SetupPlayerInputComponent</span><span class="params">(<span class="keyword">class</span> UInputComponent* PlayerInputComponent)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理用于前后移动的输入。</span></span><br><span class="line">    <span class="built_in">UFUNCTION</span>()</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">MoveForward</span><span class="params">(<span class="type">float</span> Value)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理用于左右移动的输入。</span></span><br><span class="line">    <span class="built_in">UFUNCTION</span>()</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">MoveRight</span><span class="params">(<span class="type">float</span> Value)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>声明前进和左右移动的函数，参数为Value，来自于在编辑界面中绑定的那个值</p><h2 id="FPSCharacter-cpp"><a href="#FPSCharacter-cpp" class="headerlink" title="FPSCharacter.cpp"></a>FPSCharacter.cpp</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;FPSCharacter.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置默认值</span></span><br><span class="line">AFPSCharacter::<span class="built_in">AFPSCharacter</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 将此角色设置为每帧调用Tick()。  如果不需要此特性，可以关闭以提升性能。</span></span><br><span class="line">    PrimaryActorTick.bCanEverTick = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当游戏开始或重生（Spawn）时被调用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::BeginPlay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">BeginPlay</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">check</span>(GEngine != <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 显示调试消息五秒。 </span></span><br><span class="line">    <span class="comment">// -1&quot;键&quot;值参数可以防止更新或刷新消息。</span></span><br><span class="line">      GEngine-&gt;<span class="built_in">AddOnScreenDebugMessage</span>(<span class="number">-1</span>, <span class="number">5.0f</span>, FColor::Red, <span class="built_in">TEXT</span>(<span class="string">&quot;We are using FPSCharacter.&quot;</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每一帧都被调用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::Tick</span><span class="params">( <span class="type">float</span> DeltaTime )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">Tick</span>( DeltaTime );</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 被调用，将功能与输入绑定</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::SetupPlayerInputComponent</span><span class="params">(UInputComponent* PlayerInputComponent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">SetupPlayerInputComponent</span>(PlayerInputComponent);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置&quot;移动&quot;绑定。</span></span><br><span class="line">    PlayerInputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="string">&quot;MoveForward&quot;</span>, <span class="keyword">this</span>, &amp;AFPSCharacter::MoveForward);</span><br><span class="line">    PlayerInputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="string">&quot;MoveRight&quot;</span>, <span class="keyword">this</span>, &amp;AFPSCharacter::MoveRight);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::MoveForward</span><span class="params">(<span class="type">float</span> Value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 找出&quot;前进&quot;方向，并记录玩家想向该方向移动。</span></span><br><span class="line">    FVector Direction = <span class="built_in">FRotationMatrix</span>(Controller-&gt;<span class="built_in">GetControlRotation</span>()).<span class="built_in">GetScaledAxis</span>(EAxis::X);</span><br><span class="line">    <span class="built_in">AddMovementInput</span>(Direction, Value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::MoveRight</span><span class="params">(<span class="type">float</span> Value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 找出&quot;右侧&quot;方向，并记录玩家想向该方向移动。</span></span><br><span class="line">    FVector Direction = <span class="built_in">FRotationMatrix</span>(Controller-&gt;<span class="built_in">GetControlRotation</span>()).<span class="built_in">GetScaledAxis</span>(EAxis::Y);</span><br><span class="line">    <span class="built_in">AddMovementInput</span>(Direction, Value);</span><br><span class="line">&#125;<span class="built_in">mponent</span>(PlayerInputComponent);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看移动函数，功能和输入绑定那块我们一会儿回过头来再看！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::MoveForward</span><span class="params">(<span class="type">float</span> Value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 找出&quot;前进&quot;方向，并记录玩家想向该方向移动。</span></span><br><span class="line">    FVector Direction = <span class="built_in">FRotationMatrix</span>(Controller-&gt;<span class="built_in">GetControlRotation</span>()).<span class="built_in">GetScaledAxis</span>(EAxis::X);</span><br><span class="line">    <span class="built_in">AddMovementInput</span>(Direction, Value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本函数首先通过<code>GetScaledAxis(EAxis::X)</code>获取方向，比如此处是沿X轴（在编辑器中X轴代表前方，Y轴代表右方）</p><p>再通过<code>Controller-&gt;GetControlRotation()</code>获取管理员的旋转方位作为<code>FRotationMatrix()</code>的值并记录在变量Direction中</p><p>最后<code>AddMovementInput(Direction, Value)</code>函数实现向前移动</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 被调用，将功能与输入绑定</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::SetupPlayerInputComponent</span><span class="params">(UInputComponent* PlayerInputComponent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">SetupPlayerInputComponent</span>(PlayerInputComponent);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置&quot;移动&quot;绑定。</span></span><br><span class="line">    PlayerInputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="string">&quot;MoveForward&quot;</span>, <span class="keyword">this</span>, &amp;AFPSCharacter::MoveForward);</span><br><span class="line">    PlayerInputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="string">&quot;MoveRight&quot;</span>, <span class="keyword">this</span>, &amp;AFPSCharacter::MoveRight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再回过头来看绑定操作</p><p>很眼熟是不是？和我之前那篇博客里面实现小球的移动的绑定方式一模一样</p><p>在这里简述一下</p><p><code>BindAxis</code>绑定轴映射，与编辑-&gt;项目设置-&gt;输入-&gt;轴映射里面的命名必须一致</p><p>第一个参数为事件，此事件作用于第二个参数所指定的指针，由第三个参数（一个函数）来实现这个事件！</p><h1 id="实现鼠标摄像机控制"><a href="#实现鼠标摄像机控制" class="headerlink" title="实现鼠标摄像机控制"></a>实现鼠标摄像机控制</h1><h2 id="FPSCharacter-cpp-1"><a href="#FPSCharacter-cpp-1" class="headerlink" title="FPSCharacter.cpp"></a>FPSCharacter.cpp</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 被调用，将功能与输入绑定</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::SetupPlayerInputComponent</span><span class="params">(UInputComponent* PlayerInputComponent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">SetupPlayerInputComponent</span>(PlayerInputComponent);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置&quot;移动&quot;绑定。</span></span><br><span class="line">    PlayerInputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="string">&quot;MoveForward&quot;</span>, <span class="keyword">this</span>, &amp;AFPSCharacter::MoveForward);</span><br><span class="line">    PlayerInputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="string">&quot;MoveRight&quot;</span>, <span class="keyword">this</span>, &amp;AFPSCharacter::MoveRight);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置&quot;观看&quot;绑定。</span></span><br><span class="line">    PlayerInputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="string">&quot;Turn&quot;</span>, <span class="keyword">this</span>, &amp;AFPSCharacter::AddControllerYawInput);</span><br><span class="line">    PlayerInputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="string">&quot;LookUp&quot;</span>, <span class="keyword">this</span>, &amp;AFPSCharacter::AddControllerPitchInput);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里只需要设置鼠标对应的轴映射即可，与上文的移动绑定并无太大区别</p><h1 id="实现角色跳跃"><a href="#实现角色跳跃" class="headerlink" title="实现角色跳跃"></a>实现角色跳跃</h1><h2 id="FPSCharacter-h-1"><a href="#FPSCharacter-h-1" class="headerlink" title="FPSCharacter.h"></a>FPSCharacter.h</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CoreMinimal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GameFramework/Character.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;FPSCharacter.generated.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FPSPROJECT_API</span> AFPSCharacter : <span class="keyword">public</span> ACharacter</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 为此角色的属性设置默认值</span></span><br><span class="line">    <span class="built_in">AFPSCharacter</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// 当游戏开始或重生（Spawn）时被调用</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BeginPlay</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 每一帧都被调用</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Tick</span><span class="params">( <span class="type">float</span> DeltaTime )</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 被调用，将功能与输入绑定</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SetupPlayerInputComponent</span><span class="params">(<span class="keyword">class</span> UInputComponent* PlayerInputComponent)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理用于前后移动的输入。</span></span><br><span class="line">    <span class="built_in">UFUNCTION</span>()</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">MoveForward</span><span class="params">(<span class="type">float</span> Value)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理用于左右移动的输入。</span></span><br><span class="line">    <span class="built_in">UFUNCTION</span>()</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">MoveRight</span><span class="params">(<span class="type">float</span> Value)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按下键时，设置跳跃标记。</span></span><br><span class="line">    <span class="built_in">UFUNCTION</span>()</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">StartJump</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放键时，清除跳跃标记。</span></span><br><span class="line">    <span class="built_in">UFUNCTION</span>()</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">StopJump</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在Acharacter基类接口文件中，已经有了支持跳跃的成员方法。</p><p>角色跳跃与<code>bPressedJump</code>变量绑定，因此我们只需要在跳跃惭怍按下时将该布尔值设置为true，在跳跃操作释放时将该布尔值设置为false</p><p>现在我们通过StartJump()和StopJump()两个函数来完成改变布尔值的操作</p><p>于是我们首先在FPSCharacter.h中声明两个函数的声明</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按下键时，设置跳跃标记。</span></span><br><span class="line"><span class="built_in">UFUNCTION</span>()</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StartJump</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放键时，清除跳跃标记。</span></span><br><span class="line"><span class="built_in">UFUNCTION</span>()</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StopJump</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>接来下，我们在FPSCharacter.cpp中将其定义</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::StartJump</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bPressedJump = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::StopJump</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bPressedJump = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，我们对其进行按键绑定</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置&quot;操作&quot;绑定。</span></span><br><span class="line">PlayerInputComponent-&gt;<span class="built_in">BindAction</span>(<span class="string">&quot;Jump&quot;</span>, IE_Pressed, <span class="keyword">this</span>, &amp;AFPSCharacter::StartJump);</span><br><span class="line">PlayerInputComponent-&gt;<span class="built_in">BindAction</span>(<span class="string">&quot;Jump&quot;</span>, IE_Released, <span class="keyword">this</span>, &amp;AFPSCharacter::StopJump);</span><br></pre></td></tr></table></figure><p>BindAction()函数在我的前一篇博客中也做了详细讲解</p><p>这里提醒一下IE_Preesed和IE_Released分别代表了按压按键和松开按键的行为</p><h1 id="更改摄像机视角"><a href="#更改摄像机视角" class="headerlink" title="更改摄像机视角"></a>更改摄像机视角</h1><p>在此步骤中，你将设置FPS摄像机，这样你可以调整摄像机的属性（例如位置和视野）</p><p>在FPSCharacter.h中添加头文件</p><p><code>Camera/CameraComponent.h</code>摄像机组件</p><p><code>Components/CapsuleComonent.h</code> 胶囊体组件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Camera/CameraComponent.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Components/CapsuleComponent.h&quot;</span></span></span><br></pre></td></tr></table></figure><h2 id="FPSCharacter-h-2"><a href="#FPSCharacter-h-2" class="headerlink" title="FPSCharacter.h"></a>FPSCharacter.h</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FPS摄像机。</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(VisibleAnywhere)</span><br><span class="line">UCameraComponent* FPSCameraComponent;</span><br></pre></td></tr></table></figure><p>声明一个摄像机组件，并且使其可视化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CoreMinimal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GameFramework/Character.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Camera/CameraComponent.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Components/CapsuleComponent.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;FPSCharacter.generated.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FPSPROJECT_API</span> AFPSCharacter : <span class="keyword">public</span> ACharacter</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 为此角色的属性设置默认值</span></span><br><span class="line"><span class="built_in">AFPSCharacter</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="comment">// 当游戏开始或重生（Spawn）时被调用</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BeginPlay</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:     </span><br><span class="line"><span class="comment">// 每一帧都被调用</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Tick</span><span class="params">( <span class="type">float</span> DeltaTime )</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 被调用，将功能与输入绑定</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SetupPlayerInputComponent</span><span class="params">(<span class="keyword">class</span> UInputComponent* PlayerInputComponent)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理用于前后移动的输入。</span></span><br><span class="line"><span class="built_in">UFUNCTION</span>()</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MoveForward</span><span class="params">(<span class="type">float</span> Value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理用于左右移动的输入。</span></span><br><span class="line"><span class="built_in">UFUNCTION</span>()</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MoveRight</span><span class="params">(<span class="type">float</span> Value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按下键时，设置跳跃标记。</span></span><br><span class="line"><span class="built_in">UFUNCTION</span>()</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StartJump</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放键时，清除跳跃标记。</span></span><br><span class="line"><span class="built_in">UFUNCTION</span>()</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StopJump</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// FPS摄像机</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(VisibleAnywhere)</span><br><span class="line">UCameraComponent* FPSCameraComponent;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="FPSCharacter-cpp-2"><a href="#FPSCharacter-cpp-2" class="headerlink" title="FPSCharacter.cpp"></a>FPSCharacter.cpp</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建第一人称摄像机组件。</span></span><br><span class="line">FPSCameraComponent = <span class="built_in">CreateDefaultSubobject</span>&lt;UCameraComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;FirstPersonCamera&quot;</span>));</span><br><span class="line"><span class="built_in">check</span>(FPSCameraComponent != <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将摄像机组件附加到我们的胶囊体组件。</span></span><br><span class="line">FPSCameraComponent-&gt;<span class="built_in">SetupAttachment</span>(<span class="built_in">CastChecked</span>&lt;USceneComponent, UCapsuleComponent&gt;(<span class="built_in">GetCapsuleComponent</span>()));</span><br></pre></td></tr></table></figure><p>创建FPSCameraComponent组件</p><p>加上一个断言，保证创建成功</p><p>然后将摄像机组件附加到胶囊体，但这个时候会出现类型不匹配的问题</p><p>SetupAttachment()函数里面的参数必须是一个场景类型的组件，而此时我们想要将摄像机组件附加到一个胶囊体类型的组件上面。</p><p>所以我们需要将胶囊体类型组件进行强制转换。</p><p>有两种方式</p><p>方式一：</p><p>直接进行强制转换</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FPSCameraComponent-&gt;<span class="built_in">SetupAttachment</span>((USceneComponent *)<span class="built_in">GetCapsuleComponent</span>());</span><br></pre></td></tr></table></figure><p>方式二：</p><p>通过<code>CastCheck&lt;目标类型,原类型&gt;(组件)</code>进行强制转换</p><p>通过这个函数有什么好处呢？就是强制转换成功就照常进行，但如果强制转换失败，则会抛出异常</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FPSCameraComponent-&gt;<span class="built_in">SetupAttachment</span>(<span class="built_in">CastChecked</span>&lt;USceneComponent, UCapsuleComponent&gt;(<span class="built_in">GetCapsuleComponent</span>()));</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将摄像机置于略高于眼睛上方的位置。</span></span><br><span class="line">FPSCameraComponent-&gt;<span class="built_in">SetRelativeLocation</span>(<span class="built_in">FVector</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">50.0f</span> + BaseEyeHeight));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启用Pawn控制摄像机旋转。</span></span><br><span class="line">FPSCameraComponent-&gt;bUsePawnControlRotation = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p><code>SetRelativeLocation</code> 用于设置组件的默认值。不过，上一个值仍然会在设置在编辑器中。为纠正这点，请打开蓝图编辑器。点击 <code>FPSCameraComponent</code>，然后在 <strong>细节</strong> 面板中找到 <strong>变换 -&gt; 位置（Transform -&gt; Location）</strong> 数值。点击这个值旁边的 <strong>重置为默认（Reset to Default）</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;FPSCharacter.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置默认值</span></span><br><span class="line">AFPSCharacter::<span class="built_in">AFPSCharacter</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 将此角色设置为每帧调用Tick()。  如果不需要此特性，可以关闭以提升性能。</span></span><br><span class="line">    PrimaryActorTick.bCanEverTick = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建第一人称摄像机组件。</span></span><br><span class="line">    FPSCameraComponent = <span class="built_in">CreateDefaultSubobject</span>&lt;UCameraComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;FirstPersonCamera&quot;</span>));</span><br><span class="line">    <span class="built_in">check</span>(FPSCameraComponent != <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将摄像机组件附加到我们的胶囊体组件。</span></span><br><span class="line">    FPSCameraComponent-&gt;<span class="built_in">SetupAttachment</span>(<span class="built_in">CastChecked</span>&lt;USceneComponent, UCapsuleComponent&gt;(<span class="built_in">GetCapsuleComponent</span>()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将摄像机置于略高于眼睛上方的位置。</span></span><br><span class="line">    FPSCameraComponent-&gt;<span class="built_in">SetRelativeLocation</span>(<span class="built_in">FVector</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">50.0f</span> + BaseEyeHeight));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启用Pawn控制摄像机旋转。</span></span><br><span class="line">    FPSCameraComponent-&gt;bUsePawnControlRotation = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当游戏开始或重生（Spawn）时被调用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::BeginPlay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">BeginPlay</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">check</span>(GEngine != <span class="literal">nullptr</span>)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 显示调试消息五秒。 </span></span><br><span class="line">     <span class="comment">// -1&quot;键&quot;值（第一个参数）表示我们从不需要更新或刷新此消息。</span></span><br><span class="line">      GEngine-&gt;<span class="built_in">AddOnScreenDebugMessage</span>(<span class="number">-1</span>, <span class="number">5.0f</span>, FColor::Red, <span class="built_in">TEXT</span>(<span class="string">&quot;We are using FPSCharacter.&quot;</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每一帧都被调用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::Tick</span><span class="params">( <span class="type">float</span> DeltaTime )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">Tick</span>( DeltaTime );</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 被调用，将功能与输入绑定</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::SetupPlayerInputComponent</span><span class="params">(UInputComponent* PlayerInputComponent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">SetupPlayerInputComponent</span>(PlayerInputComponent);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置&quot;移动&quot;绑定。</span></span><br><span class="line">    PlayerInputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="string">&quot;MoveForward&quot;</span>, <span class="keyword">this</span>, &amp;AFPSCharacter::MoveForward);</span><br><span class="line">    PlayerInputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="string">&quot;MoveRight&quot;</span>, <span class="keyword">this</span>, &amp;AFPSCharacter::MoveRight);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置&quot;观看&quot;绑定。</span></span><br><span class="line">    PlayerInputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="string">&quot;Turn&quot;</span>, <span class="keyword">this</span>, &amp;AFPSCharacter::AddControllerYawInput);</span><br><span class="line">    PlayerInputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="string">&quot;LookUp&quot;</span>, <span class="keyword">this</span>, &amp;AFPSCharacter::AddControllerPitchInput);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置&quot;操作&quot;绑定。</span></span><br><span class="line">    PlayerInputComponent-&gt;<span class="built_in">BindAction</span>(<span class="string">&quot;Jump&quot;</span>, IE_Pressed, <span class="keyword">this</span>, &amp;AFPSCharacter::StartJump);</span><br><span class="line">    PlayerInputComponent-&gt;<span class="built_in">BindAction</span>(<span class="string">&quot;Jump&quot;</span>, IE_Released, <span class="keyword">this</span>, &amp;AFPSCharacter::StopJump);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::MoveForward</span><span class="params">(<span class="type">float</span> Value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 找出&quot;前进&quot;方向，并记录玩家想向该方向移动。</span></span><br><span class="line">    FVector Direction = <span class="built_in">FRotationMatrix</span>(Controller-&gt;<span class="built_in">GetControlRotation</span>()).<span class="built_in">GetScaledAxis</span>(EAxis::X);</span><br><span class="line">    <span class="built_in">AddMovementInput</span>(Direction, Value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::MoveRight</span><span class="params">(<span class="type">float</span> Value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 找出&quot;右侧&quot;方向，并记录玩家想向该方向移动。</span></span><br><span class="line">    FVector Direction = <span class="built_in">FRotationMatrix</span>(Controller-&gt;<span class="built_in">GetControlRotation</span>()).<span class="built_in">GetScaledAxis</span>(EAxis::Y);</span><br><span class="line">    <span class="built_in">AddMovementInput</span>(Direction, Value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::StartJump</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bPressedJump = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::StopJump</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bPressedJump = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="将第一人称网格体添加到角色中"><a href="#将第一人称网格体添加到角色中" class="headerlink" title="将第一人称网格体添加到角色中"></a>将第一人称网格体添加到角色中</h1><h2 id="FPSCharacter-h-3"><a href="#FPSCharacter-h-3" class="headerlink" title="FPSCharacter.h"></a>FPSCharacter.h</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一人称网格体（手臂），仅对所属玩家可见。</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(VisibleDefaultsOnly, Category = Mesh)</span><br><span class="line">USkeletalMeshComponent* FPSMesh;</span><br></pre></td></tr></table></figure><p>在头文件中声明第一人称网格体，将其命名为FPSMesh</p><h2 id="FPSCharacter-cpp-3"><a href="#FPSCharacter-cpp-3" class="headerlink" title="FPSCharacter.cpp"></a>FPSCharacter.cpp</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为所属玩家创建第一人称网格体组件。</span></span><br><span class="line">FPSMesh = <span class="built_in">CreateDefaultSubobject</span>&lt;USkeletalMeshComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;FirstPersonMesh&quot;</span>));</span><br><span class="line"><span class="built_in">check</span>(FPSMesh != <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 仅所属玩家可以看见此网格体。</span></span><br><span class="line">FPSMesh-&gt;<span class="built_in">SetOnlyOwnerSee</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 FPS 网格体附加到 FPS 摄像机。</span></span><br><span class="line">FPSMesh-&gt;<span class="built_in">SetupAttachment</span>(FPSCameraComponent);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 禁用某些环境阴影以便实现只有单个网格体的感觉。</span></span><br><span class="line">FPSMesh-&gt;bCastDynamicShadow = <span class="literal">false</span>;</span><br><span class="line">FPSMesh-&gt;CastShadow = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p>定义第一人称网格体</p><p>做一个断言</p><p>将第一人称网格体设定为仅所属玩家可见</p><p>将第一人称网格体附加到摄像机上</p><p>将第一人称网格体（手臂）的阴影禁用掉，这样就不会在地面上看到一个人有四条手臂的情况了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将第一人称网格体设置为仅所属玩家可见</span></span><br><span class="line"><span class="built_in">GetMesh</span>()-&gt;<span class="built_in">SetOwnerNoSee</span>(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>将手臂设置为仅自己可见，免得到时候其他玩家看到你一个人前面悬浮着一双手！</p><p>这一处官网的解释是：所属玩家看不到常规（第三人称）全身网格体。</p><p>我觉得是有问题的，像我这样理解的话更清楚直白</p><h1 id="将发射物添加到游戏"><a href="#将发射物添加到游戏" class="headerlink" title="将发射物添加到游戏"></a>将发射物添加到游戏</h1><h2 id="FPSProjectile-h"><a href="#FPSProjectile-h" class="headerlink" title="FPSProjectile.h"></a>FPSProjectile.h</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Components/SphereComponent.h&quot;</span></span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 球体碰撞组件。</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(VisibleDefaultsOnly, Category = Projectile)</span><br><span class="line">USphereComponent* CollisionComponent;</span><br></pre></td></tr></table></figure><p>这就很常规，首先引入头文件，然后声明球体碰撞逐渐，并将其命名为CollisionComponent</p><h2 id="FPSProjectile-cpp"><a href="#FPSProjectile-cpp" class="headerlink" title="FPSProjectile.cpp"></a>FPSProjectile.cpp</h2><p>在构造函数中添加</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!RootComponent)</span><br><span class="line">&#123;</span><br><span class="line">RootComponent = <span class="built_in">CreateDefaultSubobject</span>&lt;USceneComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;ProjectileSceneComponent&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!CollisionComponent)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 用球体进行简单的碰撞展示。</span></span><br><span class="line">CollisionComponent = <span class="built_in">CreateDefaultSubobject</span>&lt;USphereComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;SphereComponent&quot;</span>));</span><br><span class="line"><span class="comment">// 设置球体的碰撞半径。</span></span><br><span class="line">CollisionComponent-&gt;<span class="built_in">InitSphereRadius</span>(<span class="number">15.0f</span>);</span><br><span class="line"><span class="comment">// 将根组件设置为碰撞组件。</span></span><br><span class="line">RootComponent = CollisionComponent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把 <code>CollisionComponent</code> 设为 <code>RootComponent</code>，接下来的操作就都是对CollisionComponent直接进行的了。</p><p>每一次都会生成一个新的CollisionComponent，然后根组件也随之更新到新的CollisionComponent上，这样我们每次进行的操作都是对新的CollisionComponent进行的。</p><h1 id="添加发射物移动组件"><a href="#添加发射物移动组件" class="headerlink" title="添加发射物移动组件"></a>添加发射物移动组件</h1><h2 id="FPSProjectile-h-1"><a href="#FPSProjectile-h-1" class="headerlink" title="FPSProjectile.h"></a>FPSProjectile.h</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GameFramework/ProjectileMovementComponent.h&quot;</span></span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发射物移动组件。</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(VisibleAnywhere, Category = Movement)</span><br><span class="line">UProjectileMovementComponent* ProjectileMovementComponent;</span><br></pre></td></tr></table></figure><p>引入头文件，声明发射物移动组件并命名为ProjectileMovementCompone</p><h2 id="FPSProjectile-cpp-1"><a href="#FPSProjectile-cpp-1" class="headerlink" title="FPSProjectile.cpp"></a>FPSProjectile.cpp</h2><p>在FPSProjectile.cpp的构造函数中添加</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!ProjectileMovementComponent)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 使用此组件驱动发射物的移动。</span></span><br><span class="line">    ProjectileMovementComponent = <span class="built_in">CreateDefaultSubobject</span>&lt;UProjectileMovementComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;ProjectileMovementComponent&quot;</span>));</span><br><span class="line">    ProjectileMovementComponent-&gt;<span class="built_in">SetUpdatedComponent</span>(CollisionComponent);</span><br><span class="line">    ProjectileMovementComponent-&gt;InitialSpeed = <span class="number">3000.0f</span>;</span><br><span class="line">    ProjectileMovementComponent-&gt;MaxSpeed = <span class="number">3000.0f</span>;</span><br><span class="line">    ProjectileMovementComponent-&gt;bRotationFollowsVelocity = <span class="literal">true</span>;</span><br><span class="line">    ProjectileMovementComponent-&gt;bShouldBounce = <span class="literal">true</span>;</span><br><span class="line">    ProjectileMovementComponent-&gt;Bounciness = <span class="number">0.3f</span>;</span><br><span class="line">    ProjectileMovementComponent-&gt;ProjectileGravityScale = <span class="number">0.0f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>定义移动组件</p></li><li><p>将移动组件进行更新</p></li><li><p>InitialSpeed初始速度设置为3000.0f</p></li><li><p>MaxSpeed最大速度设置为3000.0f</p></li><li><p>bRotationFollowsVelocity是否沿某方向进行高速旋转</p></li><li><p>bShouldBounce能否被反弹</p></li><li><p>Bounciness受到阻碍之后的反弹力是多少</p></li><li><p>ProjectileGravityScale受到的重力大小（弹道抛物线）</p></li></ul><h1 id="设置发射物的方向"><a href="#设置发射物的方向" class="headerlink" title="设置发射物的方向"></a>设置发射物的方向</h1><p>在官网上此标题为“设置发射物的初始速度”</p><p>但是我觉得不妥，因为在上一小节中，我们已经在发射物的移动组件内设置了发射物的初始速度，在这一小节中，我们只需要定义一个函数，此函数为发射物提供一个方向，然后再根据已经初始化的速度，进行发射即可</p><h2 id="FPSProjectile-h-2"><a href="#FPSProjectile-h-2" class="headerlink" title="FPSProjectile.h"></a>FPSProjectile.h</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化射击方向上发射物速度的函数。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FireInDirection</span><span class="params">(<span class="type">const</span> FVector&amp; ShootDirection)</span></span>;</span><br></pre></td></tr></table></figure><p>声明发射物方向函数，参数为设计方向（记住这里是引用传递）</p><h2 id="FPSProjectile-cpp-2"><a href="#FPSProjectile-cpp-2" class="headerlink" title="FPSProjectile.cpp"></a>FPSProjectile.cpp</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化射击方向上发射物速度的函数。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSProjectile::FireInDirection</span><span class="params">(<span class="type">const</span> FVector&amp; ShootDirection)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ProjectileMovementComponent-&gt;Velocity = ShootDirection * ProjectileMovementComponent-&gt;InitialSpeed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Velocity的中文意思是沿某一方向的速度</p><p>所以这个值是由两个参数共同决定的-&gt;方向和速度</p><p>Velocity更像是一个向量，可以将其理解为一个合成力，它的两个子力为方向和速度</p><p>于是我们直接调用射击方向*已在移动函数中设置好的速度</p><h1 id="绑定发射输入操作"><a href="#绑定发射输入操作" class="headerlink" title="绑定发射输入操作"></a>绑定发射输入操作</h1><h2 id="FPSCharacter-h-4"><a href="#FPSCharacter-h-4" class="headerlink" title="FPSCharacter.h"></a>FPSCharacter.h</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理发射物射击的函数。</span></span><br><span class="line"><span class="built_in">UFUNCTION</span>()</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Fire</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>声明函数，没啥好多说的。</p><h2 id="FPSCharacter-cpp-4"><a href="#FPSCharacter-cpp-4" class="headerlink" title="FPSCharacter.cpp"></a>FPSCharacter.cpp</h2><p>将其下内容添加到<code>SetupPlayerInputComponent</code>中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PlayerInputComponent-&gt;<span class="built_in">BindAction</span>(<span class="string">&quot;Fire&quot;</span>, IE_Pressed, <span class="keyword">this</span>, &amp;AFPSCharacter::Fire);</span><br></pre></td></tr></table></figure><p>绑定操作按键，也没啥好多说的</p><p>先将fire()的定义添加到cpp文件中，后面咱再详细定义具体实现</p><h1 id="定义发射物的生成位置"><a href="#定义发射物的生成位置" class="headerlink" title="定义发射物的生成位置"></a>定义发射物的生成位置</h1><ol><li><p>生成 <code>FPSProjectile</code> actor并实现 <code>OnFire</code> 函数时需要考虑两点，即：</p><ul><li><p>发射物的生成位置。</p></li><li><p>发射物对应的类（让 <code>FPSCharacter</code> 及其派生蓝图知道要生成哪种发射物）。</p></li></ul></li></ol><p>你将使用一个摄像机空间中的偏移向量来确定发射物的生成位置。设置该参数为可编辑参数，这样你就可以在 <code>BP_FPSCharacter</code> 蓝图中对其进行设置和调整。最终，你可以基于这些数据计算发射物的初始位置。</p><h2 id="FPSCharacter-h-5"><a href="#FPSCharacter-h-5" class="headerlink" title="FPSCharacter.h"></a>FPSCharacter.h</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 枪口相对于摄像机位置的偏移。</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadWrite, Category = Gameplay)</span><br><span class="line">FVector MuzzleOffset;</span><br></pre></td></tr></table></figure><p>MuzzleOffset是一个跟随着摄像机的中间量</p><p>在后面我们会根据这个中间量定义枪口的世界位置</p><p>将以下代码添加到protected:下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 要生成的发射物类。</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditDefaultsOnly, Category = Projectile)</span><br><span class="line">TSubclassOf&lt;<span class="keyword">class</span> <span class="title class_">AFPSProjectile</span>&gt; ProjectileClass;</span><br></pre></td></tr></table></figure><p><code>EditDefaultsOnly</code> 意味着你只能将发射物类设置为蓝图上的默认值，而不是每个蓝图实例上的默认值。</p><p>在蓝图或C++层面调用SpawnActor创建一个actor对象，或者调用SpawnActorDeferred</p><p>延迟创建一个actor对象时，都需要一个class类型的参数。</p><p>如果在C++层面，对象类型是我们自己在蓝图里做的蓝图类</p><p>那么C++层面需要得到蓝图类型</p><p>做法如下：</p><p>建立一个成员变量并暴露给蓝图</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UPROPERTY</span>(EditDefaultsOnly, Category = XXX)</span><br><span class="line"></span><br><span class="line">TSubclassOf&lt;<span class="keyword">class</span> 蓝图类的C++父类&gt; 变量名称</span><br></pre></td></tr></table></figure><p>接下来就可以再蓝图里面给这个变量设置蓝图类型</p><p>最后调用SpawnActor或SpawnActorDeferred将上面定义的变量传入给class参数即可生成对象</p><p>简单来说，就是需要依托某个类（父类）生成一个Actor对象时，就可以使用TSubclassOf</p><h1 id="实现射击"><a href="#实现射击" class="headerlink" title="实现射击"></a>实现射击</h1><h2 id="FPSCharacter-h-6"><a href="#FPSCharacter-h-6" class="headerlink" title="FPSCharacter.h"></a>FPSCharacter.h</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;FPSProjectile.h&quot;</span></span></span><br></pre></td></tr></table></figure><p>引入发射物的头文件</p><h2 id="FPSCharacter-cpp-5"><a href="#FPSCharacter-cpp-5" class="headerlink" title="FPSCharacter.cpp"></a>FPSCharacter.cpp</h2><p>用以下代码段定义fire()函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ProjectileClass)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 获取摄像机变换。</span></span><br><span class="line">FVector CameraLocation;</span><br><span class="line">FRotator CameraRotation;</span><br><span class="line"><span class="built_in">GetActorEyesViewPoint</span>(CameraLocation, CameraRotation);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置MuzzleOffset，在略靠近摄像机前生成发射物。</span></span><br><span class="line">MuzzleOffset.<span class="built_in">Set</span>(<span class="number">100.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将MuzzleOffset从摄像机空间变换到世界空间。</span></span><br><span class="line">FVector MuzzleLocation = CameraLocation + <span class="built_in">FTransform</span>(CameraRotation).<span class="built_in">TransformVector</span>(MuzzleOffset);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使目标方向略向上倾斜。</span></span><br><span class="line">FRotator MuzzleRotation = CameraRotation;</span><br><span class="line">MuzzleRotation.Pitch += <span class="number">10.0f</span>;</span><br><span class="line"></span><br><span class="line">UWorld* World = <span class="built_in">GetWorld</span>();</span><br><span class="line"><span class="keyword">if</span> (World)</span><br><span class="line">&#123;</span><br><span class="line">    FActorSpawnParameters SpawnParams;</span><br><span class="line">    SpawnParams.Owner = <span class="keyword">this</span>;</span><br><span class="line">    SpawnParams.Instigator = <span class="built_in">GetInstigator</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在枪口位置生成发射物。</span></span><br><span class="line">    AFPSProjectile* Projectile = World-&gt;<span class="built_in">SpawnActor</span>&lt;AFPSProjectile&gt;(ProjectileClass, MuzzleLocation, MuzzleRotation, SpawnParams);</span><br><span class="line">    <span class="keyword">if</span> (Projectile)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 设置发射物的初始轨迹。</span></span><br><span class="line">        FVector LaunchDirection = MuzzleRotation.<span class="built_in">Vector</span>();</span><br><span class="line">        Projectile-&gt;<span class="built_in">FireInDirection</span>(LaunchDirection);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="将枪口位置转换为世界坐标中的位置"><a href="#将枪口位置转换为世界坐标中的位置" class="headerlink" title="将枪口位置转换为世界坐标中的位置"></a>将枪口位置转换为世界坐标中的位置</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置MuzzleOffset，在略靠近摄像机前生成发射物。</span></span><br><span class="line">MuzzleOffset.<span class="built_in">Set</span>(<span class="number">100.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将MuzzleOffset从摄像机空间变换到世界空间。</span></span><br><span class="line">FVector MuzzleLocation = CameraLocation + <span class="built_in">FTransform</span>(CameraRotation).<span class="built_in">TransformVector</span>(MuzzleOffset);</span><br></pre></td></tr></table></figure><p>先设置枪口的位置，然后根据枪口位置和相机位置转换为世界坐标中的位置</p><p><code>CameraLocation + FTransform(CameraRotation).TransformVector(MuzzleOffset);</code></p><h3 id="模拟后坐力"><a href="#模拟后坐力" class="headerlink" title="模拟后坐力"></a>模拟后坐力</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使目标方向略向上倾斜。</span></span><br><span class="line">FRotator MuzzleRotation = CameraRotation;</span><br><span class="line">MuzzleRotation.Pitch += <span class="number">10.0f</span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">UWorld* World = <span class="built_in">GetWorld</span>();</span><br><span class="line"><span class="keyword">if</span> (World)</span><br><span class="line"> &#123;</span><br><span class="line">FActorSpawnParameters SpawnParams;</span><br><span class="line">SpawnParams.Owner = <span class="keyword">this</span>;</span><br><span class="line">SpawnParams.Instigator = <span class="built_in">GetInstigator</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在枪口位置生成发射物。</span></span><br><span class="line">AFPSProjectile* Projectile = World-&gt;<span class="built_in">SpawnActor</span>&lt;AFPSProjectile&gt;(ProjectileClass, MuzzleLocation, MuzzleRotation, SpawnParams);</span><br><span class="line"><span class="keyword">if</span> (Projectile)&#123;<span class="comment">//如果生成成功</span></span><br><span class="line">     <span class="comment">// 设置发射物的初始轨迹。</span></span><br><span class="line">     FVector LaunchDirection = MuzzleRotation.<span class="built_in">Vector</span>();</span><br><span class="line">     Projectile-&gt;<span class="built_in">FireInDirection</span>(LaunchDirection);</span><br><span class="line">               &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="FActorSpwanParamenters"><a href="#FActorSpwanParamenters" class="headerlink" title="FActorSpwanParamenters"></a>FActorSpwanParamenters</h3><p>是一个传递给SpawnActor函数的可选参数的结构体</p><p>它有很多的对象</p><p>Name：衍生Actor的名称（不填写的话就会有一个默认值）</p><p>Templat：将用模板值对新生成的Actor进行初始化</p><p>Owner：衍生的Actor</p><p>Instigator：敌方</p><p>定义一个FPSProjectile类的对象（发射物），这个对象要在世界坐标内，所以就需要在世界坐标内生成发射物，所以此时我们需要调用world中的SpawnActor&lt;&gt;()函数</p><h3 id="SpawnActor"><a href="#SpawnActor" class="headerlink" title="SpawnActor"></a>SpawnActor</h3><p>SpawnActor&lt;发射物的构造函数&gt;(要生成的发射物类，发射物位置，发射物角度，FActorSpawnParameters的对象)</p><p>用来生成发射物</p><p>最后是设置发射物的初始轨迹</p><p>以枪口的角度定义一个FVector</p><p>再将该FVector作为参数填入到FireInDirection()中（此函数再前文已经讲解过）</p><h1 id="添加发射物网格体"><a href="#添加发射物网格体" class="headerlink" title="添加发射物网格体"></a>添加发射物网格体</h1><h2 id="FPSProjectile-h-3"><a href="#FPSProjectile-h-3" class="headerlink" title="FPSProjectile.h"></a>FPSProjectile.h</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发射物网格体</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(VisibleDefaultsOnly, Category = Projectile)</span><br><span class="line">UStaticMeshComponent* ProjectileMeshComponent;</span><br></pre></td></tr></table></figure><h2 id="FPSProjectile-cpp-3"><a href="#FPSProjectile-cpp-3" class="headerlink" title="FPSProjectile.cpp"></a>FPSProjectile.cpp</h2><p>构造函数中添加</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!ProjectileMeshComponent)</span><br><span class="line">&#123;</span><br><span class="line">    ProjectileMeshComponent = <span class="built_in">CreateDefaultSubobject</span>&lt;UStaticMeshComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;ProjectileMeshComponent&quot;</span>));</span><br><span class="line">    <span class="type">static</span> ConstructorHelpers::FObjectFinder&lt;UStaticMesh&gt;<span class="built_in">Mesh</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;&#x27;/Game/Sphere.Sphere&#x27;&quot;</span>));</span><br><span class="line">    <span class="keyword">if</span>(Mesh.<span class="built_in">Succeeded</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        ProjectileMeshComponent-&gt;<span class="built_in">SetStaticMesh</span>(Mesh.Object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="添加发射物材质"><a href="#添加发射物材质" class="headerlink" title="添加发射物材质"></a>添加发射物材质</h1><h2 id="FPSProjectile-h-4"><a href="#FPSProjectile-h-4" class="headerlink" title="FPSProjectile.h"></a>FPSProjectile.h</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发射物材质</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(VisibleDefaultsOnly, Category = Movement)</span><br><span class="line">UMaterialInstanceDynamic* ProjectileMaterialInstance;</span><br></pre></td></tr></table></figure><h2 id="FPSProjectile-cpp-4"><a href="#FPSProjectile-cpp-4" class="headerlink" title="FPSProjectile.cpp"></a>FPSProjectile.cpp</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> ConstructorHelpers::FObjectFinder&lt;UMaterial&gt;<span class="built_in">Material</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;&#x27;/Game/SphereMaterial.SphereMaterial&#x27;&quot;</span>));</span><br><span class="line"><span class="keyword">if</span> (Material.<span class="built_in">Succeeded</span>())</span><br><span class="line">&#123;</span><br><span class="line">    ProjectileMaterialInstance = UMaterialInstanceDynamic::<span class="built_in">Create</span>(Material.Object, ProjectileMeshComponent);</span><br><span class="line">&#125;</span><br><span class="line">ProjectileMeshComponent-&gt;<span class="built_in">SetMaterial</span>(<span class="number">0</span>, ProjectileMaterialInstance);</span><br><span class="line">ProjectileMeshComponent-&gt;<span class="built_in">SetRelativeScale3D</span>(<span class="built_in">FVector</span>(<span class="number">0.09f</span>, <span class="number">0.09f</span>, <span class="number">0.09f</span>));</span><br><span class="line">ProjectileMeshComponent-&gt;<span class="built_in">SetupAttachment</span>(RootComponent);</span><br></pre></td></tr></table></figure><p>SetMaterial()源文件</p><ul><li><p>第一个参数：必须大于等于0的，具体啥玩意，确实还没搞懂，等我以后搞懂了，再做补充说明</p></li><li><p>第二个参数：材质名称</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">SetMaterial</span>(int32 ElementIndex, UMaterialInterface* Material)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">check</span>(ElementIndex &gt;= <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (ElementIndex &gt;= BaseMaterials.<span class="built_in">Num</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        BaseMaterials.<span class="built_in">SetNum</span>(ElementIndex + <span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    BaseMaterials[ElementIndex] = Material;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他的就都没什么好讲解的了，如果看不懂的话，可以看看我之前的博客内容</p><h1 id="限制发射物的生命周期"><a href="#限制发射物的生命周期" class="headerlink" title="限制发射物的生命周期"></a>限制发射物的生命周期</h1><h2 id="FPSProjectile-cpp-5"><a href="#FPSProjectile-cpp-5" class="headerlink" title="FPSProjectile.cpp"></a>FPSProjectile.cpp</h2><p>添加到构造函数中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3 秒后删除发射物。</span></span><br><span class="line">InitialLifeSpan = <span class="number">3.0f</span>;</span><br></pre></td></tr></table></figure><p>这玩意叫初始化声明周期</p><h1 id="编辑发射物的碰撞设置"><a href="#编辑发射物的碰撞设置" class="headerlink" title="编辑发射物的碰撞设置"></a>编辑发射物的碰撞设置</h1><p>虚幻引擎自带了数个预设碰撞通道；不过，引擎也支持游戏项目使用自定义通道。</p><ol><li><p>要创建自定义碰撞通道，打开项目设置（Project Settings），在引擎（Engine） - 碰撞（Collision）中，展开预设（Preset）。</p><p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/3/SettingCollisionChannels.jpg" alt="SettingCollisionChannels.png"></p></li><li><p>在对象通道（Object Channels）中，选择 <strong>新建对象通道…（New Object Channel…）</strong>，创建新碰撞通道。将新碰撞通道命名为”Projectile”，确保将默认响应（Default Response）设置为阻止（Block），然后点击接受（Accept）。</p><p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/3/NewChannel.jpg" alt="NewChannel.png"></p></li><li><p>在预设（Preset）中选择 <strong>新建…（New…）</strong>，将新配置文件命名为”Projectile”。参考以下图片来设置你的碰撞预设。然后点击”接受（Accept）”。</p><p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/3/NewProfile.jpg" alt="NewProfile.png"></p></li></ol><p>此碰撞配置文件将发射物设定为将被静态Actor、动态Actor、模拟物理Actor、载具和可破坏Actor阻挡。此外，此碰撞配置文件设定发射物与Pawn重叠。</p><h1 id="使用新的发射物的碰撞设置"><a href="#使用新的发射物的碰撞设置" class="headerlink" title="使用新的发射物的碰撞设置"></a>使用新的发射物的碰撞设置</h1><h2 id="FPSProjectile-cpp-6"><a href="#FPSProjectile-cpp-6" class="headerlink" title="FPSProjectile.cpp"></a>FPSProjectile.cpp</h2><p>在FPSProjectile构造函数中，将以下代码行添加到CreateDefaultSubobject下方</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将球体的碰撞配置文件名称设置为&quot;Projectile&quot;。</span></span><br><span class="line">CollisionComponent-&gt;BodyInstance.<span class="built_in">SetCollisionProfileName</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;Projectile&quot;</span>));</span><br></pre></td></tr></table></figure><p>这是在修改碰撞组件的形体实例的碰撞配置文件</p><h1 id="使发射物对碰撞做出响应"><a href="#使发射物对碰撞做出响应" class="headerlink" title="使发射物对碰撞做出响应"></a>使发射物对碰撞做出响应</h1><h2 id="FPSProjectile-h-5"><a href="#FPSProjectile-h-5" class="headerlink" title="FPSProjectile.h"></a>FPSProjectile.h</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当发射物击中物体时会调用的函数。</span></span><br><span class="line"><span class="built_in">UFUNCTION</span>()</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OnHit</span><span class="params">(UPrimitiveComponent* HitComponent, AActor* OtherActor, UPrimitiveComponent* OtherComponent, FVector NormalImpulse, <span class="type">const</span> FHitResult&amp; Hit)</span></span>;</span><br></pre></td></tr></table></figure><p>声明击中物体时的函数</p><h2 id="FPSProjectile-cpp-7"><a href="#FPSProjectile-cpp-7" class="headerlink" title="FPSProjectile.cpp"></a>FPSProjectile.cpp</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当发射物击中物体时会调用的函数。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSProjectile::OnHit</span><span class="params">(UPrimitiveComponent* HitComponent, AActor* OtherActor, UPrimitiveComponent* OtherComponent, FVector NormalImpulse, <span class="type">const</span> FHitResult&amp; Hit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (OtherActor != <span class="keyword">this</span> &amp;&amp; OtherComponent-&gt;<span class="built_in">IsSimulatingPhysics</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        OtherComponent-&gt;<span class="built_in">AddImpulseAtLocation</span>(ProjectileMovementComponent-&gt;Velocity * <span class="number">100.0f</span>, Hit.ImpactPoint);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Destroy</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果另一个actor不是本actor，而且另一个actor的组件上使模拟物理状态的</p><p>那么另一个组件就调用AddImpulseAtLocation()函数来模拟被击中的反馈</p><p><code>AddImpulseAtLocation(ProjectileMovementComponent-&gt;Velocity * 100.0f, Hit.ImpactPoint);</code></p><p>第一个参数为冲击力，第二个参数为冲击点。</p><p>在 <code>FPSProjectile</code> 构造函数中，将以下代码行添加到 <code>BodyInstance.SetCollisionProfileName</code> 下方：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 组件击中某物时调用的事件。</span></span><br><span class="line">CollisionComponent-&gt;OnComponentHit.<span class="built_in">AddDynamic</span>(<span class="keyword">this</span>, &amp;AFPSProjectile::OnHit);</span><br></pre></td></tr></table></figure><ul><li><p>OnComponentHit：当组件（被）碰撞时调用的函数</p></li><li><p>AddDynamic( UserObject, FuncName )：给某物添加一个力</p><ul><li><p>第一个参数：调用的对象</p></li><li><p>第二个参数：调用的函数</p></li></ul></li></ul><h1 id="将十字准星导入到视口"><a href="#将十字准星导入到视口" class="headerlink" title="将十字准星导入到视口"></a>将十字准星导入到视口</h1><h2 id="FPSHUD-h"><a href="#FPSHUD-h" class="headerlink" title="FPSHUD.h"></a>FPSHUD.h</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line">   <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CoreMinimal.h&quot;</span></span></span><br><span class="line">   <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GameFramework/HUD.h&quot;</span></span></span><br><span class="line">   <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Engine/Canvas.h&quot;</span></span></span><br><span class="line">   <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;FPSHUD.generated.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="built_in">UCLASS</span>()</span><br><span class="line">   <span class="keyword">class</span> <span class="title class_">FPSPROJECT_API</span> AFPSHUD : <span class="keyword">public</span> AHUD</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">       <span class="comment">// HUD绘制的主要调用。</span></span><br><span class="line">       <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">DrawHUD</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">protected</span>:</span><br><span class="line">       <span class="comment">// 将被绘制在屏幕中心。</span></span><br><span class="line">       <span class="built_in">UPROPERTY</span>(EditDefaultsOnly)</span><br><span class="line">       UTexture2D* CrosshairTexture;</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure><h2 id="FPSHUD-cpp"><a href="#FPSHUD-cpp" class="headerlink" title="FPSHUD.cpp"></a>FPSHUD.cpp</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;FPSHUD.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">AFPSHUD::DrawHUD</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      Super::<span class="built_in">DrawHUD</span>();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (CrosshairTexture)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="comment">// 找出我们的画布的中心点。</span></span><br><span class="line">          <span class="function">FVector2D <span class="title">Center</span><span class="params">(Canvas-&gt;ClipX * <span class="number">0.5f</span>, Canvas-&gt;ClipY * <span class="number">0.5f</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 偏移纹理大小的一半，以便纹理中心与画布中心对齐。</span></span><br><span class="line">          <span class="function">FVector2D <span class="title">CrossHairDrawPosition</span><span class="params">(Center.X - (CrosshairTexture-&gt;GetSurfaceWidth() * <span class="number">0.5f</span>), Center.Y - (CrosshairTexture-&gt;GetSurfaceHeight() * <span class="number">0.5f</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 在中心点绘制十字准星。</span></span><br><span class="line">          <span class="function">FCanvasTileItem <span class="title">TileItem</span><span class="params">(CrossHairDrawPosition, CrosshairTexture-&gt;Resource, FLinearColor::White)</span></span>;</span><br><span class="line">          TileItem.BlendMode = SE_BLEND_Translucent;</span><br><span class="line">          Canvas-&gt;<span class="built_in">DrawItem</span>(TileItem);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="FVector2D"><a href="#FVector2D" class="headerlink" title="FVector2D"></a>FVector2D</h3><p>2D类型的vector，定义方式是两条线确定的一个交点（更像是提供一个位置信息，而不是Vector2D本身）</p><p><code>FVector2D Center(Canvas-&gt;ClipX * 0.5f, Canvas-&gt;ClipY * 0.5f);</code></p><ul><li><p>第一个参数：第一条线（x轴）</p></li><li><p>第二个参数：第二条线（Y轴）</p></li></ul><h3 id="FCanvasTileItem"><a href="#FCanvasTileItem" class="headerlink" title="FCanvasTileItem"></a>FCanvasTileItem</h3><p>理解为画布基本色块，类似于，这玩意就是一个颜料，我们调用绘制函数就是画笔。</p><p>只不过这个颜料可以直接添加位置信息，就不用在绘制的时候额外添加位置信息。</p><p><code>FCanvasTileItem::FCanvasTileItem(const FVector2D&amp; InPosition, const FTexture* InTexture, const FLinearColor&amp; InColor)</code></p><ul><li><p>第一个参数：位置信息</p></li><li><p>第二个参数：资产</p></li><li><p>第三个参数：线性颜色</p></li></ul><h3 id="BlendMode"><a href="#BlendMode" class="headerlink" title="BlendMode"></a>BlendMode</h3><p>用来设置材质颜色如何与背景混合</p><p>SE_BLEND_Translucent-&gt;半透明模式</p><h3 id="DrawItem"><a href="#DrawItem" class="headerlink" title="DrawItem()"></a>DrawItem()</h3><p><code>DrawItem(FCanvasItem&amp; Item, float PosX, float PosY)</code></p><p>绘制函数（画笔），用于将第一个参数绘制进画布中</p>]]></content>
      
      
      <categories>
          
          <category> unreal engine </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UE4-第一人称FPS-实现角色</title>
      <link href="/2022/04/29/UE4-%E7%AC%AC%E4%B8%80%E4%BA%BA%E7%A7%B0FPS-%E5%AE%9E%E7%8E%B0%E8%A7%92%E8%89%B2/"/>
      <url>/2022/04/29/UE4-%E7%AC%AC%E4%B8%80%E4%BA%BA%E7%A7%B0FPS-%E5%AE%9E%E7%8E%B0%E8%A7%92%E8%89%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="建立项目"><a href="#建立项目" class="headerlink" title="建立项目"></a><a href="https://docs.unrealengine.com/4.27/zh-CN/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/1/">建立项目</a></h1><ol><li><p>通过Epic启动器打开 <strong>虚幻引擎</strong>，然后选择创建新项目。</p></li><li><p>点击 <strong>游戏（Games）</strong> 新项目类别，然后点击 <strong>下一步（Next）</strong>。</p></li><li><p>选择 <strong>空白模板（Blank template）</strong>，然后点击 <strong>下一步（Next）</strong>。</p></li><li><p>将项目类型更改为 **C++**（而非 <strong>蓝图（Blueprint）</strong>），确保选中 <strong>无初学者内容（No Starter Content）</strong>。</p></li><li><p>将新项目命名为”FPSProject”。</p></li><li><p>转到 <strong>内容浏览器（Content Browser）</strong>（通常在屏幕底部附近），在 <strong>内容（Content）</strong> 文件夹下创建一个 <strong>地图（Maps）</strong> 文件夹（选择内容文件夹，在其中任意位置点击右键，选择 <strong>文件夹（Folder）</strong> &gt; <strong>新建文件夹（New Folder）</strong>）。</p><p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/1/MapsFolder.jpg" alt="MapsFolder.png"></p></li><li><p>在 <strong>文件（File）</strong> 菜单中，选择 <strong>将当前内容另存为（Save Current as…）</strong>，然后点击地图文件夹。将新地图命名为”FPSMap”，然后点击 <strong>保存（Save）</strong>。</p><p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/1/SaveLevelAs.jpg" alt="SaveLevelAs.png"></p></li><li><p>从 <strong>编辑（Edit）</strong> 菜单中，点击 <strong>项目设置（Project Settings）</strong>。</p><p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/1/EditProjectSettings.jpg" alt="EditProjectSettings.png"></p></li><li><p>在 <strong>项目设置（Project Settings）</strong> 选项卡左侧的 <strong>项目（Project）</strong> 标题下，点击 <strong>地图和模式（Maps &amp; Modes）</strong>。</p><p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/1/ProjectMaps_Modes.jpg" alt="ProjectMaps_Modes.png"></p></li><li><p>展开 <strong>编辑器启动地图（Editor Startup Map）</strong> 下拉菜单，选择 <strong>FPSMap</strong>。</p><p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/1/EditorDefaultMap.jpg" alt="EditorDefaultMap.png"></p><p>从现在开始，编辑器将自动加载FPSMap作为默认地图。</p></li></ol><h1 id="添加日志消息"><a href="#添加日志消息" class="headerlink" title="添加日志消息"></a>添加日志消息</h1><p>日志消息对于在开发期间验证和调试代码非常有用。在这一步中，你将使用日志消息来验证自己确实在使用FPSGameMode而非虚幻引擎提供的默认游戏模式。</p><h2 id="FPSProjectGameMode头文件"><a href="#FPSProjectGameMode头文件" class="headerlink" title="FPSProjectGameMode头文件"></a>FPSProjectGameMode头文件</h2><ol><li><p>在 <strong>解决方案资源管理器</strong> 中，展开 <strong>FPSProject</strong> &gt; <strong>源（Source）</strong> &gt; <strong>FPSProject</strong>。</p></li><li><p>双击 <code>FPSProjectGameModeBase.h</code> 打开 <strong>FPSGameMode</strong> 类的头文件。</p><p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/1/InterfaceFile.jpg" alt="InterfaceFile.png"></p></li><li><p>类声明应该如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FPSPROJECT_API</span> AFPSProjectGameModeBase : <span class="keyword">public</span> AGameModeBase</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>在 <code>AFPSProjectGameMode</code> 构造函数声明下方添加以下函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">StartPlay</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br></pre></td></tr></table></figure><p>此函数声明允许你重载<a href="https://docs.unrealengine.com/en-US/API/Runtime/Engine/GameFramework/AGameModeBase/StartPlay/index.html">StartPlay</a>，以便游戏启动时在屏幕上打印日志消息。</p></li><li><p><code>FPSProjectGameMode.h</code> 应如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Epic Games, Inc版权所有。保留所有权利。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CoreMinimal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GameFramework/GameModeBase.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;FPSProjectGameModeBase.generated.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** *  */</span></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FPSPROJECT_API</span> AFPSProjectGameModeBase : <span class="keyword">public</span> AGameModeBase</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">StartPlay</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>在Visual Studio中保存你的头文件。</p></li></ol><h3 id="FPSProjectGameMode-CPP文件"><a href="#FPSProjectGameMode-CPP文件" class="headerlink" title="FPSProjectGameMode CPP文件"></a>FPSProjectGameMode CPP文件</h3><ol><li><p>在 <strong>解决方案资源管理器</strong> 中，定位到 <code>FPSProjectGameModeBase.cpp</code>（<strong>FPSProject &gt;源（Source）&gt; FPSProject</strong>）。</p><p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/1/ImplementationFile.jpg" alt="ImplementationFile.png"></p></li><li><p>双击 <code>FPSProjectGameModeBase.cpp</code> 打开 <strong>FPSGameModeBase</strong> 类的实现文件。</p></li><li><p>现在将以下代码行添加到该文件中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSProjectGameModeBase::StartPlay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Super::<span class="built_in">StartPlay</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">check</span>(GEngine != <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 显示调试消息五秒。 </span></span><br><span class="line"> <span class="comment">// 参数中的-1&quot;键&quot;值类型参数能防止该消息被更新或刷新。</span></span><br><span class="line"> GEngine-&gt;<span class="built_in">AddOnScreenDebugMessage</span>(<span class="number">-1</span>, <span class="number">5.0f</span>, FColor::Yellow, <span class="built_in">TEXT</span>(<span class="string">&quot;Hello World, this is FPSGameMode!&quot;</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>游戏启动时，StartPlay()将在屏幕上打印一条新的调试消息（”Hello World, this is FPSGameModeBase!”），采用黄色文本，显示五秒钟。</p></li><li><p><code>FPSProjectGameModeBase.cpp</code> 应如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Epic Games, Inc版权所有。保留所有权利。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;FPSProjectGameMode.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSProjectGameModeBase::StartPlay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Super::<span class="built_in">StartPlay</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">check</span>(GEngine != <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示调试消息五秒。 </span></span><br><span class="line"><span class="comment">// -1&quot;键&quot;值参数防止该消息被更新或刷新。</span></span><br><span class="line">GEngine-&gt;<span class="built_in">AddOnScreenDebugMessage</span>(<span class="number">-1</span>, <span class="number">5.0f</span>, FColor::Yellow, <span class="built_in">TEXT</span>(<span class="string">&quot;Hello World, this is FPSGameModeBase!&quot;</span>));</span><br></pre></td></tr></table></figure></li><li><p>在Visual Studio中保存CPP文件。</p></li><li><p>在”内容”文件夹中创建一个 <strong>蓝图（Blueprints）</strong> 文件夹。</p><p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/1/BlueprintsFolder.jpg" alt="BlueprintsFolder.png"></p></li><li><p>现在右键点击 <strong>FPSProjectGameModeBase</strong> 类（在 <strong>C++类（C++ Classes）</strong> &gt; <strong>FPSProject</strong> 中），打开 <strong>C++类操作（C++ Class Actions）</strong> 菜单。</p></li><li><p>点击 <strong>基于FPSProjectGameModeBase创建蓝图类（Create Blueprint class based on FPSProjectGameModeBase）</strong> 打开 <strong>添加蓝图类（Add Blueprint Class）</strong> 对话框菜单。</p><p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/1/CreateDerivedBPClass.jpg" alt="CreateDerivedBPClass.png"></p></li><li><p>将你的新蓝图类命名为”BP_FPSProjectGameModeBase”，然后选择蓝图文件夹，之后点击 <strong>创建蓝图类（Create Blueprint Class）</strong> 按钮。</p><p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/1/AddBPClass.jpg" alt="AddBPClass.png"></p></li><li><p>到目前为止，你应该有一个新创建的 <code>BP_FPSProjectGameModeBase</code> 蓝图类，位于蓝图文件夹内。</p><p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/1/AddedBPClass.jpg" alt="AddedBPClass.png"></p></li><li><p>请确保在关闭蓝图编辑器之前保存你的 <code>BP_FPSProjectGameModeBase</code> 蓝图。</p></li><li><p>展开 <strong>编辑（Edit）</strong> 菜单，点击 <strong>项目设置（Project Settings）</strong>。</p></li><li><p>在 <strong>项目设置（Project Settings）</strong> 选项卡左侧的 <strong>项目（Project）</strong> 标题下，点击 <strong>地图和模式（Maps &amp; Modes）</strong>。</p></li><li><p>展开 <strong>默认游戏模式（Default GameMode）</strong> 下拉菜单，选择 <strong>BP_FPSGameModeBase</strong>。</p><p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/1/SettingFPSGameMode.jpg" alt="SettingFPSGameMode.png"></p></li><li><p>关闭 <strong>项目设置（Project Settings）</strong> 菜单。</p></li><li><p>点击关卡编辑器工具栏中的 <strong>运行（Play）</strong> 按钮。”Hello World, this is FPSGameMode!”这句话应在视口左上角以黄色文本显示五秒钟。</p><p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/1/SectionResult.jpg" alt="SectionResult.png"></p></li><li><p>按 <strong>退出键（Escape key）</strong> 或在关卡编辑器中点击 <strong>停止（Stop）</strong> 按钮，即可退出编辑器内运行（PIE）模式。</p></li></ol><h1 id="创建新角色"><a href="#创建新角色" class="headerlink" title="创建新角色"></a>创建新角色</h1><h2 id="添加角色类"><a href="#添加角色类" class="headerlink" title="添加角色类"></a>添加角色类</h2><p>虽然你可以手动将.h和.cpp文件添加到你的Visual Studio (VS)解决方案，但使用C++类向导将新类添加到你的项目是一种很好的做法。</p><p>使用C++类向导，引擎可创建头文件和源文件模板，这些模板文件将为你预先设置一些虚幻特定的宏。</p><ol><li><p>在UE中启动FPS项目（如果你尚未完成此操作）。</p></li><li><p>在文件（File）菜单中，选择 <strong>新建C++类…（New C++ Class…）</strong>，以选择新的父类。</p><p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/SelectNewCPPClass.jpg" alt="SelectNewCPPClass.png"></p></li><li><p>以上操作将打开 <strong>选择父类（Choose Parent Class）</strong> 菜单。向下滚动，选择 <strong>角色</strong> 作为父类，然后点击 <strong>下一步（Next）</strong>。</p><p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/ChooseCharacterClass.jpg" alt="ChooseCharacterClass.png"></p></li><li><p>将新类命名为”FPSCharacter”，然后点击 <strong>创建类（Create Class）</strong>。</p><p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/MakeFPSCharacterClass.jpg" alt="MakeFPSCharacterClass.png"></p></li></ol><h2 id="确认角色类"><a href="#确认角色类" class="headerlink" title="确认角色类"></a>确认角色类</h2><ol><li><p>在VS的 <strong>解决方案浏览器</strong> 中，依次展开 <strong>FPSProject</strong> &gt; <strong>源（Source）</strong> &gt; <strong>FPSProject</strong>。</p><p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/ExpandedSolutionExplorer.jpg" alt="ExpandedSolutionExplorer.png"></p></li><li><p>点击 <code>FPSCharacter.cpp</code>，打开 <strong>FPSCharacter</strong> 类的实现文件。</p></li><li><p>在 <code>BeginPlay()</code> 函数中添加以下代码行（在 <code>Super::BeginPlay();</code> 下面），以便确认正在使用 <code>FPSCharacter</code> 类：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">check</span>(GEngine != <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示调试消息五秒。 </span></span><br><span class="line"><span class="comment">// -1&quot;键&quot;值参数可以防止更新或刷新消息。</span></span><br><span class="line">GEngine-&gt;<span class="built_in">AddOnScreenDebugMessage</span>(<span class="number">-1</span>, <span class="number">5.0f</span>, FColor::Red, <span class="built_in">TEXT</span>(<span class="string">&quot;We are using FPSCharacter.&quot;</span>));</span><br></pre></td></tr></table></figure></li><li><p>现在 <code>FPSCharacter.cpp</code> 的内容应如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版权所有Epic Games, Inc。保留所有权利。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;FPSCharacter.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置默认值</span></span><br><span class="line">AFPSCharacter::<span class="built_in">AFPSCharacter</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 将此角色设置为每帧调用Tick()。  如果不需要此特性，可以关闭以提升性能。</span></span><br><span class="line">PrimaryActorTick.bCanEverTick = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当游戏开始或重生（Spawn）时被调用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::BeginPlay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Super::<span class="built_in">BeginPlay</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">check</span>(GEngine != <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示调试消息五秒。 </span></span><br><span class="line"><span class="comment">// -1&quot;键&quot;值参数可以防止更新或刷新消息。</span></span><br><span class="line">GEngine-&gt;<span class="built_in">AddOnScreenDebugMessage</span>(<span class="number">-1</span>, <span class="number">5.0f</span>, FColor::Red, <span class="built_in">TEXT</span>(<span class="string">&quot;We are using FPSCharacter.&quot;</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每一帧都被调用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::Tick</span><span class="params">(<span class="type">float</span> DeltaTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Super::<span class="built_in">Tick</span>(DeltaTime);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 被调用，将功能与输入绑定</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::SetupPlayerInputComponent</span><span class="params">(UInputComponent* PlayerInputComponent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Super::<span class="built_in">SetupPlayerInputComponent</span>(PlayerInputComponent);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在Visual Studio中保存 <code>FPSCharacter</code> CPP文件。</p></li><li><p>在 <strong>解决方案浏览器（Solution Explorer）</strong> 中找到 <strong>FPSProject</strong>。</p><p>到目前为止，你一直在使用编辑器的 <strong>构建(Build)</strong> 按钮编译项目。在此步骤中，你将使用Visual Studio的构建功能来编译代码。要从Visual Studio中编译代码，请右键点击 <strong>FPSProject</strong>，并选择 <strong>构建（Build）</strong> 来编译项目。</p></li><li><p>要从VS中编译代码，请右键点击 <strong>FPSProject</strong>，并选择 <strong>构建（Build）</strong> 来编译项目。</p><p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/BuildProject.jpg" alt="BuildProject.png"></p><p>如果你使用的是VS的默认设置，则在界面底部附近（可能在代码编辑器的下方），你应该会看到一个对话框。当你点击构建（Build）后，在生成过程中该对话框中应该会显示一些信息，我们最希望显示的是构建成功的信息。 如果构建失败，不要紧张！回头看看你之前的操作步骤，确保你的代码与此处和第1分段中列出的内容相同。</p></li><li><p>构建完成后，打开虚幻编辑器，确认新编译的 <strong>FPSCharacter</strong> 类在 <strong>内容浏览器</strong> 中可见。</p><p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/FPSCharacterContentBrowser.jpg" alt="FPSCharacterContentBrowser.png"></p></li></ol><h3 id="扩展你的C-FPS角色类到蓝图"><a href="#扩展你的C-FPS角色类到蓝图" class="headerlink" title="扩展你的C++ FPS角色类到蓝图"></a>扩展你的C++ FPS角色类到蓝图</h3><p>现在可以扩展C++ FPS角色类到蓝图了（类似之前进行的FPSProject游戏模式操作）。请随时前往我们的<a href="https://docs.unrealengine.com/4.27/zh-CN/ProgrammingAndScripting/ClassCreation/CodeAndBlueprints">C++和蓝图</a>参考页面，以了解更多关于扩展C++类到蓝图的信息。</p><ol><li><p>右键点击FPSCharacter类，打开 <strong>C++类操作（C++ Class Actions）</strong> 菜单。</p></li><li><p>点击 <strong>基于FPSCharacter创建蓝图类（Create Blueprint class based on FPSHUD）</strong>，打开 <strong>添加蓝图类（Add Blueprint Class）</strong> 对话框菜单。</p><p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/CreateDerivedBPClass.jpg" alt="CreateDerivedBPClass.png"></p></li><li><p>将新的蓝图类命名为 <code>BP_FPSCharacter</code>，选择蓝图（Blueprints）文件夹，然后点击 <strong>创建蓝图类（Create Blueprint Class）</strong> 按钮。</p><p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/AddBPClass.jpg" alt="AddBPClass.png"></p></li><li><p>现在，在蓝图（Blueprints）文件夹内，你应该可以看到新创建的 <code>BP_FPSCharacter</code> 蓝图类。</p><p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/AddedBPClass.jpg" alt="AddedBPClass.png"></p></li><li><p>请确保在关闭蓝图编辑器前保存 <code>BP_FPSCharacter</code> 蓝图。</p></li></ol><h2 id="设置默认的Pawn类"><a href="#设置默认的Pawn类" class="headerlink" title="设置默认的Pawn类"></a>设置默认的Pawn类</h2><p>现在你已经成功地把新修改的游戏模式扩展到了蓝图，接下来你需要在此步骤中设置项目，将 <code>BP_FPSCharacter</code> 作为默认的 <strong>Pawn</strong>。</p><ol><li><p>在 <strong>编辑（Edit）</strong> 菜单中点击 <strong>项目设置（Project Settings）</strong>。</p></li><li><p>在 <strong>项目设置（Project Settings）</strong> 选项卡左侧的 <strong>项目（Project）</strong> 标题栏下，点击 <strong>地图和模式（Maps &amp; Modes）</strong>。</p></li><li><p>展开 <strong>已选择的游戏模式（Selected GameMode）</strong> 段，并在 <strong>默认Pawn类（Default Pawn Class）</strong> 下拉菜单中选择 <strong>BP_FPSCharacter</strong>。</p><p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/SettingFPSCharacter.jpg" alt="SettingFPSCharacter.png"></p></li><li><p>关闭 <strong>项目设置（Project Settings）</strong> 菜单。</p></li><li><p>在关卡编辑器工具栏中点击 <strong>运行（Play）</strong> 按钮。在视口左上角，红色文本”We are using FPSCharacter.”将显示在”Hello World, this is FPSGameMode!”的下方，并持续5秒钟。</p><p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/VerifyingFPSCharacterResult.jpg" alt="VerifyingFPSCharacterResult.png"></p><p>如果你无法移动，说明你已经正确地将FPSCharacter用作了Pawn！你的新角色还没有任何移动功能按钮，因此你还不能在关卡中四处移动。</p></li><li><p>在进入下一步前，按退出键（Escape）或在关卡编辑器中点击 <strong>停止（Stop）</strong>，退出在编辑器中运行（Play in Editor）（PIE）模式。</p></li></ol><h1 id="设置轴映射"><a href="#设置轴映射" class="headerlink" title="设置轴映射"></a>设置轴映射</h1><p>通常，轴映射支持将键盘、鼠标和控制器输入映射到”友好名称”，该名称稍后可以绑定到游戏行为上（例如移动）。轴映射会不断被轮询，从而实现无缝的移动过渡和流畅的游戏行为。硬件轴（例如游戏摇杆）所提供的输入值为程度值，而不是离散的数字输入（例如，按下为1，不按下为0）。虽然游戏摇杆输入方法在提供可平滑伸缩的移动输入方面很有效，但轴映射也可以将常见的移动键（如WASD键或箭头键）映射到持续轮询的游戏行为。</p><p>在继续此步骤之前，如果你想要了解有关玩家输入的更多信息，请参阅<a href="https://docs.unrealengine.com/4.27/zh-CN/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/PlayerInput">玩家输入和Pawn</a>教程。在此步骤中，你将设置W、A、S和D键的输入轴映射，从而使新角色可以在地图上四处移动。</p><h2 id="向前移动轴映射"><a href="#向前移动轴映射" class="headerlink" title="向前移动轴映射"></a>向前移动轴映射</h2><ol><li><p>在 <strong>编辑（Edit）</strong> 菜单中，点击 <strong>项目设置（Project Settings）</strong>。</p></li><li><p>在 <strong>项目设置（Project Settings）</strong> 选项卡左侧的 <strong>引擎（Engine）</strong> 标题栏下，点击 <strong>输入（Input）</strong>。</p></li><li><p>在 <strong>绑定（Bindings）</strong> 中，点击 <strong>轴映射（Axis Mappings）</strong> 旁边的+号。</p></li><li><p>点击 <strong>轴映射（Axis Mappings）</strong> 左侧的箭头。</p></li><li><p>在界面显示的文本框中输入”MoveForward”，然后点击文本框左侧的箭头，展开轴绑定选项。</p></li><li><p>在下拉菜单中，从 <strong>键盘（Keyboard）</strong> 下拉列表中选择 <strong>W</strong>。</p></li><li><p>现在输入设置界面应如下图所示：</p><p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/MoveForwardAxisMap_W.jpg" alt="MoveForwardAxisMap_W.png"></p></li><li><p>点击 <strong>MoveForward</strong> 旁边的+号。</p></li><li><p>在第二个下拉菜单中，从 <strong>键盘（Keyboard）</strong> 下拉列表中选择 <strong>S</strong>。</p></li><li><p>在 <strong>S</strong> 旁边的 <strong>比例（Scale）</strong> 字段中输入”-1”。</p></li><li><p>现在输入设置界面应如下图所示：</p><p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/MoveForwardAxisMap_S.jpg" alt="MoveForwardAxisMap_S.png"></p></li></ol><h2 id="向右移动轴映射"><a href="#向右移动轴映射" class="headerlink" title="向右移动轴映射"></a>向右移动轴映射</h2><ol><li><p>在 <strong>绑定（Bindings）</strong> 中，点击 <strong>轴映射（Axis Mappings）</strong> 旁边的+号。</p></li><li><p>在显示的文本字段中输入”向右移动（MoveForward）”，然后点击文本框左侧的箭头，展开轴绑定选项。</p></li><li><p>在下拉菜单中，从 <strong>键盘（Keyboard）</strong> 下拉列表中选择 <strong>D</strong>。</p></li><li><p>现在输入设置界面应如下图所示：</p><p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/MoveRightAxisMap_D.jpg" alt="MoveRightAxisMap_D.png"></p></li><li><p>点击 <strong>向右移动（MoveRight）</strong> 旁边的+号。</p></li><li><p>在第二个下拉菜单中，从 <strong>键盘（Keyboard）</strong> 下拉列表中选择 <strong>A</strong>。</p></li><li><p>在 <strong>A</strong> 旁边的 <strong>比例（Scale）</strong> 字段中输入”-1”。</p></li><li><p>现在输入设置界面应如下图所示：</p><p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/MoveRightAxisMap_A.jpg" alt="MoveRightAxisMap_A.png"></p></li><li><p>现在你已设置好向左移动（MoveLeft）和向右移动（MoveRight）轴映射，请关闭 <strong>项目设置（Project Settings）</strong> 菜单并继续。</p></li></ol><h1 id="实现角色移动函数"><a href="#实现角色移动函数" class="headerlink" title="实现角色移动函数"></a>实现角色移动函数</h1><p>在此步骤中，我们将设置玩家输入组件，并在FPSCharacter类中实现以下函数：</p><ul><li><p><code>MoveForward</code></p></li><li><p><code>MoveRight</code></p></li></ul><h2 id="移动函数接口"><a href="#移动函数接口" class="headerlink" title="移动函数接口"></a>移动函数接口</h2><p>你已经设置好FPSCharacter的轴映射，现在可以切换到VS中的项目界面。</p><ol><li><p>在 <code>FPSCharacter.h</code> 中，将以下函数声明添加到 <code>SetupPlayerInputComponent</code> 成员函数的下方。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理用于前后移动的输入。</span></span><br><span class="line"><span class="built_in">UFUNCTION</span>()</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MoveForward</span><span class="params">(<span class="type">float</span> Value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理用于左右移动的输入。</span></span><br><span class="line"><span class="built_in">UFUNCTION</span>()</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MoveRight</span><span class="params">(<span class="type">float</span> Value)</span></span>;</span><br></pre></td></tr></table></figure><p><code>UFUNCTION</code> 宏（位于每个函数上方）让引擎可以发觉这些函数，以便将它们纳入序列化和其他引擎功能中。</p></li><li><p>现在 <code>FPSCharacter.h</code> 的内容应如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版权所有Epic Games, Inc。保留所有权利。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CoreMinimal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GameFramework/Character.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;FPSCharacter.generated.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FPSPROJECT_API</span> AFPSCharacter : <span class="keyword">public</span> ACharacter</span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="comment">// 为此角色的属性设置默认值</span></span><br><span class="line">   <span class="built_in">AFPSCharacter</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">   <span class="comment">// 当游戏开始或重生（Spawn）时被调用</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BeginPlay</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="comment">// 每一帧都被调用</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Tick</span><span class="params">( <span class="type">float</span> DeltaTime )</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 被调用，将功能与输入绑定</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SetupPlayerInputComponent</span><span class="params">(<span class="keyword">class</span> UInputComponent* PlayerInputComponent)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 处理用于前后移动的输入。</span></span><br><span class="line">   <span class="built_in">UFUNCTION</span>()</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">MoveForward</span><span class="params">(<span class="type">float</span> Value)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 处理用于左右移动的输入。</span></span><br><span class="line">   <span class="built_in">UFUNCTION</span>()</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">MoveRight</span><span class="params">(<span class="type">float</span> Value)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h2 id="移动函数的实现"><a href="#移动函数的实现" class="headerlink" title="移动函数的实现"></a>移动函数的实现</h2><p>在典型的FPS控制模式中，角色的移动轴是相对于摄像机的。”向前”移动是指”摄像机指向的方向”，”向右”是指”摄像机指向方向的右侧”。你将使用 <code>PlayerController</code> 获取角色的控制旋转输入值。另外， <code>MoveForward</code> 函数将忽略控制旋转输入值的俯仰（Pitch）分量，将输入限制在XY平面上，以确保在你向上或向下看时，你的角色将沿着地面移动。</p><ol><li><p>在 <code>FPSCharacter.cpp</code> 中，将以下行添加到<code>SetupPlayerInputComponent </code>函数中的<code> Super::SetupPlayerInputComponent(PlayerInputComponent);</code> 下方 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置&quot;移动&quot;绑定。</span></span><br><span class="line">PlayerInputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="string">&quot;MoveForward&quot;</span>, <span class="keyword">this</span>, &amp;AFPSCharacter::MoveForward);</span><br><span class="line">PlayerInputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="string">&quot;MoveRight&quot;</span>, <span class="keyword">this</span>, &amp;AFPSCharacter::MoveRight);</span><br></pre></td></tr></table></figure><p><code>InputComponent</code> 是定义如何处理输入数据的组件。可以将 <code>InputComponent</code> 附加到想要接收输入的actor。</p></li><li><p>在 <code>FPSCharacter.cpp</code> 中， <code>SetupPlayerInputComponent</code> 下方，添加以下 <code>MoveForward</code> 函数定义。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::MoveForward</span><span class="params">(<span class="type">float</span> Value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// 找出&quot;前进&quot;方向，并记录玩家想向该方向移动。</span></span><br><span class="line">   FVector Direction = <span class="built_in">FRotationMatrix</span>(Controller-&gt;<span class="built_in">GetControlRotation</span>()).<span class="built_in">GetScaledAxis</span>(EAxis::X);</span><br><span class="line">   <span class="built_in">AddMovementInput</span>(Direction, Value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在 <code>FPSCharacter.cpp</code> 中添加以下 <code>MoveRight</code> 函数定义（<code>MoveForward</code> 下方）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::MoveRight</span><span class="params">(<span class="type">float</span> Value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// 找出&quot;右侧&quot;方向，并记录玩家想向该方向移动。</span></span><br><span class="line">   FVector Direction = <span class="built_in">FRotationMatrix</span>(Controller-&gt;<span class="built_in">GetControlRotation</span>()).<span class="built_in">GetScaledAxis</span>(EAxis::Y);</span><br><span class="line">   <span class="built_in">AddMovementInput</span>(Direction, Value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>现在 <code>FPSCharacter.cpp</code> 的内容应如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版权所有Epic Games, Inc。保留所有权利。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;FPSCharacter.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置默认值</span></span><br><span class="line">AFPSCharacter::<span class="built_in">AFPSCharacter</span>()</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 将此角色设置为每帧调用Tick()。  如果不需要此特性，可以关闭以提升性能。</span></span><br><span class="line">   PrimaryActorTick.bCanEverTick = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当游戏开始或重生（Spawn）时被调用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::BeginPlay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Super::<span class="built_in">BeginPlay</span>();</span><br><span class="line"></span><br><span class="line">   <span class="built_in">check</span>(GEngine != <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 显示调试消息五秒。 </span></span><br><span class="line">   <span class="comment">// -1&quot;键&quot;值参数可以防止更新或刷新消息。</span></span><br><span class="line">     GEngine-&gt;<span class="built_in">AddOnScreenDebugMessage</span>(<span class="number">-1</span>, <span class="number">5.0f</span>, FColor::Red, <span class="built_in">TEXT</span>(<span class="string">&quot;We are using FPSCharacter.&quot;</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每一帧都被调用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::Tick</span><span class="params">( <span class="type">float</span> DeltaTime )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Super::<span class="built_in">Tick</span>( DeltaTime );</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 被调用，将功能与输入绑定</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::SetupPlayerInputComponent</span><span class="params">(UInputComponent* PlayerInputComponent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Super::<span class="built_in">SetupPlayerInputComponent</span>(PlayerInputComponent);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 设置&quot;移动&quot;绑定。</span></span><br><span class="line">   PlayerInputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="string">&quot;MoveForward&quot;</span>, <span class="keyword">this</span>, &amp;AFPSCharacter::MoveForward);</span><br><span class="line">   PlayerInputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="string">&quot;MoveRight&quot;</span>, <span class="keyword">this</span>, &amp;AFPSCharacter::MoveRight);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::MoveForward</span><span class="params">(<span class="type">float</span> Value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// 找出&quot;前进&quot;方向，并记录玩家想向该方向移动。</span></span><br><span class="line">   FVector Direction = <span class="built_in">FRotationMatrix</span>(Controller-&gt;<span class="built_in">GetControlRotation</span>()).<span class="built_in">GetScaledAxis</span>(EAxis::X);</span><br><span class="line">   <span class="built_in">AddMovementInput</span>(Direction, Value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::MoveRight</span><span class="params">(<span class="type">float</span> Value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// 找出&quot;右侧&quot;方向，并记录玩家想向该方向移动。</span></span><br><span class="line">   FVector Direction = <span class="built_in">FRotationMatrix</span>(Controller-&gt;<span class="built_in">GetControlRotation</span>()).<span class="built_in">GetScaledAxis</span>(EAxis::Y);</span><br><span class="line">   <span class="built_in">AddMovementInput</span>(Direction, Value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="测试角色移动"><a href="#测试角色移动" class="headerlink" title="测试角色移动"></a>测试角色移动</h2><p>现在我们来编译和测试新实现的角色移动函数。</p><ol><li><p>在VS中保存 <code>FPSCharacter</code> 头文件（.h）和C++（.cpp）文件。</p></li><li><p>在 <strong>解决方案浏览器（Solution Explorer）</strong> 中找到 <strong>FPSProject</strong>。</p></li><li><p>右键点击 <strong>FPSProject</strong> 并选择 <strong>构建（Build）</strong>，编译你的项目。</p><p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/BuildProject.jpg" alt="BuildProject.png"></p></li><li><p>构建完毕后，在虚幻引擎中打开 <strong>FPSProject</strong>。</p></li><li><p>在关卡编辑器工具栏中点击 <strong>运行（Play）</strong>。现在，你应该能够向前、向后、向左和向右移动。</p></li><li><p>按退出键（Escape）或在关卡编辑器中点击 <strong>停止（Stop）</strong>，退出PIE模式。</p></li></ol><h1 id="实现鼠标摄像机控制"><a href="#实现鼠标摄像机控制" class="headerlink" title="实现鼠标摄像机控制"></a>实现鼠标摄像机控制</h1><p>在此步骤中，你将为角色添加能够环顾四周并用鼠标操纵的功能。</p><h2 id="转向轴映射"><a href="#转向轴映射" class="headerlink" title="转向轴映射"></a>转向轴映射</h2><ol><li><p>在FPS项目中，展开 <strong>编辑（Edit）</strong> 菜单，并点击 <strong>项目设置（Project Settings）</strong>。</p></li><li><p>在 <strong>项目设置（Project Settings）</strong> 选项卡左侧的 <strong>引擎（Engine）</strong> 标题栏下，点击 <strong>输入（Input）</strong>。</p></li><li><p>在 <strong>绑定（Bindings）</strong> 中，点击 <strong>轴映射（Axis Mappings）</strong> 旁边的+号。</p></li><li><p>点击 <strong>轴映射（Axis Mappings）</strong> 左侧的箭头。</p></li><li><p>在显示的文本输入框中输入”Turn”，然后点击文本框左侧的箭头，以便展开轴绑定选项</p></li><li><p>在下拉菜单中，从 <strong>鼠标（Mouse）</strong> 下拉列表中选择 <strong>鼠标X（Mouse X）</strong>。</p></li><li><p>现在输入设置界面应如下图所示：</p><p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/TurnAxisMapping_MouseX.jpg" alt="TurnAxisMapping_MouseX.png"></p></li></ol><h2 id="查找轴映射"><a href="#查找轴映射" class="headerlink" title="查找轴映射"></a>查找轴映射</h2><ol><li><p>在 <strong>绑定（Bindings）</strong> 中，点击 <strong>轴映射（Axis Mappings）</strong> 旁边的+号。</p></li><li><p>在显示的文本输入框中输入”LookUp”，然后点击文本框左侧的箭头，以便展开轴绑定选项。</p></li><li><p>在下拉菜单中，从 <strong>鼠标（Mouse）</strong> 下拉列表中选择 <strong>鼠标Y（Mouse Y）</strong>。</p></li><li><p>在 <strong>鼠标Y（Mouse Y）</strong> 旁边的 <strong>比例（Scale）</strong> 输入框中输入”-1.0”。</p></li><li><p>现在输入设置界面应如下图所示：</p><p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/TurnAxisMapping_MouseY.jpg" alt="TurnAxisMapping_MouseY.png"></p></li><li><p>关闭 <strong>项目设置（Project Settings）</strong> 菜单。</p></li></ol><h2 id="实现输入处理"><a href="#实现输入处理" class="headerlink" title="实现输入处理"></a>实现输入处理</h2><p>现在可以添加代码处理鼠标输入以便进行转向和抬头看。<code>角色</code> 基类为我们定义了两个必要函数，即：</p><ul><li><p><code>AddControllerYawInput</code></p></li><li><p><code>AddControllerPitchInput</code></p><p>如果你想要执行更多的处理，例如增加对灵敏度或轴反转的支持，那么你可以提供自己的函数，以便在将输入值传递给函数之前对其进行调整。但是，在本示例中，你将直接将输入绑定到 <code>AddControllerYawInput</code> 和 <code>AddControllerPitchInput</code> 函数。</p></li></ul><ol><li><p>将以下代码行添加到 <code>FPSCharacter.cpp</code> 中的 <code>SetupPlayerInputComponent</code> 函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置&quot;观看&quot;绑定。</span></span><br><span class="line">PlayerInputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="string">&quot;Turn&quot;</span>, <span class="keyword">this</span>, &amp;AFPSCharacter::AddControllerYawInput);</span><br><span class="line">PlayerInputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="string">&quot;LookUp&quot;</span>, <span class="keyword">this</span>, &amp;AFPSCharacter::AddControllerPitchInput);</span><br></pre></td></tr></table></figure></li><li><p><code>SetupPlayerInputComponent</code> 函数应如下图所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 被调用，将功能与输入绑定</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::SetupPlayerInputComponent</span><span class="params">(UInputComponent* PlayerInputComponent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Super::<span class="built_in">SetupPlayerInputComponent</span>(PlayerInputComponent);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 设置&quot;移动&quot;绑定。</span></span><br><span class="line">   PlayerInputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="string">&quot;MoveForward&quot;</span>, <span class="keyword">this</span>, &amp;AFPSCharacter::MoveForward);</span><br><span class="line">   PlayerInputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="string">&quot;MoveRight&quot;</span>, <span class="keyword">this</span>, &amp;AFPSCharacter::MoveRight);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 设置&quot;观看&quot;绑定。</span></span><br><span class="line">   PlayerInputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="string">&quot;Turn&quot;</span>, <span class="keyword">this</span>, &amp;AFPSCharacter::AddControllerYawInput);</span><br><span class="line">   PlayerInputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="string">&quot;LookUp&quot;</span>, <span class="keyword">this</span>, &amp;AFPSCharacter::AddControllerPitchInput);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="测试鼠标摄像机控制"><a href="#测试鼠标摄像机控制" class="headerlink" title="测试鼠标摄像机控制"></a>测试鼠标摄像机控制</h2><ol><li><p>在VS中保存 <code>FPSCharacter</code> 的实现文件。</p></li><li><p>在 <strong>解决方案浏览器（Solution Explorer）</strong> 中找到 <strong>FPSProject</strong>。</p></li><li><p>右键点击 <strong>FPSProject</strong> 并选择 <strong>构建（Build）</strong>，编译你的项目。</p></li><li><p>构建完毕后，在虚幻引擎中打开 <strong>FPSProject</strong>。</p></li><li><p>在关卡编辑器工具栏中点击 <strong>运行（Play）</strong>。现在，你可以通过鼠标控制摄像机。</p></li><li><p>按 <strong>退出键（Escape key）</strong> 或在关卡编辑器中点击 <strong>停止（Stop）</strong>，退出PIE模式。</p></li></ol><h1 id="实现角色跳跃"><a href="#实现角色跳跃" class="headerlink" title="实现角色跳跃"></a>实现角色跳跃</h1><p>通常，操作映射处理离散事件的输入，让你可以将输入映射到”友好名称”，该名称稍后可以与事件驱动的行为绑定。最终效果是，按下和&#x2F;或释放单个键、鼠标按钮或辅助键盘按钮可以直接触发游戏行为。在此步骤中，你将为空格键设置输入操作映射，增加角色的跳跃能力。</p><h2 id="跳跃操作映射"><a href="#跳跃操作映射" class="headerlink" title="跳跃操作映射"></a>跳跃操作映射</h2><ol><li><p>在 <strong>编辑（Edit）</strong> 菜单中，点击 <strong>项目设置（Project Settings）</strong>。</p></li><li><p>在 <strong>项目设置（Project Settings）</strong> 选项卡左侧的 <strong>引擎（Engine）</strong> 标题栏下，点击 <strong>输入（Input）</strong>。</p></li><li><p>在 <strong>绑定（Bindings）</strong> 中，点击 <strong>操作映射（Action Mappings）</strong> 旁边的+号。</p></li><li><p>点击 <strong>操作映射（Action Mappings）</strong> 左侧的箭头。</p></li><li><p>在显示的文本输入框中输入”Jump”，然后点击文本框左侧的箭头，展开操作绑定选项。</p></li><li><p>在下拉菜单中，从 <strong>键盘（Keyboard）</strong> 下拉列表中选择 <strong>空格键（Space Bar）</strong>。</p></li><li><p>现在输入设置界面应如下图所示：</p><p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/JumpActionMapping_SpaceBar.jpg" alt="JumpActionMapping_SpaceBar.png"></p></li><li><p>关闭 <strong>项目设置（Project Settings）</strong> 菜单。</p></li></ol><h2 id="实现输入处理-1"><a href="#实现输入处理-1" class="headerlink" title="实现输入处理"></a>实现输入处理</h2><p>如果你查看 <code>Acharacter</code> 基类的接口文件（.h）的内容，你会看到角色跳跃的内置支持。角色跳跃与 <code>bPressedJump</code> 变量绑定，因此我们需要做的就是，在跳跃操作按下时将该布尔值设置为 <code>true</code>，在跳跃操作释放时将该布尔值设置为 <code>false</code>。你需要添加以下两个函数完成此操作：</p><ul><li><p><code>StartJump</code></p></li><li><p><code>StopJump</code></p></li></ul><p>返回Visual Studio，将代码添加到 <code>FPSCharacter</code> 类。</p><ol><li><p>在 <code>FPSCharacter.h</code> 中，添加以下公共函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按下键时，设置跳跃标记。</span></span><br><span class="line"><span class="built_in">UFUNCTION</span>()</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StartJump</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放键时，清除跳跃标记。</span></span><br><span class="line"><span class="built_in">UFUNCTION</span>()</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StopJump</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>现在 <code>FPSCharacter.h</code> 的内容应如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版权所有Epic Games, Inc。保留所有权利。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CoreMinimal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GameFramework/Character.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;FPSCharacter.generated.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FPSPROJECT_API</span> AFPSCharacter : <span class="keyword">public</span> ACharacter</span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="comment">// 为此角色的属性设置默认值</span></span><br><span class="line">   <span class="built_in">AFPSCharacter</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">   <span class="comment">// 当游戏开始或重生（Spawn）时被调用</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BeginPlay</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="comment">// 每一帧都被调用</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Tick</span><span class="params">( <span class="type">float</span> DeltaTime )</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 被调用，将功能与输入绑定</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SetupPlayerInputComponent</span><span class="params">(<span class="keyword">class</span> UInputComponent* PlayerInputComponent)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 处理用于前后移动的输入。</span></span><br><span class="line">   <span class="built_in">UFUNCTION</span>()</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">MoveForward</span><span class="params">(<span class="type">float</span> Value)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 处理用于左右移动的输入。</span></span><br><span class="line">   <span class="built_in">UFUNCTION</span>()</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">MoveRight</span><span class="params">(<span class="type">float</span> Value)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 按下键时，设置跳跃标记。</span></span><br><span class="line">   <span class="built_in">UFUNCTION</span>()</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">StartJump</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 释放键时，清除跳跃标记。</span></span><br><span class="line">   <span class="built_in">UFUNCTION</span>()</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">StopJump</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>在 <code>FPSCharacter.cpp</code> 中，将以下函数定义添加到代码底部：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::StartJump</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   bPressedJump = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::StopJump</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   bPressedJump = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>现在，将以下代码添加到 <code>SetupPlayerInputComponent</code>，以便将跳跃操作与刚才编写的函数绑定：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置&quot;操作&quot;绑定。</span></span><br><span class="line">PlayerInputComponent-&gt;<span class="built_in">BindAction</span>(<span class="string">&quot;Jump&quot;</span>, IE_Pressed, <span class="keyword">this</span>, &amp;AFPSCharacter::StartJump);</span><br><span class="line">PlayerInputComponent-&gt;<span class="built_in">BindAction</span>(<span class="string">&quot;Jump&quot;</span>, IE_Released, <span class="keyword">this</span>, &amp;AFPSCharacter::StopJump);</span><br></pre></td></tr></table></figure></li><li><p>现在 <code>FPSCharacter.cpp</code> 的内容应如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版权所有Epic Games, Inc。保留所有权利。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;FPSCharacter.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置默认值</span></span><br><span class="line">AFPSCharacter::<span class="built_in">AFPSCharacter</span>()</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 将此角色设置为每帧调用Tick()。  如果不需要此特性，可以关闭以提升性能。</span></span><br><span class="line">   PrimaryActorTick.bCanEverTick = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当游戏开始或重生（Spawn）时被调用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::BeginPlay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Super::<span class="built_in">BeginPlay</span>();</span><br><span class="line"></span><br><span class="line">   <span class="built_in">check</span>(GEngine != <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 显示调试消息五秒。 </span></span><br><span class="line">   <span class="comment">// -1&quot;键&quot;值参数可以防止更新或刷新消息。</span></span><br><span class="line">     GEngine-&gt;<span class="built_in">AddOnScreenDebugMessage</span>(<span class="number">-1</span>, <span class="number">5.0f</span>, FColor::Red, <span class="built_in">TEXT</span>(<span class="string">&quot;We are using FPSCharacter.&quot;</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每一帧都被调用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::Tick</span><span class="params">( <span class="type">float</span> DeltaTime )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Super::<span class="built_in">Tick</span>( DeltaTime );</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 被调用，将功能与输入绑定</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::SetupPlayerInputComponent</span><span class="params">(UInputComponent* PlayerInputComponent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Super::<span class="built_in">SetupPlayerInputComponent</span>(PlayerInputComponent);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 设置&quot;移动&quot;绑定。</span></span><br><span class="line">   PlayerInputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="string">&quot;MoveForward&quot;</span>, <span class="keyword">this</span>, &amp;AFPSCharacter::MoveForward);</span><br><span class="line">   PlayerInputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="string">&quot;MoveRight&quot;</span>, <span class="keyword">this</span>, &amp;AFPSCharacter::MoveRight);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 设置&quot;观看&quot;绑定。</span></span><br><span class="line">   PlayerInputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="string">&quot;Turn&quot;</span>, <span class="keyword">this</span>, &amp;AFPSCharacter::AddControllerYawInput);</span><br><span class="line">   PlayerInputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="string">&quot;LookUp&quot;</span>, <span class="keyword">this</span>, &amp;AFPSCharacter::AddControllerPitchInput);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 设置&quot;操作&quot;绑定。</span></span><br><span class="line">   PlayerInputComponent-&gt;<span class="built_in">BindAction</span>(<span class="string">&quot;Jump&quot;</span>, IE_Pressed, <span class="keyword">this</span>, &amp;AFPSCharacter::StartJump);</span><br><span class="line">   PlayerInputComponent-&gt;<span class="built_in">BindAction</span>(<span class="string">&quot;Jump&quot;</span>, IE_Released, <span class="keyword">this</span>, &amp;AFPSCharacter::StopJump);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::MoveForward</span><span class="params">(<span class="type">float</span> Value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// 找出&quot;前进&quot;方向，并记录玩家想向该方向移动。</span></span><br><span class="line">   FVector Direction = <span class="built_in">FRotationMatrix</span>(Controller-&gt;<span class="built_in">GetControlRotation</span>()).<span class="built_in">GetScaledAxis</span>(EAxis::X);</span><br><span class="line">   <span class="built_in">AddMovementInput</span>(Direction, Value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::MoveRight</span><span class="params">(<span class="type">float</span> Value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// 找出&quot;右侧&quot;方向，并记录玩家想向该方向移动。</span></span><br><span class="line">   FVector Direction = <span class="built_in">FRotationMatrix</span>(Controller-&gt;<span class="built_in">GetControlRotation</span>()).<span class="built_in">GetScaledAxis</span>(EAxis::Y);</span><br><span class="line">   <span class="built_in">AddMovementInput</span>(Direction, Value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::StartJump</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   bPressedJump = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::StopJump</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   bPressedJump = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="测试角色跳跃"><a href="#测试角色跳跃" class="headerlink" title="测试角色跳跃"></a>测试角色跳跃</h2><p>现在我们来编译和测试新实现的角色移动函数。</p><ol><li><p>在VS中保存FPSCharacter 头文件（.h）和C++（.cpp）文件。</p></li><li><p>在 <strong>解决方案浏览器（Solution Explorer）</strong> 中找到 <strong>FPSProject</strong>。</p></li><li><p>右键点击 <strong>FPSProject</strong> 并选择 <strong>构建（Build）</strong>，编译你的项目。</p></li><li><p>构建完毕后，在虚幻引擎中打开 <strong>FPSProject</strong>。</p></li><li><p>在关卡编辑器工具栏中点击 <strong>运行（Play）</strong>。你应该能够在地图上跳跃。</p></li><li><p>按 <strong>退出（Escape）</strong> 键或在关卡编辑器中点击 <strong>停止（Stop）</strong>，退出PIE模式。</p></li></ol><p>步骤完成</p><h1 id="将网格体添加到角色"><a href="#将网格体添加到角色" class="headerlink" title="将网格体添加到角色"></a>将网格体添加到角色</h1><p>通过以下链接下载并提取示例网格体：</p><ul><li><a href="https://docs.unrealengine.com/4.27/Attachments/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/6/GenericMale.zip">示例网格体</a></li></ul><p>在此步骤中，你将为角色提供骨骼网格体。默认情况下，角色类为你创建了SkeletalMeshComponent对象，因此仅需了解使用哪个SkeletalMesh资产。</p><h2 id="导入骨骼网格体"><a href="#导入骨骼网格体" class="headerlink" title="导入骨骼网格体"></a>导入骨骼网格体</h2><ol><li><p>导航返回内容浏览器文件框内的内容（Content）文件夹。</p></li><li><p>现在，右键点击内容浏览器的文件框，打开 <strong>导入资产（Import Asset）</strong> 对话框。</p></li><li><p>点击 **‘导入&#x2F;游戏…（Import to &#x2F;Game…）’**，打开 <strong>导入（Import）</strong> 对话框。</p></li><li><p>找到并选择 <strong>GenericMale.fbx</strong> 网格体文件。</p></li><li><p>点击 <strong>打开（Open）</strong>，开始将网格体导入到你的项目中。</p></li><li><p><strong>内容浏览器（Content Browser）</strong> 中将显示 <strong>FBX导入选项（FBX Import Options）</strong> 对话框。点击 <strong>全部导入（Import All）</strong>，将你的网格体添加到项目。</p><p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/ImportGenericMale.jpg" alt="ImportGenericMale.png"></p></li><li><p>点击 <strong>保存（Save）</strong> 按钮保存导入的网格体。</p></li></ol><h2 id="设置第三人称网格体"><a href="#设置第三人称网格体" class="headerlink" title="设置第三人称网格体"></a>设置第三人称网格体</h2><ol><li><p>在 <strong>内容（Content）</strong> &gt; <strong>蓝图（Blueprints）</strong> 中，双击 <strong>BP_FPSCharacter</strong> 蓝图类图标，在 <strong>蓝图编辑器</strong> 中打开它。</p><p>如果你看到有关此蓝图为仅数据蓝图的说明，请点击 <strong>打开完整蓝图编辑器（Open Full Blueprint Editor）</strong>。</p></li><li><p>在 <strong>组件（Components）</strong> 选项卡中点击 <strong>网格体（Mesh）</strong> 组件。</p><p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/MeshComponent.jpg" alt="MeshComponent.png"></p></li><li><p>滚动到 <strong>细节（Details）</strong> 选项卡（屏幕右侧，或在 <strong>窗口（Window）</strong> &gt; <strong>细节（Details）</strong> 中）的 <strong>网格体（Mesh）</strong> 段。</p></li><li><p>点击骨骼网格体（Skeletal Mesh）行中显示为”无”的下拉列表，然后选择 <strong>GenericMale</strong> 骨骼网格体。</p><p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/SelectSkeletalMesh.jpg" alt="SelectSkeletalMesh.png"></p></li><li><p>滚动到 <strong>细节（Details）</strong> 窗格中的 <strong>变换（Transform）</strong> 段，然后，将变换的 <strong>Z</strong> 轴向位置设置为 **”-88.0”**，使 <code>SkeletalMeshComponent</code> 与 <code>CapsuleComponent</code> 对齐。</p><p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/NewZLoc_Mesh.jpg" alt="NewZLoc_Mesh.png"></p></li><li><p>打开视口（Viewport）预览骨骼网格体。骨骼网格体应该如下图所示：</p><p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/SkeletalMeshLocation.jpg" alt="SkeletalMeshLocation.png"></p><p>确认骨骼网格体在 <code>CapsuleComponent</code> 内部，并且网格体的朝向与 <code>ArrowComponent</code> 相同。正确确定骨骼网格体组件的朝向，将确保你的角色朝正确的方向在整个世界中移动。</p></li><li><p>请确保在关闭 <strong>蓝图编辑器（Blueprint Editor）</strong> 之前 <strong>编译（Compile)</strong> 并 <strong>保存（Save）</strong> <strong>BP_FPSCharacter</strong> 蓝图。</p></li></ol><h2 id="确认处于PIE模式的新网格体"><a href="#确认处于PIE模式的新网格体" class="headerlink" title="确认处于PIE模式的新网格体"></a>确认处于PIE模式的新网格体</h2><p>现在可在编辑器中查看新增网格体。</p><ol><li><p>在关卡编辑器工具栏中点击 <strong>运行（Play）</strong> 按钮。在你四处移动时，你应该能看到角色的影子。</p><p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/PawnwithShadow.jpg" alt="PawnwithShadow.png"></p><p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/Section0206.jpg" alt="Section0206.gif"></p><p>如果你要在编辑器的视口中查看角色的网格体，请按F8键，使自己从pawn中弹出来。按下F8键后，你将可以在关卡中自由移动摄像机。要移动摄像机，请在移动鼠标的同时按住鼠标左键。</p><p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/FreelyMovingCamera.jpg" alt="FreelyMovingCamera.png"></p></li><li><p>按 <strong>退出（Escape）</strong> 键或在关卡编辑器中点击 <strong>停止（Stop）</strong> 按钮，退出在编辑器中运行（Play in Editor）（PIE）模式。</p></li></ol><h1 id="更改摄像机视角"><a href="#更改摄像机视角" class="headerlink" title="更改摄像机视角"></a>更改摄像机视角</h1><p>在上一步结束时，默认摄像机放置在网格体的颈部。在此步骤中，你将设置FPS摄像机，这样你可以调整摄像机的属性（例如位置和视野）。 在开始之前，你需要在 <code>FPSCharacter.h</code> 中包含更多的头文件。这将使你的代码可以访问更多与摄像机相关的函数，并最终使你能够操纵摄像机的位置。</p><ol><li><p>打开Visual Studio项目，然后导航至 <code>FPSCharacter.h</code>。</p></li><li><p>将以下头文件添加到 <code>FPSCharacter.h</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;Camera/CameraComponent.h&quot;</span><br><span class="line">#include &quot;Components/CapsuleComponent.h&quot;</span><br></pre></td></tr></table></figure></li></ol><h3 id="附加摄像机组件"><a href="#附加摄像机组件" class="headerlink" title="附加摄像机组件"></a>附加摄像机组件</h3><ol><li><p>打开 <code>FPSCharacter.h</code>，添加以下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// FPS摄像机。</span><br><span class="line">UPROPERTY(VisibleAnywhere)</span><br><span class="line">UCameraComponent* FPSCameraComponent;</span><br></pre></td></tr></table></figure></li><li><p>现在 <code>FPSCharacter.h</code> 的内容应如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">//版权所有Epic Games, Inc。保留所有权利。</span><br><span class="line"></span><br><span class="line">#pragma once</span><br><span class="line"></span><br><span class="line">#include &quot;CoreMinimal.h&quot;</span><br><span class="line">#include &quot;GameFramework/Character.h&quot;</span><br><span class="line">#include &quot;Camera/CameraComponent.h&quot;</span><br><span class="line">#include &quot;Components/CapsuleComponent.h&quot;</span><br><span class="line">#include &quot;FPSCharacter.generated.h&quot;</span><br><span class="line"></span><br><span class="line">UCLASS()</span><br><span class="line">class FPSPROJECT_API AFPSCharacter : public ACharacter</span><br><span class="line">&#123;</span><br><span class="line">GENERATED_BODY()</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">// 为此角色的属性设置默认值</span><br><span class="line">AFPSCharacter();</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line">// 当游戏开始或重生（Spawn）时被调用</span><br><span class="line">virtual void BeginPlay() override;</span><br><span class="line"></span><br><span class="line">public:     </span><br><span class="line">// 每一帧都被调用</span><br><span class="line">virtual void Tick( float DeltaTime ) override;</span><br><span class="line"></span><br><span class="line">// 被调用，将功能与输入绑定</span><br><span class="line">virtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;</span><br><span class="line"></span><br><span class="line">// 处理用于前后移动的输入。</span><br><span class="line">UFUNCTION()</span><br><span class="line">void MoveForward(float Value);</span><br><span class="line"></span><br><span class="line">// 处理用于左右移动的输入。</span><br><span class="line">UFUNCTION()</span><br><span class="line">void MoveRight(float Value);</span><br><span class="line"></span><br><span class="line">// 按下键时，设置跳跃标记。</span><br><span class="line">UFUNCTION()</span><br><span class="line">void StartJump();</span><br><span class="line"></span><br><span class="line">// 释放键时，清除跳跃标记。</span><br><span class="line">UFUNCTION()</span><br><span class="line">void StopJump();</span><br><span class="line"></span><br><span class="line">// FPS摄像机</span><br><span class="line">UPROPERTY(VisibleAnywhere)</span><br><span class="line">UCameraComponent* FPSCameraComponent;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>打开 <code>FPSCharacter.cpp</code>，将以下代码添加到构造函数中： <code>PrimaryActorTick.bCanEverTick = true:</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 创建第一人称摄像机组件。</span><br><span class="line">FPSCameraComponent = CreateDefaultSubobject&lt;UCameraComponent&gt;(TEXT(&quot;FirstPersonCamera&quot;));</span><br><span class="line">check(FPSCameraComponent != nullptr);</span><br><span class="line"></span><br><span class="line">// 将摄像机组件附加到我们的胶囊体组件。</span><br><span class="line">FPSCameraComponent-&gt;SetupAttachment(CastChecked&lt;USceneComponent, UCapsuleComponent&gt;(GetCapsuleComponent()));</span><br></pre></td></tr></table></figure><p>此代码创建 <code>UCameraComponent</code>，并将其附加到角色的 <code>CapsuleComponent</code>。</p></li><li><p>现在，将以下代码添加到你刚刚在构造函数中编写的代码块下面：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 将摄像机置于略高于眼睛上方的位置。</span><br><span class="line">FPSCameraComponent-&gt;SetRelativeLocation(FVector(0.0f, 0.0f, 50.0f + BaseEyeHeight));</span><br><span class="line"></span><br><span class="line">// 启用Pawn控制摄像机旋转。</span><br><span class="line">FPSCameraComponent-&gt;bUsePawnControlRotation = true;</span><br></pre></td></tr></table></figure><p>此代码将摄像机的位置调整为略高于角色眼睛的位置，同时允许pawn控制摄像机的旋转。</p><p><code>SetRelativeLocation</code> 用于设置组件的默认值。不过，上一个值仍然会在设置在编辑器中。为纠正这点，请打开蓝图编辑器。点击 <code>FPSCameraComponent</code>，然后在 <strong>细节</strong> 面板中找到 <strong>变换 -&gt; 位置（Transform -&gt; Location）</strong> 数值。点击这个值旁边的 <strong>重置为默认（Reset to Default）</strong>。</p></li><li><p>现在 <code>FPSCharacter.cpp</code> 的内容应如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">//版权所有Epic Games, Inc。保留所有权利。</span><br><span class="line"></span><br><span class="line">#include &quot;FPSCharacter.h&quot;</span><br><span class="line"></span><br><span class="line">// 设置默认值</span><br><span class="line">AFPSCharacter::AFPSCharacter()</span><br><span class="line">&#123;</span><br><span class="line">   // 将此角色设置为每帧调用Tick()。  如果不需要此特性，可以关闭以提升性能。</span><br><span class="line">   PrimaryActorTick.bCanEverTick = true;</span><br><span class="line"></span><br><span class="line">   // 创建第一人称摄像机组件。</span><br><span class="line">   FPSCameraComponent = CreateDefaultSubobject&lt;UCameraComponent&gt;(TEXT(&quot;FirstPersonCamera&quot;));</span><br><span class="line">   check(FPSCameraComponent != nullptr);</span><br><span class="line"></span><br><span class="line">   // 将摄像机组件附加到我们的胶囊体组件。</span><br><span class="line">   FPSCameraComponent-&gt;SetupAttachment(CastChecked&lt;USceneComponent, UCapsuleComponent&gt;(GetCapsuleComponent()));</span><br><span class="line"></span><br><span class="line">   // 将摄像机置于略高于眼睛上方的位置。</span><br><span class="line">   FPSCameraComponent-&gt;SetRelativeLocation(FVector(0.0f, 0.0f, 50.0f + BaseEyeHeight));</span><br><span class="line"></span><br><span class="line">   // 启用Pawn控制摄像机旋转。</span><br><span class="line">   FPSCameraComponent-&gt;bUsePawnControlRotation = true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 当游戏开始或重生（Spawn）时被调用</span><br><span class="line">void AFPSCharacter::BeginPlay()</span><br><span class="line">&#123;</span><br><span class="line">   Super::BeginPlay();</span><br><span class="line"></span><br><span class="line">   check(GEngine != nullptr)</span><br><span class="line"></span><br><span class="line">     // 显示调试消息五秒。 </span><br><span class="line">    // -1&quot;键&quot;值（第一个参数）表示我们从不需要更新或刷新此消息。</span><br><span class="line">     GEngine-&gt;AddOnScreenDebugMessage(-1, 5.0f, FColor::Red, TEXT(&quot;We are using FPSCharacter.&quot;));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 每一帧都被调用</span><br><span class="line">void AFPSCharacter::Tick( float DeltaTime )</span><br><span class="line">&#123;</span><br><span class="line">   Super::Tick( DeltaTime );</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 被调用，将功能与输入绑定</span><br><span class="line">void AFPSCharacter::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)</span><br><span class="line">&#123;</span><br><span class="line">   Super::SetupPlayerInputComponent(PlayerInputComponent);</span><br><span class="line"></span><br><span class="line">   // 设置&quot;移动&quot;绑定。</span><br><span class="line">   PlayerInputComponent-&gt;BindAxis(&quot;MoveForward&quot;, this, &amp;AFPSCharacter::MoveForward);</span><br><span class="line">   PlayerInputComponent-&gt;BindAxis(&quot;MoveRight&quot;, this, &amp;AFPSCharacter::MoveRight);</span><br><span class="line"></span><br><span class="line">   // 设置&quot;观看&quot;绑定。</span><br><span class="line">   PlayerInputComponent-&gt;BindAxis(&quot;Turn&quot;, this, &amp;AFPSCharacter::AddControllerYawInput);</span><br><span class="line">   PlayerInputComponent-&gt;BindAxis(&quot;LookUp&quot;, this, &amp;AFPSCharacter::AddControllerPitchInput);</span><br><span class="line"></span><br><span class="line">   // 设置&quot;操作&quot;绑定。</span><br><span class="line">   PlayerInputComponent-&gt;BindAction(&quot;Jump&quot;, IE_Pressed, this, &amp;AFPSCharacter::StartJump);</span><br><span class="line">   PlayerInputComponent-&gt;BindAction(&quot;Jump&quot;, IE_Released, this, &amp;AFPSCharacter::StopJump);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void AFPSCharacter::MoveForward(float Value)</span><br><span class="line">&#123;</span><br><span class="line">   // 找出&quot;前进&quot;方向，并记录玩家想向该方向移动。</span><br><span class="line">   FVector Direction = FRotationMatrix(Controller-&gt;GetControlRotation()).GetScaledAxis(EAxis::X);</span><br><span class="line">   AddMovementInput(Direction, Value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void AFPSCharacter::MoveRight(float Value)</span><br><span class="line">&#123;</span><br><span class="line">   // 找出&quot;右侧&quot;方向，并记录玩家想向该方向移动。</span><br><span class="line">   FVector Direction = FRotationMatrix(Controller-&gt;GetControlRotation()).GetScaledAxis(EAxis::Y);</span><br><span class="line">   AddMovementInput(Direction, Value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void AFPSCharacter::StartJump()</span><br><span class="line">&#123;</span><br><span class="line">   bPressedJump = true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void AFPSCharacter::StopJump()</span><br><span class="line">&#123;</span><br><span class="line">   bPressedJump = false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="测试新摄像机"><a href="#测试新摄像机" class="headerlink" title="测试新摄像机"></a>测试新摄像机</h3><p>现在我们来编译和测试新实现的摄像机代码。</p><ol><li><p>在Visual Studio中保存 <code>FPSCharacter</code> 头文件（.h）和C++（.cpp）文件。</p></li><li><p>在 <strong>解决方案浏览器（Solution Explorer）</strong> 中找到 <strong>FPSProject</strong>。</p></li><li><p>右键点击 <strong>FPSProject</strong> 并选择 <strong>构建（Build）</strong>，编译你的项目。</p></li><li><p>构建完毕后，在虚幻引擎中打开 <strong>FPSProject</strong>。</p></li><li><p>在关卡编辑器工具栏中点击 <strong>运行（Play）</strong>。</p></li></ol><p>现在，摄像机应该略高于角色的头部。</p><p>你还可以通过打开BP_FPSCharacter视口来确认新添加的摄像机组件。 <img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/NewCameraComponent.jpg" alt="NewCameraComponent.png"></p><p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/NewCameraPosition.jpg" alt="NewCameraPosition.png"></p><h1 id="将第一人称网格体添加到角色"><a href="#将第一人称网格体添加到角色" class="headerlink" title="将第一人称网格体添加到角色"></a>将第一人称网格体添加到角色</h1><p>构建FPS游戏的常见方法是使用两个分开的角色网格体，其中一个是全身网格体，另一个是”武器和手部”网格体。全身网格体用于从第三人称视角观察角色。但是，当玩家以第一人称视角进行游戏时，全身网格体是隐藏的。”武器和手部”网格体通常附着到摄像机，并且仅当玩家以第一人称视角查看地图时才对玩家可见。在此步骤中，你将向角色添加第一人称网格体。</p><h3 id="添加第一人称角色网格体"><a href="#添加第一人称角色网格体" class="headerlink" title="添加第一人称角色网格体"></a>添加第一人称角色网格体</h3><ol><li><p>切换回Visual Studio并打开 <code>FPSCharacter.h</code>，在 <strong>public:</strong> 下添加以下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 第一人称网格体（手臂），仅对所属玩家可见。</span><br><span class="line">UPROPERTY(VisibleDefaultsOnly, Category = Mesh)</span><br><span class="line">USkeletalMeshComponent* FPSMesh;</span><br></pre></td></tr></table></figure></li><li><p>现在，打开 <code>FPSCharacter.cpp</code>，找到构造函数，添加以下代码，创建和配置第一人称网格体：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 为所属玩家创建第一人称网格体组件。</span><br><span class="line">FPSMesh = CreateDefaultSubobject&lt;USkeletalMeshComponent&gt;(TEXT(&quot;FirstPersonMesh&quot;));</span><br><span class="line">check(FPSMesh != nullptr);</span><br><span class="line"></span><br><span class="line">// 仅所属玩家可以看见此网格体。</span><br><span class="line">FPSMesh-&gt;SetOnlyOwnerSee(true);</span><br><span class="line"></span><br><span class="line">// 将 FPS 网格体附加到 FPS 摄像机。</span><br><span class="line">FPSMesh-&gt;SetupAttachment(FPSCameraComponent);</span><br><span class="line"></span><br><span class="line">// 禁用某些环境阴影以便实现只有单个网格体的感觉。</span><br><span class="line">FPSMesh-&gt;bCastDynamicShadow = false;</span><br><span class="line">FPSMesh-&gt;CastShadow = false;</span><br></pre></td></tr></table></figure><p><code>SetOnlyOwnerSee</code> 表示此网格体仅对拥有此角色的 <code>PlayerController</code> 可见。此代码还将网格体附加到摄像机，并禁用某些环境阴影。让手臂投射阴影会破坏第一人称角色应该只有单个网格体的感觉。</p></li><li><p>最后，将以下代码添加到FPSCharacter.cpp的构造函数中，以便隐藏所属角色的现有第三人称网格体：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 所属玩家看不到常规（第三人称）全身网格体。</span><br><span class="line">GetMesh()-&gt;SetOwnerNoSee(true);</span><br></pre></td></tr></table></figure></li><li><p>在Visual Studio中保存FPSCharacter头文件（.h）和实现（.cpp）文件。</p></li><li><p>在 <strong>解决方案浏览器（Solution Explorer）</strong> 中找到 <strong>FPSProject</strong>。</p></li><li><p>右键点击 <strong>FPSProject</strong> 并选择 <strong>构建（Build）</strong>，编译你的项目。</p></li><li><p>构建完成后，打开并以PIE模式运行 <strong>FPSProject</strong>。</p><p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/HiddenMeshInGame.jpg" alt="HiddenMeshInGame.png"></p></li></ol><p>此时，你的角色网格体在编辑器中应该不可见。</p><p>如果你仍然看到网格体及其阴影投射，请关闭并重新启动编辑器。</p><h3 id="构建网格体蓝图"><a href="#构建网格体蓝图" class="headerlink" title="构建网格体蓝图"></a>构建网格体蓝图</h3><p>在继续之前，请通过以下链接下载并提取示例网格体： <a href="https://docs.unrealengine.com/4.27/Attachments/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/8/HeroFPP.zip">“第一人称骨骼网格体”</a></p><ol><li><p>右键点击内容浏览器的文件框，打开 <strong>导入资产（Import Asset）</strong> 对话框。</p></li><li><p>点击 <strong>导入&#x2F;游戏…（Import to &#x2F;Game…）</strong>，打开 <strong>导入（Import）</strong> 对话框。</p><p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/RightClickImport.jpg" alt="RightClickImport.png"></p></li><li><p>找到并选择 <strong>HeroFPP.fbx</strong> 网格体文件。</p></li><li><p>点击 <strong>打开（Open）</strong>，开始将网格体导入到你的项目中。</p></li><li><p><strong>内容浏览器（Content Browser）</strong> 中将显示 <strong>FBX导入选项（FBX Import Options）</strong> 对话框。</p></li><li><p>请确保将 <strong>骨架（Skeleton）</strong> 设置为 <strong>无（None）</strong>，然后点击 <strong>全部导入（Import All）</strong>。</p><p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/ClearSkeletonMesh.jpg" alt="ClearSkeletonMesh.png"></p></li><li><p>关闭以下消息日志。  </p><p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/FBXWarning.jpg" alt="FBXWarning.png">  </p><p>此网格体仍展示第一人称网格体设置，它将与你在后面分段中设置的动画一起使用。</p></li><li><p>点击 <strong>保存（Save）</strong>，保存导入的网格体。</p></li><li><p>导航返回 <strong>内容浏览器（Content Browser）</strong> 中的 <strong>蓝图（Blueprints）</strong> 文件夹。</p></li><li><p>双击 <strong>BP_FPSCharacter</strong> 图标，在 <strong>蓝图编辑器</strong> 中打开它。</p></li><li><p>在 <strong>组件（Components）</strong> 选项卡中找到新的 <strong>FPSMesh</strong> 组件。首先，你可能需要打开 <strong>完整的蓝图编辑器</strong>。</p><p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/LocateFPSMeshComponent.jpg" alt="LocateFPSMeshComponent.png">  </p><p><strong>FPSMesh</strong> 组件是 <strong>FPSCameraComponent</strong> 组件的子项，这意味着它将始终附加到摄像机。</p></li><li><p>在 <strong>组件（Components）</strong> 菜单中点击 <strong>FPSMesh</strong>。</p></li><li><p>滚动到 <strong>细节（Details）</strong> 选项卡的 <strong>网格体（Mesh）</strong> 段，然后点击显示为”无（None）”的下拉菜单。现在，选择 <strong>HeroFPP</strong> 骨骼网格体，将手臂添加到 <strong>视口（Viewport）</strong>。</p><p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/SelectHeroFPPSkeletalMesh.jpg" alt="SelectHeroFPPSkeletalMesh.png"></p></li><li><p>在 <strong>视口（Viewport）</strong> 中，新增的 <strong>HeroFPP</strong> 骨骼网格体应如下图所示。</p><p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/HeroFPPMesh_Viewport.jpg" alt="HeroFPPMesh_Viewport.png"></p></li><li><p>将新增网格体的变换属性调整为在摄像机前面：将其 <strong>位置（Location）</strong> 设置为{220, 0, 35}，将其 <strong>旋转（Rotation）</strong> 设置为{180, 50, 180}。</p><p><a href="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/AdjustingArmsTransform.png"><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/AdjustingArmsTransform.jpg" alt="AdjustingArmsTransform.png"></a></p><p>点击查看大图。</p></li><li><p>请确保在关闭 <strong>蓝图编辑器（Blueprint Editor）</strong> 之前 <strong>编译（Compile)</strong> 并 <strong>保存（Save）</strong> <strong>BP_FPSCharacter</strong> 蓝图。</p></li></ol><h3 id="在游戏中查看新网格体"><a href="#在游戏中查看新网格体" class="headerlink" title="在游戏中查看新网格体"></a>在游戏中查看新网格体</h3><ol><li><p>点击 <strong>关卡编辑器工具栏</strong> 中的 <strong>运行（Play）</strong> 按钮**，在游戏中查看新网格体。</p><p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/Section0208.jpg" alt="Section0208.gif"></p></li><li><p>按 <strong>退出（Escape）</strong> 键或在关卡编辑器中点击 <strong>停止（Stop）</strong> 按钮，退出在编辑器中运行（Play in Editor）（PIE）模式。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> unreal engine </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UE4-API</title>
      <link href="/2022/04/27/UE4-API/"/>
      <url>/2022/04/27/UE4-API/</url>
      
        <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>在这里记录一些目前遇到的unreal engine中的API</p><h1 id="组件与碰撞"><a href="#组件与碰撞" class="headerlink" title="组件与碰撞"></a>组件与碰撞</h1><p>在官方案例——<a href="https://docs.unrealengine.com/4.27/zh-CN/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/Components/">组件与碰撞</a>中的API</p><h2 id="CreateDefaultSubject-lt-gt"><a href="#CreateDefaultSubject-lt-gt" class="headerlink" title="CreateDefaultSubject&lt;&gt;()"></a>CreateDefaultSubject&lt;&gt;()</h2><p>创建默认子网格体&lt;&gt;中是子网格体的类型</p><p><code>USphereComponent* SphereComponent = CreateDefaultSubobject&lt;USphereComponent&gt;(TEXT(&quot;RootComponent&quot;))</code></p><h2 id="InitSphereRadius"><a href="#InitSphereRadius" class="headerlink" title="InitSphereRadius()"></a>InitSphereRadius()</h2><p>初始化球体半径</p><p><code>SphereComponent-&gt;InitSphereRadius(40.0f);</code></p><h2 id="SetCollisionProfileName"><a href="#SetCollisionProfileName" class="headerlink" title="SetCollisionProfileName()"></a>SetCollisionProfileName()</h2><p>设置碰撞预设名称</p><p><code>SphereComponent-&gt;SetCollisionProfileName(TEXT(&quot;Pawn&quot;));</code></p><h2 id="SetupAttachment"><a href="#SetupAttachment" class="headerlink" title="SetupAttachment()"></a>SetupAttachment()</h2><p>将某组件添加到括号内的组件上</p><p><code>SphereVisual-&gt;SetupAttachment(RootComponent);</code></p><h2 id="static-ConstructorHelpers-FObjectFinder-lt-gt"><a href="#static-ConstructorHelpers-FObjectFinder-lt-gt" class="headerlink" title="static ConstructorHelpers::FObjectFinder&lt;&gt;"></a>static ConstructorHelpers::FObjectFinder&lt;&gt;</h2><p>直接在代码中设置静态网格体资源</p><p><code>static ConstructorHelpers::FObjectFinder&lt;UStaticMesh&gt; SphereVisualAsset(TEXT(&quot;/Game/StarterContent/Shapes/Shape_Sphere.Shape_Sphere&quot;));</code></p><h2 id="SetStaticMesh"><a href="#SetStaticMesh" class="headerlink" title="SetStaticMesh()"></a>SetStaticMesh()</h2><p>将找到的网格体附加到括号内的组件上</p><p>SphereVisual-&gt;SetStaticMesh(SphereVisualAsset.Object);</p><h2 id="SetRelativeLocation"><a href="#SetRelativeLocation" class="headerlink" title="SetRelativeLocation()"></a>SetRelativeLocation()</h2><p>设置相对位置</p><p><code>SphereVisual-&gt;SetRelativeLocation(FVector(0.0f, 0.0f, -40.0f));</code></p><h2 id="SetWorldScale3D"><a href="#SetWorldScale3D" class="headerlink" title="SetWorldScale3D()"></a>SetWorldScale3D()</h2><p>设置缩放大小</p><p><code>SphereVisual-&gt;SetWorldScale3D(FVector(0.8f));</code></p><h2 id="bAutoActivate"><a href="#bAutoActivate" class="headerlink" title="bAutoActivate"></a>bAutoActivate</h2><p>粒子效果开关</p><p><code>OurParticleSystem-&gt;bAutoActivate = false;</code></p><h2 id="SetTemplate"><a href="#SetTemplate" class="headerlink" title="SetTemplate"></a>SetTemplate</h2><p>给粒子系统设定模板</p><p><code>OurParticleSystem-&gt;SetTemplate(ParticleAsset.Object);</code></p><h2 id="TargetArmLength"><a href="#TargetArmLength" class="headerlink" title="TargetArmLength"></a>TargetArmLength</h2><p>弹簧臂长度</p><p><code>SpringArm-&gt;TargetArmLength = 400.0f;</code></p><h2 id="bEnableCameraLag"><a href="#bEnableCameraLag" class="headerlink" title="bEnableCameraLag"></a>bEnableCameraLag</h2><p>弹簧臂平滑效果开关</p><p><code>SpringArm-&gt;bEnableCameraLag = true;</code></p><h2 id="CameraLagSpeed"><a href="#CameraLagSpeed" class="headerlink" title="CameraLagSpeed"></a>CameraLagSpeed</h2><p>平滑效果切换速度</p><p><code>SpringArm-&gt;CameraLagSpeed = 3.0f;</code></p><h2 id="SocketName"><a href="#SocketName" class="headerlink" title="SocketName"></a>SocketName</h2><p>弹簧臂插槽</p><p><code>Camera-&gt;SetupAttachment(SpringArm, USpringArmComponent::SocketName);</code></p><h2 id="AutoPossessPlayer"><a href="#AutoPossessPlayer" class="headerlink" title="AutoPossessPlayer"></a>AutoPossessPlayer</h2><p>默认控制玩家</p><p><code>AutoPossessPlayer = EAutoReceiveInput::Player0;</code></p><h2 id="UpdatedComonent"><a href="#UpdatedComonent" class="headerlink" title="UpdatedComonent"></a>UpdatedComonent</h2><p>更新某组件</p><p><code>OurMovementComponent-&gt;UpdatedComponent = RootComponent;</code></p><h2 id="BindAxtion"><a href="#BindAxtion" class="headerlink" title="BindAxtion()"></a>BindAxtion()</h2><p>绑定输入映射</p><p><code>InInputComponent-&gt;BindAction(&quot;ParticleToggle&quot;, IE_Pressed, this, &amp;ACollidingPawn::ParticleToggle);</code></p><ul><li><p>参数一：为 虚幻4-&gt;设置 -&gt;输入-&gt;按键绑定的名称</p></li><li><p>参数二：事件名称 IE_Pressed 按下 IE_Released松开 IE_DoubleClick双击</p></li><li><p>参数三：当前对象——this</p></li><li><p>参数四：事件方法的函数指针 例 &amp;类名::方法名的写法</p></li></ul><h2 id="BindAxis"><a href="#BindAxis" class="headerlink" title="BindAxis()"></a>BindAxis()</h2><p>绑定轴映射</p><p><code>InInputComponent-&gt;BindAxis(&quot;MoveForward&quot;, this, &amp;ACollidingPawn::MoveForward);</code></p><ul><li><p>参数一：为 虚幻4-&gt;设置 -&gt;输入-&gt;按键绑定的名称 一定要一样 重要！！！ </p></li><li><p>参数二 ：当前对象——this</p></li><li><p>参数三 事件方法的函数指针 例 &amp;类名::方法名 的写法</p></li></ul><h2 id="AddInputVector"><a href="#AddInputVector" class="headerlink" title="AddInputVector()"></a>AddInputVector()</h2><p>根据输入更改Vector位置</p><p><code>OurMovementComponent-&gt;AddInputVector(GetActorForwardVector() * AxisValue);</code></p><h2 id="GetActorForwardVector"><a href="#GetActorForwardVector" class="headerlink" title="GetActorForwardVector()"></a>GetActorForwardVector()</h2><p>更新Actor向前运动的vector</p><p><code>OurMovementComponent-&gt;AddInputVector(GetActorForwardVector() * AxisValue);</code></p><h2 id="GetActorRightVector"><a href="#GetActorRightVector" class="headerlink" title="GetActorRightVector()"></a>GetActorRightVector()</h2><p>更新Actor向右运动的vector</p><p><code>OurMovementComponent-&gt;AddInputVector(GetActorRightVector() * AxisValue);</code></p><h2 id="GetActorRotation"><a href="#GetActorRotation" class="headerlink" title="GetActorRotation()"></a>GetActorRotation()</h2><p>获取Actor的旋转角度</p><p><code>FRotator NewRotation = GetActorRotation();</code></p><h2 id="SetActorRotation"><a href="#SetActorRotation" class="headerlink" title="SetActorRotation();"></a>SetActorRotation();</h2><p>设置Actor的新角度</p><p><code>SetActorRotation(NewRotation);</code></p><h2 id="ToggleActive"><a href="#ToggleActive" class="headerlink" title="ToggleActive()"></a>ToggleActive()</h2><p>转换粒子效果状态（开关）</p><p><code>OurParticleSystem-&gt;ToggleActive();</code></p><p>GetClampedToMaxSize()</p><p>用于更新vector的位置</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FVector <span class="title">FVector::GetClampedToMaxSize</span><span class="params">(<span class="type">float</span> MaxSize)</span></span></span><br></pre></td></tr></table></figure><p>用于创建一个新的vector，方向与原本的方向一直，距离为MaxSize</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FVector <span class="title">FVector::GetClampedToSize</span><span class="params">(<span class="type">float</span> Min,<span class="type">float</span> Max)</span> </span></span><br></pre></td></tr></table></figure><p>创建一个新的Vector，方向与原方向一致</p><p>距离为</p><ol><li><p>若距离&lt;Min，则新的vector距离为Min</p></li><li><p>若距离&gt;Max，则新的vector距离为Max</p></li><li><p>若距离在Min和Max之间，则新的vector等于原本的vector</p></li></ol><h2 id="ConsumeInputVector-1-0f"><a href="#ConsumeInputVector-1-0f" class="headerlink" title="ConsumeInputVector(1.0f)"></a>ConsumeInputVector(1.0f)</h2><p>报告并清空用于存储移动输入的内置变量值。</p><h2 id="SafeMoveUpdatedComponent"><a href="#SafeMoveUpdatedComponent" class="headerlink" title="SafeMoveUpdatedComponent()"></a>SafeMoveUpdatedComponent()</h2><p><code>SafeMoveUpdatedComponent(const FVector&amp; Delta, const FRotator&amp; NewRotation, bool bSweep, FHitResult&amp; OutHit, ETeleportType Teleport)</code></p><p><code>SafeMoveUpdatedComponent(DesiredMovementThisFrame, UpdatedComponent-&gt;GetComponentRotation(), true, Hit);</code></p><p>利用虚幻引擎物理移动Pawn移动组件，同时考虑固体障碍。</p><ul><li><p>第一个参数：要移动的Vector</p></li><li><p>第二个参数：旋转参数</p></li><li><p>第三个参数：是否考虑物理障碍（如果为true，将在移动过程中扫描以阻止碰撞。如果为false，它将简单地传送到下一个位置并忽略碰撞。）</p></li><li><p>第四个参数：碰撞结果</p></li><li><p>第五个参数：可省略，远距离传送类型</p></li></ul><h2 id="SlideAlongSurface"><a href="#SlideAlongSurface" class="headerlink" title="SlideAlongSurface()"></a>SlideAlongSurface()</h2><p><code>SlideAlongSurface(const FVector&amp; Delta, float Time, const FQuat Rotation, const FVector&amp; Normal, FHitResult&amp; Hit, bool bHandleImpact)</code></p><ul><li><p>第一个参数：要移动的vector</p></li><li><p>第二个参数：运动时间</p></li><li><p>第三个参数：旋转情况（可省略）</p></li><li><p>第四个参数：vector类型？（这个不太确定）</p></li><li><p>第五个参数：碰撞结果（必须为bBlockingHit）</p></li><li><p>第六个参数：手柄反馈？（这个扎找不到源文件）</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> unreal engine </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> API </tag>
            
            <tag> unreal engine </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UE4-HowTo_Components</title>
      <link href="/2022/04/25/UE4-HowTo-Components/"/>
      <url>/2022/04/25/UE4-HowTo-Components/</url>
      
        <content type="html"><![CDATA[<p>官方案例——<a href="https://docs.unrealengine.com/4.27/zh-CN/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/Components/">解组件和碰撞</a></p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol><li><p>明确目标：创建一个有物理性质的球体，能和其他物体碰撞，并且拥有火焰粒子效果</p></li><li><p>创建CollidingPawn</p></li><li><p>创建这个球体本身需要什么头文件</p></li><li><p>修改根组件为对物理反应的球体</p></li><li><p>创建球体并附加到根组件上</p></li><li><p>将粒子系统直接附加到球体上（不是根组件）</p></li><li><p>添加弹簧臂组件，并在其上插槽内添加摄像机组件</p></li><li><p>将此Pawn设为受默认玩家控制</p></li><li><p>配置输入：编辑-&gt;设置项目-&gt;输入-&gt;操作映射（粒子系统）-&gt;轴映射(移动和转动)</p></li><li><p>创建Pawn移动组件类（PawnMovementComponent）CollidingPawnMovementComponent</p></li><li><p>定义TickComonent函数，告知逐帧移动方式</p></li><li><p>将Pawn移动组件添加到Pawn内</p></li><li><p>创建Pawn移动组件并将其与Pawn关联，使其更新根组件</p></li><li><p>声明并定义一些函数处理Pawn会接收的输入</p></li><li><p>将函数绑定到输入事件</p></li></ol><h1 id="CollidingPawn-h"><a href="#CollidingPawn-h" class="headerlink" title="CollidingPawn.h"></a>CollidingPawn.h</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CoreMinimal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GameFramework/Pawn.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CollidingPawn.generated.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HOWTO_COMPONENTS_API</span> ACollidingPawn : <span class="keyword">public</span> APawn</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 设置此Pawn属性的默认值</span></span><br><span class="line">    <span class="built_in">ACollidingPawn</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// 游戏开始或生成时调用</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BeginPlay</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 逐帧调用</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Tick</span><span class="params">( <span class="type">float</span> DeltaSeconds )</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用以将功能与输入绑定（也就是将要设定的wasd和空格的输入功能）</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SetupPlayerInputComponent</span><span class="params">(<span class="keyword">class</span> UInputComponent* InInputComponent)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明粒子系统（火焰燃烧效果等）</span></span><br><span class="line">    <span class="built_in">UPROPERTY</span>()</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">UParticleSystemComponent</span>* OurParticleSystem;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明移动组件，使其可以追踪变量</span></span><br><span class="line">    <span class="built_in">UPROPERTY</span>()</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">UCollidingPawnMovementComponent</span>* OurMovementComponent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Pawn拥有名为 GetMovementComponent 的函数，用于提供引擎中其他类访问该Pawn当前所用Pawn移动组件的权限。需覆盖该函数，使其返回自定义Pawn移动组件</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> UPawnMovementComponent* <span class="title">GetMovementComponent</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建代码处理pawn接受过来的输入</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">MoveForward</span><span class="params">(<span class="type">float</span> AxisValue)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">MoveRight</span><span class="params">(<span class="type">float</span> AxisValue)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Turn</span><span class="params">(<span class="type">float</span> AxisValue)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ParticleToggle</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="CollidingPawn-cpp"><a href="#CollidingPawn-cpp" class="headerlink" title="CollidingPawn.cpp"></a>CollidingPawn.cpp</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CollidingPawn.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CollidingPawnMovementComponent.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UObject/ConstructorHelpers.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Particles/ParticleSystemComponent.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Components/SphereComponent.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Camera/CameraComponent.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GameFramework/SpringArmComponent.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置默认值</span></span><br><span class="line">ACollidingPawn::<span class="built_in">ACollidingPawn</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 设置该Pawn以逐帧调用Tick()。如无需此功能，可关闭以提高性能。</span></span><br><span class="line">    PrimaryActorTick.bCanEverTick = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根组件将成为对物理反应的球体</span></span><br><span class="line">    USphereComponent* SphereComponent = <span class="built_in">CreateDefaultSubobject</span>&lt;USphereComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;RootComponent&quot;</span>));</span><br><span class="line">    RootComponent = SphereComponent;</span><br><span class="line">    SphereComponent-&gt;<span class="built_in">InitSphereRadius</span>(<span class="number">40.0f</span>);<span class="comment">//初始化球的半径</span></span><br><span class="line">    SphereComponent-&gt;<span class="built_in">SetCollisionProfileName</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;Pawn&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建并放置网格体组件，以便查看球体位置</span></span><br><span class="line">    UStaticMeshComponent* SphereVisual = <span class="built_in">CreateDefaultSubobject</span>&lt;UStaticMeshComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;VisualRepresentation&quot;</span>));</span><br><span class="line">    SphereVisual-&gt;<span class="built_in">SetupAttachment</span>(RootComponent);</span><br><span class="line">    <span class="function"><span class="type">static</span> ConstructorHelpers::FObjectFinder&lt;UStaticMesh&gt; <span class="title">SphereVisualAsset</span><span class="params">(TEXT(<span class="string">&quot;/Game/StarterContent/Shapes/Shape_Sphere.Shape_Sphere&quot;</span>))</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (SphereVisualAsset.<span class="built_in">Succeeded</span>())<span class="comment">//如果找到了绑定的网格体</span></span><br><span class="line">    &#123;</span><br><span class="line">        SphereVisual-&gt;<span class="built_in">SetStaticMesh</span>(SphereVisualAsset.Object);<span class="comment">//则将找到的网格体附加到SphereVisual上！</span></span><br><span class="line">        SphereVisual-&gt;<span class="built_in">SetRelativeLocation</span>(<span class="built_in">FVector</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">-40.0f</span>));<span class="comment">//设置相对位置</span></span><br><span class="line">        SphereVisual-&gt;<span class="built_in">SetWorldScale3D</span>(<span class="built_in">FVector</span>(<span class="number">0.8f</span>));<span class="comment">//缩放为80%</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建可激活或停止的粒子系统</span></span><br><span class="line">    <span class="comment">// 粒子系统组件直接附加到静态网格体组件，而非附加到根。其同时略微偏离网格体底部中心，以便在运行时清晰显示。</span></span><br><span class="line">    OurParticleSystem = <span class="built_in">CreateDefaultSubobject</span>&lt;UParticleSystemComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;MovementParticles&quot;</span>));</span><br><span class="line">    OurParticleSystem-&gt;<span class="built_in">SetupAttachment</span>(SphereVisual);<span class="comment">//将粒子效果组件添加到SphereVisual上！</span></span><br><span class="line">    OurParticleSystem-&gt;bAutoActivate = <span class="literal">false</span>;<span class="comment">//关闭激活粒子效果</span></span><br><span class="line">    OurParticleSystem-&gt;<span class="built_in">SetRelativeLocation</span>(<span class="built_in">FVector</span>(<span class="number">-20.0f</span>, <span class="number">0.0f</span>, <span class="number">20.0f</span>));<span class="comment">//设定粒子效果在网格体上的相对位置</span></span><br><span class="line">    <span class="function"><span class="type">static</span> ConstructorHelpers::FObjectFinder&lt;UParticleSystem&gt; <span class="title">ParticleAsset</span><span class="params">(TEXT(<span class="string">&quot;/Game/StarterContent/Particles/P_Fire.P_Fire&quot;</span>))</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (ParticleAsset.<span class="built_in">Succeeded</span>())<span class="comment">//如果在资源中找到指定的粒子效果</span></span><br><span class="line">    &#123;</span><br><span class="line">        OurParticleSystem-&gt;<span class="built_in">SetTemplate</span>(ParticleAsset.Object);<span class="comment">//将找到的粒子效果附加到PartcleAsset上！</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用弹簧臂给予摄像机平滑自然的运动感。</span></span><br><span class="line">    USpringArmComponent* SpringArm = <span class="built_in">CreateDefaultSubobject</span>&lt;USpringArmComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;CameraAttachmentArm&quot;</span>));</span><br><span class="line">    SpringArm-&gt;<span class="built_in">SetupAttachment</span>(RootComponent);<span class="comment">//将弹簧臂附加到根组件上</span></span><br><span class="line">    SpringArm-&gt;<span class="built_in">SetRelativeRotation</span>(<span class="built_in">FRotator</span>(<span class="number">-45.f</span>, <span class="number">0.f</span>, <span class="number">0.f</span>));<span class="comment">//设定弹簧臂相对于转子的位置</span></span><br><span class="line">    SpringArm-&gt;TargetArmLength = <span class="number">400.0f</span>;<span class="comment">//弹簧臂长度</span></span><br><span class="line">    SpringArm-&gt;bEnableCameraLag = <span class="literal">true</span>;<span class="comment">//打开平滑效果</span></span><br><span class="line">    SpringArm-&gt;CameraLagSpeed = <span class="number">3.0f</span>;<span class="comment">//设置平滑效果时间</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建摄像机并附加到弹簧臂</span></span><br><span class="line">    <span class="comment">// 弹簧臂内置一个特殊的插槽，可供我们添加对象，这样就不必将对象直接添加到组件的根节点上。</span></span><br><span class="line">    UCameraComponent* Camera = <span class="built_in">CreateDefaultSubobject</span>&lt;UCameraComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;ActualCamera&quot;</span>));</span><br><span class="line">    Camera-&gt;<span class="built_in">SetupAttachment</span>(SpringArm, USpringArmComponent::SocketName);<span class="comment">//将摄像机添加到弹簧臂的插槽上！</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 控制默认玩家</span></span><br><span class="line">    AutoPossessPlayer = EAutoReceiveInput::Player0;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建移动组件的实例，并要求其更新根组件。</span></span><br><span class="line">    OurMovementComponent = <span class="built_in">CreateDefaultSubobject</span>&lt;UCollidingPawnMovementComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;CustomMovementComponent&quot;</span>));</span><br><span class="line">    OurMovementComponent-&gt;UpdatedComponent = RootComponent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 游戏开始或生成时调用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ACollidingPawn::BeginPlay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">BeginPlay</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 逐帧调用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ACollidingPawn::Tick</span><span class="params">( <span class="type">float</span> DeltaTime )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">Tick</span>( DeltaTime );</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置键盘输入将会发生的事件，其中前进左右转弯等等函数将在下文定义</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ACollidingPawn::SetupPlayerInputComponent</span><span class="params">(<span class="keyword">class</span> UInputComponent* InInputComponent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">SetupPlayerInputComponent</span>(InInputComponent);</span><br><span class="line"></span><br><span class="line">    InInputComponent-&gt;<span class="built_in">BindAction</span>(<span class="string">&quot;ParticleToggle&quot;</span>, IE_Pressed, <span class="keyword">this</span>, &amp;ACollidingPawn::ParticleToggle);</span><br><span class="line"></span><br><span class="line">    InInputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="string">&quot;MoveForward&quot;</span>, <span class="keyword">this</span>, &amp;ACollidingPawn::MoveForward);</span><br><span class="line">    InInputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="string">&quot;MoveRight&quot;</span>, <span class="keyword">this</span>, &amp;ACollidingPawn::MoveRight);</span><br><span class="line">    InInputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="string">&quot;Turn&quot;</span>, <span class="keyword">this</span>, &amp;ACollidingPawn::Turn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于提供引擎中其他类访问该Pawn当前所用Pawn移动组件的权限。</span></span><br><span class="line"><span class="function">UPawnMovementComponent* <span class="title">ACollidingPawn::GetMovementComponent</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> OurMovementComponent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义前后移动的函数代码</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ACollidingPawn::MoveForward</span><span class="params">(<span class="type">float</span> AxisValue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//保证移动组件存在并且移动组件用来更新根组件</span></span><br><span class="line">    <span class="keyword">if</span> (OurMovementComponent &amp;&amp; (OurMovementComponent-&gt;UpdatedComponent == RootComponent))</span><br><span class="line">    &#123;</span><br><span class="line">        OurMovementComponent-&gt;<span class="built_in">AddInputVector</span>(<span class="built_in">GetActorForwardVector</span>() * AxisValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义左右转动的函数代码</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ACollidingPawn::MoveRight</span><span class="params">(<span class="type">float</span> AxisValue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (OurMovementComponent &amp;&amp; (OurMovementComponent-&gt;UpdatedComponent == RootComponent))</span><br><span class="line">    &#123;</span><br><span class="line">        OurMovementComponent-&gt;<span class="built_in">AddInputVector</span>(<span class="built_in">GetActorRightVector</span>() * AxisValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义转向代码</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ACollidingPawn::Turn</span><span class="params">(<span class="type">float</span> AxisValue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FRotator NewRotation = <span class="built_in">GetActorRotation</span>();<span class="comment">//获取actor当前位置</span></span><br><span class="line">    NewRotation.Yaw += AxisValue;<span class="comment">//围绕Z轴旋转更新actor</span></span><br><span class="line">    <span class="built_in">SetActorRotation</span>(NewRotation);<span class="comment">//更新actor的旋转角度</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义粒子效果开关代码</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ACollidingPawn::ParticleToggle</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//保证粒子效果存在且已经设定好了模板</span></span><br><span class="line">    <span class="keyword">if</span> (OurParticleSystem &amp;&amp; OurParticleSystem-&gt;Template)</span><br><span class="line">    &#123;</span><br><span class="line">        OurParticleSystem-&gt;<span class="built_in">ToggleActive</span>();<span class="comment">//ToggleActor的意思是切换状态</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="有关BindAction-与BindAction"><a href="#有关BindAction-与BindAction" class="headerlink" title="有关BindAction()与BindAction()"></a>有关BindAction()与BindAction()</h2><p><code>BindAction(&quot;ZoomIn&quot;, IE_Pressed, this, &amp;APawnWithCamera::ZoomIn);</code></p><ul><li><p>参数一：为 虚幻4-&gt;设置 -&gt;输入-&gt;按键绑定的名称 </p></li><li><p>参数二：事件名称 IE_Pressed 按下 IE_Released松开 IE_DoubleClick双击 </p></li><li><p>参数三：当前对象——this</p></li><li><p>参数四：事件方法的函数指针 例 &amp;类名::方法名的写法</p></li></ul><p><code>BindAxis(&quot;MoveForward&quot;, this, &amp;ACollidingPawn::MoveForward);</code></p><p>参数一：为 虚幻4-&gt;设置 -&gt;输入-&gt;按键绑定的名称 一定要一样 重要！！！<br>参数二 ：当前对象——this<br>参数三 事件方法的函数指针 例 &amp;类名::方法名 的写法</p><h1 id="CollidingPawnMovementComponent-h"><a href="#CollidingPawnMovementComponent-h" class="headerlink" title="CollidingPawnMovementComponent.h"></a>CollidingPawnMovementComponent.h</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CoreMinimal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GameFramework/PawnMovementComponent.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CollidingPawnMovementComponent.generated.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HOWTO_COMPONENTS_API</span> UCollidingPawnMovementComponent : <span class="keyword">public</span> UPawnMovementComponent</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">//TickComponent函数类似于Tick，意思是逐帧刷新</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">TickComponent</span><span class="params">(<span class="type">float</span> DeltaTime, <span class="keyword">enum</span> ELevelTick TickType, FActorComponentTickFunction *ThisTickFunction)</span> <span class="keyword">override</span></span>;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="CollidingPawnMovementComponent-cpp"><a href="#CollidingPawnMovementComponent-cpp" class="headerlink" title="CollidingPawnMovementComponent.cpp"></a>CollidingPawnMovementComponent.cpp</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CollidingPawnMovementComponent.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UCollidingPawnMovementComponent::TickComponent</span><span class="params">(<span class="type">float</span> DeltaTime, <span class="keyword">enum</span> ELevelTick TickType, FActorComponentTickFunction *ThisTickFunction)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">TickComponent</span>(DeltaTime, TickType, ThisTickFunction);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确保所有事物持续有效，以便进行移动。</span></span><br><span class="line">    <span class="keyword">if</span> (!PawnOwner || !UpdatedComponent || <span class="built_in">ShouldSkipUpdate</span>(DeltaTime))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取（然后清除）ACollidingPawn::Tick中设置的移动向量</span></span><br><span class="line">    <span class="comment">// 设定一个变量来存储移动输入的变量值（ConsumeInputVector()），然后通过运行时间来设置运动速度</span></span><br><span class="line">    FVector DesiredMovementThisFrame = <span class="built_in">ConsumeInputVector</span>().<span class="built_in">GetClampedToMaxSize</span>(<span class="number">1.0f</span>) * DeltaTime * <span class="number">150.0f</span>;</span><br><span class="line">    <span class="keyword">if</span> (!DesiredMovementThisFrame.<span class="built_in">IsNearlyZero</span>())</span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="comment">//Hit变量来记录碰撞结果</span></span><br><span class="line">        FHitResult Hit;</span><br><span class="line">        <span class="comment">//用虚幻引擎物理移动pawn移动组件，同时会考虑到固体障碍物</span></span><br><span class="line">        <span class="built_in">SafeMoveUpdatedComponent</span>(DesiredMovementThisFrame, UpdatedComponent-&gt;<span class="built_in">GetComponentRotation</span>(), <span class="literal">true</span>, Hit);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若发生碰撞，尝试滑过去</span></span><br><span class="line">        <span class="keyword">if</span> (Hit.<span class="built_in">IsValidBlockingHit</span>())</span><br><span class="line">        &#123;    </span><br><span class="line">            <span class="comment">//移动导致碰撞时， SlideAlongSurface 会处理沿墙壁和斜坡等碰撞表面平滑滑动所涉及的计算和物理，而非直接停留原地，粘在墙壁或斜坡上。</span></span><br><span class="line">            <span class="built_in">SlideAlongSurface</span>(DesiredMovementThisFrame, <span class="number">1.f</span> - Hit.Time, Hit.Normal, Hit);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="GetClampedToMaxSize"><a href="#GetClampedToMaxSize" class="headerlink" title="GetClampedToMaxSize()"></a>GetClampedToMaxSize()</h2><p>用于更新vector的位置</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FVector <span class="title">FVector::GetClampedToMaxSize</span><span class="params">(<span class="type">float</span> MaxSize)</span></span></span><br></pre></td></tr></table></figure><p>用于创建一个新的vector，方向与原本的方向一直，距离为MaxSize</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FVector <span class="title">FVector::GetClampedToSize</span><span class="params">(<span class="type">float</span> Min,<span class="type">float</span> Max)</span> </span></span><br></pre></td></tr></table></figure><p>创建一个新的Vector，方向与原方向一致</p><p>距离为</p><ol><li><p>若距离&lt;Min，则新的vector距离为Min</p></li><li><p>若距离&gt;Max，则新的vector距离为Max</p></li><li><p>若距离在Min和Max之间，则新的vector等于原本的vector</p></li></ol><h2 id="ConsumeInputVector-1-0f"><a href="#ConsumeInputVector-1-0f" class="headerlink" title="ConsumeInputVector(1.0f)"></a>ConsumeInputVector(1.0f)</h2><p>报告并清空用于存储移动输入的内置变量值。</p><h2 id="SafeMoveUpdatedComponent"><a href="#SafeMoveUpdatedComponent" class="headerlink" title="SafeMoveUpdatedComponent()"></a>SafeMoveUpdatedComponent()</h2><p><code>SafeMoveUpdatedComponent(const FVector&amp; Delta, const FRotator&amp; NewRotation, bool bSweep, FHitResult&amp; OutHit, ETeleportType Teleport)</code></p><p><code>SafeMoveUpdatedComponent(DesiredMovementThisFrame, UpdatedComponent-&gt;GetComponentRotation(), true, Hit);</code></p><p>利用虚幻引擎物理移动Pawn移动组件，同时考虑固体障碍。</p><ul><li><p>第一个参数：要移动的Vector</p></li><li><p>第二个参数：旋转参数</p></li><li><p>第三个参数：是否考虑物理障碍（如果为true，将在移动过程中扫描以阻止碰撞。如果为false，它将简单地传送到下一个位置并忽略碰撞。）</p></li><li><p>第四个参数：碰撞结果</p></li><li><p>第五个参数：可省略，远距离传送类型</p></li></ul><h2 id="SlideAlongSurface"><a href="#SlideAlongSurface" class="headerlink" title="SlideAlongSurface()"></a>SlideAlongSurface()</h2><p><code>SlideAlongSurface(const FVector&amp; Delta, float Time, const FQuat Rotation, const FVector&amp; Normal, FHitResult&amp; Hit, bool bHandleImpact)</code></p><ul><li><p>第一个参数：要移动的vector</p></li><li><p>第二个参数：运动时间</p></li><li><p>第三个参数：旋转情况（可省略）</p></li><li><p>第四个参数：vector类型？（这个不太确定）</p></li><li><p>第五个参数：碰撞结果（必须为bBlockingHit）</p></li><li><p>第六个参数：手柄反馈？（这个扎找不到源文件）</p></li></ul><h1 id="配置项目输入设置"><a href="#配置项目输入设置" class="headerlink" title="配置项目输入设置"></a>配置项目输入设置</h1><p>这里要注意的一点是，在给动作映射和轴映射命名的时候一定要和代码中定义的函数名相同否则无效。</p><ol><li><p>回到 <strong>虚幻编辑器</strong>，开始配置项目输入设置。可在 <strong>编辑</strong> 下拉菜单中的 <strong>项目设置</strong> 下找到相关设置。</p><p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/Components/EditProjectSettings.jpg" alt="EditProjectSettings.png"></p><p>进入该菜单后，可在左侧面板中的 <strong>引擎</strong> 部分中选择 <strong>输入</strong>。同时需要设置粒子系统切换的 <strong>操作映射</strong> 、移动 <strong>Pawn</strong> 的两个 <strong>轴映射</strong>，和转动 <strong>Pawn</strong> 的一个 <strong>轴映射</strong>。</p><table><thead><tr><th>操作映射</th><th></th></tr></thead><tbody><tr><td>ParticleToggle</td><td>空格</td></tr></tbody></table><table><thead><tr><th>轴映射</th><th></th><th></th></tr></thead><tbody><tr><td>MoveForward</td><td>W</td><td>1.0</td></tr><tr><td></td><td>S</td><td>-1.0</td></tr><tr><td>MoveRight</td><td>A</td><td>-1.0</td></tr><tr><td></td><td>D</td><td>1.0</td></tr><tr><td>Turn</td><td>Mouse X</td><td>1.0</td></tr></tbody></table><p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/Components/InputSettings.jpg" alt="InputSettings.png"></p></li></ol><p>将创建 <strong>移动组件</strong> 管理移动，而非直接在Pawn类中处理所有移动。本教程中将扩展 <strong>Pawn移动组件</strong> 类。首先在 <strong>文件</strong> 下拉菜单中选择 <strong>将代码添加到项目（Add Code to Project）</strong> 命令。</p><p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/Components/AddCPPCode.jpg" alt="AddCPPCode.png"></p><p>与Pawn类不同的，Pawn移动组件类默认为不可见。要找到该组件，需选中 <strong>显示所有类（Show All Classes）</strong> 选项。</p><p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/Components/ShowAllClasses.jpg" alt="ShowAllClasses.png"></p><p>在搜索栏中输入”movement”，以便快速缩小列表范围。</p><p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/Components/ChooseParentClass2.jpg" alt="ChooseParentClass2.png"></p><p>Pawn移动组件拥有部分强大内置功能，以便使用常见物理功能，同时便于在大量Pawn类型间共享移动代码。使用组件分隔不同功能是上佳方法，可在项目增大、Pawn越加复杂时减少杂乱。</p><p>这里放一个来自于的<a href="https://blog.csdn.net/heneyT" title="heneyT">heneyT</a>移动组件的继承树</p><p><img src="https://img-blog.csdn.net/20171130205337919?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjk5OTk4NQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> unreal engine </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UE4-CameraDirector</title>
      <link href="/2022/04/22/UE4-CameraDirector/"/>
      <url>/2022/04/22/UE4-CameraDirector/</url>
      
        <content type="html"><![CDATA[<h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1><p>分析官方案例<a href="https://docs.unrealengine.com/4.27/zh-CN/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/AutoCamera/">CameraDirector</a></p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><ol><li><p>放两个摄像机</p><ul><li><p>所有类中直接拖入</p></li><li><p>先创建一个立方体，然后给他添加一个摄像机组件</p></li></ul></li><li><p>以Actor为父类创建C++类</p></li></ol><h2 id="CameraDirector-h"><a href="#CameraDirector-h" class="headerlink" title="CameraDirector.h"></a>CameraDirector.h</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line">AActor* CameraOne;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line">AActor* CameraTwo;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> TimeToNextCameraChange;</span><br></pre></td></tr></table></figure><h2 id="CameraDirector-cpp"><a href="#CameraDirector-cpp" class="headerlink" title="CameraDirector.cpp"></a>CameraDirector.cpp</h2><p>添加到引用位置</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Kismet/GameplayStatics.h&quot;</span></span></span><br></pre></td></tr></table></figure><p>添加到<strong>ACameraDirector::Tick</strong> 的底部位置</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">float</span> TimeBetweenCameraChanges = <span class="number">2.0f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">float</span> SmoothBlendTime = <span class="number">0.75f</span>;</span><br><span class="line">TimeToNextCameraChange -= DeltaTime;</span><br><span class="line"><span class="keyword">if</span> (TimeToNextCameraChange &lt;= <span class="number">0.0f</span>)</span><br><span class="line">&#123;</span><br><span class="line">    TimeToNextCameraChange += TimeBetweenCameraChanges;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找处理本地玩家控制的actor。</span></span><br><span class="line">    APlayerController* OurPlayerController = UGameplayStatics::<span class="built_in">GetPlayerController</span>(<span class="keyword">this</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (OurPlayerController)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((OurPlayerController-&gt;<span class="built_in">GetViewTarget</span>() != CameraOne) &amp;&amp; (CameraOne != <span class="literal">nullptr</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 立即切换到摄像机1。</span></span><br><span class="line">            OurPlayerController-&gt;<span class="built_in">SetViewTarget</span>(CameraOne);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((OurPlayerController-&gt;<span class="built_in">GetViewTarget</span>() != CameraTwo) &amp;&amp; (CameraTwo != <span class="literal">nullptr</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 平滑地混合到摄像机2。</span></span><br><span class="line">            OurPlayerController-&gt;<span class="built_in">SetViewTargetWithBlend</span>(CameraTwo, SmoothBlendTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="添加C-类"><a href="#添加C-类" class="headerlink" title="添加C++类"></a>添加C++类</h2><p>在代码编译完成后，我们可以将 <strong>内容浏览器（Content Browser）</strong> 中的新类的实例拖曳到 <strong>关卡编辑器（Level Editor）</strong> 中。</p><p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/AutoCamera/CameraDirectorInContentBrowser.jpg" alt="CameraDirectorInContentBrowser.png"></p><p>接下来，我们需要设置摄像机1（CameraOne）和摄像机2（CameraTwo）变量。在 <strong>World Outliner （世界大纲视图）</strong> 中找到CameraDirector，并在 <strong>详细信息面板（Details Panel）</strong> 中进行编辑。</p><p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/AutoCamera/CameraDirectorDetails.jpg" alt="CameraDirectorDetails.png"></p><p>单击标记为”无（None）”的下拉框，然后将变量设置为 <strong>Cube（立方体）</strong> 和我们之前创建的 <strong>摄像机Actor （CameraActor）</strong>。</p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>ok以上是来自官网的教程，现在我来把它掰开来理解</p><h2 id="CameraDirector-h-1"><a href="#CameraDirector-h-1" class="headerlink" title="CameraDirector.h"></a>CameraDirector.h</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GameFramework/Actor.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CameraDirector.generated.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HOWTO_AUTOCAMERA_API</span> ACameraDirector : <span class="keyword">public</span> AActor</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="comment">// 为此Actor的属性设置默认值</span></span><br><span class="line">    <span class="built_in">ACameraDirector</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// 当游戏开始或生成时调用</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BeginPlay</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 每一帧调用</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Tick</span><span class="params">( <span class="type">float</span> DeltaSeconds )</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line">    AActor* CameraOne;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line">    AActor* CameraTwo;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> TimeToNextCameraChange;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这一段代码，其实没啥需要讲解的，在我的前两篇博客中已经讲得很明白了。</p><p>在此就不多做赘述。</p><h2 id="CameraDirector-cpp-1"><a href="#CameraDirector-cpp-1" class="headerlink" title="CameraDirector.cpp"></a>CameraDirector.cpp</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;HowTo_AutoCamera.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CameraDirector.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Kismet/GameplayStatics.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置默认值</span></span><br><span class="line">ACameraDirector::<span class="built_in">ACameraDirector</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 将此Actor设置为每一帧调用Tick()。如果不需要，可以关闭此选项来提高性能。</span></span><br><span class="line">    PrimaryActorTick.bCanEverTick = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当游戏开始或生成时调用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ACameraDirector::BeginPlay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">BeginPlay</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每一帧调用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ACameraDirector::Tick</span><span class="params">( <span class="type">float</span> DeltaTime )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">Tick</span>( DeltaTime );</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">float</span> TimeBetweenCameraChanges = <span class="number">2.0f</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">float</span> SmoothBlendTime = <span class="number">0.75f</span>;</span><br><span class="line">    TimeToNextCameraChange -= DeltaTime;</span><br><span class="line">    <span class="keyword">if</span> (TimeToNextCameraChange &lt;= <span class="number">0.0f</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        TimeToNextCameraChange += TimeBetweenCameraChanges;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//查找处理本地玩家控制的Actor。</span></span><br><span class="line">        APlayerController* OurPlayerController = UGameplayStatics::<span class="built_in">GetPlayerController</span>(<span class="keyword">this</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (OurPlayerController)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (CameraTwo &amp;&amp; (OurPlayerController-&gt;<span class="built_in">GetViewTarget</span>() == CameraOne))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//平滑地混合到摄像机2。</span></span><br><span class="line">                OurPlayerController-&gt;<span class="built_in">SetViewTargetWithBlend</span>(CameraTwo, SmoothBlendTime);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (CameraOne)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//立即切换到摄像机1。</span></span><br><span class="line">                OurPlayerController-&gt;<span class="built_in">SetViewTarget</span>(CameraOne);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们首先解决这些代码中API的问题</p><h3 id="GetPlayerController-this-0"><a href="#GetPlayerController-this-0" class="headerlink" title="GetPlayerController(this,0)"></a>GetPlayerController(this,0)</h3><p>这一段可以通过查看其定义明白其含义——获取玩家控制器</p><p>this指当前玩家控制器，0是玩家控制器的标号，代表了本地玩家控制器</p><p>在定义代码中，GetPlayerController返回的返回值是APlayerController，所以在前面定义一个该类型的指针OurPlayerController</p><h3 id="GetViewTarget"><a href="#GetViewTarget" class="headerlink" title="GetViewTarget()"></a>GetViewTarget()</h3><p>获取玩家身上的摄像机Actor</p><h3 id="SetViewTargetWithBlend-CameraTwo-SmoothBlendTime"><a href="#SetViewTargetWithBlend-CameraTwo-SmoothBlendTime" class="headerlink" title="SetViewTargetWithBlend(CameraTwo,SmoothBlendTime);"></a>SetViewTargetWithBlend(CameraTwo,SmoothBlendTime);</h3><p>使摄像机平滑切换到摄像机二，前一个变量使设定切换到哪个摄像机，后一个使设定切换时间</p><p>理解了API的意思之后，代码逻辑我就不再讲解了，代码中的变量和常量完全可以见文知意，结构使非常基础的if判断，如果看不懂的话还是需要先好好学习数据结构与算法。</p>]]></content>
      
      
      <categories>
          
          <category> unreal engine </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UE4-FloatingActor</title>
      <link href="/2022/04/20/UE4-FloatingActor/"/>
      <url>/2022/04/20/UE4-FloatingActor/</url>
      
        <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>根据虚幻引擎<a href="https://docs.unrealengine.com/4.27/zh-CN/ProgrammingAndScripting/ProgrammingWithCPP/CPPProgrammingQuickStart/">官方文档</a>的编程快速入门章节所创建的第一个项目——FloatingActor</p><p>当然，官方文档中给出了详细的源码，可是他是授人以鱼，并没有授人以渔。</p><p>现在我就想着把这个渔给掰开揉碎了，方便自己理解，也供大家学习分享。</p><h1 id="创建FloatingActor"><a href="#创建FloatingActor" class="headerlink" title="创建FloatingActor"></a>创建FloatingActor</h1><p>此处不再赘述，如果像了解生成的默认代码含义，可以参考我的上一篇博客</p><h1 id="实现FloatingActor效果"><a href="#实现FloatingActor效果" class="headerlink" title="实现FloatingActor效果"></a>实现FloatingActor效果</h1><p>按照官方文档的操作，我们可以得到如下两端代码</p><h2 id="FloatingActor-h"><a href="#FloatingActor-h" class="headerlink" title="FloatingActor.h"></a>FloatingActor.h</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CoreMinimal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GameFramework/Actor.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;FloatingActor.generated.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">QUICKSTART_API</span> AFloatingActor : <span class="keyword">public</span> AActor</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="comment">// Sets default values for this actor&#x27;s properties</span></span><br><span class="line">    <span class="built_in">AFloatingActor</span>();<span class="comment">//声明FloatingActor</span></span><br><span class="line">        <span class="built_in">UPROPERTY</span>(VisibleAnywhere)<span class="comment">//这段代码的作用是让FloatActor可以在编辑器中被编辑细节面板</span></span><br><span class="line">        UStaticMeshComponent* VisualMesh;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// Called when the game starts or when spawned</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BeginPlay</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="comment">// Called every frame</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Tick</span><span class="params">(<span class="type">float</span> DeltaTime)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="AFloatingActor"><a href="#AFloatingActor" class="headerlink" title="AFloatingActor()"></a>AFloatingActor()</h3><p>声明FloatingActor</p><h3 id="UPROPERTY-VisibleAnywhere"><a href="#UPROPERTY-VisibleAnywhere" class="headerlink" title="UPROPERTY(VisibleAnywhere)"></a>UPROPERTY(VisibleAnywhere)</h3><p>让FloatingActor可以在虚幻编辑器被看见，如果去掉这个，那FloatingActor在虚幻引擎中就不能被看到了！（此时编辑框是灰色的，意味着<strong>只读，不可写</strong>）</p><h3 id="UStaticMeshComponent-VisualMesh"><a href="#UStaticMeshComponent-VisualMesh" class="headerlink" title="UStaticMeshComponent* VisualMesh;"></a>UStaticMeshComponent* VisualMesh;</h3><ul><li><p>staticmesh的意思是静态网格体</p></li><li><p>Component的意思是组件</p></li><li><p>整段代码合起来的意思是声明了一个类型为UStaticMeshComponent的名为VisualMesh的指针</p></li></ul><h2 id="FloatingActor-cpp"><a href="#FloatingActor-cpp" class="headerlink" title="FloatingActor.cpp"></a>FloatingActor.cpp</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;FloatingActor.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Sets default values</span></span><br><span class="line">AFloatingActor::<span class="built_in">AFloatingActor</span>()</span><br><span class="line">&#123;</span><br><span class="line">     <span class="comment">// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don&#x27;t need it.</span></span><br><span class="line">    PrimaryActorTick.bCanEverTick = <span class="literal">true</span>;</span><br><span class="line">    VisualMesh = <span class="built_in">CreateDefaultSubobject</span>&lt;UStaticMeshComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;Mesh&quot;</span>));</span><br><span class="line">    VisualMesh-&gt;<span class="built_in">SetupAttachment</span>(RootComponent);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> ConstructorHelpers::FObjectFinder&lt;UStaticMesh&gt; <span class="title">CubeVisualAsset</span><span class="params">(TEXT(<span class="string">&quot;/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube&quot;</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (CubeVisualAsset.<span class="built_in">Succeeded</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        VisualMesh-&gt;<span class="built_in">SetStaticMesh</span>(CubeVisualAsset.Object);</span><br><span class="line">        VisualMesh-&gt;<span class="built_in">SetRelativeLocation</span>(<span class="built_in">FVector</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Called when the game starts or when spawned</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFloatingActor::BeginPlay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">BeginPlay</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Called every frame</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFloatingActor::Tick</span><span class="params">(<span class="type">float</span> DeltaTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">Tick</span>(DeltaTime);</span><br><span class="line">    FVector NewLocation = <span class="built_in">GetActorLocation</span>();</span><br><span class="line">    FRotator NewRotation = <span class="built_in">GetActorRotation</span>();</span><br><span class="line">    <span class="type">float</span> RunningTime = <span class="built_in">GetGameTimeSinceCreation</span>();</span><br><span class="line">    <span class="type">float</span> DeltaHeight = (FMath::<span class="built_in">Sin</span>(RunningTime + DeltaTime) - FMath::<span class="built_in">Sin</span>(RunningTime));</span><br><span class="line">    NewLocation.Z += DeltaHeight * <span class="number">20.0f</span>;       <span class="comment">//Scale our height by a factor of 20</span></span><br><span class="line">    <span class="type">float</span> DeltaRotation = DeltaTime * <span class="number">20.0f</span>;    <span class="comment">//Rotate by 20 degrees per second</span></span><br><span class="line">    NewRotation.Yaw += DeltaRotation;</span><br><span class="line">    <span class="built_in">SetActorLocationAndRotation</span>(NewLocation, NewRotation);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="VisualMesh-x3D-CreateDefaultSubobject-TEXT-“Mesh”"><a href="#VisualMesh-x3D-CreateDefaultSubobject-TEXT-“Mesh”" class="headerlink" title="VisualMesh &#x3D; CreateDefaultSubobject(TEXT(“Mesh”));"></a>VisualMesh &#x3D; CreateDefaultSubobject<UStaticMeshComponent>(TEXT(“Mesh”));</h2><p>在.h文件中我们声明了VisualMesh，现在我们来给其赋值</p><p>CreateDefaultSubobject（是一个模板类）代表着创建一个组件，&lt;&gt;里面就是它创建组件的类型</p><p>因为VisualMesh的类型本身就是UStaticMeshComponent，所以就创建相同类型的组件，然后赋值给VisualMesh</p><h2 id="VisualMesh-gt-SetupAttachment-RootComponent"><a href="#VisualMesh-gt-SetupAttachment-RootComponent" class="headerlink" title="VisualMesh-&gt;SetupAttachment(RootComponent);"></a>VisualMesh-&gt;SetupAttachment(RootComponent);</h2><p>VisualMesh调用SetupAttachment()函数，将它本身附加到根组件下面</p><p><img src="D:\R_programme\Blog\source\images\Rootcomonent.png" alt="Rootcomonent.png"></p><h2 id="初始化组件"><a href="#初始化组件" class="headerlink" title="初始化组件"></a>初始化组件</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> ConstructorHelpers::FObjectFinder&lt;UStaticMesh&gt; <span class="title">CubeVisualAsset</span><span class="params">(TEXT(<span class="string">&quot;/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube&quot;</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (CubeVisualAsset.<span class="built_in">Succeeded</span>())</span><br><span class="line">&#123;</span><br><span class="line">    VisualMesh-&gt;<span class="built_in">SetStaticMesh</span>(CubeVisualAsset.Object);</span><br><span class="line">    VisualMesh-&gt;<span class="built_in">SetRelativeLocation</span>(<span class="built_in">FVector</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>static ConstructorHelpers::FObjectFinder&lt;UStaticMesh&gt; CubeVisualAsset(TEXT(&quot;/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube&quot;));</code></p><p>这么长一段，仔细看一下后面的<code>/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube</code>很容易就能理解，这是在现有资产中寻找网格体。</p><p>下面的if语句，就是在找到的情况下，进行位置的初始化</p><p>从整体上理解，其实这段代码就是在构造函数中初始化FloatingActor的</p><p>这一段不是必须的，我们可以不要它，在创建好这个组件之后，再把它添加到其他的Actor上</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFloatingActor::Tick</span><span class="params">(<span class="type">float</span> DeltaTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">Tick</span>(DeltaTime);</span><br><span class="line">    FVector NewLocation = <span class="built_in">GetActorLocation</span>();</span><br><span class="line">    FRotator NewRotation = <span class="built_in">GetActorRotation</span>();</span><br><span class="line">    <span class="type">float</span> RunningTime = <span class="built_in">GetGameTimeSinceCreation</span>();</span><br><span class="line">    <span class="type">float</span> DeltaHeight = (FMath::<span class="built_in">Sin</span>(RunningTime + DeltaTime) - FMath::<span class="built_in">Sin</span>(RunningTime));</span><br><span class="line">    NewLocation.Z += DeltaHeight * <span class="number">20.0f</span>;       <span class="comment">//Scale our height by a factor of 20</span></span><br><span class="line">    <span class="type">float</span> DeltaRotation = DeltaTime * <span class="number">20.0f</span>;    <span class="comment">//Rotate by 20 degrees per second</span></span><br><span class="line">    NewRotation.Yaw += DeltaRotation;</span><br><span class="line">    <span class="built_in">SetActorLocationAndRotation</span>(NewLocation, NewRotation);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="FVector-NewLocation-x3D-GetActorLocation"><a href="#FVector-NewLocation-x3D-GetActorLocation" class="headerlink" title="FVector NewLocation&#x3D;GetActorLocation();"></a>FVector NewLocation&#x3D;GetActorLocation();</h3><p>我通过查看了FVetoc的声明和定义代码，大概能得出他的意思——<strong>以X,Y,Z轴来设定一个物体的新的三维坐标位置的结构体</strong></p><p>那剩下的这一行的意思也可以轻易得出：</p><p>声明一个FVector类型的变量NewLocation，初始化为GetActorLocation()</p><h3 id="FRotator-NewRotation-x3D-GetActorLocation"><a href="#FRotator-NewRotation-x3D-GetActorLocation" class="headerlink" title="FRotator NewRotation&#x3D;GetActorLocation();"></a>FRotator NewRotation&#x3D;GetActorLocation();</h3><p>同样的通过查看FRotator的声明和定义代码，也得出他的意思——<strong>以Pitch，Yaw，Roll轴来设定一个物体围绕某个轴来进行旋转的结构体</strong></p><p>注意：</p><ul><li><p>Pitch是Y轴</p></li><li><p>Yaw是Z轴</p></li><li><p>Roll是X轴</p></li></ul><p>同理，此行代码意思类似于上一行，此处便不多做赘述</p><h3 id="float-RunningTime-x3D-GetGameTimeSinceCreation"><a href="#float-RunningTime-x3D-GetGameTimeSinceCreation" class="headerlink" title="float RunningTime&#x3D;GetGameTimeSinceCreation();"></a>float RunningTime&#x3D;GetGameTimeSinceCreation();</h3><p>这一行就很好理解，就是这个函数的字面意思</p><p>设定一个名为RunningTime的变量，使其为游戏开始到现在的时间</p><h3 id="float-DeltaHeight-x3D-FMath-Sin-RunningTime-DeltaTime-FMath-Sin-RunningTime"><a href="#float-DeltaHeight-x3D-FMath-Sin-RunningTime-DeltaTime-FMath-Sin-RunningTime" class="headerlink" title="float DeltaHeight &#x3D; (FMath::Sin(RunningTime + DeltaTime) - FMath::Sin(RunningTime));"></a>float DeltaHeight &#x3D; (FMath::Sin(RunningTime + DeltaTime) - FMath::Sin(RunningTime));</h3><p>这一行就比较妙了，首先声明了一个名为DeltaHeight的变量</p><p>FMath是数学命名空间的意思</p><p>sin是正弦函数</p><p>这个数学式子可以保证DeltaHeight在1与-1之间变换</p><h3 id="NewLocation-Z-x3D-DeltaHeight-20-0f"><a href="#NewLocation-Z-x3D-DeltaHeight-20-0f" class="headerlink" title="NewLocation.Z +&#x3D; DeltaHeight * 20.0f;"></a>NewLocation.Z +&#x3D; DeltaHeight * 20.0f;</h3><p>上面已经初始化过NewLocation，现在通过这个数学式子，使其实时更新</p><h3 id="float-DeltaRotation-x3D-DeltaTime-20-0f"><a href="#float-DeltaRotation-x3D-DeltaTime-20-0f" class="headerlink" title="float DeltaRotation &#x3D; DeltaTime * 20.0f;"></a>float DeltaRotation &#x3D; DeltaTime * 20.0f;</h3><p>定义一个变量DeltaRotation（旋转角度），使其每秒旋转20.0个单位</p><h3 id="NewRotation-Yaw-x3D-DeltaRotation"><a href="#NewRotation-Yaw-x3D-DeltaRotation" class="headerlink" title="NewRotation.Yaw +&#x3D; DeltaRotation;"></a>NewRotation.Yaw +&#x3D; DeltaRotation;</h3><p>实时更新旋转状态</p><h3 id="SetActorLocationAndRotation-NewLocation-NewRotation"><a href="#SetActorLocationAndRotation-NewLocation-NewRotation" class="headerlink" title="SetActorLocationAndRotation(NewLocation, NewRotation);"></a>SetActorLocationAndRotation(NewLocation, NewRotation);</h3><p>这就很容易理解——设置actor的位置和角度</p><h1 id="提高可适配性"><a href="#提高可适配性" class="headerlink" title="提高可适配性"></a>提高可适配性</h1><p>FloatingActor.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadWrite, Category=<span class="string">&quot;FloatingActor&quot;</span>)</span><br><span class="line">    <span class="type">float</span> FloatSpeed = <span class="number">20.0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadWrite, Category=<span class="string">&quot;FloatingActor&quot;</span>)</span><br><span class="line">    <span class="type">float</span> RotationSpeed = <span class="number">20.0f</span>;</span><br></pre></td></tr></table></figure><p>FloatingActor.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NewLocation.Z += DeltaHeight * FloatSpeed;          <span class="comment">//按FloatSpeed调整高度</span></span><br><span class="line"><span class="type">float</span> DeltaRotation = DeltaTime * RotationSpeed;    <span class="comment">//每秒旋转等于RotationSpeed的角度</span></span><br></pre></td></tr></table></figure><p>通过在标头文件中添加这些变量，并替换在.cpp中用于缩放DeltaHeight和DeltaRotation的浮点值，可在选择Actor时在 <strong>细节（Details）</strong> 面板中编辑浮动和旋转速度。</p><p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPProgrammingQuickStart/PRQuickStart_6-1.jpg" alt="PRQuickStart_6-1.png"></p><p>以上内容是官方文档的原文，现在我来尝试理解其中的意思</p><p>前面我们已经讲过UPROPERTY()可以使得该组件能够在虚幻编辑器中被编辑，我们现在在括号内加上其他的字符串</p><h2 id="EditAnywhere"><a href="#EditAnywhere" class="headerlink" title="EditAnywhere"></a>EditAnywhere</h2><p>见文知意，能在任何地方被编辑，在蓝图中<strong>可读且可写入</strong>。</p><h2 id="BlueprintReadWrite"><a href="#BlueprintReadWrite" class="headerlink" title="BlueprintReadWrite"></a>BlueprintReadWrite</h2><p>BlueprintReadOnly和BlueprintReadWrite是一组。明明是C++的class，和BP(Bluprint)有什么关系呢？<br>这里指的是，用BP方式创建子类，以C++代码编写父类。创建一个BPclass，从目前编写的C++ class继承，然后在子类的BP Editor里，就可以获取这个值，<strong>如果不写BlueprintReadOnly或者BlueprintReadWrite，是不能在蓝图里看到这个变量的。</strong></p><p>首先创建一个叫MyActor的C++类，然后创建一个叫做BPMyActor的class，以MyActor为父类。<br><img src="https://img-blog.csdnimg.cn/2020070600443981.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80OTE4MjY3Mw==,size_16,color_FFFFFF,t_70"></p><p>父类中定义一个变量，被BlueprintReadOnly修饰</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UPROPERTY</span>(BlueprintReadOnly, Category = <span class="string">&quot;Damage&quot;</span>)</span><br><span class="line">int32 TotalDamage</span><br></pre></td></tr></table></figure><p>那么在子类的蓝图编辑器主界面，点右键然后搜索，就会出现Get操作。</p><p><img src="https://img-blog.csdnimg.cn/20200706005200494.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80OTE4MjY3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>而如果用BlueprintReadWrite修饰变量，则既会出现Get，又会出现Set操作。</p><p><img src="https://img-blog.csdnimg.cn/20200706005309445.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80OTE4MjY3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>如果不提供任何一个，则父类中定义的这个变量，完全无法在BP继承出来的子类中访问到。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UPROPERTY</span>()</span><br><span class="line">int32 TotalDamage;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200706005500919.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80OTE4MjY3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>以上是CSDN博主「不知名图形学者」的<a href="https://blog.csdn.net/weixin_49182673/article/details/107148609">原创文章</a>中的解释</p><p>用我自己的话来说就是：用C++创建父类，蓝图方式创建它的子类。BlueprintReadWrite和BuleprintReadOnly能分别让他们可以在蓝图编辑器中可读写以及仅仅可读</p><h2 id="float-FloatSpeed-x3D-20-0f"><a href="#float-FloatSpeed-x3D-20-0f" class="headerlink" title="float FloatSpeed&#x3D;20.0f"></a>float FloatSpeed&#x3D;20.0f</h2><p>初始化浮动速度为20.0f</p><h2 id="float-FloatSpeed-x3D-20-0f-1"><a href="#float-FloatSpeed-x3D-20-0f-1" class="headerlink" title="float FloatSpeed&#x3D;20.0f"></a>float FloatSpeed&#x3D;20.0f</h2><p>初始化旋转速度为20.0f</p>]]></content>
      
      
      <categories>
          
          <category> unreal engine </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有关算法中的动态规划（一）</title>
      <link href="/2022/04/20/%E6%9C%89%E5%85%B3%E7%AE%97%E6%B3%95%E4%B8%AD%E7%9A%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2022/04/20/%E6%9C%89%E5%85%B3%E7%AE%97%E6%B3%95%E4%B8%AD%E7%9A%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是动态规划"><a href="#什么是动态规划" class="headerlink" title="什么是动态规划"></a>什么是动态规划</h1><p>如果某问题有很多重叠子问题，使用动态规划是最有效的</p><p>所以动态规划中每一个状态一定是由上一个状态推导出来的，这一点就区分与贪心，贪心没有状态推导。</p><p>例如：有N件物品和一个最多能背重量为W 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。<strong>每件物品只能用一次</strong>，求解将哪些物品装入背包里物品价值总和最大。</p><ul><li><p>动态规划中dp[j]是由dp[j-weight[i]]推导出来的，然后取max(dp[j], dp[j - weight[i]] + value[i])。</p></li><li><p>但如果是贪心呢，每次拿物品选一个最大的或者最小的就完事了，和上一个状态没有关系。</p></li></ul><p>所以贪心解决不了动态规划的问题。</p><p><strong>其实大家也不用死扣动规和贪心的理论区别，后面做做题目自然就知道了</strong>。</p><p>而且很多讲解动态规划的文章都会讲最优子结构啊和重叠子问题啊这些，这些东西都是教科书的上定义，晦涩难懂而且不实用。</p><p>大家知道动规是由前一个状态推导出来的，而贪心是局部直接选最优的，对于刷题来说就够用了。</p><p>上述提到的背包问题，后序会详细讲解。</p><h1 id="动态规划的解题步骤"><a href="#动态规划的解题步骤" class="headerlink" title="动态规划的解题步骤"></a>动态规划的解题步骤</h1><p>做动规题目的时候，很多同学会陷入一个误区，就是以为把状态转移公式背下来，照葫芦画瓢改改，就开始写代码，甚至把题目AC之后，都不太清楚dp[i]表示的是什么。</p><p><strong>这就是一种朦胧的状态，然后就把题给过了，遇到稍稍难一点的，可能直接就不会了，然后看题解，然后继续照葫芦画瓢陷入这种恶性循环中</strong>。</p><ul><li>状态转移公式（递推公式）是很重要，但动规不仅仅只有递推公式。</li></ul><p><strong>对于动态规划问题，我将拆解为如下五步曲，这五步都搞清楚了，才能说把动态规划真的掌握了！</strong></p><ol><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ol><p>一些同学可能想为什么要先确定递推公式，然后在考虑初始化呢？</p><p><strong>因为一些情况是递推公式决定了dp数组要如何初始化！</strong></p><p>后面的讲解中我都是围绕着这五点来进行讲解。</p><p>可能刷过动态规划题目的同学可能都知道递推公式的重要性，感觉确定了递推公式这道题目就解出来了。</p><p>其实 确定递推公式 仅仅是解题里的一步而已！</p><p>一些同学知道递推公式，但搞不清楚dp数组应该如何初始化，或者正确的遍历顺序，以至于记下来公式，但写的程序怎么改都通过不了。</p><p>后序的讲解的大家就会慢慢感受到这五步的重要性了。</p><h1 id="动态规划应该如何debug"><a href="#动态规划应该如何debug" class="headerlink" title="动态规划应该如何debug"></a>动态规划应该如何debug</h1><p>写动规题目，代码出问题很正常！</p><p><strong>找问题的最好方式就是把dp数组打印出来，看看究竟是不是按照自己思路推导的！</strong></p><p><strong>做动规的题目，写代码之前一定要把状态转移在dp数组的上具体情况模拟一遍，心中有数，确定最后推出的是想要的结果</strong>。</p><ul><li><p>然后再写代码，如果代码没通过就打印dp数组，看看是不是和自己预先推导的哪里不一样。</p></li><li><p>如果打印出来和自己预先模拟推导是一样的，那么就是自己的递归公式、初始化或者遍历顺序有问题了。</p></li><li><p>如果和自己预先模拟推导的不一样，那么就是代码实现细节有问题。</p></li></ul><p><strong>这样才是一个完整的思考过程，而不是一旦代码出问题，就毫无头绪的东改改西改改，最后过不了，或者说是稀里糊涂的过了</strong>。</p><p>这也是我为什么在动规五步曲里强调推导dp数组的重要性。</p><ul><li>这道题目我举例推导状态转移公式了么？</li><li>我打印dp数组的日志了么？</li><li>打印出来了dp数组和我想的一样么？</li></ul><p><strong>如果这灵魂三问自己都做到了，基本上这道题目也就解决了</strong>，或者更清晰的知道自己究竟是哪一点不明白，是状态转移不明白，还是实现代码不知道该怎么写，还是不理解遍历dp数组的顺序。</p><h1 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h1><h2 id="斐波那契数"><a href="#斐波那契数" class="headerlink" title="斐波那契数"></a><a href="https://leetcode-cn.com/problems/fibonacci-number/">斐波那契数</a></h2><p>斐波那契数，通常用 F(n) 表示，形成的序列称为斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是： F(0) &#x3D; 0，F(1) &#x3D; 1，F(n) &#x3D; F(n - 1) + F(n - 2)，其中 n &gt; 1 给你n ，请计算 F(n) 。</p><p>示例 1：</p><ul><li>输入：2</li><li>输出：1</li><li>解释：F(2) &#x3D; F(1) + F(0) &#x3D; 1 + 0 &#x3D; 1</li></ul><p>示例 2：</p><ul><li>输入：3</li><li>输出：2</li><li>解释：F(3) &#x3D; F(2) + F(1) &#x3D; 1 + 1 &#x3D; 2</li></ul><p>示例 3：</p><ul><li>输入：4</li><li>输出：3</li><li>解释：F(4) &#x3D; F(3) + F(2) &#x3D; 2 + 1 &#x3D; 3</li></ul><p>提示：</p><ul><li>0 &lt;&#x3D; n &lt;&#x3D; 30</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>动态规划五部曲：</p><p>这里我们要用一个一维dp数组来保存递归的结果</p><ol><li>确定dp数组以及下标的含义</li></ol><p>dp[i]的定义为：第i个数的斐波那契数值是dp[i]</p><ol start="2"><li>确定递推公式</li></ol><p>为什么这是一道非常简单的入门题目呢？</p><p><strong>因为题目已经把递推公式直接给我们了：状态转移方程 dp[i] &#x3D; dp[i - 1] + dp[i - 2];</strong></p><ol start="3"><li>dp数组如何初始化</li></ol><p><strong>题目中把如何初始化也直接给我们了，如下：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br></pre></td></tr></table></figure><ol start="4"><li>确定遍历顺序</li></ol><p>从递归公式dp[i] &#x3D; dp[i - 1] + dp[i - 2];中可以看出，dp[i]是依赖 dp[i - 1] 和 dp[i - 2]，那么遍历的顺序一定是从前到后遍历的</p><ol start="5"><li>举例推导dp数组</li></ol><p>按照这个递推公式dp[i] &#x3D; dp[i - 1] + dp[i - 2]，我们来推导一下，当N为10的时候，dp数组应该是如下的数列：</p><p>0 1 1 2 3 5 8 13 21 34 55</p><p>如果代码写出来，发现结果不对，就把dp数组打印出来看看和我们推导的数列是不是一致的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fib</span><span class="params">(<span class="type">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (N &lt;= <span class="number">1</span>) <span class="keyword">return</span> N;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(N + <span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= N; i++) &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[N];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><p>其实我们只需要维护两个数值就可以了，不需要记录整个序列。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fib</span><span class="params">(<span class="type">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (N &lt;= <span class="number">1</span>) <span class="keyword">return</span> N;</span><br><span class="line">        <span class="type">int</span> dp[<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= N; i++) &#123;</span><br><span class="line">            <span class="type">int</span> sum = dp[<span class="number">0</span>] + dp[<span class="number">1</span>];</span><br><span class="line">            dp[<span class="number">0</span>] = dp[<span class="number">1</span>];</span><br><span class="line">            dp[<span class="number">1</span>] = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯"></a><a href="https://leetcode-cn.com/problems/climbing-stairs/">爬楼梯</a></h2><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p>注意：给定 n 是一个正整数。</p><p>示例 1：</p><ul><li>输入： 2</li><li>输出： 2</li><li>解释： 有两种方法可以爬到楼顶。<ul><li>1 阶 + 1 阶</li><li>2 阶</li></ul></li></ul><p>示例 2：</p><ul><li>输入： 3</li><li>输出： 3</li><li>解释： 有三种方法可以爬到楼顶。<ul><li>1 阶 + 1 阶 + 1 阶</li><li>1 阶 + 2 阶</li><li>2 阶 + 1 阶</li></ul></li></ul><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>多举几个例子，就可以发现其规律。</p><p>爬到第一层楼梯有一种方法，爬到二层楼梯有两种方法。</p><p>那么第一层楼梯再跨两步就到第三层 ，第二层楼梯再跨一步就到第三层。</p><p>所以到第三层楼梯的状态可以由第二层楼梯 和 到第一层楼梯状态推导出来，那么就可以想到动态规划了。</p><p>我们来分析一下，动规五部曲：</p><p>定义一个一维数组来记录不同楼层的状态</p><ol><li>确定dp数组以及下标的含义</li></ol><p>dp[i]： 爬到第i层楼梯，有dp[i]种方法</p><ol start="2"><li>确定递推公式</li></ol><p>怎样推导出dp[i]呢？</p><p>从dp[i]的定义可以看出，dp[i] 可以有两个方向推出来。</p><p>首先是dp[i - 1]，上i-1层楼梯，有dp[i - 1]种方法，那么再一步跳一个台阶不就是dp[i]了么。</p><p>还有就是dp[i - 2]，上i-2层楼梯，有dp[i - 2]种方法，那么再一步跳两个台阶不就是dp[i]了么。</p><p>那么dp[i]就是 dp[i - 1]与dp[i - 2]之和！</p><p>所以<strong>dp[i] &#x3D; dp[i - 1] + dp[i - 2]</strong> 。</p><p>在推导dp[i]的时候，一定要时刻想着dp[i]的定义，否则容易跑偏。</p><p>这体现出确定dp数组以及下标的含义的重要性！</p><ol start="3"><li>dp数组如何初始化</li></ol><p>在回顾一下dp[i]的定义：爬到第i层楼梯，有dp[i]中方法。</p><p>那么i为0，dp[i]应该是多少呢，这个可以有很多解释，但都基本是直接奔着答案去解释的。</p><p>例如强行安慰自己爬到第0层，也有一种方法，什么都不做也就是一种方法即：dp[0] &#x3D; 1，相当于直接站在楼顶。</p><p>但总有点牵强的成分。</p><p>那还这么理解呢：我就认为跑到第0层，方法就是0啊，一步只能走一个台阶或者两个台阶，然而楼层是0，直接站楼顶上了，就是不用方法，dp[0]就应该是0.</p><p><strong>其实这么争论下去没有意义，大部分解释说dp[0]应该为1的理由其实是因为dp[0]&#x3D;1的话在递推的过程中i从2开始遍历本题就能过，然后就往结果上靠去解释dp[0] &#x3D; 1</strong>。</p><p>从dp数组定义的角度上来说，dp[0] &#x3D; 0 也能说得通。</p><p>需要注意的是：题目中说了n是一个正整数，题目根本就没说n有为0的情况。</p><p>所以本题其实就不应该讨论dp[0]的初始化！</p><p>我相信dp[1] &#x3D; 1，dp[2] &#x3D; 2，这个初始化大家应该都没有争议的。</p><p>所以我的原则是：不考虑dp[0]如果初始化，只初始化dp[1] &#x3D; 1，dp[2] &#x3D; 2，然后从i &#x3D; 3开始递推，这样才符合dp[i]的定义。</p><ol start="4"><li>确定遍历顺序</li></ol><p>从递推公式dp[i] &#x3D; dp[i - 1] + dp[i - 2];中可以看出，遍历顺序一定是从前向后遍历的</p><ol start="5"><li>举例推导dp数组</li></ol><p>举例当n为5的时候，dp table（dp数组）应该是这样的</p><p><img src="https://img-blog.csdnimg.cn/20210105202546299.png" alt="70.爬楼梯"></p><p>如果代码出问题了，就把dp table 打印出来，看看究竟是不是和自己推导的一样。</p><p><strong>此时大家应该发现了，这不就是斐波那契数列么！</strong></p><p>唯一的区别是，没有讨论dp[0]应该是什么，因为dp[0]在本题没有意义！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n; <span class="comment">// 因为下面直接对dp[2]操作了，防止空指针</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123; <span class="comment">// 注意i是从3开始的</span></span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>优化一下空间复杂度</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="type">int</span> dp[<span class="number">3</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> sum = dp[<span class="number">1</span>] + dp[<span class="number">2</span>];</span><br><span class="line">            dp[<span class="number">1</span>] = dp[<span class="number">2</span>];</span><br><span class="line">            dp[<span class="number">2</span>] = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="使用最小花费爬楼梯"><a href="#使用最小花费爬楼梯" class="headerlink" title="使用最小花费爬楼梯"></a><a href="https://leetcode-cn.com/problems/min-cost-climbing-stairs/">使用最小花费爬楼梯</a></h2><p>数组的每个下标作为一个阶梯，第 i 个阶梯对应着一个非负数的体力花费值 cost[i]（下标从 0 开始）。</p><p>每当你爬上一个阶梯你都要花费对应的体力值，一旦支付了相应的体力值，你就可以选择向上爬一个阶梯或者爬两个阶梯。</p><p>请你找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为 0 或 1 的元素作为初始阶梯。</p><p>示例 1：</p><p>输入：cost &#x3D; [10, 15, 20] 输出：15 </p><p>解释：最低花费是从 cost[1] 开始，然后走两步即可到阶梯顶，一共花费 15 。  示例 2：</p><p>输入：cost &#x3D; [1, 100, 1, 1, 1, 100, 1, 1, 100, 1] 输出：6 </p><p>解释：最低花费方式是从 cost[0] 开始，逐个经过那些 1 ，跳过 cost[3] ，一共花费 6 。</p><p>提示：</p><ul><li>cost 的长度范围是 [2, 1000]。</li><li>cost[i] 将会是一个整型数据，范围为 [0, 999] 。</li></ul><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p><strong>注意题目描述：每当你爬上一个阶梯你都要花费对应的体力值，一旦支付了相应的体力值，你就可以选择向上爬一个阶梯或者爬两个阶梯</strong></p><p>所以示例1中只花费一个15 就可以到阶梯顶，最后一步可以理解为 不用花费。</p><p>读完题大家应该知道指定需要动态规划的，贪心是不可能了。</p><ol><li>确定dp数组以及下标的含义</li></ol><p>使用动态规划，就要有一个数组来记录状态，本题只需要一个一维数组dp[i]就可以了。</p><p>**dp[i]的定义：到达第i个台阶所花费的最少体力为dp[i]**。（注意这里认为是第一步一定是要花费）</p><p><strong>对于dp数组的定义，大家一定要清晰！</strong></p><ol start="2"><li>确定递推公式</li></ol><p>**可以有两个途径得到dp[i]，一个是dp[i-1] 一个是dp[i-2]**。</p><p>那么究竟是选dp[i-1]还是dp[i-2]呢？</p><p>一定是选最小的，所以dp[i] &#x3D; min(dp[i - 1], dp[i - 2]) + cost[i];</p><p><strong>注意这里为什么是加cost[i]，而不是cost[i-1],cost[i-2]之类的</strong></p><p>因为题目中说了：<strong>每当你爬上一个阶梯你都要花费对应的体力值</strong></p><ol start="3"><li>dp数组如何初始化</li></ol><p>根据dp数组的定义，dp数组初始化其实是比较难的，因为不可能初始化为第i台阶所花费的最少体力。</p><p>那么看一下递归公式，dp[i]由dp[i-1]，dp[i-2]推出，既然初始化所有的dp[i]是不可能的，那么只初始化dp[0]和dp[1]就够了，其他的最终都是dp[0]dp[1]推出。</p><p>所以初始化代码为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(cost.size())</span></span>;</span><br><span class="line">dp[<span class="number">0</span>] = cost[<span class="number">0</span>];</span><br><span class="line">dp[<span class="number">1</span>] = cost[<span class="number">1</span>];</span><br></pre></td></tr></table></figure><ol start="4"><li>确定遍历顺序</li></ol><p>最后一步，递归公式有了，初始化有了，如何遍历呢？</p><p>本题的遍历顺序其实比较简单，简单到很多同学都忽略了思考这一步直接就把代码写出来了。</p><p>因为是模拟台阶，而且dp[i]又dp[i-1]dp[i-2]推出，所以是从前到后遍历cost数组就可以了。</p><p><strong>但是稍稍有点难度的动态规划，其遍历顺序并不容易确定下来</strong>。</p><p>例如：01背包，都知道两个for循环，一个for遍历物品嵌套一个for遍历背包容量，那么为什么不是一个for遍历背包容量嵌套一个for遍历物品呢？ 以及在使用一维dp数组的时候遍历背包容量为什么要倒序呢？</p><ol start="5"><li>举例推导dp数组</li></ol><p>拿示例2：cost &#x3D; [1, 100, 1, 1, 1, 100, 1, 1, 100, 1] ，来模拟一下dp数组的状态变化，如下：</p><p><img src="https://img-blog.csdnimg.cn/2021010621363669.png" alt="746.使用最小花费爬楼梯"></p><p>如果代码写出来有问题，就把dp数组打印出来，看看和如上推导的是不是一样的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(cost.size())</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = cost[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = cost[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; cost.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            dp[i] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>], dp[i - <span class="number">2</span>]) + cost[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注意最后一步可以理解为不用花费，所以取倒数第一步，第二步的最少值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(dp[cost.<span class="built_in">size</span>() - <span class="number">1</span>], dp[cost.<span class="built_in">size</span>() - <span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>还可以优化空间复杂度，因为dp[i]就是由前两位推出来的，那么也不用dp数组了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> dp0 = cost[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> dp1 = cost[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; cost.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> dpi = <span class="built_in">min</span>(dp0, dp1) + cost[i];</span><br><span class="line">            dp0 = dp1; <span class="comment">// 记录一下前两位</span></span><br><span class="line">            dp1 = dpi;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(dp0, dp1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="不同路径"><a href="#不同路径" class="headerlink" title="不同路径"></a><a href="https://leetcode-cn.com/problems/unique-paths/">不同路径</a></h2><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p><p>问总共有多少条不同的路径？</p><p>示例 1：</p><p><img src="https://img-blog.csdnimg.cn/20210110174033215.png"></p><ul><li>输入：m &#x3D; 3, n &#x3D; 7</li><li>输出：28</li></ul><p>示例 2：</p><ul><li>输入：m &#x3D; 2, n &#x3D; 3</li><li>输出：3</li></ul><p>解释： 从左上角开始，总共有 3 条路径可以到达右下角。</p><ol><li>向右 -&gt; 向右 -&gt; 向下</li><li>向右 -&gt; 向下 -&gt; 向右</li><li>向下 -&gt; 向右 -&gt; 向右</li></ol><p>示例 3：</p><ul><li>输入：m &#x3D; 7, n &#x3D; 3</li><li>输出：28</li></ul><p>示例 4：</p><ul><li>输入：m &#x3D; 3, n &#x3D; 3</li><li>输出：6</li></ul><p>提示：</p><ul><li>1 &lt;&#x3D; m, n &lt;&#x3D; 100</li><li>题目数据保证答案小于等于 2 * 10^9</li></ul><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><h4 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h4><p>这道题目，刚一看最直观的想法就是用图论里的深搜，来枚举出来有多少种路径。</p><p>注意题目中说机器人每次只能向下或者向右移动一步，那么其实<strong>机器人走过的路径可以抽象为一棵二叉树，而叶子节点就是终点！</strong></p><p>如图举例：</p><p><img src="https://img-blog.csdnimg.cn/20201209113602700.png" alt="62.不同路径"></p><p>此时问题就可以转化为求二叉树叶子节点的个数，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; m || j &gt; n) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 越界了</span></span><br><span class="line">        <span class="keyword">if</span> (i == m &amp;&amp; j == n) <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 找到一种方法，相当于找到了叶子节点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(i + <span class="number">1</span>, j, m, n) + <span class="built_in">dfs</span>(i, j + <span class="number">1</span>, m, n);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">1</span>, m, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>大家如果提交了代码就会发现超时了！</strong></p><p>来分析一下时间复杂度，这个深搜的算法，其实就是要遍历整个二叉树。</p><p>这棵树的深度其实就是m+n-1（深度按从1开始计算）。</p><p>那二叉树的节点个数就是 2^(m + n - 1) - 1。可以理解深搜的算法就是遍历了整个满二叉树（其实没有遍历整个满二叉树，只是近似而已）</p><p>所以上面深搜代码的时间复杂度为O(2^(m + n - 1) - 1)，可以看出，这是指数级别的时间复杂度，是非常大的。</p><h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><p>机器人从(0 , 0) 位置出发，到(m - 1, n - 1)终点。</p><p>按照动规五部曲来分析：</p><ol><li>确定dp数组（dp table）以及下标的含义</li></ol><p>dp[i][j] ：表示从（0 ，0）出发，到(i, j) 有dp[i][j]条不同的路径。</p><ol start="2"><li>确定递推公式</li></ol><p>想要求dp[i][j]，只能有两个方向来推导出来，即dp[i - 1][j] 和 dp[i][j - 1]。</p><p>此时在回顾一下 dp[i - 1][j] 表示啥，是从(0, 0)的位置到(i - 1, j)有几条路径，dp[i][j - 1]同理。</p><p>那么很自然，dp[i][j] &#x3D; dp[i - 1][j] + dp[i][j - 1]，因为dp[i][j]只有这两个方向过来。</p><ol start="3"><li>dp数组的初始化</li></ol><p>如何初始化呢，首先dp[i][0]一定都是1，因为从(0, 0)的位置到(i, 0)的路径只有一条，那么dp[0][j]也同理。</p><p>所以初始化代码为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><ol start="4"><li>确定遍历顺序</li></ol><p>这里要看一下递归公式dp[i][j] &#x3D; dp[i - 1][j] + dp[i][j - 1]，dp[i][j]都是从其上方和左方推导而来，那么从左到右一层一层遍历就可以了。</p><p>这样就可以保证推导dp[i][j]的时候，dp[i - 1][j] 和 dp[i][j - 1]一定是有数值的。</p><ol start="5"><li>举例推导dp数组</li></ol><p>如图所示：</p><p><img src="https://img-blog.csdnimg.cn/20201209113631392.png" alt="62.不同路径1"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>));<span class="comment">//将m，n数组初始化数值全为0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="不同路径-II"><a href="#不同路径-II" class="headerlink" title="不同路径 II"></a><a href="https://leetcode-cn.com/problems/unique-paths-ii/">不同路径 II</a></h2><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p><p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p><p>网格中的障碍物和空位置分别用 1 和 0 来表示。</p><p>示例 1：</p><p><img src="https://img-blog.csdnimg.cn/20210111204939971.png"></p><ul><li>输入：obstacleGrid &#x3D; [[0,0,0],[0,1,0],[0,0,0]]</li><li>输出：2 解释：</li><li>3x3 网格的正中间有一个障碍物。</li><li>从左上角到右下角一共有 2 条不同的路径：<ol><li>向右 -&gt; 向右 -&gt; 向下 -&gt; 向下</li><li>向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</li></ol></li></ul><p>示例 2：</p><p><img src="https://img-blog.csdnimg.cn/20210111205857918.png"></p><ul><li>输入：obstacleGrid &#x3D; [[0,1],[0,0]]</li><li>输出：1</li></ul><p>提示：</p><ul><li>m &#x3D;&#x3D; obstacleGrid.length</li><li>n &#x3D;&#x3D; obstacleGrid[i].length</li><li>1 &lt;&#x3D; m, n &lt;&#x3D; 100</li><li>obstacleGrid[i][j] 为 0 或 1</li></ul><h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>这道题相对于<a href="https://programmercarl.com/0062.%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84.html">62.不同路径</a>就是有了障碍。</p><p>第一次接触这种题目的同学可能会有点懵，这有障碍了，应该怎么算呢？</p><p>62.不同路径 中我们已经详细分析了没有障碍的情况，有障碍的话，其实就是标记对应的dp table（dp数组）保持初始值(0)就可以了。</p><p>动规五部曲：</p><ol><li>确定dp数组（dp table）以及下标的含义</li></ol><p>dp[i][j] ：表示从（0 ，0）出发，到(i, j) 有dp[i][j]条不同的路径。</p><ol start="2"><li>确定递推公式</li></ol><p>递推公式和62.不同路径一样，dp[i][j] &#x3D; dp[i - 1][j] + dp[i][j - 1]。</p><p>但这里需要注意一点，因为有了障碍，(i, j)如果就是障碍的话应该就保持初始状态（初始状态为0）。</p><p>所以代码为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (obstacleGrid[i][j] == <span class="number">0</span>) &#123; <span class="comment">// 当(i, j)没有障碍的时候，再推导dp[i][j]</span></span><br><span class="line">    dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>dp数组如何初始化</li></ol><p>在62.不同路径 不同路径中我们给出如下的初始化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>)); <span class="comment">// 初始值为0</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>因为从(0, 0)的位置到(i, 0)的路径只有一条，所以dp[i][0]一定为1，dp[0][j]也同理。</p><p>但如果(i, 0) 这条边有了障碍之后，障碍之后（包括障碍）都是走不到的位置了，所以<strong>障碍之后的dp[i][0]应该还是初始值0</strong>。</p><p>如图：</p><p><img src="https://img-blog.csdnimg.cn/20210104114513928.png" alt="63.不同路径II"></p><p>下标(0, j)的初始化情况同理。</p><p>所以本题初始化代码为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m &amp;&amp; obstacleGrid[i][<span class="number">0</span>] == <span class="number">0</span>; i++) dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n &amp;&amp; obstacleGrid[<span class="number">0</span>][j] == <span class="number">0</span>; j++) dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><strong>注意代码里for循环的终止条件，一旦遇到obstacleGrid[i][0] &#x3D;&#x3D; 1的情况就停止dp[i][0]的赋值1的操作，dp[0][j]同理</strong></p><ol start="4"><li>确定遍历顺序</li></ol><p>从递归公式dp[i][j] &#x3D; dp[i - 1][j] + dp[i][j - 1] 中可以看出，一定是从左到右一层一层遍历，这样保证推导dp[i][j]的时候，dp[i - 1][j] 和 dp[i][j - 1]一定是有数值。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obstacleGrid[i][j] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>举例推导dp数组</li></ol><p>拿示例1来举例如题：</p><p><img src="https://img-blog.csdnimg.cn/20210104114548983.png" alt="63.不同路径II1"></p><p>对应的dp table 如图：</p><p><img src="https://img-blog.csdnimg.cn/20210104114610256.png" alt="63.不同路径II2"></p><p>如果这个图看不同，建议在理解一下递归公式，然后照着文章中说的遍历顺序，自己推导一下​！​</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = obstacleGrid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = obstacleGrid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m &amp;&amp; obstacleGrid[i][<span class="number">0</span>] == <span class="number">0</span>; i++) dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n &amp;&amp; obstacleGrid[<span class="number">0</span>][j] == <span class="number">0</span>; j++) dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (obstacleGrid[i][j] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="整数拆分"><a href="#整数拆分" class="headerlink" title="整数拆分"></a><a href="https://leetcode-cn.com/problems/integer-break/">整数拆分</a></h2><p>给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。</p><p>示例 1:</p><ul><li>输入: 2</li><li>输出: 1</li><li>解释: 2 &#x3D; 1 + 1, 1 × 1 &#x3D; 1。</li></ul><p>示例 2:</p><ul><li><p>输入: 10</p></li><li><p>输出: 36</p></li><li><p>解释: 10 &#x3D; 3 + 3 + 4, 3 × 3 × 4 &#x3D; 36。</p></li><li><p>说明: 你可以假设 n 不小于 2 且不大于 58。</p></li></ul><h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><p>动规五部曲，分析如下：</p><ol><li>确定dp数组（dp table）以及下标的含义</li></ol><p>dp[i]：分拆数字i，可以得到的最大乘积为dp[i]。</p><p>dp[i]的定义讲贯彻整个解题过程，下面哪一步想不懂了，就想想dp[i]究竟表示的是啥！</p><ol start="2"><li>确定递推公式</li></ol><p>可以想 dp[i]最大乘积是怎么得到的呢？</p><p>其实可以从1遍历j，然后有两种渠道得到dp[i].</p><p>一个是j * (i - j) 直接相乘。</p><p>一个是j * dp[i - j]，相当于是拆分(i - j)，对这个拆分不理解的话，可以回想dp数组的定义。</p><p><strong>那有同学问了，j怎么就不拆分呢？</strong></p><p>j是从1开始遍历，拆分j的情况，在遍历j的过程中其实都计算过了。那么从1遍历j，比较(i - j) * j和dp[i - j] * j 取最大的。递推公式：dp[i] &#x3D; max(dp[i], max((i - j) * j, dp[i - j] * j));</p><p>也可以这么理解，j * (i - j) 是单纯的把整数拆分为两个数相乘，而j * dp[i - j]是拆分成两个以及两个以上的个数相乘。</p><p>如果定义dp[i - j] * dp[j] 也是默认将一个数强制拆成4份以及4份以上了。</p><p>所以递推公式：dp[i] &#x3D; max({dp[i], (i - j) * j, dp[i - j] * j});</p><p>那么在取最大值的时候，为什么还要比较dp[i]呢？</p><p>因为在递推公式推导的过程中，每次计算dp[i]，取最大的而已。</p><ol start="3"><li>dp的初始化</li></ol><p>不少同学应该疑惑，dp[0] dp[1]应该初始化多少呢？</p><p>有的题解里会给出dp[0] &#x3D; 1，dp[1] &#x3D; 1的初始化，但解释比较牵强，主要还是因为这么初始化可以把题目过了。</p><p>严格从dp[i]的定义来说，dp[0] dp[1] 就不应该初始化，也就是没有意义的数值。</p><p>拆分0和拆分1的最大乘积是多少？</p><p>这是无解的。</p><p>这里我只初始化dp[2] &#x3D; 1，从dp[i]的定义来说，拆分数字2，得到的最大乘积是1，这个没有任何异议！</p><ol start="4"><li>确定遍历顺序</li></ol><p>确定遍历顺序，先来看看递归公式：dp[i] &#x3D; max(dp[i], max((i - j) * j, dp[i - j] * j));</p><p>dp[i] 是依靠 dp[i - j]的状态，所以遍历i一定是从前向后遍历，先有dp[i - j]再有dp[i]。</p><p>枚举j的时候，是从1开始的。i是从3开始，这样dp[i - j]就是dp[2]正好可以通过我们初始化的数值求出来。</p><p>所以遍历顺序为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n ; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">        dp[i] = <span class="built_in">max</span>(dp[i], <span class="built_in">max</span>((i - j) * j, dp[i - j] * j));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>举例推导dp数组</li></ol><p>举例当n为10 的时候，dp数组里的数值，如下：</p><p><img src="https://img-blog.csdnimg.cn/20210104173021581.png" alt="343.整数拆分"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">integerBreak</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n ; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                dp[i] = <span class="built_in">max</span>(dp[i], <span class="built_in">max</span>((i - j) * j, dp[i - j] * j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="不同的二叉搜索树"><a href="#不同的二叉搜索树" class="headerlink" title="不同的二叉搜索树"></a><a href="https://leetcode-cn.com/problems/unique-binary-search-trees/">不同的二叉搜索树</a></h2><p>给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？</p><p>示例:</p><p><img src="https://img-blog.csdnimg.cn/20210113161941835.png"></p><h3 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h3><p>这道题目描述很简短，但估计大部分同学看完都是懵懵的状态，这得怎么统计呢？</p><p>关于什么是二叉搜索树，可以看看这篇<a href="https://programmercarl.com/0700.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2.html">二叉树：二叉搜索树登场！</a>讲得非常棒！。</p><p>了解了二叉搜索树之后，我们应该先举几个例子，画画图，看看有没有什么规律，如图：</p><p><img src="https://img-blog.csdnimg.cn/20210107093106367.png" alt="96.不同的二叉搜索树"></p><p>n为1的时候有一棵树，n为2有两棵树，这个是很直观的。</p><p><img src="https://img-blog.csdnimg.cn/20210107093129889.png" alt="96.不同的二叉搜索树1"></p><p>来看看n为3的时候，有哪几种情况。</p><p>当1为头结点的时候，其右子树有两个节点，看这两个节点的布局，是不是和 n 为2的时候两棵树的布局是一样的啊！</p><p>（可能有同学问了，这布局不一样啊，节点数值都不一样。别忘了我们就是求不同树的数量，并不用把搜索树都列出来，所以不用关心其具体数值的差异）</p><p>当3为头结点的时候，其左子树有两个节点，看这两个节点的布局，是不是和n为2的时候两棵树的布局也是一样的啊！</p><p>当2为头结点的时候，其左右子树都只有一个节点，布局是不是和n为1的时候只有一棵树的布局也是一样的啊！</p><p>发现到这里，其实我们就找到了重叠子问题了，其实也就是发现可以通过dp[1] 和 dp[2] 来推导出来dp[3]的某种方式。</p><p>思考到这里，这道题目就有眉目了。</p><p>dp[3]，就是 元素1为头结点搜索树的数量 + 元素2为头结点搜索树的数量 + 元素3为头结点搜索树的数量</p><p>元素1为头结点搜索树的数量 &#x3D; 右子树有2个元素的搜索树数量 * 左子树有0个元素的搜索树数量</p><p>元素2为头结点搜索树的数量 &#x3D; 右子树有1个元素的搜索树数量 * 左子树有1个元素的搜索树数量</p><p>元素3为头结点搜索树的数量 &#x3D; 右子树有0个元素的搜索树数量 * 左子树有2个元素的搜索树数量</p><p>有2个元素的搜索树数量就是dp[2]。</p><p>有1个元素的搜索树数量就是dp[1]。</p><p>有0个元素的搜索树数量就是dp[0]。</p><p>所以dp[3] &#x3D; dp[2] * dp[0] + dp[1] * dp[1] + dp[0] * dp[2]</p><p>如图所示：</p><p><img src="https://img-blog.csdnimg.cn/20210107093226241.png" alt="96.不同的二叉搜索树2"></p><p>此时我们已经找到递推关系了，那么可以用动规五部曲再系统分析一遍。</p><ol><li>确定dp数组（dp table）以及下标的含义</li></ol><p>**dp[i] ： 1到i为节点组成的二叉搜索树的个数为dp[i]**。</p><p>也可以理解是i的不同元素节点组成的二叉搜索树的个数为dp[i] ，都是一样的。</p><p>以下分析如果想不清楚，就来回想一下dp[i]的定义</p><ol start="2"><li>确定递推公式</li></ol><p>在上面的分析中，其实已经看出其递推关系， dp[i] +&#x3D; dp[以j为头结点左子树节点数量] * dp[以j为头结点右子树节点数量]</p><p>j相当于是头结点的元素，从1遍历到i为止。</p><p>所以递推公式：dp[i] +&#x3D; dp[j - 1] * dp[i - j]; ，j-1 为j为头结点左子树节点数量，i-j 为以j为头结点右子树节点数量</p><ol start="3"><li>dp数组如何初始化</li></ol><p>初始化，只需要初始化dp[0]就可以了，推导的基础，都是dp[0]。</p><p>那么dp[0]应该是多少呢？</p><p>从定义上来讲，空节点也是一棵二叉树，也是一棵二叉搜索树，这是可以说得通的。</p><p>从递归公式上来讲，dp[以j为头结点左子树节点数量] * dp[以j为头结点右子树节点数量] 中以j为头结点左子树节点数量为0，也需要dp[以j为头结点左子树节点数量] &#x3D; 1， 否则乘法的结果就都变成0了。</p><p>所以初始化dp[0] &#x3D; 1</p><ol start="4"><li>确定遍历顺序</li></ol><p>首先一定是遍历节点数，从递归公式：dp[i] +&#x3D; dp[j - 1] * dp[i - j]可以看出，节点数为i的状态是依靠 i之前节点数的状态。</p><p>那么遍历i里面每一个数作为头结点的状态，用j来遍历。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">        dp[i] += dp[j - <span class="number">1</span>] * dp[i - j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>举例推导dp数组</li></ol><p>n为5时候的dp数组状态如图：</p><p><img src="https://img-blog.csdnimg.cn/20210107093253987.png" alt="96.不同的二叉搜索树3"></p><p>当然如果自己画图举例的话，基本举例到n为3就可以了，n为4的时候，画图已经比较麻烦了。</p><p><strong>我这里列到了n为5的情况，是为了方便大家 debug代码的时候，把dp数组打出来，看看哪里有问题</strong>。</p><p>综上分析完毕，C++代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numTrees</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">                dp[i] += dp[j - <span class="number">1</span>] * dp[i - j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="0-1背包-一"><a href="#0-1背包-一" class="headerlink" title="0-1背包(一)"></a><a href="https://www.programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-1.html#_01-%E8%83%8C%E5%8C%85">0-1背包(一)</a></h2><p>对于面试的话，其实掌握01背包，和完全背包，就够用了，最多可以再来一个多重背包。</p><p>如果这几种背包，分不清，我这里画了一个图，如下：</p><p><img src="https://img-blog.csdnimg.cn/20210117171307407.png" alt="416.分割等和子集1"></p><p>至于背包九讲其其他背包，面试几乎不会问，都是竞赛级别的了，leetcode上连多重背包的题目都没有，所以题库也告诉我们，01背包和完全背包就够用了。</p><p>而完全背包又是也是01背包稍作变化而来，即：完全背包的物品数量是无限的。</p><p><strong>所以背包问题的理论基础重中之重是01背包，一定要理解透！</strong></p><p><strong>所以我先通过纯01背包问题，把01背包原理讲清楚，后续再讲解leetcode题目的时候，重点就是讲解如何转化为01背包问题了</strong>。</p><p>有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。<strong>每件物品只能用一次</strong>，求解将哪些物品装入背包里物品价值总和最大。</p><p><img src="https://img-blog.csdnimg.cn/20210117175428387.jpg" alt="动态规划-背包问题"></p><p>这是标准的背包问题，以至于很多同学看了这个自然就会想到背包，甚至都不知道暴力的解法应该怎么解了。</p><p>这样其实是没有从底向上去思考，而是习惯性想到了背包，那么暴力的解法应该是怎么样的呢？</p><p>每一件物品其实只有两个状态，取或者不取，所以可以使用回溯法搜索出所有的情况，那么时间复杂度就是$o(2^n)$，这里的n表示物品数量。</p><p><strong>所以暴力的解法是指数级别的时间复杂度。进而才需要动态规划的解法来进行优化！</strong></p><p>在下面的讲解中，我举一个例子：</p><p>背包最大重量为4。</p><p>物品为：</p><table><thead><tr><th></th><th>重量</th><th>价值</th></tr></thead><tbody><tr><td>物品0</td><td>1</td><td>15</td></tr><tr><td>物品1</td><td>3</td><td>20</td></tr><tr><td>物品2</td><td>4</td><td>30</td></tr></tbody></table><p>问背包能背的物品最大价值是多少？</p><p>以下讲解和图示中出现的数字都是以这个例子为例。</p><h3 id="二维dp数组01背包"><a href="#二维dp数组01背包" class="headerlink" title="二维dp数组01背包"></a>二维dp数组01背包</h3><p>依然动规五部曲分析一波。</p><ol><li>确定dp数组以及下标的含义</li></ol><p>对于背包问题，有一种写法， 是使用二维数组，即<strong>dp[i][j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少</strong>。</p><p>只看这个二维数组的定义，大家一定会有点懵，看下面这个图：</p><p><img src="https://img-blog.csdnimg.cn/20210110103003361.png" alt="动态规划-背包问题1"></p><p><strong>要时刻记着这个dp数组的含义，下面的一些步骤都围绕这dp数组的含义进行的</strong>，如果哪里看懵了，就来回顾一下i代表什么，j又代表什么。</p><ol start="2"><li>确定递推公式</li></ol><p>再回顾一下dp[i][j]的含义：从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少。</p><p>那么可以有两个方向推出来dp[i][j]，</p><ul><li><strong>不放物品i</strong>：由dp[i - 1][j]推出，即背包容量为j，里面不放物品i的最大价值，此时dp[i][j]就是dp[i - 1][j]。(其实就是当物品i的重量大于背包j的重量时，物品i无法放进背包中，所以被背包内的价值依然和前面相同。)</li><li><strong>放物品i</strong>：由dp[i - 1][j - weight[i]]推出，dp[i - 1][j - weight[i]] 为背包容量为j - weight[i]的时候不放物品i的最大价值，那么dp[i - 1][j - weight[i]] + value[i] （物品i的价值），就是背包放物品i得到的最大价值</li></ul><p>所以递归公式： dp[i][j] &#x3D; max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);</p><ol start="3"><li>dp数组如何初始化</li></ol><p><strong>关于初始化，一定要和dp数组的定义吻合，否则到递推公式的时候就会越来越乱</strong>。</p><p>首先从dp[i][j]的定义出发，如果背包容量j为0的话，即dp[i][0]，无论是选取哪些物品，背包价值总和一定为0。如图：</p><p><img src="https://img-blog.csdnimg.cn/2021011010304192.png" alt="动态规划-背包问题2"></p><p>在看其他情况。</p><p>状态转移方程 dp[i][j] &#x3D; max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]); 可以看出i 是由 i-1 推导出来，那么i为0的时候就一定要初始化。</p><p>dp[0][j]，即：i为0，存放编号0的物品的时候，各个容量的背包所能存放的最大价值。</p><p>那么很明显当 j &lt; weight[0]的时候，dp[0][j] 应该是 0，因为背包容量比编号0的物品重量还小。</p><p>当j &gt;&#x3D; weight[0]时，dp[0][j] 应该是value[0]，因为背包容量放足够放编号0物品。</p><p>代码初始化如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span> ; j &lt; weight[<span class="number">0</span>]; j++) &#123;  <span class="comment">// 当然这一步，如果把dp数组预先初始化为0了，这一步就可以省略，但很多同学应该没有想清楚这一点。</span></span><br><span class="line">    dp[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 正序遍历</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = weight[<span class="number">0</span>]; j &lt;= bagweight; j++) &#123;</span><br><span class="line">    dp[<span class="number">0</span>][j] = value[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时dp数组初始化情况如图所示：</p><p><img src="https://img-blog.csdnimg.cn/20210110103109140.png" alt="动态规划-背包问题7"></p><p>dp[0][j] 和 dp[i][0] 都已经初始化了，那么其他下标应该初始化多少呢？</p><p>其实从递归公式： dp[i][j] &#x3D; max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]); 可以看出dp[i][j] 是由左上方数值推导出来了，那么 其他下标初始为什么数值都可以，因为都会被覆盖。</p><p><strong>初始-1，初始-2，初始100，都可以！</strong></p><p>但只不过一开始就统一把dp数组统一初始为0，更方便一些。</p><p>如图：</p><p><img src="https://code-thinking.cdn.bcebos.com/pics/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%9810.jpg" alt="动态规划-背包问题10"></p><p>最后初始化代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化 dp</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(weight.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(bagweight + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = weight[<span class="number">0</span>]; j &lt;= bagweight; j++) &#123;</span><br><span class="line">    dp[<span class="number">0</span>][j] = value[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>费了这么大的功夫，才把如何初始化讲清楚，相信不少同学平时初始化dp数组是凭感觉来的，但有时候感觉是不靠谱的</strong>。</p><ol start="4"><li>确定遍历顺序</li></ol><p>在如下图中，可以看出，有两个遍历的维度：物品与背包重量</p><p><img src="https://img-blog.csdnimg.cn/2021011010314055.png" alt="动态规划-背包问题3"></p><p>那么问题来了，<strong>先遍历 物品还是先遍历背包重量呢？</strong></p><p><strong>其实都可以！！ 但是先遍历物品更好理解</strong>。</p><p>那么我先给出先遍历物品，然后遍历背包重量的代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// weight数组的大小 就是物品个数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; weight.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= bagweight; j++) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">        <span class="keyword">if</span> (j &lt; weight[i]) dp[i][j] = dp[i - <span class="number">1</span>][j]; </span><br><span class="line">        <span class="keyword">else</span> dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - weight[i]] + value[i]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>先遍历背包，再遍历物品，也是可以的！（注意我这里使用的二维dp数组）</strong></p><p>例如这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// weight数组的大小 就是物品个数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= bagweight; j++) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; weight.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">        <span class="keyword">if</span> (j &lt; weight[i]) dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">        <span class="keyword">else</span> dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - weight[i]] + value[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么也是可以的呢？</p><p><strong>要理解递归的本质和递推的方向</strong>。</p><p>dp[i][j] &#x3D; max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]); 递归公式中可以看出dp[i][j]是靠dp[i-1][j]和dp[i - 1][j - weight[i]]推导出来的。</p><p>dp[i-1][j]和dp[i - 1][j - weight[i]] 都在dp[i][j]的左上角方向（包括正上方向），那么先遍历物品，再遍历背包的过程如图所示：</p><p><img src="https://img-blog.csdnimg.cn/202101101032124.png" alt="动态规划-背包问题5"></p><p>再来看看先遍历背包，再遍历物品呢，如图：</p><p><img src="https://img-blog.csdnimg.cn/20210110103244701.png" alt="动态规划-背包问题6"></p><p><strong>大家可以看出，虽然两个for循环遍历的次序不同，但是dp[i][j]所需要的数据就是左上角，根本不影响dp[i][j]公式的推导！</strong></p><p>但先遍历物品再遍历背包这个顺序更好理解。</p><p><strong>其实背包问题里，两个for循环的先后循序是非常有讲究的，理解遍历顺序其实比理解推导公式难多了</strong>。</p><ol start="5"><li>举例推导dp数组</li></ol><p>来看一下对应的dp数组的数值，如图：</p><p><img src="https://img-blog.csdnimg.cn/20210118163425129.jpg" alt="动态规划-背包问题4"></p><p>最终结果就是dp[2][4]。</p><p>建议大家此时自己在纸上推导一遍，看看dp数组里每一个数值是不是这样的。</p><p><strong>做动态规划的题目，最好的过程就是自己在纸上举一个例子把对应的dp数组的数值推导一下，然后在动手写代码！</strong></p><p>很多同学做dp题目，遇到各种问题，然后凭感觉东改改西改改，怎么改都不对，或者稀里糊涂就改过了。</p><p>主要就是自己没有动手推导一下dp数组的演变过程，如果推导明白了，代码写出来就算有问题，只要把dp数组打印出来，对比一下和自己推导的有什么差异，很快就可以发现问题了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_2_wei_bag_problem1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; weight = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; value = &#123;<span class="number">15</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;</span><br><span class="line">    <span class="type">int</span> bagweight = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二维数组</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(weight.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(bagweight + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = weight[<span class="number">0</span>]; j &lt;= bagweight; j++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][j] = value[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// weight数组的大小 就是物品个数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; weight.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= bagweight; j++) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">            <span class="keyword">if</span> (j &lt; weight[i]) dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">else</span> dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - weight[i]] + value[i]);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; dp[weight.<span class="built_in">size</span>() - <span class="number">1</span>][bagweight] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test_2_wei_bag_problem1</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0-1背包问题（二）"><a href="#0-1背包问题（二）" class="headerlink" title="0-1背包问题（二）"></a><a href="https://www.programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-2.html#%E4%B8%80%E7%BB%B4dp01%E8%83%8C%E5%8C%85%E5%AE%8C%E6%95%B4c-%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81">0-1背包问题（二）</a></h2><p>今天我们就来说一说滚动数组，其实在前面的题目中我们已经用到过滚动数组了，就是把二维dp降为一维dp，一些录友当时还表示比较困惑。</p><p>那么我们通过01背包，来彻底讲一讲滚动数组！</p><p>接下来还是用如下这个例子来进行讲解</p><p>背包最大重量为4。</p><p>物品为：</p><table><thead><tr><th></th><th>重量</th><th>价值</th></tr></thead><tbody><tr><td>物品0</td><td>1</td><td>15</td></tr><tr><td>物品1</td><td>3</td><td>20</td></tr><tr><td>物品2</td><td>4</td><td>30</td></tr></tbody></table><p>问背包能背的物品最大价值是多少？</p><p>对于背包问题其实状态都是可以压缩的。</p><p>在使用二维数组的时候，递推公式：dp[i][j] &#x3D; max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);</p><p><strong>其实可以发现如果把dp[i - 1]那一层拷贝到dp[i]上，表达式完全可以是：dp[i][j] &#x3D; max(dp[i][j], dp[i][j - weight[i]] + value[i]);</strong></p><p><strong>与其把dp[i - 1]这一层拷贝到dp[i]上，不如只用一个一维数组了</strong>，只用dp[j]（一维数组，也可以理解是一个滚动数组）。</p><p>这就是滚动数组的由来，<strong>需要满足的条件是上一层可以重复利用，直接拷贝到当前层</strong>。</p><p>读到这里估计大家都忘了 dp[i][j]里的i和j表达的是什么了，i是物品，j是背包容量。</p><p><strong>dp[i][j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少</strong>。</p><p>一定要时刻记住这里i和j的含义，要不然很容易看懵了。</p><p>动规五部曲分析如下：</p><ol><li>确定dp数组的定义</li></ol><p>在一维dp数组中，dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]。</p><ol start="2"><li>一维dp数组的递推公式</li></ol><p>dp[j]为 容量为j的背包所背的最大价值，那么如何推导dp[j]呢？</p><p>dp[j]可以通过dp[j - weight[i]]推导出来，dp[j - weight[i]]表示容量为j - weight[i]的背包所背的最大价值。</p><p>dp[j - weight[i]] + value[i] 表示 容量为 j - 物品i重量 的背包 加上 物品i的价值。（也就是容量为j的背包，放入物品i了之后的价值即：dp[j]）</p><p>此时dp[j]有两个选择，一个是取自己dp[j] 相当于 二维dp数组中的dp[i-1][j]，即不放物品i，一个是取dp[j - weight[i]] + value[i]，即放物品i，指定是取最大的，毕竟是求最大价值，</p><p>所以递归公式为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[j] = <span class="built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);</span><br></pre></td></tr></table></figure><p>可以看出相对于二维dp数组的写法，就是把dp[i][j]中i的维度去掉了。</p><ol start="3"><li>一维dp数组如何初始化</li></ol><p><strong>关于初始化，一定要和dp数组的定义吻合，否则到递推公式的时候就会越来越乱</strong>。</p><p>dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]，那么dp[0]就应该是0，因为背包容量为0所背的物品的最大价值就是0。</p><p>那么dp数组除了下标0的位置，初始为0，其他下标应该初始化多少呢？</p><p>看一下递归公式：dp[j] &#x3D; max(dp[j], dp[j - weight[i]] + value[i]);</p><p>dp数组在推导的时候一定是取价值最大的数，如果题目给的价值都是正整数那么非0下标都初始化为0就可以了。</p><p><strong>这样才能让dp数组在递归公式的过程中取的最大的价值，而不是被初始值覆盖了</strong>。</p><p>那么我假设物品价值都是大于0的，所以dp数组初始化的时候，都初始为0就可以了。</p><ol start="4"><li>一维dp数组遍历顺序</li></ol><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; weight.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = bagWeight; j &gt;= weight[i]; j--) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">        dp[j] = <span class="built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这里大家发现和二维dp的写法中，遍历背包的顺序是不一样的！</strong></p><p>二维dp遍历的时候，背包容量是从小到大，而一维dp遍历的时候，背包是从大到小。</p><p>为什么呢？</p><p><strong>倒序遍历是为了保证物品i只被放入一次！</strong>。但如果一旦正序遍历了，那么物品0就会被重复加入多次！</p><p>举一个例子：物品0的重量weight[0] &#x3D; 1，价值value[0] &#x3D; 15</p><p>如果正序遍历</p><p>dp[1] &#x3D; dp[1 - weight[0]] + value[0] &#x3D; 15</p><p>dp[2] &#x3D; dp[2 - weight[0]] + value[0] &#x3D; 30</p><p>此时dp[2]就已经是30了，意味着物品0，被放入了两次，所以不能正序遍历。</p><p>为什么倒序遍历，就可以保证物品只放入一次呢？</p><p>倒序就是先算dp[2]</p><p>dp[2] &#x3D; dp[2 - weight[0]] + value[0] &#x3D; 15 （dp数组已经都初始化为0）</p><p>dp[1] &#x3D; dp[1 - weight[0]] + value[0] &#x3D; 15</p><p>所以从后往前循环，每次取得状态不会和之前取得状态重合，这样每种物品就只取一次了。</p><p><strong>那么问题又来了，为什么二维dp数组历的时候不用倒序呢？</strong></p><p>因为对于二维dp，dp[i][j]都是通过上一层即dp[i - 1][j]计算而来，本层的dp[i][j]并不会被覆盖！</p><p>（如何这里读不懂，大家就要动手试一试了，空想还是不靠谱的，实践出真知！）</p><p><strong>再来看看两个嵌套for循环的顺序，代码中是先遍历物品嵌套遍历背包容量，那可不可以先遍历背包容量嵌套遍历物品呢？</strong></p><p>不可以！</p><p>因为一维dp的写法，背包容量一定是要倒序遍历（原因上面已经讲了），如果遍历背包容量放在上一层，那么每个dp[j]就只会放入一个物品，即：背包里只放入了一个物品。</p><p>（这里如果读不懂，就在回想一下dp[j]的定义，或者就把两个for循环顺序颠倒一下试试！）</p><p><strong>所以一维dp数组的背包在遍历顺序上和二维其实是有很大差异的！</strong>，这一点大家一定要注意。</p><ol start="5"><li>举例推导dp数组</li></ol><p>一维dp，分别用物品0，物品1，物品2 来遍历背包，最终得到结果如下：</p><p><img src="https://img-blog.csdnimg.cn/20210110103614769.png" alt="动态规划-背包问题9"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_1_wei_bag_problem</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; weight = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; value = &#123;<span class="number">15</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;</span><br><span class="line">    <span class="type">int</span> bagWeight = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(bagWeight + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; weight.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = bagWeight; j &gt;= weight[i]; j--) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">            dp[j] = <span class="built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[bagWeight] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test_1_wei_bag_problem</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，一维dp 的01背包，要比二维简洁的多！ 初始化 和 遍历顺序相对简单了。</p><p><strong>所以我倾向于使用一维dp数组的写法，比较直观简洁，而且空间复杂度还降了一个数量级！</strong></p><h2 id="分割等和子集"><a href="#分割等和子集" class="headerlink" title="分割等和子集"></a><a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/">分割等和子集</a></h2><p>给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p><p>注意: 每个数组中的元素不会超过 100 数组的大小不会超过 200</p><p>示例 1: 输入: [1, 5, 11, 5] 输出: true 解释: 数组可以分割成 [1, 5, 5] 和 [11].</p><p>示例 2: 输入: [1, 2, 3, 5] 输出: false 解释: 数组不能分割成两个元素和相等的子集.</p><p>提示：</p><ul><li>1 &lt;&#x3D; nums.length &lt;&#x3D; 200</li><li>1 &lt;&#x3D; nums[i] &lt;&#x3D; 100</li></ul><h3 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h3><p>这道题目初步看，是如下两题几乎是一样的，大家可以用回溯法，解决如下两题</p><ul><li>698.划分为k个相等的子集</li><li>473.火柴拼正方形</li></ul><p>这道题目是要找是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p><p>那么只要找到集合里能够出现 sum &#x2F; 2 的子集总和，就算是可以分割成两个相同元素和子集了。</p><p>本题是可以用回溯暴力搜索出所有答案的，但最后超时了，也不想再优化了，放弃回溯，直接上01背包吧。</p><p>背包问题，大家都知道，有N件物品和一个最多能被重量为W 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品只能用一次，求解将哪些物品装入背包里物品价值总和最大。</p><p><strong>背包问题有多种背包方式，常见的有：01背包、完全背包、多重背包、分组背包和混合背包等等。</strong></p><p>要注意题目描述中商品是不是可以重复放入。</p><p><strong>即一个商品如果可以重复多次放入是完全背包，而只能放入一次是01背包，写法还是不一样的。</strong></p><p><strong>要明确本题中我们要使用的是01背包，因为元素我们只能用一次。</strong></p><p>回归主题：首先，本题要求集合里能否出现总和为 sum &#x2F; 2 的子集。</p><p>那么来一一对应一下本题，看看背包问题如果来解决。</p><p><strong>只有确定了如下四点，才能把01背包问题套到本题上来。</strong></p><ul><li>背包的体积为sum &#x2F; 2</li><li>背包要放入的商品（集合里的元素）重量为 元素的数值，价值也为元素的数值</li><li>背包如果正好装满，说明找到了总和为 sum &#x2F; 2 的子集。</li><li>背包中每一个元素是不可重复放入。</li></ul><p>以上分析完，我们就可以套用01背包，来解决这个问题了。</p><p>动规五部曲分析如下：</p><ol><li>确定dp数组以及下标的含义</li></ol><p>01背包中，dp[j] 表示： 容量为j的背包，所背的物品价值可以最大为dp[j]。</p><p>**套到本题，dp[j]表示 背包总容量是j，最大可以凑成j的子集总和为dp[j]**。</p><ol start="2"><li>确定递推公式</li></ol><p>01背包的递推公式为：dp[j] &#x3D; max(dp[j], dp[j - weight[i]] + value[i]);</p><p>本题，相当于背包里放入数值，那么物品i的重量是nums[i]，其价值也是nums[i]。</p><p>所以递推公式：dp[j] &#x3D; max(dp[j], dp[j - nums[i]] + nums[i]);</p><ol start="3"><li>dp数组如何初始化</li></ol><p>在01背包，一维dp如何初始化，已经讲过，</p><p>从dp[j]的定义来看，首先dp[0]一定是0。</p><p>如果如果题目给的价值都是正整数那么非0下标都初始化为0就可以了，如果题目给的价值有负数，那么非0下标就要初始化为负无穷。</p><p><strong>这样才能让dp数组在递归公式的过程中取的最大的价值，而不是被初始值覆盖了</strong>。</p><p>本题题目中 只包含正整数的非空数组，所以非0下标的元素初始化为0就可以了。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 题目中说：每个数组中的元素不会超过 100，数组的大小不会超过 200</span></span><br><span class="line"><span class="comment">// 总和不会大于20000，背包最大只需要其中一半，所以10001大小就可以了</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(<span class="number">10001</span>, <span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure><ol start="4"><li>确定遍历顺序</li></ol><p>在<a href="https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-2.html">动态规划：关于01背包问题，你该了解这些！（滚动数组）</a>中就已经说明：如果使用一维dp数组，物品遍历的for循环放在外层，遍历背包的for循环放在内层，且内层for循环倒序遍历！</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开始 01背包</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = target; j &gt;= nums[i]; j--) &#123; <span class="comment">// 每一个元素一定是不可重复放入，所以从大到小遍历</span></span><br><span class="line">        dp[j] = <span class="built_in">max</span>(dp[j], dp[j - nums[i]] + nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>举例推导dp数组</li></ol><p>dp[j]的数值一定是小于等于j的。</p><p><strong>如果dp[j] &#x3D;&#x3D; j 说明，集合中的子集总和正好可以凑成总和j，理解这一点很重要。</strong></p><p>用例1，输入[1,5,11,5] 为例，如图：</p><p><img src="https://img-blog.csdnimg.cn/20210110104240545.png" alt="416.分割等和子集2"></p><p>最后dp[11] &#x3D;&#x3D; 11，说明可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canPartition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// dp[i]中的i表示背包内总和</span></span><br><span class="line">        <span class="comment">// 题目中说：每个数组中的元素不会超过 100，数组的大小不会超过 200</span></span><br><span class="line">        <span class="comment">// 总和不会大于20000，背包最大只需要其中一半，所以10001大小就可以了</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(<span class="number">10001</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum % <span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> target = sum / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始 01背包</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = target; j &gt;= nums[i]; j--) &#123; <span class="comment">// 每一个元素一定是不可重复放入，所以从大到小遍历</span></span><br><span class="line">                dp[j] = <span class="built_in">max</span>(dp[j], dp[j - nums[i]] + nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 集合中的元素正好可以凑成总和target</span></span><br><span class="line">        <span class="keyword">if</span> (dp[target] == target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="最后一块石头的重量II"><a href="#最后一块石头的重量II" class="headerlink" title="最后一块石头的重量II"></a><a href="https://leetcode-cn.com/problems/last-stone-weight-ii/">最后一块石头的重量II</a></h2><p>有一堆石头，每块石头的重量都是正整数。</p><p>每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x &lt;&#x3D; y。那么粉碎的可能结果如下：</p><p>如果 x &#x3D;&#x3D; y，那么两块石头都会被完全粉碎； 如果 x !&#x3D; y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。 最后，最多只会剩下一块石头。返回此石头最小的可能重量。如果没有石头剩下，就返回 0。</p><p>示例： 输入：[2,7,4,1,8,1] </p><p>输出：1 </p><p>解释： 组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]， 组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]， 组合 2 和 1，得到 1，所以数组转化为 [1,1,1]， 组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。</p><p>提示：</p><ul><li>1 &lt;&#x3D; stones.length &lt;&#x3D; 30</li><li>1 &lt;&#x3D; stones[i] &lt;&#x3D; 1000</li></ul><h3 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h3><p>本题其实就是尽量让石头分成重量相同的两堆，相撞之后剩下的石头最小，<strong>这样就化解成01背包问题了</strong>。</p><p>是不是感觉和<a href="https://programmercarl.com/0416.%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86.html">416. 分割等和子集 </a>非常像了。</p><p>本题物品的重量为store[i]，物品的价值也为store[i]。</p><p>对应着01背包里的物品重量weight[i]和 物品价值value[i]。</p><p>接下来进行动规五步曲：</p><ol><li>确定dp数组以及下标的含义</li></ol><p><strong>dp[j]表示容量（这里说容量更形象，其实就是重量）为j的背包，最多可以背dp[j]这么重的石头</strong>。</p><ol start="2"><li>确定递推公式</li></ol><p>01背包的递推公式为：dp[j] &#x3D; max(dp[j], dp[j - weight[i]] + value[i]);</p><p>本题则是：<strong>dp[j] &#x3D; max(dp[j], dp[j - stones[i]] + stones[i]);</strong></p><p>一些同学可能看到这dp[j - stones[i]] + stones[i]中 又有- stones[i] 又有+stones[i]，看着有点晕乎。</p><p>还是要牢记dp[j]的含义，要知道dp[j - stones[i]]为 容量为j - stones[i]的背包最大所背重量。</p><ol start="3"><li>dp数组如何初始化</li></ol><p>既然 dp[j]中的j表示容量，那么最大容量（重量）是多少呢，就是所有石头的重量和。</p><p>因为提示中给出1 &lt;&#x3D; stones.length &lt;&#x3D; 30，1 &lt;&#x3D; stones[i] &lt;&#x3D; 1000，所以最大重量就是30 * 1000 。</p><p>而我们要求的target其实只是最大重量的一半，所以dp数组开到15000大小就可以了。</p><p>当然也可以把石头遍历一遍，计算出石头总重量 然后除2，得到dp数组的大小。</p><p>我这里就直接用15000了。</p><p>接下来就是如何初始化dp[j]呢，因为重量都不会是负数，所以dp[j]都初始化为0就可以了，这样在递归公式dp[j] &#x3D; max(dp[j], dp[j - stones[i]] + stones[i]);中dp[j]才不会初始值所覆盖。</p><p>代码为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(<span class="number">15001</span>, <span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure><ol start="4"><li>确定遍历顺序</li></ol><p>在<a href="https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-2.html">动态规划：关于01背包问题，你该了解这些！（滚动数组）</a>中就已经说明：如果使用一维dp数组，物品遍历的for循环放在外层，遍历背包的for循环放在内层，且内层for循环倒序遍历！</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; stones.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = target; j &gt;= stones[i]; j--) &#123; <span class="comment">// 遍历背包</span></span><br><span class="line">        dp[j] = <span class="built_in">max</span>(dp[j], dp[j - stones[i]] + stones[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>举例推导dp数组</li></ol><p>举例，输入：[2,4,1,1]，此时target &#x3D; (2 + 4 + 1 + 1)&#x2F;2 &#x3D; 4 ，dp数组状态图如下：</p><p><img src="https://img-blog.csdnimg.cn/20210121115805904.jpg" alt="1049.最后一块石头的重量II"></p><p>最后dp[target]里是容量为target的背包所能背的最大重量。</p><p>那么分成两堆石头，一堆石头的总重量是dp[target]，另一堆就是sum - dp[target]。</p><p><strong>在计算target的时候，target &#x3D; sum &#x2F; 2 因为是向下取整，所以sum - dp[target] 一定是大于等于dp[target]的</strong>。</p><p>那么相撞之后剩下的最小石头重量就是 (sum - dp[target]) - dp[target]。</p><p>以上分析完毕，C++代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lastStoneWeightII</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(<span class="number">15001</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; stones.<span class="built_in">size</span>(); i++) sum += stones[i];</span><br><span class="line">        <span class="type">int</span> target = sum / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; stones.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = target; j &gt;= stones[i]; j--) &#123; <span class="comment">// 遍历背包</span></span><br><span class="line">                dp[j] = <span class="built_in">max</span>(dp[j], dp[j - stones[i]] + stones[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum - dp[target] - dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="目标和"><a href="#目标和" class="headerlink" title="目标和"></a><a href="https://leetcode-cn.com/problems/target-sum/">目标和</a></h3><p>给定一个非负整数数组，a1, a2, …, an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。</p><p>返回可以使最终数组和为目标数 S 的所有添加符号的方法数。</p><p>示例：</p><p>输入：nums: [1, 1, 1, 1, 1], S: 3<br>输出：5</p><p>解释：<br>-1+1+1+1+1 &#x3D; 3<br>+1-1+1+1+1 &#x3D; 3<br>+1+1-1+1+1 &#x3D; 3<br>+1+1+1-1+1 &#x3D; 3<br>+1+1+1+1-1 &#x3D; 3</p><p>一共有5种方法让最终目标和为3。</p><p>提示：</p><ul><li>数组非空，且长度不会超过 20 。</li><li>初始的数组的和不会超过 1000 。</li><li>保证返回的最终结果能被 32 位整数存下。</li></ul><h3 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h3><p>如果跟着「代码随想录」一起学过<a href="https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E6%80%BB%E7%BB%93.html">回溯算法系列 </a>的录友，看到这道题，应该有一种直觉，就是感觉好像回溯法可以爆搜出来。</p><p>事实确实如此，下面我也会给出相应的代码，只不过会超时，哈哈。</p><p>这道题目咋眼一看和动态规划背包啥的也没啥关系。</p><p>本题要如何使表达式结果为target，</p><p>既然为target，那么就一定有 left组合 - right组合 &#x3D; target。</p><p>left + right等于sum，而sum是固定的。</p><p>公式来了， left - (sum - left) &#x3D; target -&gt; left &#x3D; (target + sum)&#x2F;2 。</p><p>target是固定的，sum是固定的，left就可以求出来。</p><p>此时问题就是在集合nums中找出和为left的组合。</p><h4 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h4><p>在回溯算法系列中，一起学过这道题目<a href="https://programmercarl.com/0039.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C.html">回溯算法：39. 组合总和 </a>的录友应该感觉很熟悉，这不就是组合总和问题么？</p><p>此时可以套组合总和的回溯法代码，几乎不用改动。</p><p>当然，也可以转变成序列区间选+ 或者 -，使用回溯法，那就是另一个解法。</p><p>我也把代码给出来吧，大家可以了解一下，回溯的解法，以下是本题转变为组合总和问题的回溯法代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target, <span class="type">int</span> sum, <span class="type">int</span> startIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(path);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 sum + candidates[i] &gt; target 就终止遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; candidates.<span class="built_in">size</span>() &amp;&amp; sum + candidates[i] &lt;= target; i++) &#123;</span><br><span class="line">            sum += candidates[i];</span><br><span class="line">            path.<span class="built_in">push_back</span>(candidates[i]);</span><br><span class="line">            <span class="built_in">backtracking</span>(candidates, target, sum, i + <span class="number">1</span>);</span><br><span class="line">            sum -= candidates[i];</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findTargetSumWays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) sum += nums[i];</span><br><span class="line">        <span class="keyword">if</span> (S &gt; sum) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 此时没有方案</span></span><br><span class="line">        <span class="keyword">if</span> ((S + sum) % <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 此时没有方案，两个int相加的时候要各位小心数值溢出的问题</span></span><br><span class="line">        <span class="type">int</span> bagSize = (S + sum) / <span class="number">2</span>; <span class="comment">// 转变为组合总和问题，bagsize就是要求的和</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 以下为回溯法代码</span></span><br><span class="line">        result.<span class="built_in">clear</span>();</span><br><span class="line">        path.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()); <span class="comment">// 需要排序</span></span><br><span class="line">        <span class="built_in">backtracking</span>(nums, bagSize, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="动态规划-1"><a href="#动态规划-1" class="headerlink" title="动态规划"></a>动态规划</h4><p>如何转化为01背包问题呢。</p><p>假设加法的总和为x，那么减法对应的总和就是sum - x。</p><p>所以我们要求的是 x - (sum - x) &#x3D; S</p><p>x &#x3D; (S + sum) &#x2F; 2</p><p><strong>此时问题就转化为，装满容量为x背包，有几种方法</strong>。</p><p>大家看到(S + sum) &#x2F; 2 应该担心计算的过程中向下取整有没有影响。</p><p>这么担心就对了，例如sum 是5，S是2的话其实就是无解的，所以：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((S + sum) % <span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 此时没有方案</span></span><br></pre></td></tr></table></figure><p>同时如果 S的绝对值已经大于sum，那么也是没有方案的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">abs</span>(S) &gt; sum) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 此时没有方案</span></span><br></pre></td></tr></table></figure><p>再回归到01背包问题，为什么是01背包呢？</p><p>因为每个物品（题目中的1）只用一次！</p><p>这次和之前遇到的背包问题不一样了，之前都是求容量为j的背包，最多能装多少。</p><p>本题则是装满有几种方法。其实这就是一个组合问题了。</p><ol><li>确定dp数组以及下标的含义</li></ol><p>dp[j] 表示：填满j（包括j）这么大容积的包，有dp[j]种方法</p><p>其实也可以使用二维dp数组来求解本题，dp[i][j]：使用 下标为[0, i]的nums[i]能够凑满j（包括j）这么大容量的包，有dp[i][j]种方法。</p><p>下面我都是统一使用一维数组进行讲解， 二维降为一维（滚动数组），其实就是上一层拷贝下来，这个我在<a href="https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-2.html">动态规划：关于01背包问题，你该了解这些！（滚动数组） </a>也有介绍。</p><ol start="2"><li>确定递推公式</li></ol><p>有哪些来源可以推出dp[j]呢？</p><p>不考虑nums[i]的情况下，填满容量为j - nums[i]的背包，有dp[j - nums[i]]种方法。</p><p>那么只要搞到nums[i]的话，凑成dp[j]就有dp[j - nums[i]] 种方法。</p><p>例如：dp[j]，j 为5，</p><ul><li>已经有一个1（nums[i]） 的话，有 dp[4]种方法 凑成 dp[5]。</li><li>已经有一个2（nums[i]） 的话，有 dp[3]种方法 凑成 dp[5]。</li><li>已经有一个3（nums[i]） 的话，有 dp[2]中方法 凑成 dp[5]</li><li>已经有一个4（nums[i]） 的话，有 dp[1]中方法 凑成 dp[5]</li><li>已经有一个5 （nums[i]）的话，有 dp[0]中方法 凑成 dp[5]</li></ul><p>那么凑整dp[5]有多少方法呢，也就是把 所有的 dp[j - nums[i]] 累加起来。</p><p>所以求组合类问题的公式，都是类似这种：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[j] += dp[j - nums[i]]</span><br></pre></td></tr></table></figure><p><strong>这个公式在后面在讲解背包解决排列组合问题的时候还会用到！</strong></p><ol start="3"><li>dp数组如何初始化</li></ol><p>从递归公式可以看出，在初始化的时候dp[0] 一定要初始化为1，因为dp[0]是在公式中一切递推结果的起源，如果dp[0]是0的话，递归结果将都是0。</p><p>dp[0] &#x3D; 1，理论上也很好解释，装满容量为0的背包，有1种方法，就是装0件物品。</p><p>dp[j]其他下标对应的数值应该初始化为0，从递归公式也可以看出，dp[j]要保证是0的初始值，才能正确的由dp[j - nums[i]]推导出来。</p><ol start="4"><li>确定遍历顺序</li></ol><p>在<a href="https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-2.html">动态规划：关于01背包问题，你该了解这些！（滚动数组）</a>中，我们讲过对于01背包问题一维dp的遍历，nums放在外循环，target在内循环，且内循环倒序。</p><ol start="5"><li>举例推导dp数组</li></ol><p>输入：nums: [1, 1, 1, 1, 1], S: 3</p><p>bagSize &#x3D; (S + sum) &#x2F; 2 &#x3D; (3 + 5) &#x2F; 2 &#x3D; 4</p><p>dp数组状态变化如下：</p><p><img src="https://img-blog.csdnimg.cn/20210125120743274.jpg" alt="494.目标和"></p><p>C++代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findTargetSumWays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) sum += nums[i];</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span>(S) &gt; sum) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 此时没有方案</span></span><br><span class="line">        <span class="keyword">if</span> ((S + sum) % <span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 此时没有方案</span></span><br><span class="line">        <span class="type">int</span> bagSize = (S + sum) / <span class="number">2</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(bagSize + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = bagSize; j &gt;= nums[i]; j--) &#123;</span><br><span class="line">                dp[j] += dp[j - nums[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[bagSize];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(n × m)，n为正数个数，m为背包容量</li><li>空间复杂度：O(m)，m为背包容量</li></ul><h2 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h2><p>有N件物品和一个最多能背重量为W的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。<strong>每件物品都有无限个（也就是可以放入背包多次）</strong>，求解将哪些物品装入背包里物品价值总和最大。</p><p><strong>完全背包和01背包问题唯一不同的地方就是，每种物品有无限件</strong>。</p><p>同样leetcode上没有纯完全背包问题，都是需要完全背包的各种应用，需要转化成完全背包问题，所以我这里还是以纯完全背包问题进行讲解理论和原理。</p><p>在下面的讲解中，我依然举这个例子：</p><p>背包最大重量为4。</p><p>物品为：</p><table><thead><tr><th></th><th>重量</th><th>价值</th></tr></thead><tbody><tr><td>物品0</td><td>1</td><td>15</td></tr><tr><td>物品1</td><td>3</td><td>20</td></tr><tr><td>物品2</td><td>4</td><td>30</td></tr></tbody></table><p><strong>每件商品都有无限个！</strong></p><p>问背包能背的物品最大价值是多少？</p><p>01背包和完全背包唯一不同就是体现在遍历顺序上，所以本文就不去做动规五部曲了，我们直接针对遍历顺序经行分析！</p><p>首先在回顾一下01背包的核心代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; weight.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = bagWeight; j &gt;= weight[i]; j--) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">        dp[j] = <span class="built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们知道01背包内嵌的循环是从大到小遍历，为了保证每个物品仅被添加一次。</p><p>而完全背包的物品是可以添加多次的，所以要从小到大去遍历，即：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先遍历物品，再遍历背包</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; weight.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = weight[i]; j &lt;= bagWeight ; j++) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">        dp[j] = <span class="built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dp状态图如下：</p><p><img src="https://img-blog.csdnimg.cn/20210126104510106.jpg" alt="动态规划-完全背包"></p><p>相信很多同学看网上的文章，关于完全背包介绍基本就到为止了。</p><p><strong>其实还有一个很重要的问题，为什么遍历物品在外层循环，遍历背包容量在内层循环？</strong></p><p>这个问题很多题解关于这里都是轻描淡写就略过了，大家都默认 遍历物品在外层，遍历背包容量在内层，好像本应该如此一样，那么为什么呢？</p><p>难道就不能遍历背包容量在外层，遍历物品在内层？</p><p>看过这两篇的话：</p><ul><li><a href="https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-1.html">动态规划：关于01背包问题，你该了解这些！</a></li><li><a href="https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-2.html">动态规划：关于01背包问题，你该了解这些！（滚动数组）</a></li></ul><p>就知道了，01背包中二维dp数组的两个for遍历的先后循序是可以颠倒了，一维dp数组的两个for循环先后循序一定是先遍历物品，再遍历背包容量。</p><p><strong>在完全背包中，对于一维dp数组来说，其实两个for循环嵌套顺序同样无所谓！</strong></p><p>因为dp[j] 是根据 下标j之前所对应的dp[j]计算出来的。 只要保证下标j之前的dp[j]都是经过计算的就可以了。</p><p>遍历物品在外层循环，遍历背包容量在内层循环，状态如图：</p><p><img src="https://img-blog.csdnimg.cn/20210126104529605.jpg" alt="动态规划-完全背包1"></p><p>遍历背包容量在外层循环，遍历物品在内层循环，状态如图：</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210729234011.png" alt="动态规划-完全背包2"></p><p>看了这两个图，大家就会理解，完全背包中，两个for循环的先后循序，都不影响计算dp[j]所需要的值（这个值就是下标j之前所对应的dp[j]）。</p><p>先遍历背包在遍历物品，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先遍历背包，再遍历物品</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= bagWeight; j++) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; weight.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">        <span class="keyword">if</span> (j - weight[i] &gt;= <span class="number">0</span>) dp[j] = <span class="built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="零钱兑换"><a href="#零钱兑换" class="headerlink" title="零钱兑换"></a><a href="https://leetcode-cn.com/problems/coin-change-2/">零钱兑换</a></h2><p>给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。</p><p>示例 1:</p><p>输入: amount &#x3D; 5, coins &#x3D; [1, 2, 5] </p><p>输出: 4 </p><p>解释: 有四种方式可以凑成总金额: 5&#x3D;5 5&#x3D;2+2+1 5&#x3D;2+1+1+1 5&#x3D;1+1+1+1+1</p><p>示例 2: </p><p>输入: amount &#x3D; 3, coins &#x3D; [2] </p><p>输出: 0 </p><p>解释: 只用面额2的硬币不能凑成总金额3。</p><p>示例 3: </p><p>输入: amount &#x3D; 10, coins &#x3D; [10] </p><p>输出: 1</p><p>注意，你可以假设：</p><ul><li>0 &lt;&#x3D; amount (总金额) &lt;&#x3D; 5000</li><li>1 &lt;&#x3D; coin (硬币面额) &lt;&#x3D; 5000</li><li>硬币种类不超过 500 种</li><li>结果符合 32 位符号整数</li></ul><h3 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h3><p>这是一道典型的背包问题，一看到钱币数量不限，就知道这是一个完全背包。</p><p>对完全背包还不了解的同学，可以看这篇：<a href="https://programmercarl.com/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85.html">动态规划：关于完全背包，你该了解这些！</a></p><p>但本题和纯完全背包不一样，<strong>纯完全背包是能否凑成总金额，而本题是要求凑成总金额的个数！</strong></p><p>注意题目描述中是凑成总金额的硬币组合数，为什么强调是组合数呢？</p><p>例如示例一：</p><p>5 &#x3D; 2 + 2 + 1</p><p>5 &#x3D; 2 + 1 + 2</p><p>这是一种组合，都是 2 2 1。</p><p>如果问的是排列数，那么上面就是两种排列了。</p><p><strong>组合不强调元素之间的顺序，排列强调元素之间的顺序</strong>。 其实这一点我们在讲解回溯算法专题的时候就讲过了哈。</p><p>那我为什么要介绍这些呢，因为这和下文讲解遍历顺序息息相关!</p><p>回归本题，动规五步曲来分析如下：</p><ol><li>确定dp数组以及下标的含义</li></ol><p>dp[j]：凑成总金额j的货币组合数为dp[j]</p><ol start="2"><li>确定递推公式</li></ol><p>dp[j] （考虑coins[i]的组合总和） 就是所有的dp[j - coins[i]]（不考虑coins[i]）相加。</p><p>所以递推公式：dp[j] +&#x3D; dp[j - coins[i]];</p><p><strong>这个递推公式大家应该不陌生了，我在讲解01背包题目的时候在这篇<a href="https://programmercarl.com/0494.%E7%9B%AE%E6%A0%87%E5%92%8C.html">动态规划：目标和！</a>中就讲解了，求装满背包有几种方法，一般公式都是：dp[j] +&#x3D; dp[j - nums[i]];</strong></p><ol start="3"><li>dp数组如何初始化</li></ol><p>首先dp[0]一定要为1，dp[0] &#x3D; 1是 递归公式的基础。</p><p>从dp[i]的含义上来讲就是，凑成总金额0的货币组合数为1。</p><p>下标非0的dp[j]初始化为0，这样累计加dp[j - coins[i]]的时候才不会影响真正的dp[j]</p><ol start="4"><li>确定遍历顺序</li></ol><p>本题中我们是外层for循环遍历物品（钱币），内层for遍历背包（金钱总额），还是外层for遍历背包（金钱总额），内层for循环遍历物品（钱币）呢？</p><p>我在<a href="https://programmercarl.com/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85.html">动态规划：关于完全背包，你该了解这些！ </a>中讲解了完全背包的两个for循环的先后顺序都是可以的。</p><p><strong>但本题就不行了！</strong></p><p>因为纯完全背包求得是能否凑成总和，和凑成总和的元素有没有顺序没关系，即：有顺序也行，没有顺序也行！</p><p>而本题要求凑成总和的组合数，元素之间要求没有顺序。</p><p>所以纯完全背包是能凑成总和就行，不用管怎么凑的。</p><p>本题是求凑出来的方案个数，且每个方案个数是为组合数。</p><p>那么本题，两个for循环的先后顺序可就有说法了。</p><p>我们先来看 外层for循环遍历物品（钱币），内层for遍历背包（金钱总额）的情况。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; coins.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = coins[i]; j &lt;= amount; j++) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">        dp[j] += dp[j - coins[i]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设：coins[0] &#x3D; 1，coins[1] &#x3D; 5。</p><p>那么就是先把1加入计算，然后再把5加入计算，得到的方法数量只有{1, 5}这种情况。而不会出现{5, 1}的情况。</p><p><strong>所以这种遍历顺序中dp[j]里计算的是组合数！</strong></p><p>如果把两个for交换顺序，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= amount; j++) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; coins.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">        <span class="keyword">if</span> (j - coins[i] &gt;= <span class="number">0</span>) dp[j] += dp[j - coins[i]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>背包容量的每一个值，都是经过 1 和 5 的计算，包含了{1, 5} 和 {5, 1}两种情况。</p><p><strong>此时dp[j]里算出来的就是排列数！</strong></p><p>可能这里很多同学还不是很理解，<strong>建议动手把这两种方案的dp数组数值变化打印出来，对比看一看！（实践出真知）</strong></p><ol start="5"><li>举例推导dp数组</li></ol><p>输入: amount &#x3D; 5, coins &#x3D; [1, 2, 5] ，dp状态图如下：</p><p><img src="https://img-blog.csdnimg.cn/20210120181331461.jpg" alt="518.零钱兑换II"></p><p>最后红色框dp[amount]为最终结果。</p><p>以上分析完毕，C++代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">change</span><span class="params">(<span class="type">int</span> amount, vector&lt;<span class="type">int</span>&gt;&amp; coins)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(amount + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; coins.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = coins[i]; j &lt;= amount; j++) &#123; <span class="comment">// 遍历背包</span></span><br><span class="line">                dp[j] += dp[j - coins[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="组合总和-Ⅳ"><a href="#组合总和-Ⅳ" class="headerlink" title="组合总和 Ⅳ"></a><a href="https://leetcode-cn.com/problems/combination-sum-iv/">组合总和 Ⅳ</a></h2><p>给定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。</p><p>示例:</p><p>nums &#x3D; [1, 2, 3] target &#x3D; 4</p><p>所有可能的组合为： (1, 1, 1, 1) (1, 1, 2) (1, 2, 1) (1, 3) (2, 1, 1) (2, 2) (3, 1)</p><p>请注意，顺序不同的序列被视作不同的组合。</p><p>因此输出为 7。</p><h3 id="思路-11"><a href="#思路-11" class="headerlink" title="思路"></a>思路</h3><p>本题题目描述说是求组合，但又说是可以元素相同顺序不同的组合算两个组合，<strong>其实就是求排列！</strong></p><p>弄清什么是组合，什么是排列很重要。</p><p>组合不强调顺序，(1,5)和(5,1)是同一个组合。</p><p>排列强调顺序，(1,5)和(5,1)是两个不同的排列。</p><p>大家在公众号里学习回溯算法专题的时候，一定做过这两道题目<a href="https://programmercarl.com/0039.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C.html">回溯算法：39.组合总和 </a>和<a href="https://programmercarl.com/0040.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CII.html">回溯算法：40.组合总和II</a>会感觉这两题和本题很像！</p><p>但其本质是本题求的是排列总和，而且仅仅是求排列总和的个数，并不是把所有的排列都列出来。</p><p><strong>如果本题要把排列都列出来的话，只能使用回溯算法爆搜</strong>。</p><p>动规五部曲分析如下：</p><ol><li>确定dp数组以及下标的含义</li></ol><p><strong>dp[i]: 凑成目标正整数为i的排列个数为dp[i]</strong></p><ol start="2"><li>确定递推公式</li></ol><p>dp[i]（考虑nums[j]）可以由 dp[i - nums[j]]（不考虑nums[j]） 推导出来。</p><p>因为只要得到nums[j]，排列个数dp[i - nums[j]]，就是dp[i]的一部分。</p><p>在<a href="https://programmercarl.com/0494.%E7%9B%AE%E6%A0%87%E5%92%8C.html">动态规划：494.目标和</a>和 <a href="https://programmercarl.com/0518.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2II.html">动态规划：518.零钱兑换II</a>中我们已经讲过了，求装满背包有几种方法，递推公式一般都是dp[i] +&#x3D; dp[i - nums[j]];</p><p>本题也一样。</p><ol start="3"><li>dp数组如何初始化</li></ol><p>因为递推公式dp[i] +&#x3D; dp[i - nums[j]]的缘故，dp[0]要初始化为1，这样递归其他dp[i]的时候才会有数值基础。</p><p>至于dp[0] &#x3D; 1 有没有意义呢？</p><p>其实没有意义，所以我也不去强行解释它的意义了，因为题目中也说了：给定目标值是正整数！ 所以dp[0] &#x3D; 1是没有意义的，仅仅是为了推导递推公式。</p><p>至于非0下标的dp[i]应该初始为多少呢？</p><p>初始化为0，这样才不会影响dp[i]累加所有的dp[i - nums[j]]。</p><ol start="4"><li>确定遍历顺序</li></ol><p>个数可以不限使用，说明这是一个完全背包。</p><p>得到的集合是排列，说明需要考虑元素之间的顺序。</p><p>本题要求的是排列，那么这个for循环嵌套的顺序可以有说法了。</p><p>在<a href="https://programmercarl.com/0518.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2II.html">动态规划：518.零钱兑换II</a>中就已经讲过了。</p><p><strong>如果求组合数就是外层for循环遍历物品，内层for遍历背包</strong>。</p><p><strong>如果求排列数就是外层for遍历背包，内层for循环遍历物品</strong>。</p><p>如果把遍历nums（物品）放在外循环，遍历target的作为内循环的话，举一个例子：计算dp[4]的时候，结果集只有 {1,3} 这样的集合，不会有{3,1}这样的集合，因为nums遍历放在外层，3只能出现在1后面！</p><p>所以本题遍历顺序最终遍历顺序：<strong>target（背包）放在外循环，将nums（物品）放在内循环，内循环从前到后遍历</strong>。</p><ol start="5"><li>举例来推导dp数组</li></ol><p>我们再来用示例中的例子推导一下：</p><p><img src="https://img-blog.csdnimg.cn/20210131174250148.jpg" alt="377.组合总和Ⅳ"></p><p>如果代码运行处的结果不是想要的结果，就把dp[i]都打出来，看看和我们推导的一不一样。</p><p>以上分析完毕，C++代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">combinationSum4</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(target + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= target; i++) &#123; <span class="comment">// 遍历背包</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; nums.<span class="built_in">size</span>(); j++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">                <span class="keyword">if</span> (i - nums[j] &gt;= <span class="number">0</span> &amp;&amp; dp[i] &lt; INT_MAX - dp[i - nums[j]]) &#123;</span><br><span class="line">                    dp[i] += dp[i - nums[j]];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="爬楼梯-1"><a href="#爬楼梯-1" class="headerlink" title="爬楼梯"></a>爬楼梯</h2><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p>注意：给定 n 是一个正整数。</p><p>示例 1： 输入： 2 输出： 2 解释： 有两种方法可以爬到楼顶。</p><ol><li>1 阶 + 1 阶</li><li>2 阶</li></ol><p>示例 2： 输入： 3 输出： 3 解释： 有三种方法可以爬到楼顶。</p><ol><li>1 阶 + 1 阶 + 1 阶</li><li>1 阶 + 2 阶</li><li>2 阶 + 1 阶</li></ol><h3 id="思路-12"><a href="#思路-12" class="headerlink" title="思路"></a>思路</h3><p>这道题目 我们在<a href="https://programmercarl.com/0070.%E7%88%AC%E6%A5%BC%E6%A2%AF.html">动态规划：爬楼梯 </a>中已经讲过一次了，原题其实是一道简单动规的题目。</p><p>既然这么简单为什么还要讲呢，其实本题稍加改动就是一道面试好题。</p><p><strong>改为：一步一个台阶，两个台阶，三个台阶，…….，直到 m个台阶。问有多少种不同的方法可以爬到楼顶呢？</strong></p><p>1阶，2阶，…. m阶就是物品，楼顶就是背包。</p><p>每一阶可以重复使用，例如跳了1阶，还可以继续跳1阶。</p><p>问跳到楼顶有几种方法其实就是问装满背包有几种方法。</p><p><strong>此时大家应该发现这就是一个完全背包问题了！</strong></p><p>和昨天的题目<a href="https://programmercarl.com/0377.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%E2%85%A3.html">动态规划：377. 组合总和 Ⅳ </a>基本就是一道题了。</p><p>动规五部曲分析如下：</p><ol><li>确定dp数组以及下标的含义</li></ol><p><strong>dp[i]：爬到有i个台阶的楼顶，有dp[i]种方法</strong>。</p><ol start="2"><li>确定递推公式</li></ol><p>在<a href="https://programmercarl.com/0494.%E7%9B%AE%E6%A0%87%E5%92%8C.html">动态规划：494.目标和</a>、 <a href="https://programmercarl.com/0518.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2II.html">动态规划：518.零钱兑换II </a>、<a href="https://programmercarl.com/0377.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%E2%85%A3.html">动态规划：377. 组合总和 Ⅳ </a>中我们都讲过了，求装满背包有几种方法，递推公式一般都是dp[i] +&#x3D; dp[i - nums[j]];</p><p>本题呢，dp[i]有几种来源，dp[i - 1]，dp[i - 2]，dp[i - 3] 等等，即：dp[i - j]</p><p>那么递推公式为：dp[i] +&#x3D; dp[i - j]</p><ol start="3"><li>dp数组如何初始化</li></ol><p>既然递归公式是 dp[i] +&#x3D; dp[i - j]，那么dp[0] 一定为1，dp[0]是递归中一切数值的基础所在，如果dp[0]是0的话，其他数值都是0了。</p><p>下标非0的dp[i]初始化为0，因为dp[i]是靠dp[i-j]累计上来的，dp[i]本身为0这样才不会影响结果</p><ol start="4"><li>确定遍历顺序</li></ol><p>这是背包里求排列问题，即：<strong>1、2 步 和 2、1 步都是上三个台阶，但是这两种方法不一样！</strong></p><p>所以需将target放在外循环，将nums放在内循环。</p><p>每一步可以走多次，这是完全背包，内循环需要从前向后遍历。</p><ol start="5"><li>举例来推导dp数组</li></ol><p>介于本题和<a href="https://programmercarl.com/0377.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%E2%85%A3.html">动态规划：377. 组合总和 Ⅳ </a>几乎是一样的，这里我就不再重复举例了。</p><p>以上分析完毕，C++代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123; <span class="comment">// 遍历背包</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">                <span class="keyword">if</span> (i - j &gt;= <span class="number">0</span>) dp[i] += dp[i - j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>代码中m表示最多可以爬m个台阶，代码中把m改成2就是本题70.爬楼梯可以AC的代码了。</p><p>声明：</p><p>本博客整理参考《代码随想录》，题目来自leecode</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UE4 C++ 默认生成代码详解</title>
      <link href="/2022/04/19/UE4-C-%E9%BB%98%E8%AE%A4%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/"/>
      <url>/2022/04/19/UE4-C-%E9%BB%98%E8%AE%A4%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>本系列算是学习笔记，我也是在边学边整理。</p><p>如果有说的不对的地方，欢迎大佬指正，也欢迎友好讨论。</p><p>有关unreal engine C++</p><p>我愿称之为U++</p><p>其在C++原本的基础上魔改了很多东西进去</p><p>说实话门槛还是比较高的，在学习U++之前，我们必须掌握一些前置条件。</p><h2 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h2><ol><li><p><a href="http://c.biancheng.net/view/228.html">指针与函数指针</a></p></li><li><p><a href="http://c.biancheng.net/cplus/polymorphism/">面向对象的特征与多态</a></p></li><li><p><a href="http://c.biancheng.net/cplus/70/">模板函数和模板类</a></p></li><li><p><a href="http://c.biancheng.net/stl/sequence_container/">容器</a></p></li></ol><p>如果你已经掌握了以上知识，那么现在就可以开始U++的学习啦！</p><p>如果没有，那可以点进以上的链接，可以到C语言中文网中学习（这个网站把很多知识点都讲得深入浅出！真的超棒！）</p><h1 id="在unreal-engine中生成C-类"><a href="#在unreal-engine中生成C-类" class="headerlink" title="在unreal engine中生成C++类"></a>在unreal engine中生成C++类</h1><p>版本：4.27.2</p><p>文件-&gt;新建C++类</p><p><img src="D:\R_programme\Blog\source\images\CreatC++1.jpg"></p><p>选择一个父类（我在这里选的是Actor）</p><p><img src="D:\R_programme\Blog\source\images\CreatC++2.jpg"></p><p>接下来一路下一步就ok了</p><p>注意！在生成C++类的时候，<strong>路径中不能有中文字符</strong>，那样会导致创建失败</p><p>所以最好连带项目名称和C++类名称均为符合C++文件命名标准的英文字符</p><p>在此处，我的项目名称为TestOne，C++对象名称为Foating</p><p>在创建完成后，将会自动打开vs2019</p><p>此时我们看向资源管理器，在Game&#x2F;TestOne&#x2F;Source&#x2F;TestOne&#x2F;下我们会发现两个文件</p><p>Foating.h以及Foating.cpp</p><p><img src="D:\R_programme\Blog\source\images\CreatC++3.jpg"></p><h1 id="默认生成代码讲解"><a href="#默认生成代码讲解" class="headerlink" title="默认生成代码讲解"></a>默认生成代码讲解</h1><p>我们先看Foating.h以及Foating.cpp，其他的以后再说（其实是我也暂时只理解了这两个）</p><h2 id="Foating-h"><a href="#Foating-h" class="headerlink" title="Foating.h"></a>Foating.h</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Fill out your copyright notice in the Description page of Project Settings.#pragma once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CoreMinimal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GameFramework/Actor.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Foating.generated.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TESTONE_API</span><span class="comment">/*项目名*/</span> AFoating<span class="comment">/*生成的对象名*/</span> : <span class="keyword">public</span> AActor</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="comment">// Sets default values for this actor&#x27;s properties</span></span><br><span class="line">    <span class="comment">//默认构造函数</span></span><br><span class="line">    <span class="built_in">AFoating</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// Called when the game starts or when spawned</span></span><br><span class="line">    <span class="comment">//当游戏开始时就调用函数</span></span><br><span class="line">    <span class="keyword">virtual</span><span class="comment">/*虚函数*/</span> <span class="function"><span class="type">void</span> <span class="title">BeginPlay</span><span class="params">()</span> <span class="keyword">override</span><span class="comment">/*表示覆盖一个函数并将其重写*/</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="comment">// Called every frame</span></span><br><span class="line">    <span class="comment">//逐帧调用函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Tick</span><span class="params">(<span class="type">float</span> DeltaTime)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="include-“CoreMinimal-h”"><a href="#include-“CoreMinimal-h”" class="headerlink" title="#include “CoreMinimal.h”"></a>#include “CoreMinimal.h”</h3><p>代表来自一套UE4核心变成环境的普遍存在类型</p><p>我们可以简单地把它理解为类似<code>#include &lt;iostream&gt;</code>和<code>#include &lt;ostream&gt;</code>之间的关系。此头文件只包含一些核心重要的功能，如果需要其他的功能，还需要应用其他头文件。</p><h3 id="include-“GameFramework-x2F-Actor-h”"><a href="#include-“GameFramework-x2F-Actor-h”" class="headerlink" title="#include “GameFramework&#x2F;Actor.h”"></a>#include “GameFramework&#x2F;Actor.h”</h3><p>表示包含了来自Actor的头文件——记得吗？我们创建的时候选择以Actor为父类</p><h3 id="include-Foating-generated-h"><a href="#include-Foating-generated-h" class="headerlink" title="#include Foating.generated.h"></a>#include Foating.generated.h</h3><p>表示包含了UE4中<code>反射机制</code>所生成的代码，且此行代码必须为#include中的最后一行</p><h4 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a><a href="https://blog.csdn.net/u012999985/article/details/52902065">反射机制</a></h4><p>所谓反射，是程序在运行时进行自检的一种能力，自检什么呢？就是检查自己的C++类，函数，成员变量，结构体等等（对应起来也就是大家在UE4能看到的UCLASS，UFUNCTON，UPROPERTY，USTRUCT后面还会提到）</p><p>那检查这些东西做什么呢？最明显的就是支持蓝图和C++的交互功能，说的更通俗一点，就是可以更自由的控制这些结构，让他在我们想出现的地方出现，让他在我们想使用的地方使用。</p><p>要知道我们在虚幻4中声明的任意一个类，都是继承于UObject类的，所以他远远不是我们所以为的那个普通的C++类。我们可以使用这个类进行网络复制，执行垃圾回收，让他和蓝图交互等等。而这一切原生的C++是并不支持的，也正是因此虚幻4才构建了一个这样的反射系统。</p><p>在UE4里面， 基本上所有的游戏工程的类都需要用到。比如，你用编辑器新建一个类，类的前面会自动添加UCLASS()；新建一个结构体，需要使用USTRUCT()；新建一个枚举变量，需要在前面声明UENUM()；在类的里面，也必须要加上GENERATED_UCLASS_BODY()才行。</p><p>如果你想让你的变量能显示在编辑器里面，想让你的函数可以被蓝图调用或者通过让这个函数实现RPC网络通信功能，或者你想让你的变量被系统自动的回收，这些都离不开反射系统以及这些宏定义。</p><p>所以，我们这里起码能认识到，在网络通信，蓝图交互以及垃圾回收方面，这与反射系统是密不可分的。</p><p>另外，如果要说引擎中哪部分使用到反射系统功能的话，那基本上整个引擎都脱不了干系了。</p><h3 id="UCLASS"><a href="#UCLASS" class="headerlink" title="UCLASS()"></a>UCLASS()</h3><p>这个东西就和上面提到的反射机制有关了！</p><p>在UE4里面，你无时无刻都会看到类似UFUNCTION（）这样的宏。官方文档告诉你，只要在一个函数的前面加上这个宏，然后在括号里面加上BlueprintCallable就可以在编辑器里面调用了。按照他的指示，我们就能让我们的函数实现各种各样特别的功能，那这个效果就是通过UE4的反射系统来实现的。</p><h3 id="GENERATED-BODY"><a href="#GENERATED-BODY" class="headerlink" title="GENERATED_BODY()"></a>GENERATED_BODY()</h3><p>这是一个宏定义，表示在调用此宏的时候，会先调用上一层的父类中的函数</p><p>UE4将这个标记替换为将为该类型生成的所有必要的样板代码</p><p>也就是说U++在C++上包了伊恩，使其支持类似反射，序列化之类原本C++没有的功能</p><h2 id="Foating-cpp"><a href="#Foating-cpp" class="headerlink" title="Foating.cpp"></a>Foating.cpp</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Fill out your copyright notice in the Description page of Project Settings.</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Foating.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Sets default values</span></span><br><span class="line">AFoating::<span class="built_in">AFoating</span>()</span><br><span class="line">&#123;</span><br><span class="line">     <span class="comment">// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don&#x27;t need it.</span></span><br><span class="line">    <span class="comment">//将actor设为逐帧调用Tick()，如果不需要，将其改为false可以提高性能</span></span><br><span class="line">    PrimaryActorTick.bCanEverTick = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Called when the game starts or when spawned</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFoating::BeginPlay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//super表示调用父类有参数的构造函数，也必须放在子类的构造函数里面（成员函数不行）</span></span><br><span class="line">    <span class="comment">//并且只能放在构造函数的首句，其中x,y,z是指的与父类此有参构造函数中参数数据类型相对应的子类中的参数</span></span><br><span class="line">    Super::<span class="built_in">BeginPlay</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Called every frame</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFoating::Tick</span><span class="params">(<span class="type">float</span> DeltaTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">Tick</span>(DeltaTime);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里基本上就是注释的内容</p><p>唯一需要注意的就是Super这个关键字，刚开始看的时候我也是懵圈的，这嘛玩意啊？</p><p>后来才发现，原来这玩意是JAVA里面的内容</p><h3 id="super在JAVA中的定义"><a href="#super在JAVA中的定义" class="headerlink" title="super在JAVA中的定义"></a><a href="https://blog.csdn.net/m0_63093628/article/details/122633358">super在JAVA中的定义</a></h3><p>1、当子类与父类有同名的属性时，可以通过super。属性的方式调用父类中生命的属性。</p><p>2、当子类重写父类的方法后，在子类中若想调用父类中被重写的方法时，需用super.的方法</p><p>3、super修饰构造器，通过在子类中使用super列表参数的形式调用父类中制定的构造器</p><pre><code>    a、在构造器内部，super（参数列表）必须声明在首行    b、在构造器内部，this（参数列表）或super（参数列表）只能出现一个    c、当构造器中不显示的调用this（参数列表）或super（参数列表）默认调用父类中的空参                 构造器</code></pre><h3 id="super在unreal-engine中的应用"><a href="#super在unreal-engine中的应用" class="headerlink" title="super在unreal engine中的应用"></a><a href="https://blog.csdn.net/weixin_43575837/article/details/103270755">super在unreal engine中的应用</a></h3><p>但当super放在unreal engine中的时候，它<strong>主要是用来重写父类虚函数</strong></p><p>Super是父类的类型别名，其定义是：Typedef 父类名 子类名::Super</p><p>在子类中使用Super，是对父类成员函数、成员变量的调用</p><p>下面举例说明：<br>分别创建父类AMyActor、子类AMyMyActor</p><p>在AMyActor中设置虚函数Content()和变量value：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="keyword">virtual</span> <span class="title">Content</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"><span class="comment">//定义</span></span><br><span class="line">AMyActor::<span class="built_in">AMyActor</span>()</span><br><span class="line">&#123;</span><br><span class="line">    PrimaryActorTick.bCanEverTick = <span class="literal">true</span>;</span><br><span class="line">    value = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMyActor::Content</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    GEngine-&gt;<span class="built_in">AddOnScreenDebugMessage</span>(<span class="number">-1</span>, <span class="number">5.0f</span>, FColor::Yellow, <span class="built_in">TEXT</span>(<span class="string">&quot;This is MyActor&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在子类中重写Content()函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="keyword">virtual</span> <span class="title">Content</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="comment">//定义</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMyMyActor::Content</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">Content</span>(); <span class="comment">//Typedef AMyActor Super::AMyMyActor</span></span><br><span class="line">    GEngine-&gt;<span class="built_in">AddOnScreenDebugMessage</span>(<span class="number">-1</span>, <span class="number">5.0f</span>, FColor::Yellow, <span class="built_in">TEXT</span>(<span class="string">&quot;This is MyMyActor&quot;</span>));</span><br><span class="line">    Super::value = <span class="number">2</span>;</span><br><span class="line">    GEngine-&gt;<span class="built_in">AddOnScreenDebugMessage</span>(<span class="number">-1</span>, <span class="number">5.0f</span>, FColor::Yellow, FString::<span class="built_in">Printf</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;value = %d&quot;</span>), value));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有关super的注意事项</p><ul><li><p>只能放在子类的构造函数里面（成员函数不行）</p></li><li><p>只能放在构造函数的首句</p></li></ul><p>版权声明：</p><ul><li><p>本博客根据哔哩哔哩up主<code>来自程序员的暴击</code>创作的<a href="https://www.bilibili.com/video/BV14K411J7v2?p=1">虚幻四C++入坑指南合集版</a>进行整理</p></li><li><p>反射机制的解释参考自CSDN博主「Jerish_C」</p></li><li><p>super内容参考自CSDN博主「虾仁不眨眼i」</p></li><li><p>super在unreal engine中的应用参考自CSDN博主「<a href="http://www.www.www」/">www.www.www」</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> unreal engine </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有关unreal engine中的术语</title>
      <link href="/2022/04/13/UE4-%E6%9C%AF%E8%AF%AD/"/>
      <url>/2022/04/13/UE4-%E6%9C%AF%E8%AF%AD/</url>
      
        <content type="html"><![CDATA[<h1 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h1><p><strong>虚幻引擎4项目（Project）</strong> 保存着构成游戏所需的所有内容和代码。项目在你的电脑硬盘上由许多目录构成，例如 <code>蓝图</code> 和 <code>材质</code>。你可以随时修改项目目录的名称和层级关系。</p><p><strong>虚幻编辑器</strong> 中的 <strong>内容浏览器</strong> 所展示的目录结构和你在硬盘上看到的 <code>项目</code> 目录结构相同。</p><h1 id="蓝图"><a href="#蓝图" class="headerlink" title="蓝图"></a>蓝图</h1><p>一种可视化脚本系统，允许在虚幻蓝图编辑器中通过基于节点的界面来创建游戏元素。和许多常见的脚本语言一样，你可以用它在引擎中定义面向对象的类或object。</p><p>在使用unreal engine时，使用蓝图定义的类一般也称为蓝图。</p><h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><p>在虚幻引擎中，最基本的类叫做 <strong>Object</strong>。换句话说，它就像最基本的构建单位，包含了资产的基本功能。虚幻引擎中的大多数类都继承自Object（或从中获取部分功能）。</p><p>在C++中，<code>UObject</code> 是所有Object的基类，包含各类功能，诸如垃圾回收、通过元数据（UProperty）将变量公开给编辑器，以及保存和加载时的序列化功能。</p><h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><p><strong>类（Class）</strong> 用于定义虚幻引擎中Actor或对象的行为和属性。类可以被继承，这意味着某个类可以从其父类（衍生或派生出该类的类）获得信息，然后再将信息传递给子类。类可用C++代码或蓝图创建。</p><h1 id="Actor"><a href="#Actor" class="headerlink" title="Actor"></a>Actor</h1><p>所有可以放入关卡的对象都是 <strong>Actor</strong>，比如摄像机、静态网格体、玩家起始位置。Actor支持三维变换，例如平移、旋转和缩放。你可以通过游戏逻辑代码（C++或蓝图）创建（生成）或销毁Actor。</p><p>在C++中，<strong>AActor</strong>是所有Actor的基类。</p><h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><p><strong>类型转换（Casting）</strong> 本质上是获取某个特定Actor（或类），然后将它视为另一种类进行处理。类型转换可以成功，也可以失败。如果转换成功，你就能访问目标Actor的特有函数和功能。</p><p>举个例子，你希望在游戏中创建多种Actor，让它们以不同方式影响玩家。其中一个Actor是 <strong>火焰</strong>，它会不断伤害玩家生命值。当玩家遇到关卡中的Actor时，你可以将该Actor <strong>转换</strong> 成 <strong>火焰</strong>，以此访问它的”伤害玩家”函数。</p><ul><li><p>如果转换成功，表示玩家站在火中，那么玩家生命值就会开始减少。</p></li><li><p>如果转换失败，表示玩家站在其他Actor中，那么生命值不会减少。</p></li></ul><p>类型转换不同于单纯地检查某个Actor是否属于某个类，然后返回一个二元值（是或否）；这种情况下，你无法访问该类的函数。</p><h1 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h1><p><strong>组件（Component）</strong> 是可以添加到Actor上的一项功能。</p><p>当你为Actor添加组件后，该Actor便获得了该组件所提供的功能。例如：</p><ul><li><p>聚光灯组件（Spot Light Component）允许你的Actor像聚光灯一样发光，</p></li><li><p>旋转移动组件（Rotating Movement Component）能使你的Actor四处旋转，</p></li><li><p>音频组件（Audio Component）将使你的Actor能够播放声音。</p></li></ul><p>组件必须绑定在Actor身上，它们无法单独存在。</p><h1 id="Pawn"><a href="#Pawn" class="headerlink" title="Pawn"></a>Pawn</h1><p><strong>Pawn</strong> 是Actor的子类，它可以充当游戏中的化身或人物（例如游戏中的角色）。Pawn可以由玩家控制，也可以由游戏AI控制并以非玩家角色（NPC）的形式存在于游戏中。</p><p>当Pawn被人类玩家或AI玩家控制时，它被视为 <strong>已被控制（Possessed）</strong>。相反，当Pawn未被人类玩家或AI玩家控制时，它被视为 <strong>未被控制（Unpossessed）</strong>。</p><h1 id="角色（character）"><a href="#角色（character）" class="headerlink" title="角色（character）"></a>角色（character）</h1><p><strong>角色（Character）</strong> 是Pawn Actor的子类，旨在用作玩家角色。角色子类包括碰撞设置、双足运动的输入绑定，以及用于控制运动的附加代码。</p><h1 id="玩家控制器"><a href="#玩家控制器" class="headerlink" title="玩家控制器"></a>玩家控制器</h1><p><strong>玩家控制器（Player Controller）</strong> 会获取游戏中玩家的输入信息，然后转换为交互效果，每个游戏中至少有一个玩家控制器。玩家控制器通常会控制一个Pawn或角色，将其作为玩家在游戏中的化身。</p><p>玩家控制器还是多人游戏中的主要网络交互节点。在多人游戏中，服务器会为游戏中的每个玩家生成一个玩家控制器实例，因为它必须对每个玩家进行网络函数调用。每个客户端只拥有与其玩家相对应的玩家控制器，并且只能使用其玩家控制器与服务器通信。</p><p>相关的C++类是 <code>PlayerController</code>。</p><h1 id="AI控制器"><a href="#AI控制器" class="headerlink" title="AI控制器"></a>AI控制器</h1><p>玩家控制器通过控制Pawn来表示游戏中的玩家，与此类似，<strong>AI控制器</strong> 通过控制Pawn来表示游戏中的非玩家角色（NPC）。</p><p>默认情况下，Pawn和角色最终都会由基本的AI控制器控制，除非它们被指定通过玩家控制器控制，或被告知不需要为它们自己创建AI控制器。</p><p>关联的C++类是 <code>AIController</code>。</p><h1 id="玩家状态"><a href="#玩家状态" class="headerlink" title="玩家状态"></a>玩家状态</h1><p><strong>玩家状态（Player State）</strong> 表示某个游戏参与者的状态，可以是人类玩家，也可以是模拟玩家的机器人。作为游戏场景的一部分而存在的非玩家类AI不会有玩家状态。</p><p>玩家状态（Player State）能包括的玩家信息包括：</p><ul><li><p>名称</p></li><li><p>当前关卡</p></li><li><p>生命值</p></li><li><p>分数</p></li><li><p>在某些抢旗游戏中，玩家当前是否携带旗子。</p></li></ul><p>在多人游戏中，所有电脑都保存着所有玩家的玩家状态，并且玩家状态可以将数据从服务器复制到客户端以保持同步。这点与玩家控制器不同，它只会保存在玩家所在的客户端上。</p><p>关联的C++类是 <code>PlayerState</code>。</p><h1 id="游戏模式"><a href="#游戏模式" class="headerlink" title="游戏模式"></a>游戏模式</h1><p><strong>游戏模式（GameMode）</strong> 类负责设置当前游戏的规则。规则包括：</p><ul><li><p>玩家如何加入游戏。</p></li><li><p>是否可以暂停游戏。</p></li><li><p>任何与游戏相关的行为，例如获胜条件。</p></li></ul><p>你可以在 <a href="https://docs.unrealengine.com/4.27/zh-CN/Basics/Projects/ProjectSettings">项目设置</a> 中设置默认的游戏模式，也可以关卡中覆盖这些设置。无论你如何实现游戏模式，每个关卡始终只能有一个游戏模式。</p><p>在多人游戏中，游戏模式只存在于服务器上，规则会被复制（发送）给所有联网的客户端。</p><p>相关的C++类是 <code>GameMode</code>。</p><h1 id="游戏状态"><a href="#游戏状态" class="headerlink" title="游戏状态"></a>游戏状态</h1><p><strong>游戏状态（GameState）</strong> 是一种容器，保存着你希望在游戏中复制给每个客户端的信息。简而言之，它表示每个联网玩家的”游戏状态”。</p><p>游戏状态包含的部分信息包括：</p><ul><li><p>游戏分数</p></li><li><p>比赛是否已开始</p></li><li><p>根据场景中玩家的人数，需要生成多少AI</p></li></ul><p>如果是多人游戏，则每个玩家的电脑上都只有一个游戏状态实例，而服务器的实例为权威实例（即客户端的信息更新来源）。</p><p>相关的C++类是 <code>GameState</code>。</p><h1 id="笔刷"><a href="#笔刷" class="headerlink" title="笔刷"></a>笔刷</h1><p><strong>笔刷（Brush）</strong> 是一种Actor，用于描述一个3D几何体，例如方形或圆形。你可以在关卡中应用笔刷，以便定义关卡几何体（称为二元空间划分笔刷，简称BSP笔刷）。假如你想快速搭建关卡，则可以使用这种方法。</p><h1 id="体积"><a href="#体积" class="headerlink" title="体积"></a>体积</h1><p><strong>体积（Volumes）</strong> 是一种存在边框的3D空间，会根据施加给它们的效果产生不同的用途。例如：</p><ul><li><p><strong>阻挡体积（Blocking Volumes）</strong>，一种不可见的体积，用来防止Actor穿过它们。</p></li><li><p><strong>伤害生成体积（Pain Causing Volumes）</strong>，会对进入它们的Actor产生持续性的伤害。</p></li><li><p><strong>触发体积（Trigger Volumes）</strong>，可以通过编程，让Actor在进入或离开它们是触发事件。</p></li></ul><h1 id="关卡"><a href="#关卡" class="headerlink" title="关卡"></a>关卡</h1><p><strong>关卡（Level）</strong> 是用户定义的游戏区域。关卡包含了玩家能看到的所有内容，例如几何体、Pawn和Actor。</p><p>在虚幻编辑器中，每个关卡都被保存为单独的 <code>.umap</code> 文件，它们有时也被称为 <strong>地图</strong>。</p><h1 id="世界"><a href="#世界" class="headerlink" title="世界"></a>世界</h1><p><strong>世界场景（World）</strong> 是一个容器，包含了游戏中的所有关卡。它可以处理关卡流送，还能生成（创建）动态Actor。</p>]]></content>
      
      
      <categories>
          
          <category> unreal engine </category>
          
      </categories>
      
      
        <tags>
            
            <tag> unreal engine </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>贪心算法</title>
      <link href="/2022/04/13/%E6%9C%89%E5%85%B3%E7%AE%97%E6%B3%95%E4%B8%AD%E7%9A%84%E8%B4%AA%E5%BF%83/"/>
      <url>/2022/04/13/%E6%9C%89%E5%85%B3%E7%AE%97%E6%B3%95%E4%B8%AD%E7%9A%84%E8%B4%AA%E5%BF%83/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是贪心"><a href="#什么是贪心" class="headerlink" title="什么是贪心"></a>什么是贪心</h1><p>贪心的本质是选择每一阶段的局部最优，以此达到全局最优。</p><p>举例：如果有一堆钞票，可以拿走十张，如果想达到最大的金额，你要怎么拿？</p><ul><li><p>指定每次拿最大的，最终结果就是拿走最大数额的钱</p></li><li><p>指定每次拿最大的就是局部最优解，最后拿走最大数额的前就是推出全局最优</p></li></ul><p>举例：如果有一堆盒子，你有一个背包体积为n，如何让把背包尽可能装满</p><ul><li><p>如果还每次选最大的盒子，就不行了，此时需要动态规划</p></li><li><p>动态规划为下一章内容</p></li></ul><h1 id="什么时候用贪心算法？"><a href="#什么时候用贪心算法？" class="headerlink" title="什么时候用贪心算法？"></a>什么时候用贪心算法？</h1><p>贪心算法没有固定的套路。</p><p>最好的策略是手动模拟一下，并且如果找不到反例，就可以试一试贪心算法。（常识性的推导加举反例）</p><p>至于数学推导，emmm，那是数学的范畴。</p><h1 id="贪心算法一般解题步骤"><a href="#贪心算法一般解题步骤" class="headerlink" title="贪心算法一般解题步骤"></a>贪心算法一般解题步骤</h1><ol><li><p>将问题分解为若干个子问题</p></li><li><p>找出适合的贪心策略</p></li><li><p>求解每一个子问题的最优解</p></li><li><p>将局部最优解堆叠成全局最优解</p></li></ol><h1 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h1><h2 id="分发饼干"><a href="#分发饼干" class="headerlink" title="分发饼干"></a><a href="https://leetcode-cn.com/problems/assign-cookies/">分发饼干</a></h2><p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</p><p>对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] &gt;&#x3D; g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p><p>示例 1:</p><ul><li>输入: g &#x3D; [1,2,3], s &#x3D; [1,1]</li><li>输出: 1 解释:你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。所以你应该输出1。</li></ul><p>示例 2:</p><ul><li>输入: g &#x3D; [1,2], s &#x3D; [1,2,3]</li><li>输出: 2</li><li>解释:你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。你拥有的饼干数量和尺寸都足以让所有孩子满足。所以你应该输出2.</li></ul><p>提示：</p><ul><li>1 &lt;&#x3D; g.length &lt;&#x3D; 3 * 10^4</li><li>0 &lt;&#x3D; s.length &lt;&#x3D; 3 * 10^4</li><li>1 &lt;&#x3D; g[i], s[j] &lt;&#x3D; 2^31 - 1</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li><p>要满足更多的小孩，就不能造成饼干尺寸的浪费。</p></li><li><p>大尺寸的饼干既可以满足胃口大的孩子，也可以满足胃口小的孩子，那么就应该分配给胃口大的孩子。</p></li><li><p>这里的局部最优就是大饼干喂给胃口大的，充分利用饼干尺寸喂饱一个，全局最优解就是喂饱尽可能多的小孩</p></li><li><p>可以先将饼干数组和小孩数组排序</p></li><li><p>然后从后向前遍历小孩数组，用大饼干有限满足胃口大的，并统计满足小孩数量</p></li></ul><p><img src="https://img-blog.csdnimg.cn/20201123161809624.png" alt="455.分发饼干"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度：O(nlogn)</span></span><br><span class="line"><span class="comment">// 空间复杂度：O(1)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findContentChildren</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; g, vector&lt;<span class="type">int</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(g.<span class="built_in">begin</span>(), g.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> index = s.<span class="built_in">size</span>() - <span class="number">1</span>; <span class="comment">// 饼干数组的下标</span></span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = g.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; s[index] &gt;= g[i]) &#123;</span><br><span class="line">                result++;</span><br><span class="line">                index--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从代码中可以看出我用了一个<strong>index来控制饼干数组的遍历</strong>，遍历饼干并没有再起一个for循环，而是采用自减的方式，这也是常用的技巧。</p><p>有的同学看到要遍历两个数组，就想到用两个for循环，那样逻辑其实就复杂了。</p><h2 id="摆动序列"><a href="#摆动序列" class="headerlink" title="摆动序列"></a><a href="https://leetcode-cn.com/problems/wiggle-subsequence/">摆动序列</a></h2><p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。</p><p>例如， [1,7,4,9,2,5] 是一个摆动序列，因为差值 (6,-3,5,-7,3) 是正负交替出现的。相反, [1,4,7,2,5] 和 [1,7,4,5,5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。</p><p>给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。</p><p>示例 1:</p><ul><li>输入: [1,7,4,9,2,5]</li><li>输出: 6</li><li>解释: 整个序列均为摆动序列。</li></ul><p>示例 2:</p><ul><li>输入: [1,17,5,10,13,15,10,5,16,8]</li><li>输出: 7</li><li>解释: 这个序列包含几个长度为 7 摆动序列，其中一个可为[1,17,10,13,10,16,8]。</li></ul><p>示例 3:</p><ul><li>输入: [1,2,3,4,5,6,7,8,9]</li><li>输出: 2</li></ul><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li><p>从原序列直接获取为摆动序列的子序列</p></li><li><p>从原序列删除一些元素，获得为摆动序列的子序列</p></li></ol><p>先来分析一下，要求删除元素使其达到最大摆动序列，应该删除什么元素？</p><p><img src="https://img-blog.csdnimg.cn/20201124174327597.png" alt="376.摆动序列"></p><ul><li><p>局部最优解：删除单调坡度上的节点（不包括单调坡度两端的节点），那么这个坡度就可以有两个局部峰值</p></li><li><p>整体最优解：整个序列有最多的局部峰值，从而达到最长摆动序列</p></li></ul><p>实际操作中，其实连删除的操作都不需要做，因为题目要求的是最长摆动子序列的长度，所以只需要统计数组的峰值就可以了（相当于是删除单一坡度上的节点，然后统计长度）。</p><p>这就是贪心算法所“贪”的地方，让峰值尽可能保持峰值，然后删除单一坡度上的节点。</p><p>本题代码实现中还有一些技巧：统计峰值的时候，数组最左面和最右面是最不好统计的。</p><p>例如序列[2,5]，它的峰值是2，如果靠统计差值来计算峰值个数就需要考虑数组最右边和最左边的特殊情况。</p><p>所以可以针对序列[2,5]，可以假设为[2,2,5]，这样它就有坡度了，即prediff&#x3D;0</p><p><img src="https://img-blog.csdnimg.cn/20201124174357612.png" alt="376.摆动序列1"></p><p>针对以上情况，result初始值为1（默认最右边有一个峰值），此时curdiff&gt;0&amp;&amp;prediff&lt;&#x3D;0，那么result++（计算了左边的峰值），最后得到的result就是2（峰值个数为2）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">wiggleMaxLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() &lt;= <span class="number">1</span>) <span class="keyword">return</span> nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> curDiff = <span class="number">0</span>; <span class="comment">// 当前一对差值</span></span><br><span class="line">        <span class="type">int</span> preDiff = <span class="number">0</span>; <span class="comment">// 前一对差值</span></span><br><span class="line">        <span class="type">int</span> result = <span class="number">1</span>;  <span class="comment">// 记录峰值个数，序列默认序列最右边有一个峰值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            curDiff = nums[i + <span class="number">1</span>] - nums[i];</span><br><span class="line">            <span class="comment">// 出现峰值</span></span><br><span class="line">            <span class="keyword">if</span> ((curDiff &gt; <span class="number">0</span> &amp;&amp; preDiff &lt;= <span class="number">0</span>) || (preDiff &gt;= <span class="number">0</span> &amp;&amp; curDiff &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">                result++;</span><br><span class="line">                preDiff = curDiff;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="最大子序和"><a href="#最大子序和" class="headerlink" title="最大子序和"></a><a href="https://leetcode-cn.com/problems/maximum-subarray/">最大子序和</a></h2><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p>示例: </p><p>输入: [-2,1,-3,4,-1,2,1,-5,4] 输出: 6 </p><p>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</p><h3 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h3><p>暴力解法的思路，第一层for 就是设置起始位置，第二层for循环遍历数组寻找最大值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> result = INT32_MIN;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 设置起始位置</span></span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; nums.<span class="built_in">size</span>(); j++) &#123; <span class="comment">// 每次从起始位置i开始遍历寻找最大值</span></span><br><span class="line">                count += nums[j];</span><br><span class="line">                result = count &gt; result ? count : result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h3><h4 id="逻辑思路"><a href="#逻辑思路" class="headerlink" title="逻辑思路"></a>逻辑思路</h4><ul><li><p>如果-2 1在一起，计算起点的时候，一定是从1开始计算，因为负数指挥拉低总和，这就是贪心贪的地方</p></li><li><p>局部最优解：当前“连续和”为负数的时候立马放弃，从下一个元素重新计算“连续和”，因为负数加上下一个元素会导致“连续和”越来越小</p></li><li><p>全局最优解：选取最大的“连续和”</p></li></ul><h4 id="代码思路"><a href="#代码思路" class="headerlink" title="代码思路"></a>代码思路</h4><ul><li><p>遍历nums，从头开始用count积累</p></li><li><p>如果count一旦加上nums[i]变为负数，那么就应该从nums[i+1]开始从0积累count了</p></li><li><p>因为已经变为负数的count指挥拖累总和</p></li></ul><p>这相当于是暴力算法中的不断调整最大序和区间的起始位置。</p><p>区间的终止位置：如果count取到最大值了，及时记录下来</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(count&gt;result)&#123;</span><br><span class="line">    result=count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样相当于是用result记录最大子序和区间和（变相的算是调整了终止位置）</p><p><img src="https://code-thinking.cdn.bcebos.com/gifs/53.%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C.gif" alt="53.最大子序和"></p><p>红色的起始位置就是贪心每次取count为正数的时候，开始一个区间的统计。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> result = INT32_MIN;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            count += nums[i];</span><br><span class="line">            <span class="keyword">if</span> (count &gt; result) &#123; <span class="comment">// 取区间累计的最大值（相当于不断确定最大子序终止位置）</span></span><br><span class="line">                result = count;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (count &lt;= <span class="number">0</span>) count = <span class="number">0</span>; <span class="comment">// 相当于重置最大子序起始位置，因为遇到负数一定是拉低总和</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="买卖股票的最佳时机II"><a href="#买卖股票的最佳时机II" class="headerlink" title="买卖股票的最佳时机II"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">买卖股票的最佳时机II</a></h2><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p>示例 1:</p><ul><li>输入: [7,1,5,3,6,4]</li><li>输出: 7</li><li>解释: 在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 3 天（股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5-1 &#x3D; 4。随后，在第 4 天（股票价格 &#x3D; 3）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出, 这笔交易所能获得利润 &#x3D; 6-3 &#x3D; 3 。</li></ul><p>示例 2:</p><ul><li>输入: [1,2,3,4,5]</li><li>输出: 4</li><li>解释: 在第 1 天（股票价格 &#x3D; 1）的时候买入，在第 5 天 （股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5-1 &#x3D; 4 。注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</li></ul><p>示例 3:</p><ul><li>输入: [7,6,4,3,1]</li><li>输出: 0</li><li>解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</li></ul><p>提示：</p><ul><li>1 &lt;&#x3D; prices.length &lt;&#x3D; 3 * 10 ^ 4</li><li>0 &lt;&#x3D; prices[i] &lt;&#x3D; 10 ^ 4</li></ul><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ul><li><p>只有一只股票</p></li><li><p>当前只有买股票或者卖股票的操作</p></li><li><p>想要获利，至少两天为一个单元</p></li></ul><p>利润分解：</p><p>假设第0天买入，第3天卖出——利润为：prices[3]-prices[0]</p><p>相当于：(prices[3]-prices[2])+(prices[2]-prices[1])+(prices[1]-prices[0])</p><p>此时就是把利润分解为每天为单位的维度，而不是从0天到第三天整体去考虑！</p><p>那么根据prices可以得到每天的利润序列：(prices[i]-prices[i-1])+…+(prices[1]-prices[0])</p><p>如图：</p><p><img src="https://img-blog.csdnimg.cn/2020112917480858.png" alt="122.买卖股票的最佳时机II"></p><p>一些同学陷入：第一天怎么就没有利润呢，第一天到底算不算的困惑中。</p><p>第一天当然没有利润，至少要第二天才会有利润，所以利润的序列比股票序列少一天！</p><p>从图中可以发现，其实我们需要收集每天的正利润就可以，<strong>收集正利润的区间，就是股票买卖的区间，而我们只需要关注最终利润，不需要记录区间</strong>。</p><p>那么只收集正利润就是贪心所贪的地方！</p><ul><li><p><strong>局部最优</strong>：收集每天的正利润</p></li><li><p><strong>全局最优</strong>：求得最大利润</p></li></ul><p>局部最优可以推出全局最优，找不出反例，试一试贪心！</p><p>对应C++代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            result += <span class="built_in">max</span>(prices[i] - prices[i - <span class="number">1</span>], <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="跳跃游戏"><a href="#跳跃游戏" class="headerlink" title="跳跃游戏"></a><a href="https://leetcode-cn.com/problems/jump-game/">跳跃游戏</a></h2><p>给定一个非负整数数组，你最初位于数组的第一个位置。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>判断你是否能够到达最后一个位置。</p><p>示例 1:</p><ul><li>输入: [2,3,1,1,4]</li><li>输出: true</li><li>解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。</li></ul><p>示例 2:</p><ul><li>输入: [3,2,1,0,4]</li><li>输出: false</li><li>解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。</li></ul><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>本题一开始跳几步其实无所谓，重要的其实是可跳的覆盖范围！</p><p>不一定非要明确一次究竟跳几步，每次取最大的跳跃步数，这个就是可以跳跃的覆盖范围</p><ul><li><p>这个问题转换成了——跳跃范围究竟可不可以覆盖到终点</p></li><li><p>局部最优解：每次取最大跳跃步数（取最大覆盖范围）</p></li><li><p>整体最优解：最后得到整体最大覆盖范围，看能否到达终点</p></li></ul><p><img src="https://img-blog.csdnimg.cn/20201124154758229.png" alt="55.跳跃游戏"></p><p>i每次移动只能在cover的范围内移动，每移动一个元素，cover得到该元素数值（新的覆盖范围）的补充，让i继续移动下去。</p><p>而cover每次只取 max(该元素数值补充后的范围, cover本身范围)。</p><p>如果cover大于等于了终点下标，直接return true就可以了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canJump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cover = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 只有一个元素，就是能达到</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= cover; i++) &#123; <span class="comment">// 注意这里是小于等于cover</span></span><br><span class="line">            cover = <span class="built_in">max</span>(i + nums[i], cover);</span><br><span class="line">            <span class="keyword">if</span> (cover &gt;= nums.<span class="built_in">size</span>() - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 说明可以覆盖到终点了</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="跳跃游戏II"><a href="#跳跃游戏II" class="headerlink" title="跳跃游戏II"></a><a href="https://leetcode-cn.com/problems/jump-game-ii/">跳跃游戏II</a></h2><p>给定一个非负整数数组，你最初位于数组的第一个位置。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>你的目标是使用最少的跳跃次数到达数组的最后一个位置。</p><p>示例:</p><ul><li>输入: [2,3,1,1,4]</li><li>输出: 2</li><li>解释: 跳到最后一个位置的最小跳跃数是 2。从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。</li></ul><p>说明: 假设你总是可以到达数组的最后一个位置。</p><h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>本题相对于<a href="https://programmercarl.com/0055.%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F.html">跳跃游戏 </a>还是难了不少。</p><p>但思路是相似的，还是要看最大覆盖范围。</p><ul><li><p>局部最优：当前可移动距离尽可能多走，如果还没到终点，步数再加一</p></li><li><p>整体最优：一步尽可能多走，从而达到最小步数</p></li></ul><p>思路虽然是这样，但在写代码的时候还不能真的就能跳多远跳远，那样就不知道下一步最远能跳到哪里了</p><p><strong>所以真正解题的时候，要从覆盖范围出发，不管怎么跳，覆盖范围内一定是可以跳到的，以最小的步数增加覆盖范围，覆盖范围一旦覆盖了终点，得到的就是最小步数！</strong></p><p><strong>这里需要统计两个覆盖范围，当前这一步的最大覆盖和下一步最大覆盖</strong>。</p><p>如果移动下标达到了当前这一步的最大覆盖最远距离了，还没有到终点的话，那么就必须再走一步来增加覆盖范围，直到覆盖范围覆盖了终点。</p><p><img src="https://img-blog.csdnimg.cn/20201201232309103.png" alt="45.跳跃游戏II"></p><p><strong>图中覆盖范围的意义在于，只要红色的区域，最多两步一定可以到！（不用管具体怎么跳，反正一定可以跳到）</strong></p><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>从图中可以看出来，就是移动下标达到了当前覆盖的最远距离下标时，步数就要加一，来增加覆盖距离。最后的步数就是最少步数。</p><p>这里还是有个特殊情况需要考虑，当移动下标达到了当前覆盖的最远距离下标时</p><ul><li>如果当前覆盖最远距离下标不是是集合终点，步数就加一，还需要继续走。</li><li>如果当前覆盖最远距离下标就是是集合终点，步数不用加一，因为不能再往后走了。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">jump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> curDistance = <span class="number">0</span>;    <span class="comment">// 当前覆盖最远距离下标</span></span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;            <span class="comment">// 记录走的最大步数</span></span><br><span class="line">        <span class="type">int</span> nextDistance = <span class="number">0</span>;   <span class="comment">// 下一步覆盖最远距离下标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            nextDistance = <span class="built_in">max</span>(nums[i] + i, nextDistance);  <span class="comment">// 更新下一步覆盖最远距离下标</span></span><br><span class="line">            <span class="keyword">if</span> (i == curDistance) &#123;                         <span class="comment">// 遇到当前覆盖最远距离下标</span></span><br><span class="line">                <span class="keyword">if</span> (curDistance != nums.<span class="built_in">size</span>() - <span class="number">1</span>) &#123;       <span class="comment">// 如果当前覆盖最远距离下标不是终点</span></span><br><span class="line">                    ans++;                                  <span class="comment">// 需要走下一步</span></span><br><span class="line">                    curDistance = nextDistance;             <span class="comment">// 更新当前覆盖最远距离下标（相当于加油了）</span></span><br><span class="line">                    <span class="keyword">if</span> (nextDistance &gt;= nums.<span class="built_in">size</span>() - <span class="number">1</span>) <span class="keyword">break</span>; <span class="comment">// 下一步的覆盖范围已经可以达到终点，结束循环</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">break</span>;                               <span class="comment">// 当前覆盖最远距离下标是集合终点，不用做ans++操作了，直接结束</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>依然是贪心，思路和方法一差不多，代码可以简洁一些。</p><p><strong>针对于方法一的特殊情况，可以统一处理</strong>，即：移动下标只要遇到当前覆盖最远距离的下标，直接步数加一，不考虑是不是终点的情况。</p><p>想要达到这样的效果，只要让移动下标，最大只能移动到nums.size - 2的地方就可以了。</p><p>因为当移动下标指向nums.size - 2时：</p><ul><li>如果移动下标等于当前覆盖最大距离下标， 需要再走一步（即ans++），因为最后一步一定是可以到的终点。（题目假设总是可以到达数组的最后一个位置），如图：</li></ul><p><img src="https://img-blog.csdnimg.cn/20201201232445286.png" alt="45.跳跃游戏II2"></p><ul><li>如果移动下标不等于当前覆盖最大距离下标，说明当前覆盖最远距离就可以直接达到终点了，不需要再走一步。</li></ul><p><img src="https://img-blog.csdnimg.cn/20201201232338693.png" alt="45.跳跃游戏II1"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">jump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> curDistance = <span class="number">0</span>;    <span class="comment">// 当前覆盖的最远距离下标</span></span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;            <span class="comment">// 记录走的最大步数</span></span><br><span class="line">        <span class="type">int</span> nextDistance = <span class="number">0</span>;   <span class="comment">// 下一步覆盖的最远距离下标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123; <span class="comment">// 注意这里是小于nums.size() - 1，这是关键所在</span></span><br><span class="line">            nextDistance = <span class="built_in">max</span>(nums[i] + i, nextDistance); <span class="comment">// 更新下一步覆盖的最远距离下标</span></span><br><span class="line">            <span class="keyword">if</span> (i == curDistance) &#123;                 <span class="comment">// 遇到当前覆盖的最远距离下标</span></span><br><span class="line">                curDistance = nextDistance;         <span class="comment">// 更新当前覆盖的最远距离下标</span></span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看出版本二的代码相对于版本一简化了不少！</p><p>其精髓在于控制移动下标i只移动到nums.size() - 2的位置，所以移动下标只要遇到当前覆盖最远距离的下标，直接步数加一，不用考虑别的了。</p><h2 id="K次取反后最大化的数组和"><a href="#K次取反后最大化的数组和" class="headerlink" title="K次取反后最大化的数组和"></a><a href="https://leetcode-cn.com/problems/maximize-sum-of-array-after-k-negations/">K次取反后最大化的数组和</a></h2><p>给定一个整数数组 A，我们只能用以下方法修改该数组：我们选择某个索引 i 并将 A[i] 替换为 -A[i]，然后总共重复这个过程 K 次。（我们可以多次选择同一个索引 i。）</p><p>以这种方式修改数组后，返回数组可能的最大和。</p><p>示例 1：</p><ul><li>输入：A &#x3D; [4,2,3], K &#x3D; 1</li><li>输出：5</li><li>解释：选择索引 (1,) ，然后 A 变为 [4,-2,3]。</li></ul><p>示例 2：</p><ul><li>输入：A &#x3D; [3,-1,0,2], K &#x3D; 3</li><li>输出：6</li><li>解释：选择索引 (1, 2, 2) ，然后 A 变为 [3,1,0,2]。</li></ul><p>示例 3：</p><ul><li>输入：A &#x3D; [2,-3,-1,5,-4], K &#x3D; 2</li><li>输出：13</li><li>解释：选择索引 (1, 4) ，然后 A 变为 [2,3,-1,5,4]。</li></ul><p>提示：</p><ul><li>1 &lt;&#x3D; A.length &lt;&#x3D; 10000</li><li>1 &lt;&#x3D; K &lt;&#x3D; 10000</li><li>-100 &lt;&#x3D; A[i] &lt;&#x3D; 100</li></ul><h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><ul><li><p>局部最优：让绝对值大的负数变为正数</p></li><li><p>整体最优：整个数组和达到最大</p></li></ul><p>如果将负数都转变为正数了，但是此时k!&#x3D;0</p><ul><li><p>局部最优：找数值最小的正数反转</p></li><li><p>全局最优：整个数组和达到最大</p></li></ul><p>解题步骤</p><ol><li><p>将数组按照绝对值大小从大到小排序（注意按照绝对值的大小）</p></li><li><p>从前向后遍历，遇到负数将其变为正数，同时K–</p></li><li><p>如果k还大于0，那么反复转变数值最小的元素</p></li><li><p>求和</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">abs</span>(a) &gt; <span class="built_in">abs</span>(b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">largestSumAfterKNegations</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A, <span class="type">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(A.<span class="built_in">begin</span>(), A.<span class="built_in">end</span>(), cmp);       <span class="comment">// 第一步</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 第二步</span></span><br><span class="line">            <span class="keyword">if</span> (A[i] &lt; <span class="number">0</span> &amp;&amp; K &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                A[i] *= <span class="number">-1</span>;</span><br><span class="line">                K--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (K % <span class="number">2</span> == <span class="number">1</span>) A[A.<span class="built_in">size</span>() - <span class="number">1</span>] *= <span class="number">-1</span>; <span class="comment">// 第三步</span></span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> a : A) result += a;        <span class="comment">// 第四步</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="加油站"><a href="#加油站" class="headerlink" title="加油站"></a><a href="https://leetcode-cn.com/problems/gas-station/">加油站</a></h2><p>在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。</p><p>你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。</p><p>如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。</p><p>说明:</p><ul><li>如果题目有解，该答案即为唯一答案。</li><li>输入数组均为非空数组，且长度相同。</li><li>输入数组中的元素均为非负数。</li></ul><p>示例 1: 输入:</p><ul><li>gas &#x3D; [1,2,3,4,5]</li><li>cost &#x3D; [3,4,5,1,2]</li></ul><p>输出: 3 解释:</p><ul><li>从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 &#x3D; 0 + 4 &#x3D; 4 升汽油</li><li>开往 4 号加油站，此时油箱有 4 - 1 + 5 &#x3D; 8 升汽油</li><li>开往 0 号加油站，此时油箱有 8 - 2 + 1 &#x3D; 7 升汽油</li><li>开往 1 号加油站，此时油箱有 7 - 3 + 2 &#x3D; 6 升汽油</li><li>开往 2 号加油站，此时油箱有 6 - 4 + 3 &#x3D; 5 升汽油</li><li>开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。</li><li>因此，3 可为起始索引。</li></ul><p>示例 2: 输入:</p><ul><li><p>gas &#x3D; [2,3,4]</p></li><li><p>cost &#x3D; [3,4,3]</p></li><li><p>输出: -1</p></li><li><p>解释: 你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 &#x3D; 0 + 4 &#x3D; 4 升汽油。开往 0 号加油站，此时油箱有 4 - 3 + 2 &#x3D; 3 升汽油。开往 1 号加油站，此时油箱有 3 - 3 + 3 &#x3D; 3 升汽油。你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。因此，无论怎样，你都不可能绕环路行驶一周</p></li></ul><h3 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h3><p>直接从全局进行贪心选择，情况如下：</p><ul><li><p>情况一：如果gas的总和小于cost总和，那么无论从哪里出发，一定是跑不了一圈的</p></li><li><p>情况二：rest[i] &#x3D; gas[i]-cost[i]为一天剩下的油，i从0开始计算累加到最后一站，如果累加没有出现负数，说明从0出发，油就没有断过，那么0就是起点。</p></li><li><p>情况三：如果累加的最小值是负数，汽车就要从非0节点出发，从后向前，看哪个节点能这个负数填平，能把这个负数填平的节点就是出发节点。</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">canCompleteCircuit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; gas, vector&lt;<span class="type">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> curSum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> min = INT_MAX; <span class="comment">// 从起点出发，油箱里的油量最小值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; gas.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> rest = gas[i] - cost[i];</span><br><span class="line">            curSum += rest;</span><br><span class="line">            <span class="keyword">if</span> (curSum &lt; min) &#123;</span><br><span class="line">                min = curSum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (curSum &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// 情况1</span></span><br><span class="line">        <span class="keyword">if</span> (min &gt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;     <span class="comment">// 情况2</span></span><br><span class="line">                                    <span class="comment">// 情况3</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = gas.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="type">int</span> rest = gas[i] - cost[i];</span><br><span class="line">            min += rest;</span><br><span class="line">            <span class="keyword">if</span> (min &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以换一个思路，首先如果总油量减去总消耗大于等于零那么一定可以跑完一圈，说明 各个站点的加油站 剩油量rest[i]相加一定是大于等于零的。</p><p>每个加油站的剩余量rest[i]为gas[i] - cost[i]。</p><p>i从0开始累加rest[i]，和记为curSum，一旦curSum小于零，说明[0, i]区间都不能作为起始位置，起始位置从i+1算起，再从0计算curSum。</p><p><img src="https://img-blog.csdnimg.cn/20201213162821958.png" alt="134.加油站"></p><p>那么为什么一旦[i，j] 区间和为负数，起始位置就可以是j+1呢，j+1后面就不会出现更大的负数？</p><p>如果出现更大的负数，就是更新j，那么起始位置又变成新的j+1了。</p><p>而且j之前出现了多少负数，j后面就会出现多少正数，因为耗油总和是大于零的（前提我们已经确定了一定可以跑完全程）。</p><p><strong>那么局部最优：当前累加rest[j]的和curSum一旦小于0，起始位置至少要是j+1，因为从j开始一定不行。全局最优：找到可以跑一圈的起始位置</strong>。</p><p>局部最优可以推出全局最优，找不出反例，试试贪心！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">canCompleteCircuit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; gas, vector&lt;<span class="type">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> curSum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> totalSum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; gas.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            curSum += gas[i] - cost[i];</span><br><span class="line">            totalSum += gas[i] - cost[i];</span><br><span class="line">            <span class="keyword">if</span> (curSum &lt; <span class="number">0</span>) &#123;   <span class="comment">// 当前累加rest[i]和 curSum一旦小于0</span></span><br><span class="line">                start = i + <span class="number">1</span>;  <span class="comment">// 起始位置更新为i+1</span></span><br><span class="line">                curSum = <span class="number">0</span>;     <span class="comment">// curSum从0开始</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (totalSum &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 说明怎么走都不可能跑一圈了</span></span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="分发糖果"><a href="#分发糖果" class="headerlink" title="分发糖果"></a><a href="https://leetcode-cn.com/problems/candy/">分发糖果</a></h2><p>老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。</p><p>你需要按照以下要求，帮助老师给这些孩子分发糖果：</p><ul><li>每个孩子至少分配到 1 个糖果。</li><li>相邻的孩子中，评分高的孩子必须获得更多的糖果。</li></ul><p>那么这样下来，老师至少需要准备多少颗糖果呢？</p><p>示例 1:</p><ul><li>输入: [1,0,2]</li><li>输出: 5</li><li>解释: 你可以分别给这三个孩子分发 2、1、2 颗糖果。</li></ul><p>示例 2:</p><ul><li>输入: [1,2,2]</li><li>输出: 4</li><li>解释: 你可以分别给这三个孩子分发 1、2、1 颗糖果。第三个孩子只得到 1 颗糖果，这已满足上述两个条件。</li></ul><h3 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h3><p>一定要在确定一边之后再确定另一边，否则就会顾此失彼。</p><p>先确定右边评分大于左边的情况（从前向后遍历）</p><ul><li><p>局部最优解：只要右边评分比左边大，右边的孩子就多一个糖果</p></li><li><p>全局最优解：相邻孩子中，评分高的右孩子获得比左边孩子更多的糖果</p></li></ul><p>如果ratings[i]&gt;ratings[i-1]，那么[i]的糖一定比[i-1]多一个，所以贪心candyvec[i]&#x3D;candyvec[i-1]+1</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;rating.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(rating[i]&gt;ranting[i<span class="number">-1</span>])&#123;</span><br><span class="line">    candyvec[i]=candyvec[i<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20201117114916878.png" alt="135.分发糖果"></p><p>再确定左孩子大于右孩子的情况（从后往前遍历）</p><p>为什么不能从前往后遍历——如果从前往后，根据ratings[i+1]来确定ratings[i]对应的糖果，那么每次都不能利用上前一次的比较结果了</p><p>所以确定左孩子大于右孩子的情况一定要从后往前遍历！</p><p>如果ratings[i]&gt;ratings[i+1]，此时candyvec[i]（第i个小孩的糖果数量）就有两个选择了，一个是candyvec[i+1]+1（从右边这个加1得到的糖果数量），一个是candyvec[i]（之前比较右孩子大于左孩子得到的糖果数量）</p><ul><li><p>局部最优解：取candyvec[i+1]+1和candy[i]最大的糖果数量，保证第i个小孩的糖果数量大于左边的也大于右边的</p></li><li><p>全局最优解：相邻孩子中，评分高的孩子获得更多的糖果</p></li></ul><p>所以就取candyVec[i + 1] + 1 和 candyVec[i] 最大的糖果数量，<strong>candyVec[i]只有取最大的才能既保持对左边candyVec[i - 1]的糖果多，也比右边candyVec[i + 1]的糖果多</strong>。</p><p><img src="https://img-blog.csdnimg.cn/20201117115658791.png" alt="135.分发糖果1"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从后向前</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = ratings.<span class="built_in">size</span>() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ratings[i] &gt; ratings[i + <span class="number">1</span>] ) &#123;</span><br><span class="line">        candyVec[i] = <span class="built_in">max</span>(candyVec[i], candyVec[i + <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">candy</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; ratings)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">candyVec</span><span class="params">(ratings.size(), <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="comment">// 从前向后</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; ratings.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ratings[i] &gt; ratings[i - <span class="number">1</span>]) candyVec[i] = candyVec[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从后向前</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = ratings.<span class="built_in">size</span>() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ratings[i] &gt; ratings[i + <span class="number">1</span>] ) &#123;</span><br><span class="line">                candyVec[i] = <span class="built_in">max</span>(candyVec[i], candyVec[i + <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 统计结果</span></span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; candyVec.<span class="built_in">size</span>(); i++) result += candyVec[i];</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="柠檬水找零"><a href="#柠檬水找零" class="headerlink" title="柠檬水找零"></a><a href="https://leetcode-cn.com/problems/lemonade-change/">柠檬水找零</a></h2><p>在柠檬水摊上，每一杯柠檬水的售价为 5 美元。</p><p>顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。</p><p>每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。</p><p>注意，一开始你手头没有任何零钱。</p><p>如果你能给每位顾客正确找零，返回 true ，否则返回 false 。</p><p>示例 1：</p><ul><li>输入：[5,5,5,10,20]</li><li>输出：true</li><li>解释：<ul><li>前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。</li><li>第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。</li><li>第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。</li><li>由于所有客户都得到了正确的找零，所以我们输出 true。</li></ul></li></ul><p>示例 2：</p><ul><li>输入：[5,5,10]</li><li>输出：true</li></ul><p>示例 3：</p><ul><li>输入：[10,10]</li><li>输出：false</li></ul><p>示例 4：</p><ul><li>输入：[5,5,10,10,20]</li><li>输出：false</li><li>解释：<ul><li>前 2 位顾客那里，我们按顺序收取 2 张 5 美元的钞票。</li><li>对于接下来的 2 位顾客，我们收取一张 10 美元的钞票，然后返还 5 美元。</li><li>对于最后一位顾客，我们无法退回 15 美元，因为我们现在只有两张 10 美元的钞票。</li><li>由于不是每位顾客都得到了正确的找零，所以答案是 false。</li></ul></li></ul><p>提示：</p><ul><li>0 &lt;&#x3D; bills.length &lt;&#x3D; 10000</li><li>bills[i] 不是 5 就是 10 或是 20</li></ul><h3 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h3><p>只需要维护三种金额的数量，5，10和20。</p><p>有如下三种情况：</p><ul><li>情况一：账单是5，直接收下。</li><li>情况二：账单是10，消耗一个5，增加一个10</li><li>情况三：账单是20，优先消耗一个10和一个5，如果不够，再消耗三个5</li></ul><p>此时大家就发现 情况一，情况二，都是固定策略，都不用我们来做分析了，而唯一不确定的其实在情况三。</p><p>而情况三逻辑也不复杂甚至感觉纯模拟就可以了，其实情况三这里是有贪心的。</p><p>账单是20的情况，为什么要优先消耗一个10和一个5呢？</p><p><strong>因为美元10只能给账单20找零，而美元5可以给账单10和账单20找零，美元5更万能！</strong></p><ul><li><p>局部最优：遇到账单20，优先消耗美元10，完成本次找零</p></li><li><p>全局最优：完成全部账单的找零</p></li></ul><p>局部最优可以推出全局最优，并找不出反例，那么就试试贪心算法！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">lemonadeChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; bills)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> five = <span class="number">0</span>, ten = <span class="number">0</span>, twenty = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> bill : bills) &#123;</span><br><span class="line">            <span class="comment">// 情况一</span></span><br><span class="line">            <span class="keyword">if</span> (bill == <span class="number">5</span>) five++;</span><br><span class="line">            <span class="comment">// 情况二</span></span><br><span class="line">            <span class="keyword">if</span> (bill == <span class="number">10</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (five &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                ten++;</span><br><span class="line">                five--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 情况三</span></span><br><span class="line">            <span class="keyword">if</span> (bill == <span class="number">20</span>) &#123;</span><br><span class="line">                <span class="comment">// 优先消耗10美元，因为5美元的找零用处更大，能多留着就多留着</span></span><br><span class="line">                <span class="keyword">if</span> (five &gt; <span class="number">0</span> &amp;&amp; ten &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    five--;</span><br><span class="line">                    ten--;</span><br><span class="line">                    twenty++; <span class="comment">// 其实这行代码可以删了，因为记录20已经没有意义了，不会用20来找零</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (five &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">                    five -= <span class="number">3</span>;</span><br><span class="line">                    twenty++; <span class="comment">// 同理，这行代码也可以删了</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="根据身高重建队列"><a href="#根据身高重建队列" class="headerlink" title="根据身高重建队列"></a><a href="https://leetcode-cn.com/problems/queue-reconstruction-by-height/">根据身高重建队列</a></h2><p>假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] &#x3D; [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。</p><p>请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] &#x3D; [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。</p><p>示例 1：</p><ul><li>输入：people &#x3D; [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]</li><li>输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]</li><li>解释：<ul><li>编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。</li><li>编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。</li><li>编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。</li><li>编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。</li><li>编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。</li><li>编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。</li><li>因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。</li></ul></li></ul><p>示例 2：</p><ul><li>输入：people &#x3D; [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]</li><li>输出：[[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]]</li></ul><p>提示：</p><ul><li>1 &lt;&#x3D; people.length &lt;&#x3D; 2000</li><li>0 &lt;&#x3D; hi &lt;&#x3D; 10^6</li><li>0 &lt;&#x3D; ki &lt; people.length</li></ul><p>题目数据确保队列可以被重建</p><h3 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h3><p>本题有两个维度，h和k，看到这种题目一定要想如何确定一个维度，然后在按照另一个维度重新排列。</p><p>其实如果大家认真做了<a href="https://programmercarl.com/0135.%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C.html">分发糖果</a>，就会发现和此题有点点的像。</p><p>在<a href="https://programmercarl.com/0135.%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C.html">分发糖果</a>我就强调过一次，遇到两个维度权衡的时候，一定要先确定一个维度，再确定另一个维度。</p><p><strong>如果两个维度一起考虑一定会顾此失彼</strong>。</p><p>对于本题相信大家困惑的点是先确定k还是先确定h呢，也就是究竟先按h排序呢，还先按照k排序呢？</p><p>如果按照k来从小到大排序，排完之后，会发现k的排列并不符合条件，身高也不符合条件，两个维度哪一个都没确定下来。</p><p>那么按照身高h来排序呢，身高一定是从大到小排（身高相同的话则k小的站前面），让高个子在前面。</p><p><strong>此时我们可以确定一个维度了，就是身高，前面的节点一定都比本节点高！</strong></p><p>那么只需要按照k为下标重新插入队列就可以了，为什么呢？</p><p>以图中{5,2} 为例：</p><p><img src="https://img-blog.csdnimg.cn/20201216201851982.png" alt="406.根据身高重建队列"></p><p>按照身高排序之后，优先按身高高的people的k来插入，后序插入节点也不会影响前面已经插入的节点，最终按照k的规则完成了队列。</p><p>所以在按照身高从大到小排序后：</p><ul><li><p><strong>局部最优：优先按身高高的people的k来插入。插入操作过后的people满足队列属性</strong></p></li><li><p><strong>全局最优：最后都做完插入操作，整个队列满足题目队列属性</strong></p></li></ul><p>一些同学可能也会疑惑，你怎么知道局部最优就可以推出全局最优呢？ 有数学证明么？</p><p>在贪心系列开篇词<a href="https://programmercarl.com/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">关于贪心算法，你该了解这些！</a>中，我已经讲过了这个问题了。</p><p>刷题或者面试的时候，手动模拟一下感觉可以局部最优推出整体最优，而且想不到反例，那么就试一试贪心，至于严格的数学证明，就不在讨论范围内了。</p><p>回归本题，整个插入过程如下：</p><p>排序完的people： [[7,0], [7,1], [6,1], [5,0], [5,2]，[4,4]]</p><p>插入的过程：</p><ul><li>插入[7,0]：[[7,0]]</li><li>插入[7,1]：[[7,0],[7,1]]</li><li>插入[6,1]：[[7,0],[6,1],[7,1]]</li><li>插入[5,0]：[[5,0],[7,0],[6,1],[7,1]]</li><li>插入[5,2]：[[5,0],[7,0],[5,2],[6,1],[7,1]]</li><li>插入[4,4]：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]</li></ul><p>此时就按照题目的要求完成了重新排列。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; a, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a[<span class="number">0</span>] == b[<span class="number">0</span>]) <span class="keyword">return</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>] &gt; b[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">reconstructQueue</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; people) &#123;</span><br><span class="line">        <span class="built_in">sort</span> (people.<span class="built_in">begin</span>(), people.<span class="built_in">end</span>(), cmp);</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; que;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; people.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> position = people[i][<span class="number">1</span>];</span><br><span class="line">            que.<span class="built_in">insert</span>(que.<span class="built_in">begin</span>() + position, people[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> que;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但使用vector是非常费时的，C++中vector（可以理解是一个动态数组，底层是普通数组实现的）如果插入元素大于预先普通数组大小，vector底部会有一个扩容的操作，即申请两倍于原先普通数组的大小，然后把数据拷贝到另一个更大的数组上。</p><p>所以使用vector（动态数组）来insert，是费时的，插入再拷贝的话，单纯一个插入的操作就是O(n^2)了，甚至可能拷贝好几次，就不止O(n^2)了。</p><p>改成链表之后，C++代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 身高从大到小排（身高相同k小的站前面）</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; a, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a[<span class="number">0</span>] == b[<span class="number">0</span>]) <span class="keyword">return</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>] &gt; b[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">reconstructQueue</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; people) &#123;</span><br><span class="line">        <span class="built_in">sort</span> (people.<span class="built_in">begin</span>(), people.<span class="built_in">end</span>(), cmp);</span><br><span class="line">        list&lt;vector&lt;<span class="type">int</span>&gt;&gt; que; <span class="comment">// list底层是链表实现，插入效率比vector高的多</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; people.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> position = people[i][<span class="number">1</span>]; <span class="comment">// 插入到下标为position的位置</span></span><br><span class="line">            std::list&lt;vector&lt;<span class="type">int</span>&gt;&gt;::iterator it = que.<span class="built_in">begin</span>();</span><br><span class="line">            <span class="keyword">while</span> (position--) &#123; <span class="comment">// 寻找在插入位置</span></span><br><span class="line">                it++;</span><br><span class="line">            &#125;</span><br><span class="line">            que.<span class="built_in">insert</span>(it, people[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(que.<span class="built_in">begin</span>(), que.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>直观上来看数组的insert操作是O(n)的，整体代码的时间复杂度是O(n^2)。</p><p>这么一分析好像和版本二链表实现的时间复杂度是一样的啊，为什么提交之后效率会差距这么大呢？</p><p><strong>首先vector的底层实现也是普通数组</strong>。</p><p>vector的大小有两个维度一个是size一个是capicity，size就是我们平时用来遍历vector时候用的</p><p>而capicity是vector底层数组（就是普通数组）的大小，capicity可不一定就是size。</p><p>当insert数据的时候，如果已经大于capicity，capicity会成倍扩容，但对外暴漏的size其实仅仅是+1。</p><p>那么既然vector底层实现是普通数组，怎么扩容的？</p><p>就是重新申请一个二倍于原数组大小的数组，然后把数据都拷贝过去，并释放原数组内存。（对，就是这么原始粗暴的方法！）</p><p><img src="https://img-blog.csdnimg.cn/20201218185902217.png" alt="vector原理"></p><p>原vector中的size和capicity相同都是3，初始化为1 2 3，此时要push_back一个元素4。</p><p>那么底层其实就要申请一个大小为6的普通数组，并且把原元素拷贝过去，释放原数组内存，<strong>注意图中底层数组的内存起始地址已经变了</strong>。</p><p><strong>同时也注意此时capicity和size的变化，关键的地方我都标红了</strong>。</p><p>而在<a href="https://programmercarl.com/0406.%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97.html">贪心算法：根据身高重建队列</a>中，我们使用vector来做insert的操作，此时大家可会发现，<strong>虽然表面上复杂度是O(n^2)，但是其底层都不知道额外做了多少次全量拷贝了，所以算上vector的底层拷贝，整体时间复杂度可以认为是O(n^2 + t × n)级别的，t是底层拷贝的次数</strong>。</p><h2 id="用最少数量的箭引爆气球"><a href="#用最少数量的箭引爆气球" class="headerlink" title="用最少数量的箭引爆气球"></a><a href="https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/">用最少数量的箭引爆气球</a></h2><p>在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以纵坐标并不重要，因此只要知道开始和结束的横坐标就足够了。开始坐标总是小于结束坐标。</p><p>一支弓箭可以沿着 x 轴从不同点完全垂直地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足  xstart ≤ x ≤ xend，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。</p><p>给你一个数组 points ，其中 points [i] &#x3D; [xstart,xend] ，返回引爆所有气球所必须射出的最小弓箭数。</p><p>示例 1：</p><ul><li>输入：points &#x3D; [[10,16],[2,8],[1,6],[7,12]]</li><li>输出：2</li><li>解释：对于该样例，x &#x3D; 6 可以射爆 [2,8],[1,6] 两个气球，以及 x &#x3D; 11 射爆另外两个气球</li></ul><p>示例 2：</p><ul><li>输入：points &#x3D; [[1,2],[3,4],[5,6],[7,8]]</li><li>输出：4</li></ul><p>示例 3：</p><ul><li>输入：points &#x3D; [[1,2],[2,3],[3,4],[4,5]]</li><li>输出：2</li></ul><p>示例 4：</p><ul><li>输入：points &#x3D; [[1,2]]</li><li>输出：1</li></ul><p>示例 5：</p><ul><li>输入：points &#x3D; [[2,3],[2,3]]</li><li>输出：1</li></ul><p>提示：</p><ul><li>0 &lt;&#x3D; points.length &lt;&#x3D; 10^4</li><li>points[i].length &#x3D;&#x3D; 2</li><li>-2^31 &lt;&#x3D; xstart &lt; xend &lt;&#x3D; 2^31 - 1</li></ul><h3 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h3><p>当气球重叠的时候一起射中，用的弓箭最少</p><ul><li><p>局部最优解：当气球出现重叠的时候，一起射，所用的弓箭最少</p></li><li><p>全局最优解：把所有气球射爆所用弓箭最少</p></li></ul><p><strong>算法确定下来了，那么如何模拟气球射爆的过程呢？是在数组中移除元素还是做标记呢？</strong></p><p>如果真实的模拟射气球的过程，应该射一个，气球数组就remove一个元素，这样最直观，毕竟气球被射了。</p><p>但仔细思考一下就发现：如果把气球排序之后，从前到后遍历气球，被射过的气球仅仅跳过就行了，没有必要让气球数组remote气球，只要记录一下箭的数量就可以了。</p><p>以上为思考过程，已经确定下来使用贪心了，那么开始解题。</p><p><strong>为了让气球尽可能的重叠，需要对数组进行排序</strong>。</p><p>那么按照气球起始位置排序，还是按照气球终止位置排序呢？</p><p>其实都可以！只不过对应的遍历顺序不同，我就按照气球的起始位置排序了。</p><p>既然按照起始位置排序，那么就从前向后遍历气球数组，靠左尽可能让气球重复。</p><p>从前向后遍历遇到重叠的气球了怎么办？</p><p><strong>如果气球重叠了，重叠气球中右边边界的最小值 之前的区间一定需要一个弓箭</strong>。</p><p>以题目示例： [[10,16],[2,8],[1,6],[7,12]]为例，如图：（方便起见，已经排序）</p><p><img src="https://img-blog.csdnimg.cn/20201123101929791.png" alt="452.用最少数量的箭引爆气球"></p><p>可以看出首先第一组重叠气球，一定是需要一个箭，气球3的左边界大于了第一组重叠气球的最小右边界，所以再需要一支箭来射气球3了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; a, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMinArrowShots</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (points.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">sort</span>(points.<span class="built_in">begin</span>(), points.<span class="built_in">end</span>(), cmp);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> result = <span class="number">1</span>; <span class="comment">// points 不为空至少需要一支箭</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; points.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (points[i][<span class="number">0</span>] &gt; points[i - <span class="number">1</span>][<span class="number">1</span>]) &#123;  <span class="comment">// 表示i左边界大于i-1右边界-&gt;气球i和气球i-1不挨着，注意这里不是&gt;=</span></span><br><span class="line">                result++; <span class="comment">// 需要一支箭</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;  <span class="comment">// 气球i和气球i-1挨着</span></span><br><span class="line">                points[i][<span class="number">1</span>] = <span class="built_in">min</span>(points[i - <span class="number">1</span>][<span class="number">1</span>], points[i][<span class="number">1</span>]); <span class="comment">// 更新重叠气球最小右边界</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="无重叠区间"><a href="#无重叠区间" class="headerlink" title="无重叠区间"></a><a href="https://leetcode-cn.com/problems/non-overlapping-intervals/">无重叠区间</a></h2><p>给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。</p><p>注意: 可以认为区间的终点总是大于它的起点。 区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。</p><p>示例 1:</p><ul><li>输入: [ [1,2], [2,3], [3,4], [1,3] ]</li><li>输出: 1</li><li>解释: 移除 [1,3] 后，剩下的区间没有重叠。</li></ul><p>示例 2:</p><ul><li>输入: [ [1,2], [1,2], [1,2] ]</li><li>输出: 2</li><li>解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。</li></ul><p>示例 3:</p><ul><li>输入: [ [1,2], [2,3] ]</li><li>输出: 0</li><li>解释: 你不需要移除任何区间，因为它们已经是无重叠的了。</li></ul><h3 id="思路-11"><a href="#思路-11" class="headerlink" title="思路"></a>思路</h3><p>这道题是要排序的，但是按照右边界排序还是按照左边界排序呢？</p><ul><li><p>按照右边界排序，就要从左向右遍历，因为右边界越小越好，只要右边界越小，留给下一个区间的空间就越大，所以从左向右遍历，优先选右边界小的</p></li><li><p>按照左边界排序，就要从右向左遍历，因为左边界数值越大越好（越靠右），这样就给前一个区间的空间就越大，所以可以从右向左遍历</p></li></ul><p><strong>按照右边界排序，从左向右记录非交叉区间的个数。最后用区间总数减去非交叉区间的个数就是需要移除的区间个数了</strong>。</p><p>求非交叉区间的最大个数。</p><ul><li><p>局部最优：优先选右边界小的区间，所以从左向右遍历，留给下一个区间的空间大一些，从而尽量避免交叉</p></li><li><p>全局最优：选取最多的非交叉区间</p></li></ul><p><img src="https://img-blog.csdnimg.cn/20201221201553618.png" alt="435.无重叠区间"></p><p>区间，1，2，3，4，5，6都按照右边界排好序。</p><p>每次取非交叉区间的时候，都是可右边界最小的来做分割点（这样留给下一个区间的空间就越大），所以第一条分割线就是区间1结束的位置。</p><p>接下来就是找大于区间1结束位置的区间，是从区间4开始。</p><p><strong>那有同学问了为什么不从区间5开始？</strong></p><p><strong>别忘已经是按照右边界排序的了</strong>。</p><p>区间4结束之后，在找到区间6，所以一共记录非交叉区间的个数是三个。</p><p>总共区间个数为6，减去非交叉区间的个数3。移除区间的最小数量就是3。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 按照区间右边界排序</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">cmp</span> <span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; a, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (intervals.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>(), cmp);</span><br><span class="line">        <span class="type">int</span> count = <span class="number">1</span>; <span class="comment">// 记录非交叉区间的个数</span></span><br><span class="line">        <span class="type">int</span> end = intervals[<span class="number">0</span>][<span class="number">1</span>]; <span class="comment">// 记录区间分割点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; intervals.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (end &lt;= intervals[i][<span class="number">0</span>]) &#123;</span><br><span class="line">                end = intervals[i][<span class="number">1</span>];</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> intervals.<span class="built_in">size</span>() - count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="划分字母区间"><a href="#划分字母区间" class="headerlink" title="划分字母区间"></a><a href="https://leetcode-cn.com/problems/partition-labels/">划分字母区间</a></h2><p>字符串 S 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表。</p><p>示例：</p><ul><li>输入：S &#x3D; “ababcbacadefegdehijhklij”</li><li>输出：[9,7,8] 解释： 划分结果为 “ababcbaca”, “defegde”, “hijhklij”。 每个字母最多出现在一个片段中。 像 “ababcbacadefegde”, “hijhklij” 的划分是错误的，因为划分的片段数较少。</li></ul><p>提示：</p><ul><li>S的长度在[1, 500]之间。</li><li>S只包含小写字母 ‘a’ 到 ‘z’ 。</li></ul><h3 id="思路-12"><a href="#思路-12" class="headerlink" title="思路"></a>思路</h3><p>一想到分割字符串就想到了回溯，但本题其实不用回溯去暴力搜索。</p><p>题目要求同一字母最多出现在一个片段中，那么如何把同一个字母的都圈在同一个区间里呢？</p><p>如果没有接触过这种题目的话，还挺有难度的。</p><p>在遍历的过程中相当于是要找每一个字母的边界，<strong>如果找到之前遍历过的所有字母的最远边界，说明这个边界就是分割点了</strong>。此时前面出现过所有字母，最远也就到这个边界了。</p><p>可以分为如下两步：</p><ul><li>统计每一个字符最后出现的位置</li><li>从头遍历字符，并更新字符的最远出现下标，如果找到字符最远出现位置下标和当前下标相等了，则找到了分割点</li></ul><p>如图：</p><p><img src="https://img-blog.csdnimg.cn/20201222191924417.png" alt="763.划分字母区间"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">partitionLabels</span><span class="params">(string S)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> hash[<span class="number">27</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">// i为字符，hash[i]为字符出现的最后位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; S.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 统计每一个字符最后出现的位置</span></span><br><span class="line">            hash[S[i] - <span class="string">&#x27;a&#x27;</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; S.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            right = <span class="built_in">max</span>(right, hash[S[i] - <span class="string">&#x27;a&#x27;</span>]); <span class="comment">// 找到字符出现的最远边界</span></span><br><span class="line">            <span class="keyword">if</span> (i == right) &#123;</span><br><span class="line">                result.<span class="built_in">push_back</span>(right - left + <span class="number">1</span>);</span><br><span class="line">                left = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="合并区间"><a href="#合并区间" class="headerlink" title="合并区间"></a><a href="https://leetcode-cn.com/problems/merge-intervals/">合并区间</a></h2><p>给出一个区间的集合，请合并所有重叠的区间。</p><p>示例 1:</p><ul><li>输入: intervals &#x3D; [[1,3],[2,6],[8,10],[15,18]]</li><li>输出: [[1,6],[8,10],[15,18]]</li><li>解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</li></ul><p>示例 2:</p><ul><li>输入: intervals &#x3D; [[1,4],[4,5]]</li><li>输出: [[1,5]]</li><li>解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。</li><li>注意：输入类型已于2019年4月15日更改。 请重置默认代码定义以获取新方法签名。</li></ul><p>提示：</p><ul><li>intervals[i][0] &lt;&#x3D; intervals[i][1]</li></ul><h3 id="思路-13"><a href="#思路-13" class="headerlink" title="思路"></a>思路</h3><p>按照左边界排序</p><ul><li><p>局部最优：每次合并都取最大的右边界，这样就可以合并更多的区间了</p></li><li><p>整体最优：合并所有重叠的区间</p></li></ul><p>按照左边界从小到大排序之后</p><p>如果 <code>intervals[i][0] &lt; intervals[i - 1][1]</code> 即intervals[i]左边界 &lt; intervals[i - 1]右边界，则一定有重复，因为intervals[i]的左边界一定是大于等于intervals[i - 1]的左边界</p><p>即：intervals[i]的左边界在intervals[i - 1]左边界和右边界的范围内，那么一定有重复！</p><p>这么说有点抽象，看图：（<strong>注意图中区间都是按照左边界排序之后了</strong>）</p><p><img src="https://img-blog.csdnimg.cn/20201223200632791.png" alt="56.合并区间"></p><p>知道如何判断重复之后，剩下的就是合并了，如何去模拟合并区间呢？</p><p>其实就是用合并区间后左边界和右边界，作为一个新的区间，加入到result数组里就可以了。如果没有合并就把原区间加入到result数组。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 按照区间左边界从小到大排序</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">cmp</span> <span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; a, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">merge</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="keyword">if</span> (intervals.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> result;</span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>(), cmp);</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">false</span>; <span class="comment">// 标记最后一个区间有没有合并</span></span><br><span class="line">        <span class="type">int</span> length = intervals.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> start = intervals[i - <span class="number">1</span>][<span class="number">0</span>];    <span class="comment">// 初始为i-1区间的左边界</span></span><br><span class="line">            <span class="type">int</span> end = intervals[i - <span class="number">1</span>][<span class="number">1</span>];      <span class="comment">// 初始i-1区间的右边界</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; length &amp;&amp; intervals[i][<span class="number">0</span>] &lt;= end) &#123; <span class="comment">// 合并区间</span></span><br><span class="line">                end = <span class="built_in">max</span>(end, intervals[i][<span class="number">1</span>]);    <span class="comment">// 不断更新右区间</span></span><br><span class="line">                <span class="keyword">if</span> (i == length - <span class="number">1</span>) flag = <span class="literal">true</span>;   <span class="comment">// 最后一个区间也合并了</span></span><br><span class="line">                i++;                                <span class="comment">// 继续合并下一个区间</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// start和end是表示intervals[i - 1]的左边界右边界，所以最优intervals[i]区间是否合并了要标记一下</span></span><br><span class="line">            result.<span class="built_in">push_back</span>(&#123;start, end&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果最后一个区间没有合并，将其加入result</span></span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="literal">false</span>) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(&#123;intervals[length - <span class="number">1</span>][<span class="number">0</span>], intervals[length - <span class="number">1</span>][<span class="number">1</span>]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当然以上代码有冗余一些，可以优化一下，如下：（思路是一样的）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">merge</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="keyword">if</span> (intervals.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> result;</span><br><span class="line">        <span class="comment">// 排序的参数使用了lamda表达式</span></span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>(), [](<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; a, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; b)&#123;<span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>];&#125;);</span><br><span class="line"></span><br><span class="line">        result.<span class="built_in">push_back</span>(intervals[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; intervals.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (result.<span class="built_in">back</span>()[<span class="number">1</span>] &gt;= intervals[i][<span class="number">0</span>]) &#123; <span class="comment">// 合并区间</span></span><br><span class="line">                result.<span class="built_in">back</span>()[<span class="number">1</span>] = <span class="built_in">max</span>(result.<span class="built_in">back</span>()[<span class="number">1</span>], intervals[i][<span class="number">1</span>]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result.<span class="built_in">push_back</span>(intervals[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="单调递增的数字"><a href="#单调递增的数字" class="headerlink" title="单调递增的数字"></a><a href="https://leetcode-cn.com/problems/monotone-increasing-digits/">单调递增的数字</a></h2><p>给定一个非负整数 N，找出小于或等于 N 的最大的整数，同时这个整数需要满足其各个位数上的数字是单调递增。</p><p>（当且仅当每个相邻位数上的数字 x 和 y 满足 x &lt;&#x3D; y 时，我们称这个整数是单调递增的。）</p><p>示例 1:</p><ul><li>输入: N &#x3D; 10</li><li>输出: 9</li></ul><p>示例 2:</p><ul><li>输入: N &#x3D; 1234</li><li>输出: 1234</li></ul><p>示例 3:</p><ul><li>输入: N &#x3D; 332</li><li>输出: 299</li></ul><p>说明: N 是在 [0, 10^9] 范围内的一个整数。</p><h3 id="思路-14"><a href="#思路-14" class="headerlink" title="思路"></a>思路</h3><p>题目要求小于等于N的最大单调递增的整数，那么拿一个两位的数字来举例。</p><p>例如：98，一旦出现strNum[i - 1] &gt; strNum[i]的情况（非单调递增），首先想让strNum[i - 1]–，然后strNum[i]给为9，这样这个整数就是89，即小于98的最大的单调递增整数。</p><p>这一点如果想清楚了，这道题就好办了。</p><ul><li><p><strong>局部最优：遇到strNum[i - 1] &gt; strNum[i]的情况，让strNum[i - 1]–，然后strNum[i]给为9，可以保证这两位变成最大单调递增整数</strong>。</p></li><li><p><strong>全局最优：得到小于等于N的最大单调递增的整数</strong>。</p></li></ul><p><strong>但这里局部最优推出全局最优，还需要其他条件，即遍历顺序，和标记从哪一位开始统一改成9</strong>。</p><p>此时是从前向后遍历还是从后向前遍历呢？</p><p>从前向后遍历的话，遇到strNum[i - 1] &gt; strNum[i]的情况，让strNum[i - 1]减一，但此时如果strNum[i - 1]减一了，可能又小于strNum[i - 2]。</p><p>这么说有点抽象，举个例子，数字：332，从前向后遍历的话，那么就把变成了329，此时2又小于了第一位的3了，真正的结果应该是299。</p><p><strong>所以从前后向遍历会改变已经遍历过的结果！</strong></p><p>那么从后向前遍历，就可以重复利用上次比较得出的结果了，从后向前遍历332的数值变化为：332 -&gt; 329 -&gt; 299</p><p>确定了遍历顺序之后，那么此时局部最优就可以推出全局，找不出反例，试试贪心。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">monotoneIncreasingDigits</span><span class="params">(<span class="type">int</span> N)</span> </span>&#123;</span><br><span class="line">        string strNum = <span class="built_in">to_string</span>(N);</span><br><span class="line">        <span class="comment">// flag用来标记赋值9从哪里开始</span></span><br><span class="line">        <span class="comment">// 设置为这个默认值，为了防止第二个for循环在flag没有被赋值的情况下执行</span></span><br><span class="line">        <span class="type">int</span> flag = strNum.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = strNum.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (strNum[i - <span class="number">1</span>] &gt; strNum[i] ) &#123;</span><br><span class="line">                flag = i;</span><br><span class="line">                strNum[i - <span class="number">1</span>]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = flag; i &lt; strNum.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            strNum[i] = <span class="string">&#x27;9&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">stoi</span>(strNum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="买股票的最佳时机含手续费"><a href="#买股票的最佳时机含手续费" class="headerlink" title="买股票的最佳时机含手续费"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">买股票的最佳时机含手续费</a></h2><p>给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。</p><p>你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</p><p>返回获得利润的最大值。</p><p>注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要支付一次手续费。</p><p>示例 1: 输入: prices &#x3D; [1, 3, 2, 8, 4, 9], fee &#x3D; 2 输出: 8</p><p>解释: 能够达到的最大利润: 在此处买入 prices[0] &#x3D; 1 在此处卖出 prices[3] &#x3D; 8 在此处买入 prices[4] &#x3D; 4 在此处卖出 prices[5] &#x3D; 9 总利润: ((8 - 1) - 2) + ((9 - 4) - 2) &#x3D; 8.</p><p>注意:</p><ul><li>0 &lt; prices.length &lt;&#x3D; 50000.</li><li>0 &lt; prices[i] &lt; 50000.</li><li>0 &lt;&#x3D; fee &lt; 50000.</li></ul><h3 id="思路-15"><a href="#思路-15" class="headerlink" title="思路"></a>思路</h3><p>在<a href="https://programmercarl.com/0122.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII.html">买卖股票的最佳时机II</a>中使用贪心策略不用关心具体什么时候买卖，只要收集每天的正利润，最后稳稳的就是最大利润了。</p><p>而本题有了手续费，就要关系什么时候买卖了，因为计算所获得利润，需要考虑买卖利润可能不足以手续费的情况。</p><p>如果使用贪心策略，就是最低值买，最高值（如果算上手续费还盈利）就卖。</p><p>此时无非就是要找到两个点，买入日期，和卖出日期。</p><ul><li>买入日期：其实很好想，遇到更低点就记录一下。</li><li>卖出日期：这个就不好算了，但也没有必要算出准确的卖出日期，只要当前价格大于（最低价格+手续费），就可以收获利润，至于准确的卖出日期，就是连续收获利润区间里的最后一天（并不需要计算是具体哪一天）。</li></ul><p>所以我们在做收获利润操作的时候其实有三种情况：</p><ul><li>情况一：收获利润的这一天并不是收获利润区间里的最后一天（不是真正的卖出，相当于持有股票），所以后面要继续收获利润。</li><li>情况二：前一天是收获利润区间里的最后一天（相当于真正的卖出了），今天要重新记录最小价格了。</li><li>情况三：不作操作，保持原有状态（买入，卖出，不买不卖）</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices, <span class="type">int</span> fee)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> minPrice = prices[<span class="number">0</span>]; <span class="comment">// 记录最低价格</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 情况二：相当于买入</span></span><br><span class="line">            <span class="keyword">if</span> (prices[i] &lt; minPrice) minPrice = prices[i];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 情况三：保持原有状态（因为此时买则不便宜，卖则亏本）</span></span><br><span class="line">            <span class="keyword">if</span> (prices[i] &gt;= minPrice &amp;&amp; prices[i] &lt;= minPrice + fee) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 计算利润，可能有多次计算利润，最后一次计算利润才是真正意义的卖出</span></span><br><span class="line">            <span class="keyword">if</span> (prices[i] &gt; minPrice + fee) &#123;</span><br><span class="line">                result += prices[i] - minPrice - fee;</span><br><span class="line">                minPrice = prices[i] - fee; <span class="comment">// 情况一，这一步很关键</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从代码中可以看出对情况一的操作，因为如果还在收获利润的区间里，表示并不是真正的卖出，而计算利润每次都要减去手续费，<strong>所以要让minPrice &#x3D; prices[i] - fee;，这样在明天收获利润的时候，才不会多减一次手续费！</strong></p><p>大家也可以发现，情况三，那块代码是可以删掉的，我是为了让代码表达清晰，所以没有精简。</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/%E8%B4%AA%E5%BF%83%E6%80%BB%E7%BB%93water.png"></p><p>声明：本博客整理顺序参考《代码随想录》题目来源leetcode</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>取悦自己</title>
      <link href="/2022/04/08/%E5%8F%96%E6%82%A6%E8%87%AA%E5%B7%B1/"/>
      <url>/2022/04/08/%E5%8F%96%E6%82%A6%E8%87%AA%E5%B7%B1/</url>
      
        <content type="html"><![CDATA[<p>        哪个正经人在网上写日记？</p><p>        自上次念叨完之后，自己的状态确实好了一些，虽然有限，但是至少对我来说，偶尔自我满足的倾诉欲，对我的状态调整是有利的。所以我决定不再做正经人。</p><p>        这几天食欲的问题得到了明显的改善。也和一些朋友交流了一阵，发现自己其实一直生活在焦虑中，学习和休息这两者之间并没有达到一个良好的平衡。</p><p>        之前的状态是：每天都要学习，一旦停下来就会开始愧疚，所以就会不间断地进行学习，但是我明显忽略了一个问题——我一直以来都没有获得真正的休息。短期内可能并不会有什么问题，但是这样的状态我已经持续了一年有余了。一直生活在愧疚和疲惫当中。到了现在，问题已经不得不重视了。</p><p>        加上现在的时间比较多——我拒绝了绝大部分的无效社交。基本上一直是独处的状态。</p><p>        也许我可以用这些时间来做些什么。</p><p>        梳理一下日程安排：</p><table><thead><tr><th>上午9：00-11：30</th><th>算法</th></tr></thead><tbody><tr><td>中午11：30-13：30</td><td>午饭+休息</td></tr><tr><td>下午13：30-17：00</td><td>unreal engine</td></tr><tr><td>下午17：00-18：30</td><td>晚饭+休息</td></tr><tr><td>晚上18：30-19：30</td><td>算法</td></tr><tr><td>晚上19：30-20：30</td><td>keep</td></tr><tr><td>晚上20：30-23：30</td><td>洗漱+休息</td></tr></tbody></table><p>        大概就是这样吧，每周六休息。偶尔周日也可以休息一次，但不能太多。</p><p>        那么学习进度呢？</p><p>        希望能在六月到来之前把代码随想录刷一遍，C语言中文网上剩下的图结构和剩下的几个章节看完。至于unreal engine的话，还不好说，等我再学一会儿才可以制定下进度目标了。理想的状态是六月底就可以新建独立游戏的文件夹。</p><p>        </p><p>        </p><p>        好想快一些离开这里，我要逃离这座城市。我想要到烟雨的江南开始我的新生活。真希望保持这样的作息习惯可以让时间如同白驹过隙那般飞驰而去。</p>]]></content>
      
      
      <categories>
          
          <category> 梦游笔谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嬉荒杂录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回溯算法</title>
      <link href="/2022/04/05/%E6%9C%89%E5%85%B3%E7%AE%97%E6%B3%95%E4%B8%AD%E7%9A%84%E5%9B%9E%E6%BA%AF/"/>
      <url>/2022/04/05/%E6%9C%89%E5%85%B3%E7%AE%97%E6%B3%95%E4%B8%AD%E7%9A%84%E5%9B%9E%E6%BA%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是回溯算法"><a href="#什么是回溯算法" class="headerlink" title="什么是回溯算法"></a>什么是回溯算法</h1><p>回溯算法也叫做回溯搜索法，是一种搜索的方式</p><p>回溯是递归的副产物，只要存在递归，就一定会有回溯</p><h1 id="回溯算法的效率"><a href="#回溯算法的效率" class="headerlink" title="回溯算法的效率"></a>回溯算法的效率</h1><p>回溯的本质是穷举，穷举所有的可能，然后选出我们的答案，所以其效率并不算很高</p><h1 id="回溯算法解决的问题"><a href="#回溯算法解决的问题" class="headerlink" title="回溯算法解决的问题"></a>回溯算法解决的问题</h1><ul><li><p>组合问题：N个数里面按一定规则找出K个数的集合</p></li><li><p>切割问题：一个字符串按一定规则有几种切割方式</p></li><li><p>子集问题：一个N个数的集合里有多少符合条件的子集</p></li><li><p>排列问题：N个数按一定规则全排列，有几种排列方式</p></li><li><p>棋盘问题：N皇后，解数独等</p></li></ul><h1 id="如何理解回溯法"><a href="#如何理解回溯法" class="headerlink" title="如何理解回溯法"></a>如何理解回溯法</h1><p>回溯算法解决的问题都可以抽象为树形结构！</p><p>因为回溯算法解决的都是集中递归查找子集，<strong>集合的大小就构成了树的宽度；递归的深度，都构成树的深度</strong></p><p>递归就要有终止条件，所以必然是一棵高度有限的树（N叉树）</p><h1 id="回溯法模板"><a href="#回溯法模板" class="headerlink" title="回溯法模板"></a>回溯法模板</h1><h2 id="回溯函数模板返回值以及参数"><a href="#回溯函数模板返回值以及参数" class="headerlink" title="回溯函数模板返回值以及参数"></a>回溯函数模板返回值以及参数</h2><ul><li><p>回溯算法中函数返回值一般为void</p></li><li><p>先写逻辑，然后需要什么参数就填什么参数</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(参数)</span></span></span><br></pre></td></tr></table></figure><h2 id="回溯终止条件"><a href="#回溯终止条件" class="headerlink" title="回溯终止条件"></a>回溯终止条件</h2><p>既然是树形结构，那么在遍历树形结构的时候一定要有终止条件！</p><p>什么时候达到了终止条件，树中就可以看出，一般来说搜到叶子节点，也就找到了满足条件的一条答案，把这个答案存放起来，并结束本层递归</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(终止条件)&#123;</span><br><span class="line">    存放结果;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="回溯搜索的遍历过程"><a href="#回溯搜索的遍历过程" class="headerlink" title="回溯搜索的遍历过程"></a>回溯搜索的遍历过程</h2><p>回溯算法一般是在集合中递归搜索，<strong>集合的大小构成了树的宽度，递归的深度构成了树的深度</strong></p><p><img src="https://img-blog.csdnimg.cn/20210130173631174.png" alt="回溯算法理论基础"></p><p>注意：此处集合大小和孩子的数量是相等的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(选择：本层集合中元素（树中节点孩子的数量就是集合的大小）)&#123;</span><br><span class="line">    处理节点;</span><br><span class="line">    <span class="built_in">backtracking</span>(路径,选择列表);<span class="comment">//递归</span></span><br><span class="line">    回溯，撤销处理结果</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for循环理解为横向遍历，backtracking（递归）就是纵向遍历</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(参数)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(终止条件)&#123;</span><br><span class="line">    存放结果;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(选择：本层集合中元素（树中节点孩子的数量就是集合的大小）)&#123;</span><br><span class="line">    处理节点;</span><br><span class="line">    <span class="built_in">backtracking</span>(路径,选择列表);<span class="comment">//递归</span></span><br><span class="line">    回溯，撤销处理结果</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h1><h2 id="组合问题"><a href="#组合问题" class="headerlink" title="组合问题"></a><a href="%5B%E5%8A%9B%E6%89%A3%5D(https://leetcode-cn.com/problems/combinations/)">组合问题</a></h2><p>给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。</p><p>示例:<br>输入: n &#x3D; 4, k &#x3D; 2<br>输出:<br>[<br>[2,4],<br>[3,4],<br>[2,3],<br>[1,2],<br>[1,3],<br>[1,4],<br>]</p><p>思路：</p><p>把这个问题放到一棵树里面去思考</p><p><img src="https://img-blog.csdnimg.cn/20201123195223940.png" alt="77.组合"></p><p>每次从集合中选取元素，可选择的范围随着选择的进行而收缩，调整可选择的范围。</p><p>图中我们不难发现：n相当于树的宽度，k相当于树的深度</p><p>结果：每搜索到一个叶子节点，就相当于找到了一个结果</p><h3 id="递归函数的返回值及参数"><a href="#递归函数的返回值及参数" class="headerlink" title="递归函数的返回值及参数"></a>递归函数的返回值及参数</h3><ol><li>返回值</li></ol><p>定义两个全局变量，一个用来存放符合条件的单一结果，一个用来存放符合条件结果的集合</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;<span class="comment">//存放符合条件结果的集合</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; path;<span class="comment">//存放符合条件的结果</span></span><br></pre></td></tr></table></figure><ol start="2"><li>参数</li></ol><p>函数内一定有两个参数：int k,int n</p><p>还需要一个参数，为int类型变量startindex，这个参数用来记录本层递归中集合从哪里开始遍历（集合就是[1,….,n]）</p><p>startindex的意义：每次从集合中选取元素，可选择的范围随着选择的进行而收缩，调整可选择的范围就是靠startindex</p><p>startindex记录下一层递归，搜索起始位</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;result;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> k,<span class="type">int</span> startindex)</span></span></span><br></pre></td></tr></table></figure><h3 id="函数终止条件"><a href="#函数终止条件" class="headerlink" title="函数终止条件"></a>函数终止条件</h3><p>什么时候到达叶子节点了？</p><p>path这个数组的大小达到了k，说明找到了一个子集大小为k的组合了</p><p>此时就用result二维数组把path保存起来，并终止本层递归</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(path.<span class="built_in">size</span>()==k)&#123;</span><br><span class="line">    result.<span class="built_in">push_back</span>(path);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单层搜索的过程"><a href="#单层搜索的过程" class="headerlink" title="单层搜索的过程"></a>单层搜索的过程</h3><p>用for循环来横向遍历，递归的过程就是纵向遍历</p><p>for循环每次从startindex开始遍历，然后用path保存取得的节点j</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=startindex;i&lt;=n;i++)&#123;<span class="comment">//控制树的横向遍历</span></span><br><span class="line">    path.<span class="built_in">push_back</span>(i);<span class="comment">//处理节点</span></span><br><span class="line">    <span class="built_in">backtracking</span>(n,k,i+<span class="number">1</span>);<span class="comment">//递归：控制树的纵向遍历，注意下一层搜索从i+1开始</span></span><br><span class="line">    path.<span class="built_in">pop_back</span>();<span class="comment">//回溯，撤销处理的节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出backtracking通过不断调用子集一直往深处遍历，总会遇到叶子节点，遇到了叶子节点就要返回</p><p>完整代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result; <span class="comment">// 存放符合条件结果的集合</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path; <span class="comment">// 用来存放符合条件结果</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k, <span class="type">int</span> startIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (path.<span class="built_in">size</span>() == k) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt;= n; i++) &#123;</span><br><span class="line">            path.<span class="built_in">push_back</span>(i); <span class="comment">// 处理节点 </span></span><br><span class="line">            <span class="built_in">backtracking</span>(n, k, i + <span class="number">1</span>); <span class="comment">// 递归</span></span><br><span class="line">            path.<span class="built_in">pop_back</span>(); <span class="comment">// 回溯，撤销处理的节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combine</span>(<span class="type">int</span> n, <span class="type">int</span> k) &#123;</span><br><span class="line">        result.<span class="built_in">clear</span>(); <span class="comment">// 可以不写</span></span><br><span class="line">        path.<span class="built_in">clear</span>();   <span class="comment">// 可以不写</span></span><br><span class="line">        <span class="built_in">backtracking</span>(n, k, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剪枝优化"><a href="#剪枝优化" class="headerlink" title="剪枝优化"></a>剪枝优化</h4><p>我们说过，回溯法虽然是暴力搜索，但也有时候可以有点剪枝优化一下的。</p><p>在遍历的过程中有如下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt;= n; i++) &#123;</span><br><span class="line">    path.<span class="built_in">push_back</span>(i);</span><br><span class="line">    <span class="built_in">backtracking</span>(n, k, i + <span class="number">1</span>);</span><br><span class="line">    path.<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来举一个例子，n &#x3D; 4，k &#x3D; 4的话，那么第一层for循环的时候，从元素2开始的遍历都没有意义了。 在第二层for循环，从元素3开始的遍历都没有意义了。</p><p>这么说有点抽象，如图所示：</p><p><img src="https://img-blog.csdnimg.cn/20210130194335207.png" alt="77.组合4"></p><p>图中每一个节点（图中为矩形），就代表本层的一个for循环，那么每一层的for循环从第二个数开始遍历的话，都没有意义，都是无效遍历。</p><p><strong>所以，可以剪枝的地方就在递归中每一层的for循环所选择的起始位置</strong>。</p><p><strong>如果for循环选择的起始位置之后的元素个数 已经不足 我们需要的元素个数了，那么就没有必要搜索了</strong>。</p><p>注意代码中i，就是for循环里选择的起始位置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt;= n; i++) </span><br></pre></td></tr></table></figure><p>接下来看一下优化过程如下：</p><ol><li><p>已经选择的元素个数：path.size();</p></li><li><p>还需要的元素个数为: k - path.size();</p></li><li><p>在集合n中至多要从该起始位置 : n - (k - path.size()) + 1，开始遍历</p></li></ol><p>为什么有个+1呢，因为包括起始位置，我们要是一个左闭的集合。</p><p>举个例子，n &#x3D; 4，k &#x3D; 3， 目前已经选取的元素为0（path.size为0），n - (k - 0) + 1 即 4 - ( 3 - 0) + 1 &#x3D; 2。</p><p>从2开始搜索都是合理的，可以是组合[2, 3, 4]。</p><p>这里大家想不懂的话，建议也举一个例子，就知道是不是要+1了。</p><p>所以优化之后的for循环是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt;= n - (k - path.<span class="built_in">size</span>()) + <span class="number">1</span>; i++) <span class="comment">// i为本次搜索的起始位置</span></span><br></pre></td></tr></table></figure><p>完整代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k, <span class="type">int</span> startIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (path.<span class="built_in">size</span>() == k) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt;= n - (k - path.<span class="built_in">size</span>()) + <span class="number">1</span>; i++) &#123; <span class="comment">// 优化的地方</span></span><br><span class="line">            path.<span class="built_in">push_back</span>(i); <span class="comment">// 处理节点</span></span><br><span class="line">            <span class="built_in">backtracking</span>(n, k, i + <span class="number">1</span>);</span><br><span class="line">            path.<span class="built_in">pop_back</span>(); <span class="comment">// 回溯，撤销处理的节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combine</span>(<span class="type">int</span> n, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="built_in">backtracking</span>(n, k, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="组合总和"><a href="#组合总和" class="headerlink" title="组合总和"></a><a href="%5B%E5%8A%9B%E6%89%A3%5D(https://leetcode-cn.com/problems/combination-sum-iii/)">组合总和</a></h2><p>找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。</p><p>说明：</p><ul><li>所有数字都是正整数。</li><li>解集不能包含重复的组合。</li></ul><p>示例 1: 输入: k &#x3D; 3, n &#x3D; 7 输出: [[1,2,4]]</p><p>示例 2: 输入: k &#x3D; 3, n &#x3D; 9 输出: [[1,2,6], [1,3,5], [2,3,4]]</p><p>思路：</p><ul><li>k相当于树的深度，9相当于树的宽度（整个集合就是9个数）</li></ul><img title="" src="https://img-blog.csdnimg.cn/20201123195717975.png" alt="216.组合总和III" width="810"><h3 id="确定递归函数返回值与参数"><a href="#确定递归函数返回值与参数" class="headerlink" title="确定递归函数返回值与参数"></a>确定递归函数返回值与参数</h3><ol><li>返回值</li></ol><p>一维数组path存储符合条件的结果</p><p>二维数组result存储结果集</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;<span class="comment">//存放结果集</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;path;<span class="comment">//符合条件的结果</span></span><br></pre></td></tr></table></figure><ol start="2"><li><p>参数</p><ul><li><p>targetsum(int)目标和，也就是题目中的n</p></li><li><p>k(int)就是题目中要求k个数的集合</p></li><li><p>sum(int)为已经收集的元素的总和，也就是path中元素的总和</p></li><li><p>startindex(int)为下一层for循环搜索的起始位置</p></li></ul></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">int</span> targetsum,<span class="type">int</span> k,<span class="type">int</span> sum,<span class="type">int</span> startindex)</span></span></span><br></pre></td></tr></table></figure><p>回溯算法中递归函数参数很难一次性确定下来，所以先写逻辑，需要啥再补啥也完全可以</p><h3 id="确定终止条件"><a href="#确定终止条件" class="headerlink" title="确定终止条件"></a>确定终止条件</h3><p>根据题意：取k个元素-&gt;也就是说path.size()&#x3D;&#x3D;k时，就可以终止</p><p>如果此时path里手机到的元素和sum&#x3D;&#x3D;targetsum，就可以用result收集当前结果</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(path.<span class="built_in">size</span>()==k)&#123;</span><br><span class="line">    <span class="keyword">if</span>(sum==targetsum)&#123;</span><br><span class="line">    result.<span class="built_in">push_back</span>(path);</span><br><span class="line">    <span class="keyword">return</span>;<span class="comment">//如果size()==k,但sum!=targetsum，则直接返回</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单层搜索过程"><a href="#单层搜索过程" class="headerlink" title="单层搜索过程"></a>单层搜索过程</h3><p>集合固定在1-9之间，所以for循环固定i&lt;&#x3D; 9</p><p>处理过程就是path收集每次选取的元素，相当于树形结构里的边，sum来统计path里元素的总和</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=startindex;i&lt;=<span class="number">9</span>;i++)&#123;</span><br><span class="line">    sum+=i;</span><br><span class="line">    path.<span class="built_in">push_back</span>(i);</span><br><span class="line">    <span class="built_in">backtracking</span>(targetsum,k,sum,i+<span class="number">1</span>);</span><br><span class="line">    sum-=i;<span class="comment">//回溯</span></span><br><span class="line">    path.<span class="built_in">pop_back</span>(i);<span class="comment">//回溯</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result; <span class="comment">// 存放结果集</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path; <span class="comment">// 符合条件的结果</span></span><br><span class="line">    <span class="comment">// targetSum：目标和，也就是题目中的n。</span></span><br><span class="line">    <span class="comment">// k：题目中要求k个数的集合。</span></span><br><span class="line">    <span class="comment">// sum：已经收集的元素的总和，也就是path里元素的总和。</span></span><br><span class="line">    <span class="comment">// startIndex：下一层for循环搜索的起始位置。</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">int</span> targetSum, <span class="type">int</span> k, <span class="type">int</span> sum, <span class="type">int</span> startIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (path.<span class="built_in">size</span>() == k) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum == targetSum) result.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// 如果path.size() == k 但sum != targetSum 直接返回</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt;= <span class="number">9</span>; i++) &#123;</span><br><span class="line">            sum += i; <span class="comment">// 处理</span></span><br><span class="line">            path.<span class="built_in">push_back</span>(i); <span class="comment">// 处理</span></span><br><span class="line">            <span class="built_in">backtracking</span>(targetSum, k, sum, i + <span class="number">1</span>); <span class="comment">// 注意i+1调整startIndex</span></span><br><span class="line">            sum -= i; <span class="comment">// 回溯</span></span><br><span class="line">            path.<span class="built_in">pop_back</span>(); <span class="comment">// 回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum3</span>(<span class="type">int</span> k, <span class="type">int</span> n) &#123;</span><br><span class="line">        result.<span class="built_in">clear</span>(); <span class="comment">// 可以不加</span></span><br><span class="line">        path.<span class="built_in">clear</span>();   <span class="comment">// 可以不加</span></span><br><span class="line">        <span class="built_in">backtracking</span>(n, k, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="电话号码的字母组合"><a href="#电话号码的字母组合" class="headerlink" title="电话号码的字母组合"></a><a href="%5B%E5%8A%9B%E6%89%A3%5D(https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)">电话号码的字母组合</a></h2><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><img title="" src="https://img-blog.csdnimg.cn/2020102916424043.png" alt="17.电话号码的字母组合" width="567"><p>示例: 输入：”23” 输出：[“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”].</p><p>说明：尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。</p><p>思路：</p><ol><li><p>数字和字母如何映射</p></li><li><p>两个字母就两个for，三个字母三个for，以此类推的话，根本写不出来</p></li><li><p>输入1 * #按键等等异常情况</p></li></ol><h3 id="数字和字母如何映射"><a href="#数字和字母如何映射" class="headerlink" title="数字和字母如何映射"></a>数字和字母如何映射</h3><p>使用map或者定义一个二维数组</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> string letterMap[<span class="number">10</span>] = &#123;</span><br><span class="line">    <span class="string">&quot;&quot;</span>, <span class="comment">// 0</span></span><br><span class="line">    <span class="string">&quot;&quot;</span>, <span class="comment">// 1</span></span><br><span class="line">    <span class="string">&quot;abc&quot;</span>, <span class="comment">// 2</span></span><br><span class="line">    <span class="string">&quot;def&quot;</span>, <span class="comment">// 3</span></span><br><span class="line">    <span class="string">&quot;ghi&quot;</span>, <span class="comment">// 4</span></span><br><span class="line">    <span class="string">&quot;jkl&quot;</span>, <span class="comment">// 5</span></span><br><span class="line">    <span class="string">&quot;mno&quot;</span>, <span class="comment">// 6</span></span><br><span class="line">    <span class="string">&quot;pqrs&quot;</span>, <span class="comment">// 7</span></span><br><span class="line">    <span class="string">&quot;tuv&quot;</span>, <span class="comment">// 8</span></span><br><span class="line">    <span class="string">&quot;wxyz&quot;</span>, <span class="comment">// 9</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>输入：”23”，抽象为树形结构，如图所示：</p><p><img src="https://img-blog.csdnimg.cn/20201123200304469.png" alt="17. 电话号码的字母组合"></p><p>图中可以看出遍历的深度，就是输入”23”的长度，而叶子节点就是我们要收集的结果，输出[“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”]。</p><h3 id="确定回溯函数参数与返回值"><a href="#确定回溯函数参数与返回值" class="headerlink" title="确定回溯函数参数与返回值"></a>确定回溯函数参数与返回值</h3><ol><li>返回值</li></ol><p>需要一个字符串s来手机叶子节点的结果</p><p>用一个字符串数组result保存起来</p><ol start="2"><li>参数</li></ol><p>题目中给的string digits</p><p>还需要一个int类型的index：记录遍历到第几个数字了，就是用来遍历digits的；同时index也表示树的深度</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; result;</span><br><span class="line">string s;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">const</span> string&amp; digits,<span class="type">int</span> index)</span></span></span><br></pre></td></tr></table></figure><h3 id="确定终止条件-1"><a href="#确定终止条件-1" class="headerlink" title="确定终止条件"></a>确定终止条件</h3><p>例如输入用例“23”，两个数字，那么根节点往下递归两层就可以了，叶子节点就是要收集的结果集</p><p>那么终止条件就是如果index&#x3D;&#x3D;digits.size()</p><p>然后收集结果，结束本层递归</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(index==digits.<span class="built_in">size</span>())&#123;</span><br><span class="line">    result.<span class="built_in">push_back</span>(s);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="确定单层遍历逻辑"><a href="#确定单层遍历逻辑" class="headerlink" title="确定单层遍历逻辑"></a>确定单层遍历逻辑</h3><p>首先要取index指向的数字，并找到对应的字符集（手机键盘里的字符集）</p><p>然后用for循环来处理这个字符集</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> digit = digits[index] - <span class="string">&#x27;0&#x27;</span>;        <span class="comment">// 将index指向的数字转为int</span></span><br><span class="line">string letters = letterMap[digit];      <span class="comment">// 取数字对应的字符集</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; letters.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    s.<span class="built_in">push_back</span>(letters[i]);            <span class="comment">// 处理</span></span><br><span class="line">    <span class="built_in">backtracking</span>(digits, index + <span class="number">1</span>);    <span class="comment">// 递归，注意index+1，一下层要处理下一个数字了</span></span><br><span class="line">    s.<span class="built_in">pop_back</span>();                       <span class="comment">// 回溯</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的for循环，不是像上一题那样从startindex开始遍历的</p><p>因为本题每个数字代表的是不同的集合，也就是求不同集合之间的组合，而上一题是在求同一个集合中的组合</p><p>注意：输入1，*，#的异常情况</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> string letterMap[<span class="number">10</span>] = &#123;</span><br><span class="line">        <span class="string">&quot;&quot;</span>, <span class="comment">// 0</span></span><br><span class="line">        <span class="string">&quot;&quot;</span>, <span class="comment">// 1</span></span><br><span class="line">        <span class="string">&quot;abc&quot;</span>, <span class="comment">// 2</span></span><br><span class="line">        <span class="string">&quot;def&quot;</span>, <span class="comment">// 3</span></span><br><span class="line">        <span class="string">&quot;ghi&quot;</span>, <span class="comment">// 4</span></span><br><span class="line">        <span class="string">&quot;jkl&quot;</span>, <span class="comment">// 5</span></span><br><span class="line">        <span class="string">&quot;mno&quot;</span>, <span class="comment">// 6</span></span><br><span class="line">        <span class="string">&quot;pqrs&quot;</span>, <span class="comment">// 7</span></span><br><span class="line">        <span class="string">&quot;tuv&quot;</span>, <span class="comment">// 8</span></span><br><span class="line">        <span class="string">&quot;wxyz&quot;</span>, <span class="comment">// 9</span></span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;string&gt; result;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">const</span> string&amp; digits, <span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index == digits.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(s);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> digit = digits[index] - <span class="string">&#x27;0&#x27;</span>;        <span class="comment">// 将index指向的数字转为int</span></span><br><span class="line">        string letters = letterMap[digit];      <span class="comment">// 取数字对应的字符集</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; letters.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            s.<span class="built_in">push_back</span>(letters[i]);            <span class="comment">// 处理</span></span><br><span class="line">            <span class="built_in">backtracking</span>(digits, index + <span class="number">1</span>);    <span class="comment">// 递归，注意index+1，一下层要处理下一个数字了</span></span><br><span class="line">            s.<span class="built_in">pop_back</span>();                       <span class="comment">// 回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">letterCombinations</span><span class="params">(string digits)</span> </span>&#123;</span><br><span class="line">        s.<span class="built_in">clear</span>();</span><br><span class="line">        result.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">if</span> (digits.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">backtracking</span>(digits, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="组合总和2"><a href="#组合总和2" class="headerlink" title="组合总和2"></a>组合总和2</h2><p>给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p><p>candidates 中的数字可以无限制重复被选取。</p><p>说明：</p><ul><li>所有数字（包括 target）都是正整数。</li><li>解集不能包含重复的组合。</li></ul><p>示例 1： 输入：candidates &#x3D; [2,3,6,7], target &#x3D; 7, 所求解集为： [ [7], [2,2,3] ]</p><p>示例 2： 输入：candidates &#x3D; [2,3,5], target &#x3D; 8, 所求解集为： [   [2,2,2,2],   [2,3,3],   [3,5] ]</p><p>思路：</p><p>抽象为树形结构</p><p>横向遍历的宽度：candidates.size()</p><p>树的深度：</p><p>回溯算法三步</p><ul><li><p>函数的返回值和参数</p></li><li><p>终止条件</p></li><li><p>横向遍历逻辑</p></li></ul><h3 id="返回值与参数"><a href="#返回值与参数" class="headerlink" title="返回值与参数"></a>返回值与参数</h3><ul><li><p>参数：题目给出的int target，vector<int>&amp; candidates；startindex来控制for循环的起始位置</p></li><li><p>返回值：一维数组path存放符合条件的结果；二维数组result存放结果集</p></li></ul><h4 id="什么时候需要startindex？"><a href="#什么时候需要startindex？" class="headerlink" title="什么时候需要startindex？"></a>什么时候需要startindex？</h4><ul><li><p>如果是一个集合求组合的话，就需要startindex</p></li><li><p>如果是多个集合求组合，各个集合之间互不影响，就不需要startindex</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;result;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; candidate,<span class="type">int</span> target,<span class="type">int</span> sum,<span class="type">int</span> startindex)</span></span></span><br></pre></td></tr></table></figure><h3 id="递归终止条件"><a href="#递归终止条件" class="headerlink" title="递归终止条件"></a>递归终止条件</h3><p>当sum&gt;target时直接返回</p><p>当sum&#x3D;&#x3D;target时操作后再返回</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(sum&gt;target)&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(sum==target)&#123;</span><br><span class="line">    result.<span class="built_in">push_back</span>(path);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单层搜索逻辑"><a href="#单层搜索逻辑" class="headerlink" title="单层搜索逻辑"></a>单层搜索逻辑</h3><p>单层搜索从startindex开始，搜索candidates</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=startindex;i&lt;candidates.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">    sum+=candidates[i];</span><br><span class="line">    path.<span class="built_in">push_back</span>(sum);</span><br><span class="line">    <span class="built_in">backtracking</span>(candidates,target,sum,i);<span class="comment">//关键点，不需要写成i+1，表示可以重复读取当前的数</span></span><br><span class="line">    sum-=canidates[i];</span><br><span class="line">    path.<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target, <span class="type">int</span> sum, <span class="type">int</span> startIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; candidates.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            sum += candidates[i];</span><br><span class="line">            path.<span class="built_in">push_back</span>(candidates[i]);</span><br><span class="line">            <span class="built_in">backtracking</span>(candidates, target, sum, i); <span class="comment">// 不用i+1了，表示可以重复读取当前的数</span></span><br><span class="line">            sum -= candidates[i];</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">        result.<span class="built_in">clear</span>();</span><br><span class="line">        path.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="built_in">backtracking</span>(candidates, target, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="数组总和3"><a href="#数组总和3" class="headerlink" title="数组总和3"></a>数组总和3</h2><p>给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p><p>candidates 中的每个数字在每个组合中只能使用一次。</p><p>说明： 所有数字（包括目标数）都是正整数。 解集不能包含重复的组合。</p><p>示例 1: 输入: candidates &#x3D; [10,1,2,7,6,1,5], target &#x3D; 8, 所求解集为: [ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6] ]</p><p>示例 2: 输入: candidates &#x3D; [2,5,2,1,2], target &#x3D; 5, 所求解集为: [   [1,2,2],   [5] ]</p><ol><li><p>本题candidates中的每个数字在每个组合中只能使用一次</p></li><li><p>本题candidates中的元素是有重复的</p></li></ol><p>难点：candidates有重复元素，但最后不可以有重复的组合</p><p>如果把所有的组合求出来，再用set或者map去重很容易超时，所以我们需要在搜索的过程中就去重。</p><p><strong>去重</strong>：使用过的元素不能重复选取</p><p>都知道组合问题可以抽象为树形结构，那么“使用过”在这个树形结构上是有两个维度的，一个维度是同一树枝上使用过，一个维度是同一树层上使用过。<strong>没有理解这两个层面上的“使用过” 是造成大家没有彻底理解去重的根本原因。</strong></p><p>那么问题来了，我们是要同一树层上使用过，还是同一树枝上使用过呢？</p><p>回看一下题目，元素在同一个组合内是可以重复的，怎么重复都没事，但两个组合不能相同。</p><p><strong>所以我们要去重的是同一树层上的“使用过”，同一树枝上的都是一个组合里的元素，不用去重</strong>。</p><p>为了理解去重我们来举一个例子，candidates &#x3D; [1, 1, 2], target &#x3D; 3，（方便起见candidates已经排序了）</p><p><strong>强调一下，树层去重的话，需要对数组排序！</strong></p><p>选择过程树形结构如图所示：</p><p><img src="https://img-blog.csdnimg.cn/20201123202736384.png" alt="40.组合总和II"></p><h3 id="递归函数参数与返回值"><a href="#递归函数参数与返回值" class="headerlink" title="递归函数参数与返回值"></a>递归函数参数与返回值</h3><p>与前两题思路相同，但是此题还需要加一个bool型数组used，用来记录同一树枝上的元素是否使用过。</p><p>就是通过used来实现集合去重</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result; <span class="comment">// 存放组合集合</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; path;           <span class="comment">// 符合条件的组合</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target, <span class="type">int</span> sum, <span class="type">int</span> startIndex, vector&lt;<span class="type">bool</span>&gt;&amp; used)</span> </span></span><br></pre></td></tr></table></figure><h3 id="终止条件"><a href="#终止条件" class="headerlink" title="终止条件"></a>终止条件</h3><p>和上两题区别不大</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (sum &gt; target) &#123; <span class="comment">// 这个条件其实可以省略</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">    result.<span class="built_in">push_back</span>(path);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单层搜索逻辑-1"><a href="#单层搜索逻辑-1" class="headerlink" title="单层搜索逻辑"></a>单层搜索逻辑</h3><p>我们需要在这里进行去重操作</p><p>首先明确目标：</p><ul><li>要去重的是“同一树层上使用过的元素”</li></ul><p>解决问题：</p><ul><li>如何判断同一树层上元素（相同元素）是否使用过？</li></ul><p>如果<code>candidates[i]==candidates[i-1]</code>并且<code>used[i-1]==false</code>，就说明：前一个树枝，使用了<code>candidates[i-1]</code>，也就是说同一树层使用过<code>candidate[i-1]</code></p><p>此时for循环内就应该使用continue操作</p><p><img src="https://img-blog.csdnimg.cn/20201123202817973.png" alt="40.组合总和II1"></p><p>图中将used的变化用橘黄色标注上，可以看出在candidates[i] &#x3D;&#x3D; candidates[i - 1]相同的情况下：</p><ul><li>used[i - 1] &#x3D;&#x3D; true，说明同一树枝candidates[i - 1]使用过</li><li>used[i - 1] &#x3D;&#x3D; false，说明同一树层candidates[i - 1]使用过</li></ul><p><strong>这块去重的逻辑很抽象，网上搜的题解基本没有能讲清楚的，如果大家之前思考过这个问题或者刷过这道题目，看到这里一定会感觉通透了很多！</strong></p><p>那么单层搜索的逻辑代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; candidates.<span class="built_in">size</span>() &amp;&amp; sum + candidates[i] &lt;= target; i++) &#123;</span><br><span class="line">    <span class="comment">// used[i - 1] == true，说明同一树枝candidates[i - 1]使用过</span></span><br><span class="line">    <span class="comment">// used[i - 1] == false，说明同一树层candidates[i - 1]使用过</span></span><br><span class="line">    <span class="comment">// 要对同一树层使用过的元素进行跳过</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; candidates[i] == candidates[i - <span class="number">1</span>] &amp;&amp; used[i - <span class="number">1</span>] == <span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sum += candidates[i];</span><br><span class="line">    path.<span class="built_in">push_back</span>(candidates[i]);</span><br><span class="line">    used[i] = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">backtracking</span>(candidates, target, sum, i + <span class="number">1</span>, used); <span class="comment">// 和39.组合总和的区别1：这里是i+1，每个数字在每个组合中只能使用一次</span></span><br><span class="line">    used[i] = <span class="literal">false</span>;</span><br><span class="line">    sum -= candidates[i];</span><br><span class="line">    path.<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意sum + candidates[i] &lt;&#x3D; target为剪枝操作</strong> </p><p>完整代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target, <span class="type">int</span> sum, <span class="type">int</span> startIndex, vector&lt;<span class="type">bool</span>&gt;&amp; used)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; candidates.<span class="built_in">size</span>() &amp;&amp; sum + candidates[i] &lt;= target; i++) &#123;</span><br><span class="line">            <span class="comment">// used[i - 1] == true，说明同一树枝candidates[i - 1]使用过</span></span><br><span class="line">            <span class="comment">// used[i - 1] == false，说明同一树层candidates[i - 1]使用过</span></span><br><span class="line">            <span class="comment">// 要对同一树层使用过的元素进行跳过</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; candidates[i] == candidates[i - <span class="number">1</span>] &amp;&amp; used[i - <span class="number">1</span>] == <span class="literal">false</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sum += candidates[i];</span><br><span class="line">            path.<span class="built_in">push_back</span>(candidates[i]);</span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">backtracking</span>(candidates, target, sum, i + <span class="number">1</span>, used); <span class="comment">// 和39.组合总和的区别1，这里是i+1，每个数字在每个组合中只能使用一次</span></span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">            sum -= candidates[i];</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum2</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">used</span><span class="params">(candidates.size(), <span class="literal">false</span>)</span></span>;</span><br><span class="line">        path.<span class="built_in">clear</span>();</span><br><span class="line">        result.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="comment">// 首先把给candidates排序，让其相同的元素都挨在一起。</span></span><br><span class="line">        <span class="built_in">sort</span>(candidates.<span class="built_in">begin</span>(), candidates.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">backtracking</span>(candidates, target, <span class="number">0</span>, <span class="number">0</span>, used);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="分割问题"><a href="#分割问题" class="headerlink" title="分割问题"></a>分割问题</h2><p>给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。</p><p>返回 s 所有可能的分割方案。</p><p>示例: 输入: “aab” 输出: [ [“aa”,”b”], [“a”,”a”,”b”] ]</p><p>思路：</p><ol><li><p>切割问题，不同的切割方式</p></li><li><p>判断回文</p></li></ol><p>切割问题起始类似于组合问题</p><p>例如：对于字符串abcdef：</p><ul><li><p>组合问题：选取一个a之后，在bcdef中再选取第二个，选取b之后在cdef中选第三个</p></li><li><p>切割问题：切割一个a之后，在bcdef中再去切割第二段，切割b之后在cdef中切割第三段</p></li></ul><img src="https://code-thinking.cdn.bcebos.com/pics/131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.jpg" title="" alt="131.分割回文串" width="663"><p>递归用来纵向遍历，for循环用来横向遍历</p><h3 id="递归函数参数与返回值-1"><a href="#递归函数参数与返回值-1" class="headerlink" title="递归函数参数与返回值"></a>递归函数参数与返回值</h3><p>返回值：</p><ul><li><p>一维数组path存储切割之后的回文的子串</p></li><li><p>二维数组result存放结果集</p></li></ul><p>参数：</p><ul><li><p>因为不可重复切割，所以需要startindex</p></li><li><p>题目中给出的const string&amp; s</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;result;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;path;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">const</span> string&amp; s,<span class="type">int</span> startindex)</span></span></span><br></pre></td></tr></table></figure><h3 id="函数终止条件-1"><a href="#函数终止条件-1" class="headerlink" title="函数终止条件"></a>函数终止条件</h3><p><img src="https://code-thinking.cdn.bcebos.com/pics/131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.jpg" alt="131.分割回文串"></p><p>从树形结构的图中可以看出：<strong>切割线切到了字符串最后面</strong>，说明找到了一种切割方法，此时就是本层递归的终止终止条件。</p><p><strong>那么在代码里什么是切割线呢？</strong></p><p>在处理组合问题的时候，递归参数需要传入startIndex，表示下一轮递归遍历的起始位置，这个startIndex就是切割线。</p><p>所以终止条件代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">const</span> string&amp; s,<span class="type">int</span> stratindex)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(stratindex&gt;=s.size)&#123;</span><br><span class="line">    result.<span class="built_in">push_back</span>(path);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单层搜索逻辑-2"><a href="#单层搜索逻辑-2" class="headerlink" title="单层搜索逻辑"></a>单层搜索逻辑</h3><p>关键点：在递归循环中如何截取字串</p><p>在<code>for (int i = startIndex; i &lt; s.size(); i++)</code>循环中，我们定义了起始位置startindex，那么[startindex,i]就是需要截取的子串</p><p>先判断[startindex,i]是不是回文，如果是，就将其插入<code>vector&lt;string&gt;path</code>，path用来记录切割过的回文子串</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=startindex;i&lt;s.<span class="built_in">size</span>(),i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">isPalindrom</span>(s,startindex,i))&#123;<span class="comment">//判断是否为回文串</span></span><br><span class="line">    <span class="comment">//获取[startindex,i]在s中的子串</span></span><br><span class="line">    string str=s.<span class="built_in">substr</span>(startindex,i-startindex+<span class="number">1</span>);</span><br><span class="line">    path.<span class="built_in">push_back</span>(str);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">backtracking</span>(s,i+<span class="number">1</span>);<span class="comment">//寻找i+1为起始位置的子串</span></span><br><span class="line">    path.<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：切割过的位置不可以重复切割，所以<code>backtracking(s,i+1);</code>传入下一层的起始位置为i+1</p><h3 id="判断回文串"><a href="#判断回文串" class="headerlink" title="判断回文串"></a>判断回文串</h3><p>双指针法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="type">const</span> string&amp; s, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = start, j = end; i &lt; j; i++, j--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] != s[j]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; result;</span><br><span class="line">    vector&lt;string&gt; path; <span class="comment">// 放已经回文的子串</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span> <span class="params">(<span class="type">const</span> string&amp; s, <span class="type">int</span> startIndex)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果起始位置已经大于s的大小，说明已经找到了一组分割方案了</span></span><br><span class="line">        <span class="keyword">if</span> (startIndex &gt;= s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isPalindrome</span>(s, startIndex, i)) &#123;   <span class="comment">// 是回文子串</span></span><br><span class="line">                <span class="comment">// 获取[startIndex,i]在s中的子串</span></span><br><span class="line">                string str = s.<span class="built_in">substr</span>(startIndex, i - startIndex + <span class="number">1</span>);</span><br><span class="line">                path.<span class="built_in">push_back</span>(str);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;                                <span class="comment">// 不是回文，跳过</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">backtracking</span>(s, i + <span class="number">1</span>); <span class="comment">// 寻找i+1为起始位置的子串</span></span><br><span class="line">            path.<span class="built_in">pop_back</span>(); <span class="comment">// 回溯过程，弹出本次已经填在的子串</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="type">const</span> string&amp; s, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = start, j = end; i &lt; j; i++, j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] != s[j]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">partition</span>(string s) &#123;</span><br><span class="line">        result.<span class="built_in">clear</span>();</span><br><span class="line">        path.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="built_in">backtracking</span>(s, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="子集问题"><a href="#子集问题" class="headerlink" title="子集问题"></a>子集问题</h2><p>给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。</p><p>说明：解集不能包含重复的子集。</p><p>示例: 输入: nums &#x3D; [1,2,3] 输出: [ [3],   [1],   [2],   [1,2,3],   [1,3],   [2,3],   [1,2],   [] ]</p><p>组合问题和分割问题是收集树的节点</p><p>子集问题是找树的所有节点</p><p>子集问题是无序的，取过的元素不会重复取，写回溯算法的时候，<strong>for就要从startindex开始</strong>，而不是从0开始</p><p><img src="https://img-blog.csdnimg.cn/202011232041348.png" alt="78.子集"></p><p>从图中红线部分，可以看出<strong>遍历这个树的时候，把所有节点记录下来</strong>，就是要求的子集集合</p><h3 id="递归函数参数与返回值-2"><a href="#递归函数参数与返回值-2" class="headerlink" title="递归函数参数与返回值"></a>递归函数参数与返回值</h3><p>返回值：一维数组path为子集收集元素；二维数组result存放子集组合。</p><p>参数：题意中给出的<code>vector&lt;int&gt;&amp; nums</code>还有startindex来确定遍历起始位置</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;result;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;path;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> startindex)</span></span></span><br></pre></td></tr></table></figure><h3 id="递归终止条件-1"><a href="#递归终止条件-1" class="headerlink" title="递归终止条件"></a>递归终止条件</h3><p>由转换为的树状图能看出：当剩余集合为空的时候，就是叶子节点</p><p>什么时候剩余集合为空？</p><ul><li>startindex已经大于数组的长度的时候，因为此时已经没有元素可以取了</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(stratindex&gt;=nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单层搜索逻辑-3"><a href="#单层搜索逻辑-3" class="headerlink" title="单层搜索逻辑"></a>单层搜索逻辑</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=startindex;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">    path.<span class="built_in">push_back</span>(nums[i]);<span class="comment">//子集收集元素</span></span><br><span class="line">    <span class="built_in">backtracking</span>(nums,i+<span class="number">1</span>);<span class="comment">//元素不重复，所以从i+1开始</span></span><br><span class="line">    path.<span class="built_in">pop_back</span>();<span class="comment">//回溯</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> startIndex)</span> </span>&#123;</span><br><span class="line">        result.<span class="built_in">push_back</span>(path); <span class="comment">// 收集子集，要放在终止添加的上面，否则会漏掉自己</span></span><br><span class="line">        <span class="keyword">if</span> (startIndex &gt;= nums.<span class="built_in">size</span>()) &#123; <span class="comment">// 终止条件可以不加</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">backtracking</span>(nums, i + <span class="number">1</span>);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsets</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        result.<span class="built_in">clear</span>();</span><br><span class="line">        path.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="built_in">backtracking</span>(nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="子集问题2"><a href="#子集问题2" class="headerlink" title="子集问题2"></a>子集问题2</h2><p>给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。</p><p>说明：解集不能包含重复的子集。</p><p>示例:</p><ul><li>输入: [1,2,2]</li><li>输出: [ [2], [1], [1,2,2], [2,2], [1,2], [] ]</li></ul><p>思路：</p><p>此题和上一题的区别在于，集合里面有重复元素，而且求取的子集要去重</p><p>用示例中的[1, 2, 2] 来举例，如图所示： （<strong>注意去重需要先对集合排序</strong>）</p><p><img src="https://img-blog.csdnimg.cn/20201124195411977.png" alt="90.子集II"></p><p>从图中可以看出，同一树层上重复取2 就要过滤掉，同一树枝上就可以重复取2，因为同一树枝上元素的集合才是唯一子集！</p><p>其实本题就是在上一题的基础上加上了去重</p><p>完整代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> startIndex, vector&lt;<span class="type">bool</span>&gt;&amp; used)</span> </span>&#123;</span><br><span class="line">        result.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// used[i - 1] == true，说明同一树枝candidates[i - 1]使用过</span></span><br><span class="line">            <span class="comment">// used[i - 1] == false，说明同一树层candidates[i - 1]使用过</span></span><br><span class="line">            <span class="comment">// 而我们要对同一树层使用过的元素进行跳过</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; used[i - <span class="number">1</span>] == <span class="literal">false</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">backtracking</span>(nums, i + <span class="number">1</span>, used);</span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsetsWithDup</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        result.<span class="built_in">clear</span>();</span><br><span class="line">        path.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">used</span><span class="params">(nums.size(), <span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()); <span class="comment">// 去重需要排序</span></span><br><span class="line">        <span class="built_in">backtracking</span>(nums, <span class="number">0</span>, used);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>用set去重版本</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> startIndex, vector&lt;<span class="type">bool</span>&gt;&amp; used)</span> </span>&#123;</span><br><span class="line">        result.<span class="built_in">push_back</span>(path);</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; uset;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (uset.<span class="built_in">find</span>(nums[i]) != uset.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            uset.<span class="built_in">insert</span>(nums[i]);</span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">backtracking</span>(nums, i + <span class="number">1</span>, used);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsetsWithDup</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        result.<span class="built_in">clear</span>();</span><br><span class="line">        path.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">used</span><span class="params">(nums.size(), <span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()); <span class="comment">// 去重需要排序</span></span><br><span class="line">        <span class="built_in">backtracking</span>(nums, <span class="number">0</span>, used);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="递增子序列"><a href="#递增子序列" class="headerlink" title="递增子序列"></a>递增子序列</h2><p>给定一个整型数组, 你的任务是找到所有该数组的递增子序列，递增子序列的长度至少是2。</p><p>示例:</p><ul><li>输入: [4, 6, 7, 7]</li><li>输出: [[4, 6], [4, 7], [4, 6, 7], [4, 6, 7, 7], [6, 7], [6, 7, 7], [7,7], [4,7,7]]</li></ul><p>说明:</p><ul><li>给定数组的长度不会超过15。</li><li>数组中的整数范围是 [-100,100]。</li><li>给定数组中可能包含重复数字，相等的数字应该被视为递增的一种情况。</li></ul><p>本题求自增子序列，不可以对原数组进行排序！排序完之后的数组都是自增子序列了！</p><p>为了鲜明对比，以下用[4,7,4,6]这个数组来举例</p><p><img src="https://img-blog.csdnimg.cn/20201124200229824.png" alt="491. 递增子序列1"></p><h3 id="递归函数参数与返回值-3"><a href="#递归函数参数与返回值-3" class="headerlink" title="递归函数参数与返回值"></a>递归函数参数与返回值</h3><p>参数：一个元素不能重复使用，startindex，题干中给出的<code>vector&lt;int&gt;&amp; nums</code></p><p>返回值：存储结果的一维数组path，存储结果集的二维数组result</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;result;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;path;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrackting</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> startindex)</span></span></span><br></pre></td></tr></table></figure><h3 id="终止条件-1"><a href="#终止条件-1" class="headerlink" title="终止条件"></a>终止条件</h3><p>因为要遍历树形结构的每一个节点，所以其实可以不用加终止条件</p><p>但是又因为要求递增子序列大小至少为2，所以：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(path.<span class="built_in">size</span>()&gt;<span class="number">1</span>)&#123;</span><br><span class="line">    result.<span class="built_in">push_back</span>(path);</span><br><span class="line">    <span class="comment">//注意此处不用加return，因为要遍历所有节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单层搜索逻辑-4"><a href="#单层搜索逻辑-4" class="headerlink" title="单层搜索逻辑"></a>单层搜索逻辑</h3><p><img src="https://img-blog.csdnimg.cn/20201124200229824.png" alt="491. 递增子序列1"></p><p>由图可知，同一父节点下的同层上使用过的元素就不可以继续使用了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">unordered_set&lt;<span class="type">int</span>&gt;uset;<span class="comment">//使用set来对本层元素进行去重</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=startindex;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>((!path.<span class="built_in">empty</span>()&amp;&amp;nums[i]&lt;path.<span class="built_in">back</span>())||uset.<span class="built_in">find</span>(nums[i])!=uset.<span class="built_in">end</span>())&#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">    uset.<span class="built_in">insert</span>(nums[i]);<span class="comment">//记录这个元素在本层已经使用过了</span></span><br><span class="line">    path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">    <span class="built_in">backtracking</span>(nums,i+<span class="number">1</span>);</span><br><span class="line">    path.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>uset.insert(nums[i]);</code>是负责记录本层元素是否重复使用，新的一层uset都会重新定义（清空），所以要明确：uset只负责本层！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> startIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (path.<span class="built_in">size</span>() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="comment">// 注意这里不要加return，要取树上的节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; uset; <span class="comment">// 使用set对本层元素进行去重</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((!path.<span class="built_in">empty</span>() &amp;&amp; nums[i] &lt; path.<span class="built_in">back</span>())</span><br><span class="line">                    || uset.<span class="built_in">find</span>(nums[i]) != uset.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            uset.<span class="built_in">insert</span>(nums[i]); <span class="comment">// 记录这个元素在本层用过了，本层后面不能再用了</span></span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">backtracking</span>(nums, i + <span class="number">1</span>);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">findSubsequences</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        result.<span class="built_in">clear</span>();</span><br><span class="line">        path.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="built_in">backtracking</span>(nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h2><p>给定一个 没有重复 数字的序列，返回其所有可能的全排列。</p><p>示例:</p><ul><li>输入: [1,2,3]</li><li>输出: [ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1] ]</li></ul><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20211027181706.png" alt="46.全排列"></p><h3 id="递归函数参数与返回值-4"><a href="#递归函数参数与返回值-4" class="headerlink" title="递归函数参数与返回值"></a>递归函数参数与返回值</h3><p>首先，因为排列是有序的，也就是说[1,2]和[2,1]是不相同的，这是和之前分析的子集以及组合不同的地方</p><p>因为元素1在[1,2]中使用过一次，但是在后面的[2,1]还会继续使用，所以处理排列问题就不需要startindex了</p><p>但是排列问题需要一个bool组成的used数组，标记已经选择的元素，如图中橘黄色部分</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20211027181706.png" alt="46.全排列"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;result;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;path;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,vector&lt;<span class="type">bool</span>&gt;used)</span></span></span><br></pre></td></tr></table></figure><h3 id="递归终止条件-2"><a href="#递归终止条件-2" class="headerlink" title="递归终止条件"></a>递归终止条件</h3><p>遍历到叶子节点的时候就可以终止循环了</p><p>也就是path.size()&#x3D;&#x3D;nums.size()</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(path.<span class="built_in">size</span>()==nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">    result.<span class="built_in">push_back</span>(path);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单层搜索逻辑-5"><a href="#单层搜索逻辑-5" class="headerlink" title="单层搜索逻辑"></a>单层搜索逻辑</h3><p>因为是排列问题（无startindex），每次循环都从头开始</p><p>还有used数组，就是记录path当中又那些元素是已经使用了，一个排列中一个元素只能使用一次</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(used[i]==<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    used[i]=<span class="literal">true</span>;</span><br><span class="line">    path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">    <span class="built_in">backtracking</span>(nums,used);</span><br><span class="line">    path.<span class="built_in">pop_back</span>();</span><br><span class="line">    used[i]=<span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span> <span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;<span class="type">bool</span>&gt;&amp; used)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 此时说明找到了一组</span></span><br><span class="line">        <span class="keyword">if</span> (path.<span class="built_in">size</span>() == nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (used[i] == <span class="literal">true</span>) <span class="keyword">continue</span>; <span class="comment">// path里已经收录的元素，直接跳过</span></span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">backtracking</span>(nums, used);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        result.<span class="built_in">clear</span>();</span><br><span class="line">        path.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">used</span><span class="params">(nums.size(), <span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="built_in">backtracking</span>(nums, used);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="全排列-1"><a href="#全排列-1" class="headerlink" title="全排列"></a>全排列</h2><p>给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。</p><p>示例 1：</p><ul><li>输入：nums &#x3D; [1,1,2]</li><li>输出： [[1,1,2], [1,2,1], [2,1,1]]</li></ul><p>示例 2：</p><ul><li>输入：nums &#x3D; [1,2,3]</li><li>输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</li></ul><p>提示：</p><ul><li>1 &lt;&#x3D; nums.length &lt;&#x3D; 8</li><li>-10 &lt;&#x3D; nums[i] &lt;&#x3D; 10</li></ul><p>思路：</p><p>此题与上一题的区别在于：本题给出的原集合里面可能又重复的数组，但是为我们得到的结果当中不可以有重复的排列</p><p>此时我们就需要去重</p><p>注意：<strong>去重一定要对元素进行排序，这样我们才方便通过相邻的节点来判断是否重复使用了</strong>。</p><p>以示例中的 [1,1,2]为例 （为了方便举例，已经排序）抽象为一棵树，去重过程如图：</p><p><img src="https://img-blog.csdnimg.cn/20201124201331223.png" alt="47.全排列II1"></p><p>图中我们对同一树层，前一位（也就是nums[i-1]）如果使用过，那么就进行去重。</p><p><strong>一般来说：组合问题和排列问题是在树形结构的叶子节点上收集结果，而子集问题就是取树上所有节点的结果</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span> <span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;<span class="type">bool</span>&gt;&amp; used)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 此时说明找到了一组</span></span><br><span class="line">        <span class="keyword">if</span> (path.<span class="built_in">size</span>() == nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// used[i - 1] == true，说明同一树枝nums[i - 1]使用过</span></span><br><span class="line">            <span class="comment">// used[i - 1] == false，说明同一树层nums[i - 1]使用过</span></span><br><span class="line">            <span class="comment">// 如果同一树层nums[i - 1]使用过则直接跳过</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; used[i - <span class="number">1</span>] == <span class="literal">false</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (used[i] == <span class="literal">false</span>) &#123;</span><br><span class="line">                used[i] = <span class="literal">true</span>;</span><br><span class="line">                path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">                <span class="built_in">backtracking</span>(nums, used);</span><br><span class="line">                path.<span class="built_in">pop_back</span>();</span><br><span class="line">                used[i] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permuteUnique</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        result.<span class="built_in">clear</span>();</span><br><span class="line">        path.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()); <span class="comment">// 排序</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">used</span><span class="params">(nums.size(), <span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="built_in">backtracking</span>(nums, used);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一些碎碎念</title>
      <link href="/2022/04/04/%E4%B8%80%E4%BA%9B%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
      <url>/2022/04/04/%E4%B8%80%E4%BA%9B%E7%A2%8E%E7%A2%8E%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<p>        这是一篇碎碎念的文字——有关我最近的精神状态。</p><p>        我现在在尝试通过这篇文字调整自己。</p><p>        自从跟前女友分手半个月以来，我的状态就不太对劲。</p><p>        具体表现为：身体明明很饥饿，可是一点食欲都没有；脑海里经常会想起跟前女友有关的事情，一直在复盘我对她如何好，但是她对我如何坏；经常对很多事情提不起兴趣，即使事情可能已经迫在眉睫；没有想做的事，没有想见的人，失去了期待这种情绪；拒绝社交，把自己困在一个逼仄的角落；经常会莫名地感到一阵空虚。</p><p>        首先，我要明确一点——跟前女友分手我一点也不后悔，这完全可以称得上是及时止损。</p><p>        具体分手原因，此处便不再赘述，现在的主要目的是调整我自己的心态。</p><p>        孤独才是人生的常态，虽然很多时候我们看似身边会有很多亲人朋友陪着自己，但是实际上，早晚有一天人会离开父母独自生活。到时候跑到很远的地方去也是说不定的；朋友不能一直陪伴着你，在人生迈入下一个阶段的时候，留在上一个章节的朋友们就该和你挥手道别了，也许不一定会再也不见，但起码会很少再见；再就是恋人，先不说这个恋人能不能走到最后，就算是幸运的遇见了能走到最后的那个人，两个人之间也不可能一直保持激情，一直有话题可以聊。</p><p>        之前我一直天真地以为——不管是情亲，友情，爱情都应该是无时无刻在我周围环绕着我的。其实不是这样的，我们首先是自己本人，然后才是父母的子女，朋友的知音等等这些身份。也许在大多数时候，我们更多的应该学会自己独处，在重要的人需要我们的时候，我们再在此时出现，扮演那个该扮演的角色。</p><p>        想来这不该算作是一件坏事，本就是及时止损的事情，加上接下来我会有很长一段时间是独处的，这些时间都可以用来找到自己想要做的事情。算法还有很多没有刷完，unreal engine也要尽早提上日程。也还有很多游戏买了但是还没有玩完。太多太多的事情等着我去做。我还有很多的提升空间。再者，迟早也要离开这座城市，与其在那时不知所措，还不如在此时就开始提前适应。</p><p>        我承认，我是一个需要陪伴的人，我会忍受不了孤独。我害怕一个人，我会焦虑，无措，彷徨。但那又怎么样？除了我之外的千千万万人都会经历像这样的事情，凭什么我不能？我只是需要一点时间去适应，或者不需要很久，或者明天早上醒来我就会像以前那样充满朝气。</p><p>        我应该期待，期待远方的山海，期待春与秋的朝朝暮暮，期待听涛打浪声，期待峭壁与沟壑，喧嚣与宁静。</p><p>        写下这些话，就是把过往留在这里。从此刻往前，我的象牙之章就该落下帷幕了。</p><p>        再见，旧时光。</p><p>        你好，新世界！</p>]]></content>
      
      
      <categories>
          
          <category> 梦游笔谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嬉荒杂录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有关算法中的栈与队列</title>
      <link href="/2022/04/04/%E6%9C%89%E5%85%B3%E7%AE%97%E6%B3%95%E4%B8%AD%E7%9A%84%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"/>
      <url>/2022/04/04/%E6%9C%89%E5%85%B3%E7%AE%97%E6%B3%95%E4%B8%AD%E7%9A%84%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="基础理论"><a href="#基础理论" class="headerlink" title="基础理论"></a>基础理论</h1><p>栈：先进后出</p><p>队列：先进先出</p><table><thead><tr><th>成员函数</th><th>功能</th></tr></thead><tbody><tr><td>empty()</td><td>无元素时返回true；反之，返回false</td></tr><tr><td>size()</td><td>返回存储元素个数</td></tr><tr><td>top()</td><td>返回栈顶元素的引用，类型为T&amp;。如果为空，则报错</td></tr><tr><td>push(const T&amp; val)</td><td>先复制val，再将val的副本压入栈顶</td></tr><tr><td>push(T&amp;&amp; obj)</td><td>以移动元素的方式将其压入栈顶</td></tr><tr><td>pop()</td><td>弹出栈顶元素</td></tr><tr><td>emplace(arg…)</td><td>arg…可以是一个元素，也可以是多个元素。用于在栈顶直接生成一个元素</td></tr><tr><td>swap(stack<T>&amp;other_stack)</td><td>将两个栈中的元素进行互换（元素类型和底层的基础类型必须相同）</td></tr></tbody></table><h2 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h2><p>其实<strong>就是一个披着队列外衣的堆</strong>，因为优先级队列对外接口只是从队头取元素，从队尾添加元素，再无其他取元素的方式，看起来就是一个队列。</p><p>而且优先级队列内部元素是自动依照元素的权值排列。那么它是如何有序排列的呢？</p><p>缺省情况下priority_queue利用max-heap（大顶堆）完成对元素的排序，这个大顶堆是以vector为表现形式的complete binary tree（完全二叉树）。</p><p>什么是堆呢？</p><p><strong>堆是一棵完全二叉树，树中每个结点的值都不小于（或不大于）其左右孩子的值。</strong> 如果父亲结点是大于等于左右孩子就是<strong>大顶堆</strong>，小于等于左右孩子就是<strong>小顶堆</strong>。</p><p>所以大家经常说的大顶堆（堆头是最大元素），小顶堆（堆头是最小元素），如果懒得自己实现的话，就直接用priority_queue（优先级队列）就可以了，底层实现都是一样的，<strong>从小到大排就是小顶堆，从大到小排就是大顶堆</strong>。</p><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><h2 id="用栈实现队列"><a href="#用栈实现队列" class="headerlink" title="用栈实现队列"></a>用栈实现队列</h2><p>使用栈实现队列的下列操作：</p><p>push(x) – 将一个元素放入队列的尾部。<br>pop() – 从队列首部移除元素。<br>peek() – 返回队列首部的元素。<br>empty() – 返回队列是否为空。</p><p>示例:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MyQueue queue = <span class="keyword">new</span> <span class="built_in">MyQueue</span>();</span><br><span class="line">queue.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">queue.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">queue.<span class="built_in">peek</span>();  <span class="comment">// 返回 1</span></span><br><span class="line">queue.<span class="built_in">pop</span>();   <span class="comment">// 返回 1</span></span><br><span class="line">queue.<span class="built_in">empty</span>(); <span class="comment">// 返回 false</span></span><br></pre></td></tr></table></figure><p>说明:</p><ul><li>你只能使用标准的栈操作 – 也就是只有 push to top, peek&#x2F;pop from top, size, 和 is empty 操作是合法的。</li><li>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。</li><li>假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）。</li></ul><p>思路</p><ul><li><p>用两个栈，一个输出栈，一个输入栈</p></li><li><p>在push数据时，将数据放入输入栈即可</p></li><li><p>在pop数据时</p><ul><li><p>若输出栈为空，就把输入栈的数据全部导入进来，再从输出栈弹出数据</p></li><li><p>如果不为空，直接弹出</p></li></ul></li><li><p>如何判断队列为空？</p><ul><li>如果输入栈和输出栈都为空，则模拟队列为空</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stIn;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stOut;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">MyQueue</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** Push element x to the back of queue. */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        stIn.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 只有当stOut为空的时候，再从stIn里导入数据（导入stIn全部数据）</span></span><br><span class="line">        <span class="keyword">if</span> (stOut.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="comment">// 从stIn导入数据直到stIn为空</span></span><br><span class="line">            <span class="keyword">while</span>(!stIn.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                stOut.<span class="built_in">push</span>(stIn.<span class="built_in">top</span>());</span><br><span class="line">                stIn.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> result = stOut.<span class="built_in">top</span>();</span><br><span class="line">        stOut.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Get the front element. */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="keyword">this</span>-&gt;<span class="built_in">pop</span>(); <span class="comment">// 直接使用已有的pop函数</span></span><br><span class="line">        stOut.<span class="built_in">push</span>(res); <span class="comment">// 因为pop函数弹出了元素res，所以再添加回去</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns whether the queue is empty. */</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stIn.<span class="built_in">empty</span>() &amp;&amp; stOut.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="用队列实现栈"><a href="#用队列实现栈" class="headerlink" title="用队列实现栈"></a>用队列实现栈</h2><p>使用队列实现栈的下列操作：</p><ul><li>push(x) – 元素 x 入栈</li><li>pop() – 移除栈顶元素</li><li>top() – 获取栈顶元素</li><li>empty() – 返回栈是否为空</li></ul><p>注意:</p><ul><li>你只能使用队列的基本操作– 也就是 push to back, peek&#x2F;pop from front, size, 和 is empty 这些操作是合法的。</li><li>你所使用的语言也许不支持队列。 你可以使用 list 或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。</li><li>你可以假设所有操作都是有效的（例如, 对一个空的栈不会调用 pop 或者 top 操作）。</li></ul><p>思路：</p><ul><li><p>que1和que2两个队列模拟栈</p></li><li><p>que2完全就是用来备份的</p></li><li><p>把que1最后面的元素以外的所有元素都备份到<img src="/" alt="que2">中</p></li><li><p>弹出que1最后面的元素</p></li><li><p>再把其他元素从que2导入到que1</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">queue.<span class="built_in">push</span>(<span class="number">1</span>);        </span><br><span class="line">queue.<span class="built_in">push</span>(<span class="number">2</span>);        </span><br><span class="line">queue.<span class="built_in">pop</span>();   <span class="comment">// 注意弹出的操作       </span></span><br><span class="line">queue.<span class="built_in">push</span>(<span class="number">3</span>);        </span><br><span class="line">queue.<span class="built_in">push</span>(<span class="number">4</span>);       </span><br><span class="line">queue.<span class="built_in">pop</span>();  <span class="comment">// 注意弹出的操作    </span></span><br><span class="line">queue.<span class="built_in">pop</span>();    </span><br><span class="line">queue.<span class="built_in">pop</span>();    </span><br><span class="line">queue.<span class="built_in">empty</span>();  </span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; que1;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; que2; <span class="comment">// 辅助队列，用来备份</span></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">MyStack</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Push element x onto stack. */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        que1.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Removes the element on top of the stack and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> size = que1.<span class="built_in">size</span>();</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">while</span> (size--) &#123; <span class="comment">// 将que1 导入que2，但要留下最后一个元素</span></span><br><span class="line">            que2.<span class="built_in">push</span>(que1.<span class="built_in">front</span>());</span><br><span class="line">            que1.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> result = que1.<span class="built_in">front</span>(); <span class="comment">// 留下的最后一个元素就是要返回的值</span></span><br><span class="line">        que1.<span class="built_in">pop</span>();</span><br><span class="line">        que1 = que2;            <span class="comment">// 再将que2赋值给que1</span></span><br><span class="line">        <span class="keyword">while</span> (!que2.<span class="built_in">empty</span>()) &#123; <span class="comment">// 清空que2</span></span><br><span class="line">            que2.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Get the top element. */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> que1.<span class="built_in">back</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns whether the stack is empty. */</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> que1.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="有效括号"><a href="#有效括号" class="headerlink" title="有效括号"></a>有效括号</h2><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</p><p>有效字符串需满足：</p><ul><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li><li>注意空字符串可被认为是有效字符串。</li></ul><p>示例 1:</p><ul><li>输入: “()”</li><li>输出: true</li></ul><p>示例 2:</p><ul><li>输入: “()[]{}”</li><li>输出: true</li></ul><p>示例 3:</p><ul><li>输入: “(]”</li><li>输出: false</li></ul><p>示例 4:</p><ul><li>输入: “([)]”</li><li>输出: false</li></ul><p>示例 5:</p><ul><li>输入: “{[]}”</li><li>输出: true</li></ul><p>思路：</p><ul><li><p>用栈来解决问题</p></li><li><p>遍历s，当s[i]为左括号时，则将其对应的右括号入栈</p></li><li><p>第一种情况：还没有遍历完，栈已经为空（右括号没有对应的左括号），返回false</p></li><li><p>第二种情况：遍历过程中，发现栈里面没有我们要匹配的字符，返回false</p></li><li><p>第三种情况：已经遍历完字符串，但是栈不为空，返回false</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span>) st.<span class="built_in">push</span>(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;&#123;&#x27;</span>) st.<span class="built_in">push</span>(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;[&#x27;</span>) st.<span class="built_in">push</span>(<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">            <span class="comment">// 第三种情况：遍历字符串匹配的过程中，栈已经为空了，没有匹配的字符了，说明右括号没有找到对应的左括号 return false</span></span><br><span class="line">            <span class="comment">// 第二种情况：遍历字符串匹配的过程中，发现栈里没有我们要匹配的字符。所以return false</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (st.<span class="built_in">empty</span>() || st.<span class="built_in">top</span>() != s[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> st.<span class="built_in">pop</span>(); <span class="comment">// st.top() 与 s[i]相等，栈弹出元素</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第一种情况：此时我们已经遍历完了字符串，但是栈不为空，说明有相应的左括号没有右括号来匹配，所以return false，否则就return true</span></span><br><span class="line">        <span class="keyword">return</span> st.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="删除字符串中所有相邻重复项"><a href="#删除字符串中所有相邻重复项" class="headerlink" title="删除字符串中所有相邻重复项"></a>删除字符串中所有相邻重复项</h2><p>给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。</p><p>在 S 上反复执行重复项删除操作，直到无法继续删除。</p><p>在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。</p><p>示例：</p><ul><li>输入：”abbaca”</li><li>输出：”ca”</li><li>解释：例如，在 “abbaca” 中，我们可以删除 “bb” 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 “aaca”，其中又只有 “aa” 可以执行重复项删除操作，所以最后的字符串为 “ca”。</li></ul><p>提示：</p><ul><li>1 &lt;&#x3D; S.length &lt;&#x3D; 20000</li><li>S 仅由小写英文字母组成。</li></ul><p>思路：</p><ul><li><p>用栈解决问题</p></li><li><p>如果发现相邻的两个元素相等，则弹出栈顶元素</p></li><li><p>出栈</p></li><li><p>反转字符串（因为<strong>从栈里弹出的元素是倒叙的</strong>）</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">removeDuplicates</span><span class="params">(string S)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">char</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> s : S) &#123;</span><br><span class="line">            <span class="keyword">if</span> (st.<span class="built_in">empty</span>() || s != st.<span class="built_in">top</span>()) &#123;</span><br><span class="line">                st.<span class="built_in">push</span>(s);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                st.<span class="built_in">pop</span>(); <span class="comment">// s 与 st.top()相等的情况</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        string result = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123; <span class="comment">// 将栈中元素放到result字符串汇总</span></span><br><span class="line">            result += st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span> (result.<span class="built_in">begin</span>(), result.<span class="built_in">end</span>()); <span class="comment">// 此时字符串需要反转一下</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="逆波兰表达式求值"><a href="#逆波兰表达式求值" class="headerlink" title="逆波兰表达式求值"></a>逆波兰表达式求值</h2><p>根据 逆波兰表示法，求表达式的值。</p><p>有效的运算符包括 + ,  - ,  * ,  &#x2F; 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。</p><p>说明：</p><p>整数除法只保留整数部分。 给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。</p><p>示例 1：</p><ul><li>输入: [“2”, “1”, “+”, “3”, “ * “]</li><li>输出: 9</li><li>解释: 该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) &#x3D; 9</li></ul><p>示例 2：</p><ul><li>输入: [“4”, “13”, “5”, “&#x2F;“, “+”]</li><li>输出: 6</li><li>解释: 该算式转化为常见的中缀算术表达式为：(4 + (13 &#x2F; 5)) &#x3D; 6</li></ul><p>示例 3：</p><ul><li><p>输入: [“10”, “6”, “9”, “3”, “+”, “-11”, “ * “, “&#x2F;“, “ * “, “17”, “+”, “5”, “+”]</p></li><li><p>输出: 22</p></li><li><p>解释:该算式转化为常见的中缀算术表达式为：</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">((<span class="number">10</span> * (<span class="number">6</span> / ((<span class="number">9</span> + <span class="number">3</span>) * <span class="number">-11</span>))) + <span class="number">17</span>) + <span class="number">5</span>       </span><br><span class="line">= ((<span class="number">10</span> * (<span class="number">6</span> / (<span class="number">12</span> * <span class="number">-11</span>))) + <span class="number">17</span>) + <span class="number">5</span>       </span><br><span class="line">= ((<span class="number">10</span> * (<span class="number">6</span> / <span class="number">-132</span>)) + <span class="number">17</span>) + <span class="number">5</span>     </span><br><span class="line">= ((<span class="number">10</span> * <span class="number">0</span>) + <span class="number">17</span>) + <span class="number">5</span>     </span><br><span class="line">= (<span class="number">0</span> + <span class="number">17</span>) + <span class="number">5</span>    </span><br><span class="line">= <span class="number">17</span> + <span class="number">5</span>    </span><br><span class="line">= <span class="number">22</span>    </span><br></pre></td></tr></table></figure><p>逆波兰表达式：是一种后缀表达式，所谓后缀就是指算符写在后面。</p><p>平常使用的算式则是一种中缀表达式，如 ( 1 + 2 ) * ( 3 + 4 ) 。</p><p>该算式的逆波兰表达式写法为 ( ( 1 2 + ) ( 3 4 + ) * ) 。</p><p>逆波兰表达式主要有以下两个优点：</p><ul><li><p>去掉括号后表达式无歧义，上式即便写成 1 2 + 3 4 + * 也可以依据次序计算出正确结果。</p></li><li><p>适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中。</p></li></ul><p>思路：</p><ul><li><p>用栈来解决问题</p></li><li><p>如果输入是数字，则直接压入栈顶</p></li><li><p>如果输入是运算符，则将栈顶元素取出，然后再取出一个栈顶元素</p></li><li><p>两个元素进行对应运算符的运算</p></li><li><p>将结果压入栈</p></li><li><p>运算结束后，栈中只剩一个元素，此元素则为结果</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">evalRPN</span><span class="params">(vector&lt;string&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; tokens.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tokens[i] == <span class="string">&quot;+&quot;</span> || tokens[i] == <span class="string">&quot;-&quot;</span> || tokens[i] == <span class="string">&quot;*&quot;</span> || tokens[i] == <span class="string">&quot;/&quot;</span>) &#123;</span><br><span class="line">                <span class="type">int</span> num1 = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="type">int</span> num2 = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (tokens[i] == <span class="string">&quot;+&quot;</span>) st.<span class="built_in">push</span>(num2 + num1);</span><br><span class="line">                <span class="keyword">if</span> (tokens[i] == <span class="string">&quot;-&quot;</span>) st.<span class="built_in">push</span>(num2 - num1);</span><br><span class="line">                <span class="keyword">if</span> (tokens[i] == <span class="string">&quot;*&quot;</span>) st.<span class="built_in">push</span>(num2 * num1);</span><br><span class="line">                <span class="keyword">if</span> (tokens[i] == <span class="string">&quot;/&quot;</span>) st.<span class="built_in">push</span>(num2 / num1);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                st.<span class="built_in">push</span>(<span class="built_in">stoi</span>(tokens[i]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> result = st.<span class="built_in">top</span>();</span><br><span class="line">        st.<span class="built_in">pop</span>(); <span class="comment">// 把栈里最后一个元素弹出（其实不弹出也没事）</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="滑动窗口最大值"><a href="#滑动窗口最大值" class="headerlink" title="滑动窗口最大值"></a>滑动窗口最大值</h2><p>给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p><p>返回滑动窗口中的最大值。</p><p>进阶：</p><p>你能在线性时间复杂度内解决此题吗？</p><p>思路：</p><ul><li><p>采用用deque实现的单调队列（即元素单调递增或单调递减的队列）</p></li><li><p>单调队列只维护维护其中最大或者最小的两个元素，保证在输出的时候是单调递减（递增）就可以了</p></li><li><p>此时单调队列里的元素怎么配合窗口进行滑动？</p><ul><li><p>pop(value)：如果窗口移除的元素value等于单调队列的出口元素，那么队列弹出元素，否则就不用进行任何操作</p></li><li><p>push(value)：如果push的元素value大于入口元素的数值，那么九江队列入口的元素弹出，直到push元素的数值小于等于队列入口的元素值为止</p></li><li><p>保持上述规则，就可以使每次窗口移动的时候，只要que.front()就可以返回当前窗口的最大值</p></li></ul></li></ul><p>单调队列的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123; <span class="comment">//单调队列（从大到小）</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; que; <span class="comment">// 使用deque来实现单调队列</span></span><br><span class="line">    <span class="comment">// 每次弹出的时候，比较当前要弹出的数值是否等于队列出口元素的数值，如果相等则弹出。</span></span><br><span class="line">    <span class="comment">// 同时pop之前判断队列当前是否为空。</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!que.<span class="built_in">empty</span>() &amp;&amp; value == que.<span class="built_in">front</span>()) &#123;</span><br><span class="line">            que.<span class="built_in">pop_front</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果push的数值大于入口元素的数值，那么就将队列后端的数值弹出，直到push的数值小于等于队列入口元素的数值为止。</span></span><br><span class="line">    <span class="comment">// 这样就保持了队列里的数值是单调从大到小的了。</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>() &amp;&amp; value &gt; que.<span class="built_in">back</span>()) &#123;</span><br><span class="line">            que.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        que.<span class="built_in">push_back</span>(value);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查询当前队列里的最大值 直接返回队列前端也就是front就可以了。</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> que.<span class="built_in">front</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>滑动窗口问题：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123; <span class="comment">//单调队列（从大到小）</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        deque&lt;<span class="type">int</span>&gt; que; <span class="comment">// 使用deque来实现单调队列</span></span><br><span class="line">        <span class="comment">// 每次弹出的时候，比较当前要弹出的数值是否等于队列出口元素的数值，如果相等则弹出。</span></span><br><span class="line">        <span class="comment">// 同时pop之前判断队列当前是否为空。</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!que.<span class="built_in">empty</span>() &amp;&amp; value == que.<span class="built_in">front</span>()) &#123;</span><br><span class="line">                que.<span class="built_in">pop_front</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果push的数值大于入口元素的数值，那么就将队列后端的数值弹出，直到push的数值小于等于队列入口元素的数值为止。</span></span><br><span class="line">        <span class="comment">// 这样就保持了队列里的数值是单调从大到小的了。</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (!que.<span class="built_in">empty</span>() &amp;&amp; value &gt; que.<span class="built_in">back</span>()) &#123;</span><br><span class="line">                que.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            que.<span class="built_in">push_back</span>(value);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 查询当前队列里的最大值 直接返回队列前端也就是front就可以了。</span></span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> que.<span class="built_in">front</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        MyQueue que;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123; <span class="comment">// 先将前k的元素放进队列</span></span><br><span class="line">            que.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        result.<span class="built_in">push_back</span>(que.<span class="built_in">front</span>()); <span class="comment">// result 记录前k的元素的最大值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = k; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            que.<span class="built_in">pop</span>(nums[i - k]); <span class="comment">// 滑动窗口移除最前面元素</span></span><br><span class="line">            que.<span class="built_in">push</span>(nums[i]); <span class="comment">// 滑动窗口前加入最后面的元素</span></span><br><span class="line">            result.<span class="built_in">push_back</span>(que.<span class="built_in">front</span>()); <span class="comment">// 记录对应的最大值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="前k个高频元素"><a href="#前k个高频元素" class="headerlink" title="前k个高频元素"></a>前k个高频元素</h2><p>给定一个非空的整数数组，返回其中出现频率前 k 高的元素。</p><p>示例 1:</p><ul><li>输入: nums &#x3D; [1,1,1,2,2,3], k &#x3D; 2</li><li>输出: [1,2]</li></ul><p>示例 2:</p><ul><li>输入: nums &#x3D; [1], k &#x3D; 1</li><li>输出: [1]</li></ul><p>提示：</p><ul><li>你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。</li><li>你的算法的时间复杂度必须优于 $O(n \log n)$ , n 是数组的大小。</li><li>题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的。</li><li>你可以按任意顺序返回答案。</li></ul><p>思路：</p><ol><li><p>要统计元素出现的频率（使用map进行统计）</p></li><li><p>对频率排序（<strong>优先级队列</strong>）</p></li><li><p>找出前k个高频元素</p><ol><li>用小顶堆：要统计最大前k个元素，只有小顶堆每次将最小的元素弹出，最后小顶堆里积累的才是前k个最大的元素</li></ol></li></ol><p>寻找前k个最大元素流程如图所示：（图中的频率只有三个，所以正好构成一个大小为3的小顶堆，如果频率更多一些，则用这个小顶堆进行扫描）</p><p><img src="https://code-thinking.cdn.bcebos.com/pics/347.%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0.jpg" alt="347.前K个高频元素"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度：O(nlogk)</span></span><br><span class="line"><span class="comment">// 空间复杂度：O(n)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 小顶堆</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">mycomparison</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; lhs, <span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; rhs)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> lhs.second &gt; rhs.second;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">topKFrequent</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 要统计元素出现频率</span></span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; map; <span class="comment">// map&lt;nums[i],对应出现的次数&gt;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            map[nums[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对频率排序</span></span><br><span class="line">        <span class="comment">// 定义一个小顶堆，大小为k</span></span><br><span class="line">        priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;, mycomparison&gt; pri_que;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用固定大小为k的小顶堆，扫面所有频率的数值</span></span><br><span class="line">        <span class="keyword">for</span> (unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator it = map.<span class="built_in">begin</span>(); it != map.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">            pri_que.<span class="built_in">push</span>(*it);</span><br><span class="line">            <span class="keyword">if</span> (pri_que.<span class="built_in">size</span>() &gt; k) &#123; <span class="comment">// 如果堆的大小大于了K，则队列弹出，保证堆的大小一直为k</span></span><br><span class="line">                pri_que.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找出前K个高频元素，因为小顶堆先弹出的是最小的，所以倒序来输出到数组</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">result</span><span class="params">(k)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = k - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            result[i] = pri_que.<span class="built_in">top</span>().first;</span><br><span class="line">            pri_que.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>声明：本博客整理思路参考《代码随想录》，题目来自leetcode</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有关算法中的哈希表</title>
      <link href="/2022/04/01/%E6%9C%89%E5%85%B3%E7%AE%97%E6%B3%95%E4%B8%AD%E7%9A%84%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
      <url>/2022/04/01/%E6%9C%89%E5%85%B3%E7%AE%97%E6%B3%95%E4%B8%AD%E7%9A%84%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="哈希容器属性一览"><a href="#哈希容器属性一览" class="headerlink" title="哈希容器属性一览"></a>哈希容器属性一览</h1><p>当我们遇到需要快速判断一个元素是否存在一个集合里面的时候，就可以考虑使用哈希表</p><table><thead><tr><th>集合</th><th>底层</th><th>是否有序</th><th>数值是否可重复</th><th>是否能更改数值</th><th>查询效率</th><th>增删改效率</th></tr></thead><tbody><tr><td>std::set</td><td>红黑树</td><td>有序</td><td>否</td><td>否</td><td>$O(\log n)$</td><td>$O(\log n)$</td></tr><tr><td>std::multiset</td><td>红黑树</td><td>有序</td><td>是</td><td>否</td><td>$O(\log n)$</td><td>$O(\log n)$</td></tr><tr><td>std::unordered_set</td><td>哈希表</td><td>无序</td><td>否</td><td>否</td><td>$O(1)$</td><td>$O(1)$</td></tr></tbody></table><table><thead><tr><th>映射</th><th>底层实现</th><th>是否有序</th><th>数值是否可以重复</th><th>能否更改数值</th><th>查询效率</th><th>增删效率</th></tr></thead><tbody><tr><td>std::map</td><td>红黑树</td><td>key有序</td><td>key不可重复</td><td>key不可修改</td><td>$O(\log n)$</td><td>$O(\log n)$</td></tr><tr><td>std::multimap</td><td>红黑树</td><td>key有序</td><td>key可重复</td><td>key不可修改</td><td>$O(\log n)$</td><td>$O(\log n)$</td></tr><tr><td>std::unordered_map</td><td>哈希表</td><td>key无序</td><td>key不可重复</td><td>key不可修改</td><td>$O(1)$</td><td>$O(1)$</td></tr></tbody></table><h1 id="应用场景实例"><a href="#应用场景实例" class="headerlink" title="应用场景实例"></a>应用场景实例</h1><h2 id="有效的字母异位"><a href="#有效的字母异位" class="headerlink" title="有效的字母异位"></a>有效的字母异位</h2><p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</p><p>示例 1: 输入: s &#x3D; “anagram”, t &#x3D; “nagaram” 输出: true</p><p>示例 2: 输入: s &#x3D; “rat”, t &#x3D; “car” 输出: false</p><p><strong>说明:</strong> 你可以假设字符串只包含小写字母。</p><p>思路：</p><ol><li><p>首先定义一个大小为26的record数组，初始化为0</p></li><li><p>把a~z映射到数组内（a下标为0，z下标为25）</p></li><li><p>先遍历t，将record[s[i]-‘a’]++;</p></li><li><p>再遍历s，将record[s[i]-‘a’]–;</p></li><li><p>最后判断record中有没有不为0的数，如果有，则返回false</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isAnagram</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> record[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 并不需要记住字符a的ASCII，只要求出一个相对数值就可以了</span></span><br><span class="line">            record[s[i] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; t.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            record[t[i] - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (record[i] != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// record数组如果有的元素不为零0，说明字符串s和t 一定是谁多了字符或者谁少了字符。</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// record数组所有元素都为零0，说明字符串s和t是字母异位词</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="两个数组的交集"><a href="#两个数组的交集" class="headerlink" title="两个数组的交集"></a>两个数组的交集</h2><p>题意：给定两个数组，编写一个函数来计算它们的交集。</p><p><strong>说明：</strong> 输出结果中的每个元素一定是唯一的。 我们可以不考虑输出结果的顺序。</p><p>思路：</p><ol><li><p>使用unordered_set</p></li><li><p>unordered_set将nums1中的数据转换一次</p></li><li><p>nums2再输入一次数据，如果发现原本unordered中有的数据，则输出</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intersection</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; result_set; <span class="comment">// 存放结果</span></span><br><span class="line">        <span class="function">unordered_set&lt;<span class="type">int</span>&gt; <span class="title">nums_set</span><span class="params">(nums1.begin(), nums1.end())</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums2) &#123;</span><br><span class="line">            <span class="comment">// 发现nums2的元素 在nums_set里又出现过</span></span><br><span class="line">            <span class="keyword">if</span> (nums_set.<span class="built_in">find</span>(num) != nums_set.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                result_set.<span class="built_in">insert</span>(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(result_set.<span class="built_in">begin</span>(), result_set.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="快乐数"><a href="#快乐数" class="headerlink" title="快乐数"></a>快乐数</h2><p>编写一个算法来判断一个数 n 是不是快乐数。</p><p>「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果 可以变为  1，那么这个数就是快乐数。</p><p>如果 n 是快乐数就返回 True ；不是，则返回 False 。</p><p><strong>示例：</strong></p><p>输入：19<br>输出：true<br>解释：<br>1^2 + 9^2 &#x3D; 82<br>8^2 + 2^2 &#x3D; 68<br>6^2 + 8^2 &#x3D; 100<br>1^2 + 0^2 + 0^2 &#x3D; 1</p><p>思路：</p><ul><li><p>根据题意，如果出现无限循环的情况下，就不是快乐数。返回false</p></li><li><p>就用哈希表来判断，某数是否出现过，如果出现过，直接返回false</p></li><li><p>一直到sum为1</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 取数值各个位上的单数之和</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getSum</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n) &#123;</span><br><span class="line">            sum += (n % <span class="number">10</span>) * (n % <span class="number">10</span>);</span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isHappy</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; set;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> sum = <span class="built_in">getSum</span>(n);</span><br><span class="line">            <span class="keyword">if</span> (sum == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果这个sum曾经出现过，说明已经陷入了无限循环了，立刻return false</span></span><br><span class="line">            <span class="keyword">if</span> (set.<span class="built_in">find</span>(sum) != set.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                set.<span class="built_in">insert</span>(sum);</span><br><span class="line">            &#125;</span><br><span class="line">            n = sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h2><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p><p><strong>示例:</strong></p><p>给定 nums &#x3D; [2, 7, 11, 15], target &#x3D; 9</p><p>因为 nums[0] + nums[1] &#x3D; 2 + 7 &#x3D; 9</p><p>所以返回 [0, 1]</p><p>思路：</p><ul><li><p>本题使用map进行解决，键保存数值，值保存下标</p></li><li><p>因为本题不需要map有序，所以选用unordered_map效率更高</p></li><li><p>unordered_map&lt;数值,下标&gt; map</p></li><li><p>寻找target-nums[i]在不在map中，若不在，则将其插入到map中</p></li><li><p>若在map中找到了，则返回两者的下标</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        std::unordered_map &lt;<span class="type">int</span>,<span class="type">int</span>&gt; map;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">auto</span> iter = map.<span class="built_in">find</span>(target - nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(iter != map.<span class="built_in">end</span>()) &#123;<span class="comment">//若find()未找到，则返回map的end()</span></span><br><span class="line">                <span class="keyword">return</span> &#123;iter-&gt;second, i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            map.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(nums[i], i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="四数相加"><a href="#四数相加" class="headerlink" title="四数相加"></a>四数相加</h2><p>给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] &#x3D; 0。</p><p>为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -2^28 到 2^28 - 1 之间，最终结果不会超过 2^31 - 1 。</p><p><strong>例如:</strong></p><p>输入: A &#x3D; [ 1, 2] B &#x3D; [-2,-1] C &#x3D; [-1, 2] D &#x3D; [ 0, 2] 输出: 2 </p><p><strong>解释:</strong> 两个元组如下:</p><ol><li>(0, 0, 0, 1) -&gt; A[0] + B[0] + C[0] + D[1] &#x3D; 1 + (-2) + (-1) + 2 &#x3D; 0</li><li>(1, 1, 0, 0) -&gt; A[1] + B[1] + C[0] + D[0] &#x3D; 2 + (-1) + (-1) + 0 &#x3D; 0</li></ol><p>思路：</p><ol><li><p>定义一个unordered_map，key放a与b两数之和，value放a与b两数之和出现的次数</p></li><li><p>遍历A，B数组，统计两个数组元素之和，以及出现的次数，放进map中</p></li><li><p>定义int变量count，用来统计a+b+c+d&#x3D;0出现的次数</p></li><li><p>在遍历C与D数组，找到如果0-(c+d)在map中出现过的话，就用count把map中key对应的value（出现次数）统计出来</p></li><li><p>最后返回count</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fourSumCount</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A, vector&lt;<span class="type">int</span>&gt;&amp; B, vector&lt;<span class="type">int</span>&gt;&amp; C, vector&lt;<span class="type">int</span>&gt;&amp; D)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; umap; <span class="comment">//key:a+b的数值，value:a+b数值出现的次数</span></span><br><span class="line">        <span class="comment">// 遍历大A和大B数组，统计两个数组元素之和，和出现的次数，放到map中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> a : A) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> b : B) &#123;</span><br><span class="line">                umap[a + b]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>; <span class="comment">// 统计a+b+c+d = 0 出现的次数</span></span><br><span class="line">        <span class="comment">// 在遍历大C和大D数组，找到如果 0-(c+d) 在map中出现过的话，就把map中key对应的value也就是出现次数统计出来。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> c : C) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> d : D) &#123;</span><br><span class="line">                <span class="keyword">if</span> (umap.<span class="built_in">find</span>(<span class="number">0</span> - (c + d)) != umap.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                    count += umap[<span class="number">0</span> - (c + d)];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="赎金信"><a href="#赎金信" class="headerlink" title="赎金信"></a>赎金信</h2><p>给定一个赎金信 (ransom) 字符串和一个杂志(magazine)字符串，判断第一个字符串 ransom 能不能由第二个字符串 magazines 里面的字符构成。如果可以构成，返回 true ；否则返回 false。</p><p>(题目说明：为了不暴露赎金信字迹，要从杂志上搜索各个需要的字母，组成单词来表达意思。杂志字符串中的每个字符只能在赎金信字符串中使用一次。)</p><p><strong>注意：</strong></p><p>你可以假设两个字符串均只含有小写字母。</p><p>canConstruct(“a”, “b”) -&gt; false<br>canConstruct(“aa”, “ab”) -&gt; false<br>canConstruct(“aa”, “aab”) -&gt; true</p><p>思路：</p><ul><li><p>用一个长度为26的数组记录magazine里字母出现的次数</p></li><li><p>再用ransomnote验证这个数组里面是否包含了ransomnote所需要的字母</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canConstruct</span><span class="params">(string ransomNote, string magazine)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> record[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; magazine.<span class="built_in">length</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 通过recode数据记录 magazine里各个字符出现次数</span></span><br><span class="line">            record[magazine[i]-<span class="string">&#x27;a&#x27;</span>] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; ransomNote.<span class="built_in">length</span>(); j++) &#123;</span><br><span class="line">            <span class="comment">// 遍历ransomNote，在record里对应的字符个数做--操作</span></span><br><span class="line">            record[ransomNote[j]-<span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">            <span class="comment">// 如果小于零说明ransomNote里出现的字符，magazine没有</span></span><br><span class="line">            <span class="keyword">if</span>(record[ransomNote[j]-<span class="string">&#x27;a&#x27;</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>声明：本博客整理思路参考《代码随想录》，题目来源于leetcode</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有关算法中的数组</title>
      <link href="/2022/03/31/%E6%9C%89%E5%85%B3%E7%AE%97%E6%B3%95%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84/"/>
      <url>/2022/03/31/%E6%9C%89%E5%85%B3%E7%AE%97%E6%B3%95%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="数组中的二分查找"><a href="#数组中的二分查找" class="headerlink" title="数组中的二分查找"></a>数组中的二分查找</h1><p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p><ul><li>你可以假设 nums 中的所有元素是不重复的。</li><li>n 将在 [1, 10000]之间。</li><li>nums 的每个元素都将在 [-9999, 9999]之间。</li></ul><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [<span class="number">-1</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">12</span>], target = <span class="number">9</span>     </span><br><span class="line">输出: <span class="number">4</span>       </span><br><span class="line">解释: <span class="number">9</span> 出现在 nums 中并且下标为 <span class="number">4</span>   </span><br></pre></td></tr></table></figure><p>思路：当数组为<strong>有序数组</strong>，同时数组中<strong>无重复元素</strong>即可考虑使用<strong>二分法查找</strong></p><p><strong>二分法</strong>：</p><ul><li><p>条件：序列必须为有序，且序列中元素不重复</p></li><li><p>区间：一般定义为<strong>左闭右闭</strong>[left,right]，或者<strong>左闭右开</strong>[left,right)</p></li><li><p>原理：如果序列为空，则返回-1；如果不为空，则将中间元素与要查找的目标元素匹配，若匹配，则返回中间元素的索引；若中间元素大于目标元素，则将序列后半部分舍去；反之亦然。重复比较。</p></li></ul><h2 id="左闭右闭"><a href="#左闭右闭" class="headerlink" title="左闭右闭"></a>左闭右闭</h2><p>定义target在一个左闭右闭的区间内[left,right]</p><ul><li><p>while(left&lt;&#x3D;right)，因为left&#x3D;&#x3D;right是有意义的，所以使用&lt;&#x3D;</p></li><li><p>if(nums[middle]&gt;target)，right要赋值为middle-1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是middle-1</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>; <span class="comment">// 定义target在左闭右闭的区间里，[left, right]</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123; <span class="comment">// 当left==right，区间[left, right]依然有效，所以用 &lt;=</span></span><br><span class="line">            <span class="type">int</span> middle = left + ((right - left) / <span class="number">2</span>);<span class="comment">// 防止溢出 等同于(left + right)/2</span></span><br><span class="line">            <span class="keyword">if</span> (nums[middle] &gt; target) &#123;</span><br><span class="line">                right = middle - <span class="number">1</span>; <span class="comment">// target 在左区间，所以[left, middle - 1]</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[middle] &lt; target) &#123;</span><br><span class="line">                left = middle + <span class="number">1</span>; <span class="comment">// target 在右区间，所以[middle + 1, right]</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// nums[middle] == target</span></span><br><span class="line">                <span class="keyword">return</span> middle; <span class="comment">// 数组中找到目标值，直接返回下标</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 未找到目标值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="左闭右开"><a href="#左闭右开" class="headerlink" title="左闭右开"></a>左闭右开</h2><p>定义target在一个左闭右开的区间内[left,right)</p><ul><li><p>while(left&lt;right)，这里使用&lt;，因为left&#x3D;&#x3D;right在[left,right)无意义</p></li><li><p>if(nums[middle]&gt;target)，right更新为middle，因为当前nums[middle]不等于target，去左区间继续寻找，而寻找区间是左闭右开的，所以right更新为middle。即：下一个查询区间不会去比较nums[middle]</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = nums.<span class="built_in">size</span>(); <span class="comment">// 定义target在左闭右开的区间里，即：[left, right)</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123; <span class="comment">// 因为left == right的时候，在[left, right)是无效的空间，所以使用 &lt;</span></span><br><span class="line">            <span class="type">int</span> middle = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (nums[middle] &gt; target) &#123;</span><br><span class="line">                right = middle; <span class="comment">// target 在左区间，在[left, middle)中</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[middle] &lt; target) &#123;</span><br><span class="line">                left = middle + <span class="number">1</span>; <span class="comment">// target 在右区间，在[middle + 1, right)中</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// nums[middle] == target</span></span><br><span class="line">                <span class="keyword">return</span> middle; <span class="comment">// 数组中找到目标值，直接返回下标</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 未找到目标值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><p>不断地调节子序列的起始位置和终止位置，从而得出我们想要的结果  </p><p>滑动窗口需要明确的三点：</p><ul><li><p>窗口内是什么？</p></li><li><p>如何移动窗口的起始位置？</p></li><li><p>如何移动窗口的结束位置？</p></li></ul><p>解决思路：</p><ul><li><p>窗口就是满足：其和&gt;&#x3D;s的长度最小的连续 子数组</p></li><li><p>窗口起始位置的移动：如果当前窗口的值大于s了，窗口就需要向前移动了（该缩小了）</p></li><li><p>窗口结束位置的移动：窗口结束位置就是遍历数组的指针，窗口的起始位置设置为数组的起始位置就可以了</p></li></ul><p>eg1：给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度<strong>最小的</strong> 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。</p><p>思路：解题关键在于窗口起始位置在满足 窗口内的数组之和&gt;&#x3D;s，并且与上一个满足条件的sum的长度对比，取更小的那一个为result；然后通过sum&#x3D;sum-nums[i]，然后i++的方式，使起始位置向前移动一步。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> s, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> result = INT32_MAX;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>; <span class="comment">// 滑动窗口数值之和</span></span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>; <span class="comment">// 滑动窗口起始位置</span></span><br><span class="line">        <span class="type">int</span> subLength = <span class="number">0</span>; <span class="comment">// 滑动窗口的长度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; nums.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            sum += nums[j];</span><br><span class="line">            <span class="comment">// 注意这里使用while，每次更新 i（起始位置），并不断比较子序列是否符合条件</span></span><br><span class="line">            <span class="keyword">while</span> (sum &gt;= s) &#123;</span><br><span class="line">                subLength = (j - i + <span class="number">1</span>); <span class="comment">// 取子序列的长度</span></span><br><span class="line">                result = result &lt; subLength ? result : subLength;</span><br><span class="line">                sum -= nums[i++]; <span class="comment">// 这里体现出滑动窗口的精髓之处，不断变更i（子序列的起始位置）</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列</span></span><br><span class="line">        <span class="keyword">return</span> result == INT32_MAX ? <span class="number">0</span> : result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="螺旋矩阵"><a href="#螺旋矩阵" class="headerlink" title="螺旋矩阵"></a>螺旋矩阵</h1><p>给定一个正整数 n，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。</p><p>示例:</p><p>输入: 3 输出: [ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ] ]</p><p>思路：坚持循环不变量原则</p><p>模拟顺时针画矩阵的过程:</p><ul><li>填充上行从左到右</li><li>填充右列从上到下</li><li>填充下行从右到左</li><li>填充左列从下到上</li></ul><p>由外向内一圈一圈这么画下去。</p><p>可以发现这里的边界条件非常多，在一个循环中，如此多的边界条件，如果不按照固定规则来遍历，那就是<strong>一进循环深似海，从此offer是路人</strong>。</p><p>这里一圈下来，我们要画每四条边，这四条边怎么画，每画一条边都要坚持一致的左闭右开，或者左开又闭的原则，这样这一圈才能按照统一的规则画下来。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">generateMatrix</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">res</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>)); <span class="comment">// 使用vector定义一个二维数组</span></span><br><span class="line">        <span class="type">int</span> startx = <span class="number">0</span>, starty = <span class="number">0</span>; <span class="comment">// 定义每循环一个圈的起始位置</span></span><br><span class="line">        <span class="type">int</span> loop = n / <span class="number">2</span>; <span class="comment">// 每个圈循环几次，例如n为奇数3，那么loop = 1 只是循环一圈，矩阵中间的值需要单独处理</span></span><br><span class="line">        <span class="type">int</span> mid = n / <span class="number">2</span>; <span class="comment">// 矩阵中间的位置，例如：n为3， 中间的位置就是(1，1)，n为5，中间位置为(2, 2)</span></span><br><span class="line">        <span class="type">int</span> count = <span class="number">1</span>; <span class="comment">// 用来给矩阵中每一个空格赋值</span></span><br><span class="line">        <span class="type">int</span> offset = <span class="number">1</span>; <span class="comment">// 每一圈循环，需要控制每一条边遍历的长度</span></span><br><span class="line">        <span class="type">int</span> i,j;</span><br><span class="line">        <span class="keyword">while</span> (loop --) &#123;</span><br><span class="line">            i = startx;</span><br><span class="line">            j = starty;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 下面开始的四个for就是模拟转了一圈</span></span><br><span class="line">            <span class="comment">// 模拟填充上行从左到右(左闭右开)</span></span><br><span class="line">            <span class="keyword">for</span> (j = starty; j &lt; starty + n - offset; j++) &#123;</span><br><span class="line">                res[startx][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 模拟填充右列从上到下(左闭右开)</span></span><br><span class="line">            <span class="keyword">for</span> (i = startx; i &lt; startx + n - offset; i++) &#123;</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 模拟填充下行从右到左(左闭右开)</span></span><br><span class="line">            <span class="keyword">for</span> (; j &gt; starty; j--) &#123;</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 模拟填充左列从下到上(左闭右开)</span></span><br><span class="line">            <span class="keyword">for</span> (; i &gt; startx; i--) &#123;</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 第二圈开始的时候，起始位置要各自加1， 例如：第一圈起始位置是(0, 0)，第二圈起始位置是(1, 1)</span></span><br><span class="line">            startx++;</span><br><span class="line">            starty++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// offset 控制每一圈里每一条边遍历的长度</span></span><br><span class="line">            offset += <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果n为奇数的话，需要单独给矩阵最中间的位置赋值</span></span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span>) &#123;</span><br><span class="line">            res[mid][mid] = count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>声明：本博客整理思路参考《代码随想录》，题目摘自leetcode</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>有关算法中的位运算</title>
      <link href="/2022/03/28/%E6%9C%89%E5%85%B3%E7%AE%97%E6%B3%95%E4%B8%AD%E7%9A%84%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
      <url>/2022/03/28/%E6%9C%89%E5%85%B3%E7%AE%97%E6%B3%95%E4%B8%AD%E7%9A%84%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<h1 id="一，位运算符"><a href="#一，位运算符" class="headerlink" title="一，位运算符"></a>一，位运算符</h1><table><thead><tr><th>&amp;</th><th>按位与</th></tr></thead><tbody><tr><td>^</td><td>按位异或</td></tr><tr><td>~</td><td>取反</td></tr><tr><td>&lt;&lt;</td><td>左移</td></tr><tr><td>&gt;&gt;</td><td>右移</td></tr></tbody></table><h2 id="lt-lt-按位左移运算符"><a href="#lt-lt-按位左移运算符" class="headerlink" title="&lt;&lt;(按位左移运算符)"></a>&lt;&lt;(按位左移运算符)</h2><p>左移是基于一个数的二进制来说的，&lt;&lt;用来将一个数的二进制整体向位左移动若干位，移动的位数取决于其右操作数（右操作数必须是非负数），右边空出的位用0来补足。</p><ul><li><p>如果高位左移后出现溢出情况，则舍弃高位</p></li><li><p>若高位不为1，左移一位相当于原数据在十进制的情况下乘以2【2&lt;&lt;1&#x3D;&#x3D;4】</p></li></ul><h2 id="gt-gt-按位右移运算符"><a href="#gt-gt-按位右移运算符" class="headerlink" title="&gt;&gt;(按位右移运算符)"></a>&gt;&gt;(按位右移运算符)</h2><p>右移也是基于数的二进制来说的，&gt;&gt;用来将一个属的二进制数整体向右移动若干位，移动的位数取决于其右操作数（必须为非负数），移到右端的数被舍弃。</p><ul><li><p>对于无符号数，高位补0</p></li><li><p>对于有符号数，有些计算机将左边空出的位数用符号位补足，而有些用0补足</p></li></ul><h2 id="amp-按位与运算符"><a href="#amp-按位与运算符" class="headerlink" title="&amp;(按位与运算符)"></a>&amp;(按位与运算符)</h2><p>a&amp;b是指将参加运算的两个整数a与b的<strong>二进制位</strong>进行与运算</p><p>运算规则：两者同时为1才为1，否则为0</p><ul><li><p>0&amp;0&#x3D;0</p></li><li><p>0&amp;1&#x3D;0</p></li><li><p>1&amp;1&#x3D;0</p></li></ul><h2 id="按位或运算符"><a href="#按位或运算符" class="headerlink" title="|(按位或运算符)"></a>|(按位或运算符)</h2><p>a|b是指将参加运算的两个整数a与b的<strong>二进制位</strong>进行或运算</p><p>运算规则：两者只要有一个为1，则结果为1</p><ul><li><p>0|0&#x3D;0</p></li><li><p>0|1&#x3D;1</p></li><li><p>1|1&#x3D;1</p></li></ul><p>例如：3|5</p><p>3|5 -&gt; 0000 0011|0000 0101&#x3D;0000 0111</p><p>即结果为7</p><p>另外，负数按照补码形式参加运算</p><h2 id="按位异或运算符"><a href="#按位异或运算符" class="headerlink" title="^(按位异或运算符)"></a>^(按位异或运算符)</h2><p>a^b是指将a与b的二进制形式进行异或运算</p><p>运算规则：参加运算的两个对象如果值不同，结果为1，否则为0</p><ul><li><p>0^0&#x3D;0</p></li><li><p>0^1&#x3D;1</p></li><li><p>1^1&#x3D;0</p></li></ul><p>异或其实就是不进位的加法</p><p>1+1&#x3D;0；0+0&#x3D;0；1+0&#x3D;1</p><p>异或的性质</p><ul><li><p>交换律：a^b&#x3D;b^a</p></li><li><p>结合律：(a^b)^c&#x3D;a^(b^c)</p></li></ul><p>异或运算的特殊作用</p><ol><li><p>使特定位翻转</p><ul><li>x&#x3D;1010 1110 我们要把<strong>后4位数反转</strong>，则可以使x^0000 1111&#x3D;1010 0001</li></ul></li><li><p>与0相异或可保留原值</p><ul><li>1010 1110^0000 0000&#x3D;1010 1110</li></ul></li><li><p>对于任何数x都有<strong>自反性</strong></p><ul><li>x^x&#x3D;0；x^0&#x3D;x    A^B^B&#x3D;A</li></ul></li><li><p>交换两个数</p><ul><li>a&#x3D;a^b；b&#x3D;b^a；a&#x3D;a^b</li></ul></li></ol><h2 id="按位取反运算符"><a href="#按位取反运算符" class="headerlink" title="~(按位取反运算符)"></a>~(按位取反运算符)</h2><p>按位取反是指将a的二进制形式全都取反——1变为0，0变为1</p><p>eg：~9</p><p>9&#x3D;0000 1001-&gt;1111 0110</p><p>1111 0110的最高位是1，即为补码</p><p>补码还原成反码（补码减1）得1111 0101</p><p>反码还原成原码（最高位不变，其他各位取反）得1000 1010</p><p>则~9&#x3D;-10</p><h1 id="二，不同长度进行位运算"><a href="#二，不同长度进行位运算" class="headerlink" title="二，不同长度进行位运算"></a>二，不同长度进行位运算</h1><p>如果两个不同长度的数据进行位运算，则将两者按右对其，然后进行位运算</p><p>eg：若一个4字节的数据与一个2字节的数据进行与运算</p><p>首先右端对齐，然后左边有以下三种情况</p><ol><li><p>如果数据为正数，则左边补16个0</p></li><li><p>如果数据为负数，则左边补16个1</p></li><li><p>如果数据为无符号数，则左边补16个0</p></li></ol><h1 id="三，常见的二进制位变换操作"><a href="#三，常见的二进制位变换操作" class="headerlink" title="三，常见的二进制位变换操作"></a>三，常见的二进制位变换操作</h1><table><thead><tr><th>x&gt;&gt;1</th><th>去掉最后一位</th><th>1011 01-&gt;1011 0</th></tr></thead><tbody><tr><td>x&lt;&lt;1</td><td>在最后加一个0</td><td>1011 01-&gt;1011 010</td></tr><tr><td>(x&lt;&lt;1)+1</td><td>在最后加一个1</td><td>1011 01-&gt;1011 011</td></tr><tr><td>x|1</td><td>把最后一位变为1</td><td>1011 00-&gt;1011 01</td></tr><tr><td>(x|1)-1</td><td>把最后一位变为0</td><td>1011 01-&gt;1011 00</td></tr><tr><td>x^1</td><td>最后一位取反</td><td>101101-&gt;1011 00</td></tr><tr><td>x|(1&lt;&lt;(k-1))，k&#x3D;3</td><td>把右往左数第k位数变为1</td><td>1010 01-&gt;1011 01</td></tr><tr><td>x&amp;~(1&lt;&lt;(k-1))，k&#x3D;3</td><td>把从右往左数第k位变为0</td><td>1011 01-&gt;1011 01</td></tr><tr><td>x ^ (1&lt;&lt;(k-1))，k&#x3D;3</td><td>右数第k位取反</td><td>1010 01-&gt;1011 01</td></tr><tr><td>x &amp;7</td><td>取末三位</td><td>11011 01-&gt;101</td></tr><tr><td>x &gt;&gt; (k-1)&amp;1，k&#x3D;4</td><td>取右数第k位</td><td>1101 101-&gt;1</td></tr><tr><td>x|(1&lt;&lt;k-1)，k&#x3D;4</td><td>把末k位变成1</td><td>1010 01-&gt;1011 11</td></tr><tr><td>x^(1&lt;&lt;k-1)，k&#x3D;4</td><td>末k位取反</td><td>101001-&gt;100110</td></tr><tr><td>x&amp;(x+1)</td><td>把右边连续的1变成0</td><td>100101111-&gt;100100000</td></tr><tr><td>x|(x-1)</td><td>把右边连续的0变成1</td><td>11011000-&gt;11011111</td></tr><tr><td>x|(x+1)</td><td>把右起第一个0变成1</td><td>100101111-&gt;100111111</td></tr><tr><td>(x^(x+1))&gt;&gt;1</td><td>取右边连续的1</td><td>100101111-&gt;1111</td></tr><tr><td>x&amp;(x^(x-1))</td><td>去掉右起第一个1的左边</td><td>100101000-&gt;1000</td></tr></tbody></table><h1 id="四，应用举例"><a href="#四，应用举例" class="headerlink" title="四，应用举例"></a>四，应用举例</h1><h2 id="一，按位与（-amp-）"><a href="#一，按位与（-amp-）" class="headerlink" title="一，按位与（&amp;）"></a>一，按位与（&amp;）</h2><p>eg1：判断一个数n是否为2的整数幂</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(n&amp;(n<span class="number">-1</span>))&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;no&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;yes&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>eg2:编写一个函数，以二进制串的形式输入一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。【leetcode.191.easy】</p><p>思路：循环检查n的二进制每一位是否为1</p><p>当检查第i位时，可以让n与2的i次方(<strong>1进行左移i位</strong>)进行与运算，当且仅当n的第i位为1时，运算结果不为0</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="type">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n &amp; (<span class="number">1</span> &lt;&lt; i)) &#123;</span><br><span class="line">                ret++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="按位或（-）"><a href="#按位或（-）" class="headerlink" title="按位或（|）"></a>按位或（|）</h2><p>eg1:颠倒给定的 32 位无符号整数的二进制位。</p><p>思路：将n视作一个长为32的二进制串，从低位往高位枚举n的每一位，将其倒序添加到反转结果rev中。</p><p>每枚举一位就将n右移一位，这样当前n的最低位就是我们要枚举的那一位，当n为0时就可以结束循环。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">uint32_t</span> <span class="title">reverseBits</span><span class="params">(<span class="type">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">uint32_t</span> rev = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//rev由32个0组成</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span> &amp;&amp; n &gt; <span class="number">0</span>; ++i) &#123;</span><br><span class="line">            <span class="comment">//n&amp;1用来取n的最低位(1或者0)</span></span><br><span class="line">            <span class="comment">//rev | (n&amp;1)则是把rev的最后一位变为1或者不变（原本值为0）</span></span><br><span class="line">            rev |= (n &amp; <span class="number">1</span>) &lt;&lt; (<span class="number">31</span> - i);<span class="comment">//将rev |= (n &amp; 1)的结果左移31-i位</span></span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;<span class="comment">//n右移1位，保证当前最低位为我们要操作的那一位</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="异或（-）"><a href="#异或（-）" class="headerlink" title="异或（^）"></a>异或（^）</h2><p>给定一个<strong>非空</strong>整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><p>异或运算有以下三个性质。</p><p>任何数和 0 做异或运算，结果仍然是原来的数<br>任何数和其自身做异或运算，结果是 0<br>异或运算满足交换律和结合律</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> e: nums) ret ^= e;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>未完待续……</p><p>声明：此博客整理思路参考《代码随想录》题目摘自leetcode</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>有关算法中的双指针</title>
      <link href="/2022/03/27/%E6%9C%89%E5%85%B3%E7%AE%97%E6%B3%95%E4%B8%AD%E7%9A%84%E5%8F%8C%E6%8C%87%E9%92%88/"/>
      <url>/2022/03/27/%E6%9C%89%E5%85%B3%E7%AE%97%E6%B3%95%E4%B8%AD%E7%9A%84%E5%8F%8C%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<h1 id="双指针的应用"><a href="#双指针的应用" class="headerlink" title="双指针的应用"></a>双指针的应用</h1><h2 id="双指针的分类"><a href="#双指针的分类" class="headerlink" title="双指针的分类"></a>双指针的分类</h2><p>快慢指针与对撞指针</p><h2 id="双指针解决的主要问题"><a href="#双指针解决的主要问题" class="headerlink" title="双指针解决的主要问题"></a>双指针解决的主要问题</h2><p>数组，链表以及字符串问题</p><h2 id="双指针的应用场景"><a href="#双指针的应用场景" class="headerlink" title="双指针的应用场景"></a>双指针的应用场景</h2><p><em>快慢指针</em>：主要应用与处理<em>链表内部环路</em>问题与<em>数组内是否有重复项</em>问题</p><h3 id="删除有序数组中的重复项"><a href="#删除有序数组中的重复项" class="headerlink" title="删除有序数组中的重复项"></a>删除有序数组中的重复项</h3><p>给你一个 <strong>升序排列</strong> 的数组 <code>nums</code> ，请你 <strong>原地</strong> 删除重复出现的元素，使每个元素 <strong>只出现一次</strong> ，返回删除后数组的新长度。元素的 <strong>相对顺序</strong> 应该保持 <strong>一致</strong> 。</p><p>思路：定义一堆快慢指针<em>fast</em>与<em>slow</em>同时指向nums[1]</p><p>slow表示将要插入的位置，fast与fast-1比较是否相等，如果相等，则将其插入到slow位置</p><p>返回的新长度就是slow的值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeDuplicates</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果nums的长度为0或1，则直接返回nums</span></span><br><span class="line">        <span class="type">int</span> len=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建快慢指针,并让他们都指向nums[1]</span></span><br><span class="line">        <span class="type">int</span> fast=<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> slow=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(fast&lt;len)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[fast]!=nums[fast<span class="number">-1</span>])&#123;</span><br><span class="line">            nums[slow]=nums[fast];</span><br><span class="line">            ++slow;</span><br><span class="line">        &#125;</span><br><span class="line">        ++fast;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="移除重复元素"><a href="#移除重复元素" class="headerlink" title="移除重复元素"></a>移除重复元素</h3><p>给你一个数组 <code>nums</code> 和一个值 <code>val</code>，你需要 <strong>原地</strong> 移除所有数值等于 <code>val</code> 的元素，并返回移除后数组的新长度。</p><p>思路：快慢双指针right与left</p><ul><li><p>right指向当前将要处理的元素，left指向下一个将要赋值的位置</p></li><li><p>如果right指向的元素不等于val，它一定是输出数组的元素。所以我们将right指针指向的元素赋值到left的位置，然后左右同时向右移动</p></li><li><p>如果right指向的元素等于val，它不能在输出数组中，此时左指针不动，右指针右移一位</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line"> <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line"> <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> right = <span class="number">0</span>; right &lt; n; right++) &#123;</span><br><span class="line"> <span class="keyword">if</span> (nums[right] != val) &#123;</span><br><span class="line"> nums[left] = nums[right];</span><br><span class="line"> left++;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> left;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="判断链表中是否有环"><a href="#判断链表中是否有环" class="headerlink" title="判断链表中是否有环"></a>判断链表中是否有环</h3><p>给你一个链表的头节点 head ，判断链表中是否有环。</p><p>思路：快指针走得快，慢指针走得慢，若链表中存在环路，则两指针一定会相遇，并且快指针会快慢指针一周。若链表中不存在环路，则快指针一定会指向null。</p><p>假想「乌龟」和「兔子」在链表上移动，「兔子」跑得快，「乌龟」跑得慢。当「乌龟」和「兔子」从链表上的同一个节点开始移动时，如果该链表中没有环，那么「兔子」将一直处于「乌龟」的前方；如果该链表中有环，那么「兔子」会先于「乌龟」进入环，并且一直在环内移动。等到「乌龟」进入环时，由于「兔子」的速度快，它一定会在某个时刻与乌龟相遇，即套了「乌龟」若干圈。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="type">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> ListNode* slow = head;</span><br><span class="line"> ListNode* fast = head-&gt;next;</span><br><span class="line"> <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line"> <span class="keyword">if</span> (fast == <span class="literal">nullptr</span> || fast-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> slow = slow-&gt;next;</span><br><span class="line"> fast = fast-&gt;next-&gt;next;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><em>对撞指针</em>:主要用于处理数组和字符喜欢的索引问题</p><h3 id="验证回文串"><a href="#验证回文串" class="headerlink" title="验证回文串"></a>验证回文串</h3><p>给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。</p><p>思路：分别定义两个指针，分别指向字符串的第一个元素和最后一个元素<br>两个指针不断地相向移动，每移动一次就判断这两个指针指向的字符是否相同。当两个指针相遇时，说明此字符串是回文串</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line"> string sgood;</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">char</span> ch: s) &#123;</span><br><span class="line"> <span class="keyword">if</span> (<span class="built_in">isalnum</span>(ch)) &#123; <span class="comment">//isalnum()判断ch是否为字母或者十进制数字</span></span><br><span class="line"> sgood += <span class="built_in">tolower</span>(ch);<span class="comment">//转换为小写字母</span></span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="type">int</span> n = sgood.<span class="built_in">size</span>();</span><br><span class="line"> <span class="type">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line"> <span class="keyword">if</span> (sgood[left] != sgood[right]) &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> ++left;</span><br><span class="line"> --right;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="替换空格"><a href="#替换空格" class="headerlink" title="替换空格"></a>替换空格</h3><p>请实现一个函数，把字符串 s 中的每个空格替换成”%20”。</p><p>示例 1： 输入：s &#x3D; “We are happy.”<br>输出：”We%20are%20happy.”</p><p>思路：</p><ol><li><p>首先将数组扩展成空格已替换成%20的长度</p></li><li><p>然后设定两个指针i，j，从后往前遍历</p></li><li><p>i指向新数组最后一个位置，j指向旧数组最后一个位置（此位置有值）</p></li><li><p>如果s[j]!&#x3D;’ ‘，则s[i]&#x3D;s[j]</p></li><li><p>如果s[j]&#x3D;&#x3D;’ ‘，则s[i]&#x3D;”0”,s[i-1]&#x3D;”2”,s[i-2]&#x3D;”%”</p></li><li><p>然后移动i指针使i&#x3D;i-2</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">replaceSpace</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>; <span class="comment">// 统计空格的个数</span></span><br><span class="line">        <span class="type">int</span> sOldSize = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 扩充字符串s的大小，也就是每个空格替换成&quot;%20&quot;之后的大小</span></span><br><span class="line">        s.<span class="built_in">resize</span>(s.<span class="built_in">size</span>() + count * <span class="number">2</span>);</span><br><span class="line">        <span class="type">int</span> sNewSize = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 从后先前将空格替换为&quot;%20&quot;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = sNewSize - <span class="number">1</span>, j = sOldSize - <span class="number">1</span>; j &lt; i; i--, j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[j] != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                s[i] = s[j];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                s[i] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                s[i - <span class="number">1</span>] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">                s[i - <span class="number">2</span>] = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">                i -= <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="反转字符串里的单词"><a href="#反转字符串里的单词" class="headerlink" title="反转字符串里的单词"></a>反转字符串里的单词</h3><p>给定一个字符串，逐个翻转字符串中的每个单词。</p><p>示例 1：<br>输入: “the sky is blue”<br>输出: “blue is sky the”</p><p>示例 2：<br>输入: “  hello world!  “<br>输出: “world! hello”<br>解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</p><p>示例 3：<br>输入: “a good   example”<br>输出: “example good a”<br>解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</p><p>思路：</p><ol><li><p>移除多余空格（最后一个单词后的空格）</p></li><li><p>将整个字符串反转</p></li><li><p>将每个单词反转</p></li></ol><h4 id="使用erase"><a href="#使用erase" class="headerlink" title="使用erase()"></a>使用erase()</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">removeExtraSpaces</span><span class="params">(string&amp; s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = s.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == s[i - <span class="number">1</span>] &amp;&amp; s[i] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            s.<span class="built_in">erase</span>(s.<span class="built_in">begin</span>() + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除字符串最后面的空格</span></span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">size</span>() &gt; <span class="number">0</span> &amp;&amp; s[s.<span class="built_in">size</span>() - <span class="number">1</span>] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">        s.<span class="built_in">erase</span>(s.<span class="built_in">begin</span>() + s.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除字符串最前面的空格</span></span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">size</span>() &gt; <span class="number">0</span> &amp;&amp; s[<span class="number">0</span>] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">        s.<span class="built_in">erase</span>(s.<span class="built_in">begin</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用双指针"><a href="#使用双指针" class="headerlink" title="使用双指针"></a>使用双指针</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">removeExtraSpaces</span><span class="params">(string&amp; s)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> slowIndex = <span class="number">0</span>, fastIndex = <span class="number">0</span>; <span class="comment">// 定义快指针，慢指针</span></span><br><span class="line">    <span class="comment">// 去掉字符串前面的空格</span></span><br><span class="line">    <span class="keyword">while</span> (s.<span class="built_in">size</span>() &gt; <span class="number">0</span> &amp;&amp; fastIndex &lt; s.<span class="built_in">size</span>() &amp;&amp; s[fastIndex] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">        fastIndex++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; fastIndex &lt; s.<span class="built_in">size</span>(); fastIndex++) &#123;</span><br><span class="line">        <span class="comment">// 去掉字符串中间部分的冗余空格</span></span><br><span class="line">        <span class="keyword">if</span> (fastIndex - <span class="number">1</span> &gt; <span class="number">0</span></span><br><span class="line">                &amp;&amp; s[fastIndex - <span class="number">1</span>] == s[fastIndex]</span><br><span class="line">                &amp;&amp; s[fastIndex] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            s[slowIndex++] = s[fastIndex];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (slowIndex - <span class="number">1</span> &gt; <span class="number">0</span> &amp;&amp; s[slowIndex - <span class="number">1</span>] == <span class="string">&#x27; &#x27;</span>) &#123; <span class="comment">// 去掉字符串末尾的空格</span></span><br><span class="line">        s.<span class="built_in">resize</span>(slowIndex - <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        s.<span class="built_in">resize</span>(slowIndex); <span class="comment">// 重新设置字符串大小</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="翻转链表"><a href="#翻转链表" class="headerlink" title="翻转链表"></a>翻转链表</h3><p>题意：反转一个单链表。</p><p>示例: 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL 输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p><ol><li><p>定义两个结点，cur指向头结点，pre指向null</p></li><li><p>定义一个temp结点，用来指向cur-&gt;next</p></li><li><p>cur-&gt;next&#x3D;pre(翻转操作)</p></li><li><p>pre&#x3D;cur;cur&#x3D;temp;(更新结点指向)</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* temp; <span class="comment">// 保存cur的下一个节点</span></span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        ListNode* pre = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur) &#123;</span><br><span class="line">            temp = cur-&gt;next;  <span class="comment">// 保存一下 cur的下一个节点，因为接下来要改变cur-&gt;next</span></span><br><span class="line">            cur-&gt;next = pre; <span class="comment">// 翻转操作</span></span><br><span class="line">            <span class="comment">// 更新pre 和 cur指针</span></span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="删除链表的倒数第N个结点"><a href="#删除链表的倒数第N个结点" class="headerlink" title="删除链表的倒数第N个结点"></a>删除链表的倒数第N个结点</h3><p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</p><p>输入：head &#x3D; [1,2,3,4,5], n &#x3D; 2 输出：[1,2,3,5]</p><p>输入：head &#x3D; [1], n &#x3D; 1 输出：[]</p><p>输入：head &#x3D; [1,2], n &#x3D; 1</p><p>思路：如果要删除倒数第n个结点，让fast移动n步，然后让fast和slow同时移动，直到fast指向链表末尾。最后删掉slow指向的结点就可以了。</p><ol><li><p>fast与slow初始值均为虚拟头结点</p></li><li><p>fast先走n+1步（因为只有这样，在同时移动的时候slow才能指向被删除结点的上一个结点）</p></li><li><p>fast和slow同时移动，直到fast指向末尾</p></li><li><p>删除slow指向的下一个结点</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode* dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);<span class="comment">//虚拟头结点</span></span><br><span class="line">        dummyHead-&gt;next = head;</span><br><span class="line">        ListNode* slow = dummyHead;</span><br><span class="line">        ListNode* fast = dummyHead;</span><br><span class="line">        <span class="keyword">while</span>(n-- &amp;&amp; fast != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        fast = fast-&gt;next; <span class="comment">// fast再提前走一步，因为需要让slow指向删除节点的上一个节点</span></span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        slow-&gt;next = slow-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="两两交换链表中的节点"><a href="#两两交换链表中的节点" class="headerlink" title="两两交换链表中的节点"></a>两两交换链表中的节点</h3><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p><ol><li><p>使用虚拟头结点</p></li><li><p>头结点指向第二个元素</p></li><li><p>第二个元素指向第一个元素</p></li><li><p>第一个元素指向第三个元素</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>); <span class="comment">// 设置一个虚拟头结点</span></span><br><span class="line">        dummyHead-&gt;next = head; <span class="comment">// 将虚拟头结点指向head，这样方面后面做删除操作</span></span><br><span class="line">        ListNode* cur = dummyHead;</span><br><span class="line">        <span class="keyword">while</span>(cur-&gt;next != <span class="literal">nullptr</span> &amp;&amp; cur-&gt;next-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            ListNode* tmp = cur-&gt;next; <span class="comment">// 记录临时节点</span></span><br><span class="line">            ListNode* tmp1 = cur-&gt;next-&gt;next-&gt;next; <span class="comment">// 记录临时节点</span></span><br><span class="line"></span><br><span class="line">            cur-&gt;next = cur-&gt;next-&gt;next;    <span class="comment">// 步骤一</span></span><br><span class="line">            cur-&gt;next-&gt;next = tmp;          <span class="comment">// 步骤二</span></span><br><span class="line">            cur-&gt;next-&gt;next-&gt;next = tmp1;   <span class="comment">// 步骤三</span></span><br><span class="line"></span><br><span class="line">            cur = cur-&gt;next-&gt;next; <span class="comment">// cur移动两位，准备下一轮交换</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="链表相交"><a href="#链表相交" class="headerlink" title="链表相交"></a>链表相交</h3><p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。</p><p>思路：</p><ol><li><p>定义两个指针curA与curB</p></li><li><p>求两个链表的长度</p></li><li><p>假设A.size()&gt;B.size()，则使curA指向A.begin()+B.size()。curB指向B.begin()（反之亦然）</p></li><li><p>比较curA&#x3D;&#x3D;curB，若!&#x3D;，则-&gt;</p></li><li><p>直到curA&#x3D;&#x3D;curB，此处为交点</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        ListNode* curA = headA;</span><br><span class="line">        ListNode* curB = headB;</span><br><span class="line">        <span class="type">int</span> lenA = <span class="number">0</span>, lenB = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (curA != <span class="literal">NULL</span>) &#123; <span class="comment">// 求链表A的长度</span></span><br><span class="line">            lenA++;</span><br><span class="line">            curA = curA-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (curB != <span class="literal">NULL</span>) &#123; <span class="comment">// 求链表B的长度</span></span><br><span class="line">            lenB++;</span><br><span class="line">            curB = curB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        curA = headA;</span><br><span class="line">        curB = headB;</span><br><span class="line">        <span class="comment">// 让curA为最长链表的头，lenA为其长度</span></span><br><span class="line">        <span class="keyword">if</span> (lenB &gt; lenA) &#123;</span><br><span class="line">            <span class="built_in">swap</span> (lenA, lenB);</span><br><span class="line">            <span class="built_in">swap</span> (curA, curB);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 求长度差</span></span><br><span class="line">        <span class="type">int</span> gap = lenA - lenB;</span><br><span class="line">        <span class="comment">// 让curA和curB在同一起点上（末尾位置对齐）</span></span><br><span class="line">        <span class="keyword">while</span> (gap--) &#123;</span><br><span class="line">            curA = curA-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历curA 和 curB，遇到相同则直接返回</span></span><br><span class="line">        <span class="keyword">while</span> (curA != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curA == curB) &#123;</span><br><span class="line">                <span class="keyword">return</span> curA;</span><br><span class="line">            &#125;</span><br><span class="line">            curA = curA-&gt;next;</span><br><span class="line">            curB = curB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a>环形链表</h3><p>题意： 给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p><p>为了表示给定链表中的环，使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p><p><strong>说明</strong>：不允许修改给定的链表。</p><p>思路：</p><ol><li><p>定义快慢双指针fast与slow同时指向头结点</p></li><li><p>fast每次移动两步，slow每次移动一步</p></li><li><p>如果有环，则总会得到fast&#x3D;&#x3D;slow</p></li><li><p>从fast与slow相遇节点处出发一个指针index1，头结点处出发一个指针index2</p></li><li><p>index1与index2每次同时移动一步，最后相遇的位置就是<a href="%5B%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%5D(https://www.programmercarl.com/0142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II.html#%E6%80%9D%E8%B7%AF)">环形入口位置</a></p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            <span class="comment">// 快慢指针相遇，此时从head 和 相遇点，同时查找直至相遇</span></span><br><span class="line">            <span class="keyword">if</span> (slow == fast) &#123;</span><br><span class="line">                ListNode* index1 = fast;</span><br><span class="line">                ListNode* index2 = head;</span><br><span class="line">                <span class="keyword">while</span> (index1 != index2) &#123;</span><br><span class="line">                    index1 = index1-&gt;next;</span><br><span class="line">                    index2 = index2-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> index2; <span class="comment">// 返回环的入口</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h3><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c &#x3D; 0 ？请你找出所有满足条件且不重复的三元组。</p><p><strong>注意：</strong> 答案中不可以包含重复的三元组。</p><p>示例：</p><p>给定数组 nums &#x3D; [-1, 0, 1, 2, -1, -4]，</p><p>满足要求的三元组集合为： [ [-1, 0, 1], [-1, -1, 2] ]</p><p>思路：</p><ol><li><p>首先将数组排序</p></li><li><p>for(int i&#x3D;0,i&lt;nums.size();i++)</p></li><li><p>定义两个指针left&#x3D;1，right&#x3D;nums.size()-1</p></li><li><p>寻找满足a&#x3D;nums[i]+nums[left]+nums[right]</p></li><li><p>如果nums[i]+nums[left]+nums[right]&gt;0，则三数之和大了（nums排过序了），所以right向左移动</p></li><li><p>如果nums[i]+nums[left]+nums[right]&lt;0，则三数之和小了，所以left向右移动</p></li><li><p>直到left&#x3D;&#x3D;right就可结束这一次循环</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="comment">// 找出a + b + c = 0</span></span><br><span class="line">        <span class="comment">// a = nums[i], b = nums[left], c = nums[right]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 排序之后如果第一个元素已经大于零，那么无论如何组合都不可能凑成三元组，直接返回结果就可以了</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 错误去重方法，将会漏掉-1,-1,2 这种情况</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            if (nums[i] == nums[i + 1]) &#123;</span></span><br><span class="line"><span class="comment">                continue;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="comment">// 正确去重方法</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> left = i + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (right &gt; left) &#123;</span><br><span class="line">                <span class="comment">// 去重复逻辑如果放在这里，0，0，0 的情况，可能直接导致 right&lt;=left 了，从而漏掉了 0,0,0 这种三元组</span></span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                while (right &gt; left &amp;&amp; nums[right] == nums[right - 1]) right--;</span></span><br><span class="line"><span class="comment">                while (right &gt; left &amp;&amp; nums[left] == nums[left + 1]) left++;</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[left] + nums[right] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    right--;</span><br><span class="line">                    <span class="comment">// 当前元素不合适了，可以去重</span></span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right + <span class="number">1</span>]) right--;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] + nums[left] + nums[right] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    left++;</span><br><span class="line">                    <span class="comment">// 不合适，去重</span></span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left - <span class="number">1</span>]) left++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    result.<span class="built_in">push_back</span>(vector&lt;<span class="type">int</span>&gt;&#123;nums[i], nums[left], nums[right]&#125;);</span><br><span class="line">                    <span class="comment">// 去重逻辑应该放在找到一个三元组之后</span></span><br><span class="line">                    <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) right--;</span><br><span class="line">                    <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) left++;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 找到答案时，双指针同时收缩</span></span><br><span class="line">                    right--;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="四数之和"><a href="#四数之和" class="headerlink" title="四数之和"></a>四数之和</h3><p>题意：给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。</p><p><strong>注意：</strong></p><p>答案中不可以包含重复的四元组。</p><p>示例： 给定数组 nums &#x3D; [1, 0, -1, 0, -2, 2]，和 target &#x3D; 0。 满足要求的四元组集合为： [ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2] ]</p><p>思路：</p><ol><li>等同三数之和，无非是再套一层for循环</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">fourSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; nums.<span class="built_in">size</span>(); k++) &#123;</span><br><span class="line">            <span class="comment">// 这种剪枝是错误的，这道题目target 是任意值</span></span><br><span class="line">            <span class="comment">// if (nums[k] &gt; target) &#123;</span></span><br><span class="line">            <span class="comment">//     return result;</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            <span class="comment">// 去重</span></span><br><span class="line">            <span class="keyword">if</span> (k &gt; <span class="number">0</span> &amp;&amp; nums[k] == nums[k - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = k + <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">                <span class="comment">// 正确去重方法</span></span><br><span class="line">                <span class="keyword">if</span> (i &gt; k + <span class="number">1</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> left = i + <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (right &gt; left) &#123;</span><br><span class="line">                    <span class="comment">// nums[k] + nums[i] + nums[left] + nums[right] &gt; target 会溢出</span></span><br><span class="line">                    <span class="keyword">if</span> (nums[k] + nums[i] &gt; target - (nums[left] + nums[right])) &#123;</span><br><span class="line">                        right--;</span><br><span class="line">                        <span class="comment">// 当前元素不合适了，可以去重</span></span><br><span class="line">                        <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right + <span class="number">1</span>]) right--;</span><br><span class="line">                    <span class="comment">// nums[k] + nums[i] + nums[left] + nums[right] &lt; target 会溢出</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[k] + nums[i]  &lt; target - (nums[left] + nums[right])) &#123;</span><br><span class="line">                        left++;</span><br><span class="line">                        <span class="comment">// 不合适，去重</span></span><br><span class="line">                        <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left - <span class="number">1</span>]) left++;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        result.<span class="built_in">push_back</span>(vector&lt;<span class="type">int</span>&gt;&#123;nums[k], nums[i], nums[left], nums[right]&#125;);</span><br><span class="line">                        <span class="comment">// 去重逻辑应该放在找到一个四元组之后</span></span><br><span class="line">                        <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) right--;</span><br><span class="line">                        <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) left++;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 找到答案时，双指针同时收缩</span></span><br><span class="line">                        right--;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>声明：本博客整理思路参考自《代码随想录》，题目摘自leetcode</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>const int* i与const int&amp; i以及int* const i的区别</title>
      <link href="/2022/03/13/about%20const%20int/"/>
      <url>/2022/03/13/about%20const%20int/</url>
      
        <content type="html"><![CDATA[<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>const int* i(int const* i):指向一个常量的指针，使用时不需要初始化，被指向的常量不可改变，但是可以改变指针指向的地址。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> x=<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* p1=&amp;x;</span><br><span class="line">p1++;        <span class="comment">//ok</span></span><br><span class="line">(*p1)++;     <span class="comment">//error</span></span><br></pre></td></tr></table></figure><p>const int&amp; i:指向常量的引用，使用时必须初始化。初始化后引用值不可改变，引用的常量也不可改变。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; p2;        <span class="comment">//error</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; p2=x;        <span class="comment">//ok</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> y=<span class="number">20</span>;</span><br><span class="line">p2=y;                <span class="comment">//error</span></span><br><span class="line">p2++;                <span class="comment">//error</span></span><br></pre></td></tr></table></figure><p>int* const i:指向的内容可以改变，但是指向的地址不能改变</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
