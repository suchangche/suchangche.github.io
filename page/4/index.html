<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.1.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.0.0/css/all.min.css" integrity="sha256-jTIdiMuX/e3DGJUGwl3pKSxuc6YOuqtJYkM0bGQESA4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.10.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="孤独是人生的常态">
<meta property="og:type" content="website">
<meta property="og:title" content="Williny&#39;home">
<meta property="og:url" content="http://example.com/page/4/index.html">
<meta property="og:site_name" content="Williny&#39;home">
<meta property="og:description" content="孤独是人生的常态">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="williny">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/4/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/4/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Williny'home</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Williny'home</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="williny"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">williny</p>
  <div class="site-description" itemprop="description">孤独是人生的常态</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">85</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/suchangche" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;suchangche" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:469478061@qq.com" title="E-Mail → mailto:469478061@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/27/UE4-%E9%A1%B9%E7%9B%AE-%E6%AD%BB%E5%AF%82-%E6%95%8C%E4%BA%BAAI/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="williny">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Williny'home">
      <meta itemprop="description" content="孤独是人生的常态">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Williny'home">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/06/27/UE4-%E9%A1%B9%E7%9B%AE-%E6%AD%BB%E5%AF%82-%E6%95%8C%E4%BA%BAAI/" class="post-title-link" itemprop="url">UE4-项目-死寂-敌人AI与简单伤害系统</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-06-27 14:58:48" itemprop="dateCreated datePublished" datetime="2022-06-27T14:58:48+08:00">2022-06-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-07-03 11:12:54" itemprop="dateModified" datetime="2022-07-03T11:12:54+08:00">2022-07-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/unreal-engine/" itemprop="url" rel="index"><span itemprop="name">unreal engine</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h1><p>前面的几个章节已经将角色的大部分功能完善了，关于玩家角色还剩下的功能，大概就是伤害系统，生命值系统这些有要用到UI界面的，这就放到后面的UI一起解决。</p>
<p>接下来就是激动人心的敌人AI了！兄弟们，这个FPS项目进度正式过半，加油！！！</p>
<h1 id="丧尸随机移动及追逐玩家"><a href="#丧尸随机移动及追逐玩家" class="headerlink" title="丧尸随机移动及追逐玩家"></a>丧尸随机移动及追逐玩家</h1><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><h3 id="获取黑板"><a href="#获取黑板" class="headerlink" title="获取黑板"></a>获取黑板</h3><p>在AI控制器中使用，字面意思</p>
<h3 id="创建文字命名"><a href="#创建文字命名" class="headerlink" title="创建文字命名"></a>创建文字命名</h3><p>根据传入的值，返回变量名相同的变量</p>
<h3 id="将值设为布尔"><a href="#将值设为布尔" class="headerlink" title="将值设为布尔"></a>将值设为布尔</h3><p>在AI控制器使用，字面意思</p>
<p>将目标中的名为key name引脚传入的值的布尔变量进行设置</p>
<h3 id="行为树中的Sequence"><a href="#行为树中的Sequence" class="headerlink" title="行为树中的Sequence"></a>行为树中的Sequence</h3><ol>
<li><p>可添加装饰器backbroad</p>
</li>
<li><p>修改backbroad的黑板键，观察器中止</p>
</li>
</ol>
<h3 id="Backbroad"><a href="#Backbroad" class="headerlink" title="Backbroad"></a>Backbroad</h3><ol>
<li><p>观察器中止：再AI行为树的同一深度中，任一一个条件达成，就会中断同层的所有节点</p>
</li>
<li><p>黑板键：黑板中设置的值</p>
</li>
</ol>
<h3 id="新建任务"><a href="#新建任务" class="headerlink" title="新建任务"></a>新建任务</h3><p>AI行为树中的左上角图表，点击之后为该行为树创建一个任务，用于在达成某条件之后AI需要执行的操作</p>
<h3 id="事件接收执行AI"><a href="#事件接收执行AI" class="headerlink" title="事件接收执行AI"></a>事件接收执行AI</h3><p>在任务被触发的时候会执行的函数</p>
<h3 id="完成执行"><a href="#完成执行" class="headerlink" title="完成执行"></a>完成执行</h3><p>AI行为树的任务中的节点，告诉系统此任务已经完成，可以执行下一个任务</p>
<h3 id="AI-MoveTo"><a href="#AI-MoveTo" class="headerlink" title="AI MoveTo"></a>AI MoveTo</h3><p>AI行为树的任务中的节点：操控AI移动到具体位置或者跟随某Actor进行移动</p>
<h3 id="控制时"><a href="#控制时" class="headerlink" title="控制时"></a>控制时</h3><p>AI控制器中的可重载函数：在AI被AI控制器控制的时候触发的事件</p>
<h3 id="运行行为树"><a href="#运行行为树" class="headerlink" title="运行行为树"></a>运行行为树</h3><p>AI控制器中的节点：字面意思</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol>
<li><p>创建丧尸蓝图类，动画蓝图，混合空间1D，AI行为树，黑板，AI控制器</p>
</li>
<li><p>在蓝图类中配置动画蓝图，AI控制器，移动组件的“将旋转朝向运动”为true，类默认值“使用控制器旋转yaw”为false</p>
</li>
<li><p>设置混合空间1D，设置根据速度变化的丧尸行走&#x2F;慢跑&#x2F;冲刺动画</p>
</li>
<li><p>配置动画蓝图</p>
<ul>
<li><p>创建基础状态机并缓存，输出为基础状态机的缓存</p>
</li>
<li><p>编辑基础状态机，添加状态“基础状态”</p>
</li>
<li><p>编辑基础状态，将创建的混合空间1D输出，并将其速度引脚提升为变量</p>
</li>
<li><p>编辑事件图表，判断尝试获取pawn拥有者是否有效，如果有效则获取其速度，再获取其向量长度，传给变量“速度”</p>
</li>
</ul>
</li>
<li><p>编辑黑板，添加变量“是否看到玩家”（布尔），“是否追逐玩家”（布尔），“要去的位置”（向量）</p>
</li>
<li><p>编辑AI控制器，添加组件“AI感知组件”</p>
<ul>
<li><p>编辑AI感知组件，添加AI视力配置并修改其属性</p>
</li>
<li><p>其中视力配置除了视线半径和角度之外，重要的还有按归属检测需要全部勾选</p>
</li>
<li><p>添加AI感知组件的事件“目标感知更新时”，中断其值并将类型转换为BP_Player</p>
</li>
<li><p>用“将值设置为布尔”节点，根据中断值中的“Successfully Sensed”节点修改黑板中的“是否看到玩家”（“获取黑板”节点和“创建文字命名”节点）</p>
</li>
</ul>
</li>
<li><p>配置行为树</p>
<ul>
<li><p>将行为树的黑板配置为刚创建的</p>
</li>
<li><p>跟节点引出一个Selector；Selector引出两个Sequence</p>
</li>
<li><p>给两个Sequence添加一个装饰器“backbroad”，将其黑板键设置为“是否看到玩家”（一个设置为已设置，另一个设置为未设置），观察器终止修改为Both</p>
</li>
<li><p>新建一个任务并编辑，重载函数“事件接收执行AI”</p>
</li>
<li><p>获取Actor位置，并获取可导航半径的随机点</p>
</li>
<li><p>新建黑板键选择器类型的变量“随机移动位置”，并将其设置为可编辑实例</p>
</li>
<li><p>将“随机移动位置”拖出，并将黑板值设为变量，将“获取可导航半径内的随机点”的输出引脚作为输入引入</p>
</li>
<li><p>添加“完成执行”节点</p>
</li>
<li><p>在行为树中调用刚创建的事件，并在其默认值中传入形参“随机移动位置”的实参</p>
</li>
<li><p>调用内置任务“Move To”和“Wait”（到这里才会移动，上一个任务是计算“要去的位置”，在Move To节点中调用其值才会具体行动）</p>
</li>
<li><p>新建任务“发现玩家”，重载“事件接收TickAI”函数，调用AI MoveTo节点，“获取玩家pawn”作为“Target Actor”引脚的输入值，最后“完成执行”</p>
</li>
<li><p>在行为树中调用该任务</p>
</li>
</ul>
</li>
<li><p>修改AI控制器</p>
<ul>
<li>重载函数“事件控制时”，并将其引脚提升为变量“控制的zombie”，“运行行为树”</li>
</ul>
</li>
<li><p>在世界中放入“导航网格体边界体积”</p>
</li>
<li><p>优化丧尸行动速度</p>
<ul>
<li><p>在丧尸的角色蓝图中添加事件图表“随机移动”，添加自定义事件“随机找点移动”，调用角色移动组件并“set max walk speed”为20（此时为未发现玩家的速度）</p>
</li>
<li><p>添加事件图表“发现玩家”，添加自定义事件“发现玩家做的事”，调用角色移动组件并“set max walk speed”，传入速度用“范围内随机浮点”取值为400-500</p>
</li>
<li><p>在两个AI行为树的任务“随即移动”和“发现玩家”中分别用蓝图通信后调用“随即找点移动”以及“发现玩家做的事”</p>
</li>
<li><p>最后在丧尸的角色蓝图中设置其最大行走速度为20</p>
</li>
</ul>
</li>
</ol>
<h1 id="丧尸看见玩家尖叫并追赶"><a href="#丧尸看见玩家尖叫并追赶" class="headerlink" title="丧尸看见玩家尖叫并追赶"></a>丧尸看见玩家尖叫并追赶</h1><h2 id="知识点-1"><a href="#知识点-1" class="headerlink" title="知识点"></a>知识点</h2><h3 id="生成音效已附加"><a href="#生成音效已附加" class="headerlink" title="生成音效已附加"></a>生成音效已附加</h3><p>生成一个音效并且附加到某个组件上，实现丧尸追逐玩家的同时会发出声音</p>
<h3 id="销毁组件"><a href="#销毁组件" class="headerlink" title="销毁组件"></a>销毁组件</h3><p>某组件可引出的节点，字面意思</p>
<h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><ol>
<li><p>打开丧尸的动画蓝图，添加两个变量“是否可以尖叫”，“是否死亡”，判断是否死亡后判断是否可以尖叫，然后播放尖叫的蒙太奇动画（在动画蓝图中需要添加其插槽），在丧尸尖叫的时候速度为0，动画播放完之后设置移动速度为400-500</p>
</li>
<li><p>添加一个变量“是否正在尖叫”，在开始尖叫是设置为true，结束播放尖叫动画的时候设置为false</p>
</li>
<li><p>使用“生成音效已附加”节点，创建一个丧尸追逐主角的音效，附加到丧尸身上，实现丧尸追逐主角的同时进行尖叫</p>
</li>
<li><p>在丧尸不能尖叫的时候判断丧尸是否在尖叫，如果不在尖叫，则判断丧尸的追逐音效是否有效，若无效，则将逻辑链接到后面的设置速度并且添加音效上</p>
</li>
<li><p>丧尸随机移动事件图表，首先判断是否死亡，然后设置行走速度，在之后需要用一个序列，判断丧尸追逐音效是否有效，有效则“销毁组件”（未看到玩家的时候随机移动但不发出尖叫）</p>
</li>
<li><p>序列的另一个引脚引出“Do Once”节点，并以函数名设置定时器，时间设置为15s</p>
<ul>
<li><p>新建自定义事件“重置尖叫”，并设置“是否可以尖叫”为true</p>
</li>
<li><p>新建自定义事件“reset”，链接到Do Once的Reset引脚上</p>
</li>
<li><p>将“以函数名设置定时器”的函数名修改为“重置尖叫”</p>
</li>
</ul>
</li>
<li><p>为了防止丧尸在发现玩家之后尖叫，并且在十五秒之后又尖叫，所以在“发现玩家”事件图表中的开头调用“reset”事件，并“以函数名清除定时器”</p>
</li>
<li><p>优化一下丧尸追逐玩家时候的音效，在“生成音效已附加”节点的“Start Time”引脚中引出节点“范围内随机浮点”，看下丧尸音效的时长，设置在范围内即可</p>
</li>
</ol>
<h1 id="丧尸丢失目标后移动到目标最后位置"><a href="#丧尸丢失目标后移动到目标最后位置" class="headerlink" title="丧尸丢失目标后移动到目标最后位置"></a>丧尸丢失目标后移动到目标最后位置</h1><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><ol>
<li><p>在丧尸的AI控制器中新建向量类型变量“最后看到玩家的位置”</p>
</li>
<li><p>获取BP_Player的位置后，获取可导航半径内的随机点，然后设置给“最后看到玩家的位置”</p>
</li>
<li><p>判断感知组件是否感知到玩家，false则链接Do Once节点，并且使用“将值设为布尔值”，key name为“是否追逐玩家”，目标为黑板</p>
</li>
<li><p>新建自定义事件“reset”连接到Do Once的reset节点上、</p>
</li>
<li><p>优化行为树，先“是否看到玩家”，在“未设置”分支中选择“是否追逐玩家”，未追逐则随即移动等，追逐则创建新的任务</p>
<ul>
<li><p>新建任务“追赶玩家到最后位置”，重载“事件接收执行AI”，类型转换为AI控制器，获取其中的“最后看到玩家位置”并且“AI MoveTo”</p>
</li>
<li><p>使用“将值设置为布尔”将黑板中的“是否追逐玩家”设置为false，再调用AI控制器中的reset事件，最后“完成执行”</p>
</li>
</ul>
</li>
</ol>
<h1 id="丧尸攻击玩家动画"><a href="#丧尸攻击玩家动画" class="headerlink" title="丧尸攻击玩家动画"></a>丧尸攻击玩家动画</h1><h2 id="知识点-2"><a href="#知识点-2" class="headerlink" title="知识点"></a>知识点</h2><h3 id="随机序列播放器"><a href="#随机序列播放器" class="headerlink" title="随机序列播放器"></a>随机序列播放器</h3><p>动画蓝图中的节点：随机播放这个节点中的动画中的某一个</p>
<h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><ol>
<li><p>在动画蓝图中创建变量“是否攻击”，并作为“按布尔混合姿势”的判断条件</p>
</li>
<li><p>添加节点“随机序列播放器”，在此节点中放入两个丧尸攻击的动画，勾选随机播放</p>
</li>
<li><p>使用“每个骨骼的分层混合”节点将基础状态和攻击动画进行上下半身混合。注意添加骨骼之后还需要勾选“网格体空间旋转混合”</p>
</li>
<li><p>最后基础状态作为“按布尔混合姿势”的false，上下半身混合之后的动画作为true</p>
</li>
<li><p>在丧尸的角色蓝图中创建新图表“攻击玩家”，由“事件Tick”先判断是否死亡，再以黑板中的“是否看到玩家”作为判断条件，true则创建射线检测（由通道检测球体）</p>
</li>
<li><p>“由通道检测球体”的起始位置是actor位置，终点位置是actor前方110cm的100cm半径的球体</p>
<ul>
<li><p>创建新的通道命名为“ZombieAttack”默认为忽略</p>
</li>
<li><p>在球形通道检测中使用该通道</p>
</li>
<li><p>在角色蓝图中的mesh组件中将碰撞预设的ZombieAttack修改为阻挡</p>
</li>
</ul>
</li>
<li><p>接下来判断球体检测是否碰撞到物体，若是，则中断其检测结果，判断是否为玩家actor（类型转换为玩家actor，如果成功，则是）</p>
</li>
<li><p>获取丧尸动画实例中的“是否攻击”，如果玩家未死亡，则设置为true，否则false</p>
<ul>
<li>与此同时，在类型转换为玩家失败的时候（检测物体不为玩家），以及丧尸未看到玩家的时候均将“是否攻击”设置为false</li>
</ul>
</li>
</ol>
<h1 id="优化-丧尸攻击角色时的面向及阻挡摄像机"><a href="#优化-丧尸攻击角色时的面向及阻挡摄像机" class="headerlink" title="优化-丧尸攻击角色时的面向及阻挡摄像机"></a>优化-丧尸攻击角色时的面向及阻挡摄像机</h1><p>如果不进行这个优化的话就会出现玩家一个绕背就能让丧尸丢失目标</p>
<h2 id="知识点-3"><a href="#知识点-3" class="headerlink" title="知识点"></a>知识点</h2><h3 id="Orient-Roatation-to-Movement"><a href="#Orient-Roatation-to-Movement" class="headerlink" title="Orient Roatation to Movement"></a>Orient Roatation to Movement</h3><p>角色移动组件的属性：将旋转朝向运动</p>
<h3 id="Use-Content-Rotation-Yaw"><a href="#Use-Content-Rotation-Yaw" class="headerlink" title="Use Content Rotation Yaw"></a>Use Content Rotation Yaw</h3><p>角色移动组件的属性：使用控制器旋转</p>
<h3 id="设置焦距"><a href="#设置焦距" class="headerlink" title="设置焦距"></a>设置焦距</h3><p>AI控制器：脚焦距设置到指定的actor上</p>
<h3 id="清除焦距"><a href="#清除焦距" class="headerlink" title="清除焦距"></a>清除焦距</h3><p>AI控制器：字面意思啦！</p>
<h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><ol>
<li><p>丧尸蓝图中创建函数”更改控制旋转模式“</p>
</li>
<li><p>使用角色移动组件，分别调用”Orient Roatation to Movement“和”Use Content Rotation Yaw“节点并将其公开到函数参数</p>
</li>
<li><p>在丧尸攻击玩家时调用此函数，”使用控制器所需的旋转“勾选，否则勾选”将旋转朝向的运动“</p>
</li>
<li><p>获取AI控制器，然后”设置焦距“在玩家上，不攻击则”清除焦距“</p>
</li>
<li><p>点开丧尸的mesh，将碰撞中的摄像机忽略</p>
</li>
</ol>
<h1 id="丧尸攻击音效"><a href="#丧尸攻击音效" class="headerlink" title="丧尸攻击音效"></a>丧尸攻击音效</h1><h2 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h2><ol>
<li><p>创建一个音效cue</p>
</li>
<li><p>找到丧尸攻击动画，在合适位置创建通知音效，将cue传入到通知中</p>
</li>
</ol>
<h1 id="丧尸脚步声实现"><a href="#丧尸脚步声实现" class="headerlink" title="丧尸脚步声实现"></a>丧尸脚步声实现</h1><h2 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h2><ol>
<li><p>直接用玩家角色蓝图中的“脚步声判断”函数来实现脚步功能</p>
</li>
<li><p>丧尸角色蓝图的事件图表中，事件开始运行时，获取actor的所有类，提升为变量“玩家蓝图实例”</p>
</li>
<li><p>添加两个箭头组件分别将其插槽设置到丧尸的左右脚</p>
</li>
<li><p>创建新事件图表“脚步声”，新建自定义事件“左脚步声”，“右脚步声”，分别调用玩家蓝图实例中的“脚步声判断”，并且将两个箭头组件作为参数传入</p>
</li>
<li><p>复制之前玩家的动画通知“Notif_RightFoot”和“Notif_LeftFoot”到丧尸文件夹并改为“Notif_ZombieRightFoot”和“Notif_ZombieLeftFoot”</p>
<ul>
<li>修改动画通知，将类型转换为“BP_Zombie”并分别调用左右脚步声</li>
</ul>
</li>
<li><p>将动画通知添加到动画的合适位置</p>
</li>
</ol>
<h1 id="随机丧尸模型和朝向"><a href="#随机丧尸模型和朝向" class="headerlink" title="随机丧尸模型和朝向"></a>随机丧尸模型和朝向</h1><h2 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h2><ol>
<li><p>在丧尸角色蓝图中创建新图表“随机丧尸模型”</p>
</li>
<li><p>创建一个元素为骨骼网格体的数组“丧尸模型”，并向其中添加丧尸骨骼网格体元素</p>
</li>
<li><p>新建自定义事件“随机Zombie模型”，由网格体组件引出“设置骨骼网格体”</p>
</li>
<li><p>将“丧尸模型”在“范围内随机整数”传入到“设置骨骼网格体”</p>
</li>
<li><p>在事件图表的开始运行处调用“随机Zombie模型”事件</p>
</li>
<li><p>最后设置actor旋转，传入“范围内随机浮点”</p>
</li>
</ol>
<h1 id="丧尸被击中动画和死亡系统"><a href="#丧尸被击中动画和死亡系统" class="headerlink" title="丧尸被击中动画和死亡系统"></a>丧尸被击中动画和死亡系统</h1><h2 id="知识点-4"><a href="#知识点-4" class="headerlink" title="知识点"></a>知识点</h2><h3 id="应用伤害"><a href="#应用伤害" class="headerlink" title="应用伤害"></a>应用伤害</h3><p>将伤害施加给“Damaged Actor”引脚传入的Actor</p>
<h3 id="获取相关剩余动画的时间"><a href="#获取相关剩余动画的时间" class="headerlink" title="获取相关剩余动画的时间"></a>获取相关剩余动画的时间</h3><p>在动画蓝图中使用：字面意思</p>
<h3 id="事件任意伤害"><a href="#事件任意伤害" class="headerlink" title="事件任意伤害"></a>事件任意伤害</h3><p>会响应并输出对此蓝图类造成的任何伤害信息</p>
<p>和“应用伤害”属于配套的接口</p>
<h2 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h2><ol>
<li><p>在子弹事件蓝图中判断击中的是否为丧尸（类型转换为丧尸蓝图类）</p>
</li>
<li><p>类型转换成功则在击中部位生成血液飞溅例子特效和血色烟雾例子特效（在位置处生成发射器）</p>
</li>
<li><p>根据子弹的命中结果判断击中的骨骼是否为头部骨骼，如果是，则使用“应用伤害”节点施加更多的伤害，如果不是，则施加适量伤害</p>
</li>
<li><p>在击中位置“播放位置处音效”，连接上之前蓝图逻辑的序列，判断击中物体是否模拟物理</p>
</li>
<li><p>因为子弹的碰撞对象类型对丧尸的类型“pawn”是重叠的，不能造成影响，所以要将丧尸模型的碰撞对象类型修改为“PhysicalBody”，将丧尸胶囊体的碰撞预设的子弹进行忽略</p>
</li>
<li><p>添加丧尸被击中动画，在丧尸动画蓝图中的基础状态机中新增状态“被击中”，添加新的变量“是否被击中”，被击中判断逻辑为“是否被击中”为true，被击中返回基础状态逻辑为“获取相关剩余动画的时间”&lt;0.1</p>
</li>
<li><p>在被击中状态中添加动画，使用上下半身混合（每个骨骼的分层混合）base为丧尸的混合空间动画，blend posed 0为丧尸被击中动画（取消勾选循环播放）</p>
</li>
<li><p>在丧尸蓝图类中新建事件图表“事件任意伤害”，新建浮点型变量“丧尸血量”，将“事件任意伤害”传出的Damage引脚与“丧尸血量”相减之后再赋值给“丧尸血量”</p>
</li>
<li><p>判断丧尸血量是否&lt;&#x3D;0，true则死亡，false则播放被击中动画</p>
</li>
<li><p>再播放被击中动画之前要先判断丧尸是否在播放攻击动画</p>
</li>
<li><p>新建一个函数“通信到动画蓝图”，获取角色mesh的动画实例，再类型转换为Anim_Zombie，添加一个返回节点，将类型转换返回值输出</p>
</li>
<li><p>在“伤害检测和死亡系统”事件图表中调用“通信到动画蓝图”函数，引出“是否攻击”作为判断依据，false时设置“是否被击中”为true，延迟0.1s之后设置“是否被击中”为false</p>
</li>
<li><p>判断丧尸为死亡的时候使用“Do Once”设置丧尸网格体模拟物理，将其角色移动最大速度设置为0，并且将碰撞预设碰撞启用修改为“已启用碰撞（查询和物理）”</p>
</li>
<li><p>将丧尸的胶囊体的碰撞预设中忽略PhyscialBody</p>
</li>
<li><p>将丧尸的“是否死亡”设置为true，关闭胶囊体的碰撞，调用通信到动画蓝图函数之后设置“是否攻击”为false，判断“丧尸追逐音效”是否有效，true则销毁组件，同时序列“延迟10s”之后销毁actor</p>
</li>
<li><p>最后在丧尸脚步声事件图表中先判断丧尸是否死亡，未死王才能生成脚步声</p>
</li>
</ol>
<h1 id="丧尸攻击范围检测"><a href="#丧尸攻击范围检测" class="headerlink" title="丧尸攻击范围检测"></a>丧尸攻击范围检测</h1><h2 id="知识点-5"><a href="#知识点-5" class="headerlink" title="知识点"></a>知识点</h2><h3 id="获取插槽位置"><a href="#获取插槽位置" class="headerlink" title="获取插槽位置"></a>获取插槽位置</h3><p>获取骨骼插槽位置信息</p>
<h2 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h2><ol>
<li><p>丧尸角色蓝图中新建事件图表“攻击范围检测”，新建自定义事件“攻击范围”，使用“由通道检测球体”来检测丧尸的攻击范围</p>
</li>
<li><p>创建两个命名类型的变量“攻击检测起始骨骼”和“攻击检测终点骨骼”，并且调用网格体“获取插槽位置”，并将两个变量作为引脚传入</p>
</li>
<li><p>创建新的Actor类型变量“HitPlayer”，判断是否击中物体，再判断击中物体是否与“HitPlayer”相同，不相同才可继续操作（为了防止一个动画造成N次伤害）</p>
</li>
<li><p>接下来类型转换为BP_Player，重新保存“HitPlyaer”</p>
</li>
<li><p>使用“应用伤害”节点，然后“在位置处生成发射器”</p>
</li>
<li><p>创建动画通知，在动画通知中调用此事件</p>
</li>
<li><p>创建三个动画通知“Notif_ZombieBoneSettings”，“Notif_ZombieEndOfAttack”，“Notif_ZombieStartAttack”</p>
</li>
<li><p>在“Notif_ZombieStartAttack”中“以函数名设置定时器”调用自定义事件“攻击范围”</p>
</li>
<li><p>在“Notif_ZombieEndOfAttack”中“以函数名清除定时器”清除“攻击范围”函数，并且将“HitPlayer”设置为空</p>
</li>
<li><p>在“Notif_ZombieBoneSettings”中设置“攻击检测起始骨骼”和“攻击检测终点骨骼”分别为右手手肘和右手中指（因为攻击动画中是用右手攻击的）</p>
</li>
<li><p>在丧尸死亡之后清除攻击范围检测并且将HitPlayer设置为空，攻击玩家事件图表的最后（停止播放攻击动画）亦然</p>
</li>
<li><p>在丧尸攻击动画中的合适位置添加三个动画通知</p>
</li>
</ol>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ol>
<li>在动画通知中“以函数名设置定时器”节点的Time引脚和Looping引脚需要设置（每Time秒调用一次该函数）</li>
</ol>
<h1 id="角色死亡系统"><a href="#角色死亡系统" class="headerlink" title="角色死亡系统"></a>角色死亡系统</h1><h2 id="知识点-6"><a href="#知识点-6" class="headerlink" title="知识点"></a>知识点</h2><h3 id="设置激活"><a href="#设置激活" class="headerlink" title="设置激活"></a>设置激活</h3><p>可以激活或者关闭某个组件</p>
<h3 id="禁用移动"><a href="#禁用移动" class="headerlink" title="禁用移动"></a>禁用移动</h3><p>使用此节点可以使得角色移动组件不可移动</p>
<h3 id="设置碰撞已启用"><a href="#设置碰撞已启用" class="headerlink" title="设置碰撞已启用"></a>设置碰撞已启用</h3><p>可以设置某组件碰撞类型（关闭&#x2F;查询&#x2F;物理）</p>
<h3 id="set-post-process-setting"><a href="#set-post-process-setting" class="headerlink" title="set post process setting"></a>set post process setting</h3><p>可以设置摄像机后期盒子的一些参数</p>
<p>拉住唯一的引脚”创建PostProcessSettings“</p>
<h3 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h3><ol>
<li><p>新建事件图表“死亡系统”，调用“事件任意伤害”，新建float变量“当前血量”默认值为100和“目标血量”默认值为0</p>
</li>
<li><p>用受到伤害量与当前血量相减，然后传给“目标血量”，用一个序列节点，第一个引脚链接一个时间轴“血量平滑过渡”的“Playe from start”，设置时间轴时长为0.5s，值为1</p>
</li>
<li><p>用“插值”节点，将当前血量到目标血量进行过渡，最后传给“当前血量”</p>
</li>
<li><p>序列节点的第二个引脚判断目标血量是否小于等于0，如果是，则使用Do Once将角色状态设置为死亡（前面的角色状态枚举中添加一个死亡状态）</p>
</li>
<li><p>开启角色模型的碰撞预设中的启用碰撞（查询和物理）并且调用模型“设置模拟物理”为true，碰撞对象类型为PhycialBody，忽略bullit碰撞，胶囊体的碰撞对于PhycialBody进行忽略</p>
</li>
<li><p>添加新的摄像机视角，实现死亡之后的视角</p>
<ul>
<li><p>在胶囊体之下添加一个新的弹簧臂组件（关闭碰撞，摄像机设置全部关闭）和新的摄像机组件（默认值激活为false）</p>
</li>
<li><p>将原本的摄像机使用“设置激活”为false，将新的摄像机设置为true</p>
</li>
<li><p>调用角色移动组件并且“禁用移动”</p>
</li>
<li><p>调用胶囊体组件并“设置碰撞已启用”为无碰撞</p>
</li>
</ul>
</li>
<li><p>使得武器自动掉落到地上</p>
<ul>
<li><p>武器父类新建事件图表“开启模拟物理”，并自定义事件“开启物理模拟“，使得武器模型”设置物理模拟“为true</p>
</li>
<li><p>设置武器模型的碰撞预设为自定义，碰撞启用为查询和物理，对象类型为WorldDynamic，并将PhycialBody和Bullet进行忽略</p>
</li>
<li><p>在角色蓝图死亡系统最后使用一个序列节点，分别判断主武器和副武器是否有效，若有效则使用”从Actor分离“后开启模拟物理</p>
</li>
</ul>
</li>
<li><p>实现视角从彩色变为黑白效果</p>
<ul>
<li><p>在原本的序列节点上加一个引脚，引出一个时间轴”拉长弹簧臂长度“，新建轨道之后使用插值从默认长度300到2000update给死亡后弹簧臂长度</p>
</li>
<li><p>调用死亡后摄像机组件“set post process setting”并且”创建set post process setting“将Saturation（饱和度）和Contrast（对比度）以及Intensity（强度）公开为引脚</p>
</li>
<li><p>在世界中放入后期处理盒子并使其无线范围</p>
</li>
<li><p>使用”插值“和”创建向量4“分别设置饱和度，对比度，强度（只用插值即可）</p>
</li>
</ul>
</li>
</ol>
<h2 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h2><ol>
<li>任意伤害事件更新血量的时候，不要把伤害量和当前血量减法位置弄错</li>
</ol>
<h1 id="玩家被击中动画"><a href="#玩家被击中动画" class="headerlink" title="玩家被击中动画"></a>玩家被击中动画</h1><h2 id="知识点-7"><a href="#知识点-7" class="headerlink" title="知识点"></a>知识点</h2><h3 id="客户端开始摄像机晃动"><a href="#客户端开始摄像机晃动" class="headerlink" title="客户端开始摄像机晃动"></a>客户端开始摄像机晃动</h3><p>玩家控制器的内置函数：字面意思</p>
<h2 id="思路-11"><a href="#思路-11" class="headerlink" title="思路"></a>思路</h2><ol>
<li><p>四个被击中动画批量编辑RoorMotion-&gt;启用跟运动true-&gt;强制根锁定</p>
</li>
<li><p>给四个被击中动画创建为蒙太奇，并且修改插槽为Hit</p>
</li>
<li><p>将四个蒙太奇动画的混入和混出时间均修改为0.35</p>
</li>
<li><p>在角色蓝图动画中最外层添加插槽Hit（这个被击中动画优先级最高）</p>
</li>
<li><p>在角色蓝图中的死亡系统中，未死亡的情况下，先播放被击中音效，然后获取玩家控制器“客户端开始摄像机晃动”，接下来遍历玩家功能状态枚举，在“空白”，“跳跃”，“拾取物品”的时候可以“蒙太奇播放”</p>
</li>
<li><p>将蒙太奇输入引脚提升为变量，变为数组类型，将四个蒙太奇动画输入其中，然后在“范围内随机整数”下get</p>
</li>
</ol>
<h1 id="玩家死亡之后丧尸随机移动"><a href="#玩家死亡之后丧尸随机移动" class="headerlink" title="玩家死亡之后丧尸随机移动"></a>玩家死亡之后丧尸随机移动</h1><h2 id="思路-12"><a href="#思路-12" class="headerlink" title="思路"></a>思路</h2><p>之前玩家死亡之后丧尸没有随机移动是因为玩家死亡后虽然将状态修改为死亡，但是在其他的蓝图中有不少定时器，会在一定时间内将玩家状态修改为空白</p>
<ol>
<li><p>在修改玩家状态为死亡之前添加一个“以函数名设置定时器”节点，每0.1秒循环</p>
</li>
<li><p>创建一个自定义事件“强制开启死亡”，将状态修改为死亡</p>
</li>
<li><p>函数名设置定时器“强制开启死亡”。这样就保证了玩家死亡之后每0.1秒都会将状态重置为死亡</p>
</li>
<li><p>在丧尸AI控制器中，类型转换为玩家角色之后，判断玩家状态是否为死亡，true则将黑板中的“是否看到玩家”设置为false，false则走原本的逻辑路线</p>
</li>
<li><p>在丧尸角色蓝图中的“发现玩家”事件图表中也做相同的操作</p>
</li>
</ol>
<h1 id="优化-丧尸阻挡摄像机与死亡后音效关闭"><a href="#优化-丧尸阻挡摄像机与死亡后音效关闭" class="headerlink" title="优化-丧尸阻挡摄像机与死亡后音效关闭"></a>优化-丧尸阻挡摄像机与死亡后音效关闭</h1><ol>
<li><p>将丧尸的胶囊体和网格体组件中均忽略摄像机组件</p>
</li>
<li><p>在丧尸死亡系统中最后将“丧尸追逐音效”使用“设置激活”为false</p>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/23/UE4-%E9%A1%B9%E7%9B%AE-%E6%AD%BB%E5%AF%82-%E6%8B%BE%E5%8F%96%E7%B3%BB%E7%BB%9F%E5%8F%8A%E6%AD%A6%E5%99%A8%E5%88%87%E6%8D%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="williny">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Williny'home">
      <meta itemprop="description" content="孤独是人生的常态">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Williny'home">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/06/23/UE4-%E9%A1%B9%E7%9B%AE-%E6%AD%BB%E5%AF%82-%E6%8B%BE%E5%8F%96%E7%B3%BB%E7%BB%9F%E5%8F%8A%E6%AD%A6%E5%99%A8%E5%88%87%E6%8D%A2/" class="post-title-link" itemprop="url">UE4-项目-死寂-拾取系统及武器切换</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-06-23 11:44:39" itemprop="dateCreated datePublished" datetime="2022-06-23T11:44:39+08:00">2022-06-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-06-25 17:26:10" itemprop="dateModified" datetime="2022-06-25T17:26:10+08:00">2022-06-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/unreal-engine/" itemprop="url" rel="index"><span itemprop="name">unreal engine</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="拾取物品高亮显示"><a href="#拾取物品高亮显示" class="headerlink" title="拾取物品高亮显示"></a>拾取物品高亮显示</h1><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><h3 id="蓝图接口"><a href="#蓝图接口" class="headerlink" title="蓝图接口"></a>蓝图接口</h3><p>一个集成了很多功能的函数，可以通过蓝图接口实现蓝图之间的通信</p>
<h3 id="获取玩家摄像机管理器"><a href="#获取玩家摄像机管理器" class="headerlink" title="获取玩家摄像机管理器"></a>获取玩家摄像机管理器</h3><p>无论在第一人称或者第三人称状态下都可以返回摄像机相关的信息</p>
<h3 id="添加返回节点"><a href="#添加返回节点" class="headerlink" title="添加返回节点"></a>添加返回节点</h3><p>在函数内使用，添加函数的返回值</p>
<h3 id="获取有接口的所有actor"><a href="#获取有接口的所有actor" class="headerlink" title="获取有接口的所有actor"></a>获取有接口的所有actor</h3><p>选择一个接口，然后获取拥有该接口的所有actor</p>
<h3 id="设置渲染自定义深度"><a href="#设置渲染自定义深度" class="headerlink" title="设置渲染自定义深度"></a>设置渲染自定义深度</h3><p>能够产生物体的描边效果</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol>
<li><p>创建一个拾取物品列表“BP_PickUpItemsBase”</p>
</li>
<li><p>创建一个拾取物品蓝图接口”PickUpSystem”</p>
<ul>
<li>新增三个函数“拾取物品”，“开启该光显示”，“关闭高光显示”</li>
</ul>
</li>
<li><p>在“BP_PickUpItemsBase”中添加蓝图接口</p>
</li>
<li><p>在角色蓝图中添加函数“拾取范围检测”</p>
<ul>
<li><p>在一定范围内检测是否可以拾取</p>
</li>
<li><p>选择“由通道检测球体”来规定范围</p>
</li>
<li><p>起始点为摄像机位置</p>
</li>
<li><p>终点为摄像机往前（*向量）一定距离的位置（+向量）</p>
</li>
</ul>
</li>
<li><p>新增碰撞通道PickUp，默认设置为忽略（能拾取的物体再设置为阻挡）</p>
</li>
<li><p>设置“由通道检测球体”节点的检测通道</p>
</li>
<li><p>在“BP_PickUpItemsBase”的球体检测的碰撞属性中修改PickUp为阻挡</p>
</li>
<li><p>在角色蓝图中添加事件图表“拾取系统”</p>
<ul>
<li><p>添加actor类型的变量“检测到的物体”</p>
</li>
<li><p>调用“拾取范围检测”函数，判断是否检测到物体</p>
</li>
<li><p>判断检测到的物体是否为之前未检测到的物体（对同一个物体，高亮效果只执行一次）</p>
</li>
<li><p>判断检测到的物体是否有效（以免第一次使用的时候“检测到的物品”为空）</p>
</li>
<li><p>有效则关闭当前物体的高亮显示，将当前碰撞检测到的物体设置为“检测到的物品”，然后开启高亮显示</p>
</li>
<li><p>无效则将当前碰撞检测到的物体设置为“检测到的物品”，然后开启高亮显示</p>
</li>
<li><p>如果检测到物体不是可以拾取的，就要将之前识别到的高亮物体取消高亮</p>
</li>
<li><p>使用Do once节点关闭物体高亮（因为“拾取范围检测”是每帧都会执行一次的，我们不需要每帧都关闭，关闭一次即可）</p>
</li>
<li><p>当重新检测到能拾取的物体的时候重置do once（用序列节点实现）</p>
</li>
<li><p>关闭所有高亮显示使用“获取有接口的所有actor”</p>
</li>
<li><p>遍历获取到的actor，再调用“关闭高亮显示”节点，最后将“检测到的物品“重置为空</p>
</li>
</ul>
</li>
<li><p>在角色事件图表中每帧调用”拾取物品高亮显示“</p>
</li>
<li><p>在“BP_PickUpItemsBase”中定义蓝图接口中的三个函数</p>
</li>
<li><p>调用”设置渲染自定义深度“，并且在世界中放入”后期处理体积“来实现物体描边显示</p>
<ul>
<li><p>”后期处理体积“将无限范围为True</p>
</li>
<li><p>渲染功能的后期处理材质调用一个特定材质</p>
</li>
</ul>
</li>
</ol>
<h1 id="拾取系统"><a href="#拾取系统" class="headerlink" title="拾取系统"></a>拾取系统</h1><h2 id="知识点-1"><a href="#知识点-1" class="headerlink" title="知识点"></a>知识点</h2><h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>和C++里面的没区别</p>
<h3 id="固定在条目上重设"><a href="#固定在条目上重设" class="headerlink" title="固定在条目上重设"></a>固定在条目上重设</h3><p>状态机中状态的细节属性，勾选后可以使得每次播放动画都是从头开始播放（包括上一次动画如果被打断的话，下一次播放还是从头开始）</p>
<h3 id="设置骨骼网格体"><a href="#设置骨骼网格体" class="headerlink" title="设置骨骼网格体"></a>设置骨骼网格体</h3><p>在”目标“的位置生成”new mesh“传入的骨骼网格体</p>
<h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><ol>
<li><p>添加操作映射”拾取“，在角色蓝图中的”拾取系统“事件图表中调用</p>
</li>
<li><p>先判断角色状态是否为空白，或者是否瞄准（空白状态和瞄准状态均可拾取物品）</p>
</li>
<li><p>调用”拾取范围检测“节点，其返回值中的”Hit Actor“调用”拾取物品“</p>
</li>
<li><p>创建三个枚举”PickUpType“,”ClothType”,”WeaponType”来区分拾取到的物品类型，然后创建一个结构体，将其包含进去</p>
</li>
<li><p>结构体”Struct_PickUp“包含三个枚举之外，还包含骨骼网格体类型的”服饰模型“，Actor（类引用）类型的”拾取后生成的类“</p>
</li>
<li><p>将设置好的结构体作为变量添加到“BP_PickUpItemsBase”中</p>
</li>
<li><p>在角色蓝图的”拾取系统“事件图表中添加自定义事件”获取拾取信息并播放动画“,并且添加变量”拾取物品种类“，”武器种类“，”服饰种类“，”拾取后生成的类“，”服饰模型“</p>
</li>
<li><p>添加”获取拾取信息并播放动画“的输入”拾取物品信息“，类型为之前创建好的结构体</p>
</li>
<li><p>中断其命中结果，将五个引脚分别保存至刚创建的五个变量中</p>
</li>
<li><p>在“BP_PickUpItemsBase”中的事件图表实现和角色蓝图的通信，变量保存为”角色蓝图实例“</p>
</li>
<li><p>实现”拾取物品“事件：用角色蓝图实例调用”获取拾取信息并播放拾取动画“事件，传入PickUp变量，延迟0.4秒（播放完角色拾取动画）后销毁self</p>
</li>
<li><p>将角色功能状态枚举中新增一个”拾取物品“状态，在角色蓝图的”获取拾取信息并播放动画“事件中设置状态为”拾取物品“</p>
</li>
<li><p>在动画蓝图中添加新的变量”是否拾取“，在功能状态机中创建新的状态”拾取动画“，来去逻辑根据”是否拾取“决定</p>
</li>
<li><p>创建混合空间设置动画，水平坐标”站立蹲“，垂直坐标”持枪状态“</p>
</li>
<li><p>在”拾取动画“状态中调用混合空间，并且通过”每个骨骼的分层混合“节点进行混合</p>
</li>
<li><p>将”站立蹲“和”持枪状态“均提升为变量，然后在分别在动画蓝图的事件图表和角色蓝图类中的”装备武器“事件图表中设置</p>
</li>
<li><p>在角色蓝图中设置”是否拾取“为true，然后延迟0.4秒之后将其设置为false，并且将功能状态枚举修改为空白</p>
</li>
<li><p>在动画蓝图中的功能状态机中点击”拾取动画“，将其事件的”固定在条目上重设“</p>
</li>
<li><p>在角色蓝图类”拾取系统“中，延迟0.4秒之前用一个序列节点，同样延迟0.4秒，判断拾取物品种类-&gt;判断服饰种类&#x2F;判断武器种类</p>
</li>
<li><p>是背包的话，将角色模型中原本背包组件的位置作为目标，服饰模型作为参数”设置骨骼网格体“</p>
</li>
<li><p>在”BP_PickUp_BackBag”蓝图中设置变量”PickUp“，拾取种类设置为”服饰“，服饰模型设置为背包的模型</p>
</li>
<li><p>创建可以拾取的武器</p>
<ul>
<li><p>在角色蓝图的事件图表中将武器添加到角色身上的那一组逻辑剪切下来（角色一开始就没有武器在身上了）</p>
</li>
<li><p>创建一个新函数“生成主武器”，将之前剪切下来的粘贴进去</p>
</li>
<li><p>将从类生成actor的类传入之前定义的变量“拾取后生成的类”，将返回值转换为“BP_WeaponBase”，将武器实例的变量类型转换为“BP_WeaponBase”类型的</p>
</li>
<li><p>在拾取系统事件图表中调用“生成主武器”函数</p>
</li>
<li><p>以BP_PickUpItemsBase为父类生成子类“BP_PickUpAKM”，在其中设置其结构体的变量，特别是将拾取后生成的类修改为BP_Weapon_AKM</p>
</li>
</ul>
</li>
</ol>
<h1 id="主副武器切换"><a href="#主副武器切换" class="headerlink" title="主副武器切换"></a>主副武器切换</h1><h2 id="知识点-2"><a href="#知识点-2" class="headerlink" title="知识点"></a>知识点</h2><h3 id="Blend"><a href="#Blend" class="headerlink" title="Blend"></a>Blend</h3><p>在动画蓝图中使用，和switch遍历方式一样，需要右键节点手动添加引脚</p>
<p>可以根据遍历出的值的不同和输出不同的动画</p>
<h3 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h3><p>一个选择节点，将下标改为bool类型之后即可根据引入判断值返回true引脚或者false引脚</p>
<h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><ol>
<li><p>修改之前与武器相关的变量名称，并添加一些变量名称，分别代表主副武器的实例，装备插槽，未装备插槽</p>
</li>
<li><p>在角色的骨骼中的合适位置添加虚拟骨骼插槽，并于角色蓝图中的新建变量和旧有变量进行绑定</p>
</li>
<li><p>复制“生成主武器”函数，并将其修改为“生成副武器”函数（需要修改其中的实例和插槽）</p>
</li>
<li><p>在拾取系统中分别调用“生成主武器”和“生成副武器”</p>
<ul>
<li><p>主武器实例无效时生成主武器，有效时生成副武器</p>
</li>
<li><p>副武器实例无效时生成副武器，有效时提醒“武器已满”</p>
</li>
</ul>
</li>
<li><p>在装备了背包之后需要修改主武器和副武器在背上的位置</p>
<ul>
<li><p>将主副武器未装备插槽的名称修改为虚拟骨骼对应的名称</p>
</li>
<li><p>判断是否拥有主副武器，判断是否装备了主副武器</p>
</li>
<li><p>未装备则使用“附加Actor到组件”节点，将主副武器实例附加到网格体的对应插槽位置上</p>
</li>
</ul>
</li>
<li><p>修改原本的装备武器动画通知为Notif_EquipMainWeaponAnimation和创建新的动画通知Notif_EquipSecondaryWeaponAnimation，并且将装备副武器动画通知中的主武器实例替换成副武器，主武器插槽也替换成副武器插槽</p>
</li>
<li><p>将之前装备武器的动画通知复制一下，在其中将装备主武器动画通知替换为装备副武器动画通知</p>
</li>
<li><p>在动画蓝图中新建WeaponType类型的变量“武器种类”，根据这个变量的值来播放不同的动画</p>
</li>
<li><p>在动画蓝图中的功能状态机的装备武器状态中调用Blend节点遍历“武器种类”，使得装备主武器动画和装备副武器动画进行选择输出</p>
</li>
<li><p>添加新的操作映射“主武器切换”1和“副武器切换”2</p>
</li>
<li><p>在“装备武器”事件图表中“判断是否持枪”的false之后需要修改“武器种类”为主武器</p>
</li>
<li><p>装备武器动画播放方向之后需要设置“是否装备主武器”为false和true</p>
</li>
<li><p>新建变量“是否可以主切换副”，“是否可以副切换主”</p>
</li>
<li><p>将主武器切换蓝图逻辑复制一下，替换为副武器切换，注意其中需要将武器种类修改为副武器，是否装备主武器修改为是否装备副武器，按键映射也需要修改，最后两者的时间轴用同一个即可，以免冲突</p>
</li>
<li><p>另外，在装备主武器之前还需要判断是否装备了副武器，如果未装备副武器，则可以直接装备主武器，如果已经装备了副武器，则需要将副武器收起来，然后再装备主武器</p>
<ul>
<li><p>创建一个自定义事件“收起副武器”链接到装备副武器的逻辑节点前</p>
</li>
<li><p>在主武器逻辑中“是否装备副武器”为true时调用“收起副武器”</p>
</li>
<li><p>于此同时需要创建一个自定义事件“副武器切换主武器”链接到主武器“是否持枪”之前</p>
</li>
<li><p>最后在副武器装备的蓝图逻辑中判断“是否可以副切换主”，为true时调用“副武器切换主武器”，并且延迟0.1秒之后将“是否可以副切换主”设置为false</p>
</li>
</ul>
</li>
<li><p>主武器切换为副武器同理创建“收起主武器”，“主武器切换副武器”事件即可</p>
</li>
<li><p>再切换主武器和副武器开头，还需要判断是否拥有主副武器，也就是判断主武器&#x2F;副武器实例是否有效，只有再拥有了武器的状态下才能切换武器</p>
</li>
<li><p>还需要做一个替换，在射击的时候，之前的蓝图节点中都写得是主武器的实例，如果不加上副武器，那么射击的时候，背在背上的主武器射击，手上的副武器就不动了</p>
<ul>
<li><p>在射击事件中，开始射击之前使用“选择”节点，将index修改为bool，以“是否装备主武器”为判断依据，分别返回主武器实例和副武器实例</p>
</li>
<li><p>根据查找引用，同样替换其他逻辑代码（射击，换弹，全自动半自动切换）</p>
</li>
</ul>
</li>
<li><p>新建枪械Scar的模型，子弹，弹匣，可拾取蓝图（复制AKM的之后修改细节，注意的是可拾取蓝图中生成的类需要替换成Scar的蓝图类）</p>
</li>
<li><p>将三个换弹的动画通知里面的主武器实例同上修改为以选择节点来判断的逻辑</p>
</li>
</ol>
<h1 id="拾取多把武器替换功能"><a href="#拾取多把武器替换功能" class="headerlink" title="拾取多把武器替换功能"></a>拾取多把武器替换功能</h1><p>拾取第三把武器的时候将主武器丢弃，将新的武器安置在主武器的位置</p>
<p>但是当手持主武器的时候，就替换副武器</p>
<p>最后将替换下来的武器生成在脚下</p>
<h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><ol>
<li><p>在拾取系统事件图表中创建自定义事件“替换武器”，在原本的“武器已满”位置调用“替换武器”事件图表</p>
</li>
<li><p>创建一个新函数“生成可拾取武器到地上”</p>
<ul>
<li><p>“由通道检测线条”，起始位置是actor位置，终点位置是actor往下500cm</p>
</li>
<li><p>用一个分支节点判断是否命中，中断检测结果，将其中的位置信息传入“由类生成actor”中</p>
</li>
<li><p>在武器父类中创建Actor类引用的变量“替换现有武器到地上”</p>
</li>
<li><p>在武器子类中分别设置“替换现有武器到地上”为对应武器的可拾取蓝图</p>
</li>
<li><p>以“是否装备副武器为判断依据”true输出主武器实例，false输出副武器实例，链接“替换现有武器到地上”，最后作为从类生成actor的类</p>
</li>
<li><p>在武器父类中创建新的事件图表“自己销毁”，创建新的自定义事件“自毁”，销毁武器，并且销毁弹匣</p>
</li>
<li><p>在角色蓝图的生成可拾取武器到地上函数中的选择输出的武器实例调用“自毁”事件</p>
</li>
<li><p>最后通过输出的武器实例来判断是主武器实例还是副武器实例，如果是主武器实例，则调用“生成主武器”；否则“生成副武器”</p>
</li>
</ul>
</li>
<li><p>在“替换武器”事件中调用“生成可拾取武器在地上”</p>
</li>
</ol>
<h1 id="角色拾取服装系统"><a href="#角色拾取服装系统" class="headerlink" title="角色拾取服装系统"></a>角色拾取服装系统</h1><h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><ol>
<li><p>在拾取系统内，判断服饰种类之后，添加背包之前，需要判断一下当前身上有没有背包</p>
<ul>
<li>将背包组件拖入，引出get skeletal mesh（获取骨骼网格体）判断是否为空（&#x3D;&#x3D;），如果为空，则可以直接生成背包，否则需要执行替换背包逻辑</li>
</ul>
</li>
<li><p>创建一个Actor类引用类型的变量“生成可拾取的背包”，在上一节点为true时，set“生成可拾取的背包”，并将拾取物品信息中断，将拾取后生成的类引入</p>
</li>
<li><p>创建函数“生成可拾取服饰到地上”逻辑思路类似“生成可拾取武器到地上”，其中删除自毁逻辑和生成主副武器逻辑，将“从类生成actor”的class为函数的形式参数</p>
</li>
<li><p>在拾取系统中调用“生成可拾取服饰到地上”</p>
<ul>
<li><p>传入的参数为”生成可拾取的背包“，也就是之前旧的背包</p>
</li>
<li><p>下一个节点为”设置生成可拾取的背包“</p>
</li>
<li><p>也就是每次拾取到新背包之后，将旧背包生成到地上，在这之后，需要将现在背上的背包传入”生成可拾取的背包“变量里面</p>
</li>
</ul>
</li>
<li><p>在”BP_PickUp_Bag“里面的结构体中设置拾取后生成的类</p>
</li>
<li><p>创建一个透明的材质球，打开一个角色网格体将角色衣服之外的材质均替换为透明材质球，重命名为Cloth1</p>
</li>
<li><p>根据可拾取物品创建一个子类”BP_PickUpCloth1”设置其模型和类默认值中的”拾取后生成的类“等属性</p>
</li>
<li><p>在角色蓝图中新增骨骼网格体组件”衣服“，在其构造函数中将其传入到”设置总姿势组件“节点的“目标”引脚</p>
</li>
<li><p>在角色拾取系统中先判断角色是否穿衣服（和背包那边相同），然后设置角色网格体的材质（衣服材质）为透明【让这个角色看起来没有穿衣服】，后面的逻辑就和之前的背包逻辑一模一样了</p>
</li>
</ol>
<h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><h2 id="切换全自动与半自动"><a href="#切换全自动与半自动" class="headerlink" title="切换全自动与半自动"></a>切换全自动与半自动</h2><p>在切换之前要判断是否装备武器，先判断主武器，再判断副武器，任意有一把就能切换，否则打印字符串“未装备武器，不能切换”</p>
<h2 id="拾取系统中创建的变量"><a href="#拾取系统中创建的变量" class="headerlink" title="拾取系统中创建的变量"></a>拾取系统中创建的变量</h2><p>将之前创建了很多的变量全部用结构体代替</p>
<p>将该事件的输入值“拾取物品信息”创建为一个变量，输入值传入变量中，在后面需要结构体中的变量的时候就将其调用</p>
<h2 id="装备武器系统"><a href="#装备武器系统" class="headerlink" title="装备武器系统"></a>装备武器系统</h2><p>可以将相同的逻辑节点写到一个宏当中，根据情况的不同传入不同的参数即可</p>
<h1 id="BUG小结"><a href="#BUG小结" class="headerlink" title="BUG小结"></a>BUG小结</h1><ol>
<li>报错出现“无访问”的提示的时候就是引入的目标为空置，也就是没有赋值！此时就需要去检查一下引入的变量的赋值情况</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/14/UE4-%E9%A1%B9%E7%9B%AE-%E6%AD%BB%E5%AF%82-%E8%A7%92%E8%89%B2%E6%AD%A6%E5%99%A8%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%8C%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="williny">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Williny'home">
      <meta itemprop="description" content="孤独是人生的常态">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Williny'home">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/06/14/UE4-%E9%A1%B9%E7%9B%AE-%E6%AD%BB%E5%AF%82-%E8%A7%92%E8%89%B2%E6%AD%A6%E5%99%A8%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%8C%EF%BC%89/" class="post-title-link" itemprop="url">UE4-项目-死寂-角色武器系统（二）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-06-14 16:20:40" itemprop="dateCreated datePublished" datetime="2022-06-14T16:20:40+08:00">2022-06-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-06-18 11:41:04" itemprop="dateModified" datetime="2022-06-18T11:41:04+08:00">2022-06-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/unreal-engine/" itemprop="url" rel="index"><span itemprop="name">unreal engine</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="子弹击中设置，击中特效"><a href="#子弹击中设置，击中特效" class="headerlink" title="子弹击中设置，击中特效"></a>子弹击中设置，击中特效</h1><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><h3 id="发射物移动组件"><a href="#发射物移动组件" class="headerlink" title="发射物移动组件"></a>发射物移动组件</h3><p>此组件可给物体添加抛射线计算，使其有初始速度和弹道</p>
<h3 id="事件命中"><a href="#事件命中" class="headerlink" title="事件命中"></a>事件命中</h3><p>当蓝图实例产生了碰撞之后，就会产生信息，此节点可将信息输出</p>
<h3 id="贴花"><a href="#贴花" class="headerlink" title="贴花"></a>贴花</h3><p>在某位置产生贴花的时候，就可以覆盖原本位置的材质和图案（弹孔效果）</p>
<p>当贴花材质完全垂直于原物体的表面的时候，才可以完整的显示出来（没有拉伸）</p>
<h3 id="在位置处生成贴画"><a href="#在位置处生成贴画" class="headerlink" title="在位置处生成贴画"></a>在位置处生成贴画</h3><p>字面意思</p>
<h3 id="物理材质"><a href="#物理材质" class="headerlink" title="物理材质"></a>物理材质</h3><p>通过物理材质可以实现任务走在不同材质的地面上产生不同的声音</p>
<p>可以理解为一个标签，用来区分角色走在的材质表面具体是哪一种材质</p>
<h3 id="物理表面类型"><a href="#物理表面类型" class="headerlink" title="物理表面类型"></a>物理表面类型</h3><p>辅助物理材质来使用，有了类型才能区分物理材质</p>
<p>在项目设置-&gt;物理-&gt;物理表面即可新建和编辑</p>
<h3 id="命中结果"><a href="#命中结果" class="headerlink" title="命中结果"></a>命中结果</h3><p>这是一个数据类型，代表的就是字面意思</p>
<h3 id="中断命中结果"><a href="#中断命中结果" class="headerlink" title="中断命中结果"></a>中断命中结果</h3><p>这是一个节点，可以获取“命中结果”类型数据的信息（法线，位置，时间等等）</p>
<h3 id="由通道检测球体"><a href="#由通道检测球体" class="headerlink" title="由通道检测球体"></a>由通道检测球体</h3><p>此节点和球形碰撞检测的“碰撞预设”中的“检测相应”相关。</p>
<p>要想运用此节点，就需要创建新的碰撞检测通道，如果想要被检测到，就在节点设置中调用对应通道，并在球形碰撞检测的详情面板中调整为“阻挡”</p>
<h3 id="获取表面类型"><a href="#获取表面类型" class="headerlink" title="获取表面类型"></a>获取表面类型</h3><p>是“由通道检测球体”的输出节点，由“Out Hit”引脚引出</p>
<p>获取碰撞到的物体的表面材质，属性，类别等信息</p>
<h3 id="物理材质-1"><a href="#物理材质-1" class="headerlink" title="物理材质"></a>物理材质</h3><p>新建-&gt;物理-&gt;物理材质</p>
<p>可在其中修改物理属性-&gt;表面类型</p>
<h3 id="在位置处生成发射器"><a href="#在位置处生成发射器" class="headerlink" title="在位置处生成发射器"></a>在位置处生成发射器</h3><p>在位置处生成一些粒子特效</p>
<h3 id="为模拟物理现象"><a href="#为模拟物理现象" class="headerlink" title="为模拟物理现象"></a>为模拟物理现象</h3><p>由“事件命中”节点引出，用来判断被击中的物体是否开启模拟物理选项</p>
<h3 id="添加冲量"><a href="#添加冲量" class="headerlink" title="添加冲量"></a>添加冲量</h3><p>由“事件命中”节点引出，给被击中的物体添加一个冲量，输入为一个向量“速度”</p>
<h3 id="播放位置处的音效"><a href="#播放位置处的音效" class="headerlink" title="播放位置处的音效"></a>播放位置处的音效</h3><p>字面意思</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol>
<li><p>要先创建一个子弹父类蓝图</p>
<ul>
<li><p>添加一个球形碰撞检测</p>
</li>
<li><p>添加一个“发射物移动组件”，并设置其速度属性</p>
</li>
</ul>
</li>
<li><p>给子弹新增一个碰撞通道，默认响应设置为Block</p>
</li>
<li><p>回到子弹父类蓝图中，设置碰撞预设</p>
</li>
<li><p>编辑子弹击中物体时的蓝图逻辑</p>
<ul>
<li>用“事件命中”和“在位置处生成贴花”生成弹孔效果</li>
</ul>
</li>
<li><p>添加击中物体特效</p>
<ul>
<li>创建一个函数“击中物体特效”</li>
<li>用“中断命中结果”，“由通道检测球体”，“获取表面类型”来编写逻辑</li>
<li>最后用Switch来遍历获取到的表面类型，并“在位置处生成发射器”来生成例子特效</li>
</ul>
</li>
<li><p>在事件图表中调用“击中物体特效”函数</p>
</li>
<li><p>还需要判断被子弹击中的物体是否有“模拟物理”的效果，如果有，就要给它们添加一个冲量</p>
<ul>
<li><p>在事件图表中的“事件命中”节点的“Other Comp”引脚引出“is Valid”判断是否击中其他组件（模型）</p>
</li>
<li><p>接着引出“为模拟物理现象”和“为模拟物理现象”来判断击中的目标是否模拟物理</p>
</li>
<li><p>用“添加冲量”为被击中的物体添加冲量</p>
</li>
<li><p>最后销毁子弹Actor</p>
</li>
</ul>
</li>
<li><p>添加子弹击中物体的音效</p>
<ul>
<li>“事件开始运行”节点引出“播放位置处的音效”，将音效提升为变量“武器音效”，并“获取Actor位置”</li>
</ul>
</li>
<li><p>现在已经把通用父类的逻辑编辑好，如今根据父类创建一个蓝图子类“BP_AKM_Bullet”</p>
<ul>
<li><p>在眼睛图标那边点击显示继承的变量</p>
</li>
<li><p>设置“武器音效”</p>
</li>
</ul>
</li>
</ol>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol>
<li><p>添加球形碰撞检测之后需要使其覆盖最上层的组件</p>
</li>
<li><p>如果要给子弹添加网格体，那就需要将子弹的碰撞预设改成NoCollision（因为碰撞是由球形碰撞盒子进行检测的）</p>
</li>
<li><p>碰撞预设设置为自定义的，并且碰撞启用“检测和物理”，并且碰撞相应得设置为阻挡（除了Pawn）</p>
</li>
<li><p>“由通道检测球体”节点需要创建碰撞检测通道，并绑定</p>
</li>
<li><p>销毁子弹的时候使用“序列”节点，并且放在“在位置处生成贴花”后面</p>
</li>
</ol>
<h1 id="发射子弹"><a href="#发射子弹" class="headerlink" title="发射子弹"></a>发射子弹</h1><h2 id="知识点-1"><a href="#知识点-1" class="headerlink" title="知识点"></a>知识点</h2><h3 id="获取插槽变换"><a href="#获取插槽变换" class="headerlink" title="获取插槽变换"></a>获取插槽变换</h3><p>由一个拥有骨骼的组件（静态网格体组件）引出，即可获得虚拟插槽的位置信息</p>
<h3 id="箭头组件"><a href="#箭头组件" class="headerlink" title="箭头组件"></a>箭头组件</h3><p>一个游戏中看不见的箭头，可根据箭头位置生成抛壳特效</p>
<h3 id="以事件设置定时器"><a href="#以事件设置定时器" class="headerlink" title="以事件设置定时器"></a>以事件设置定时器</h3><p>和之前的以函数名设置定时器差不多，是倒计时结束之后就开始执行引入的事件</p>
<h3 id="以句柄清除定时器并使之无效"><a href="#以句柄清除定时器并使之无效" class="headerlink" title="以句柄清除定时器并使之无效"></a>以句柄清除定时器并使之无效</h3><p>就是清除定时器的意思，但是注意的是，引入引脚需要是“要清除定时器”的返回值</p>
<h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><ol>
<li><p>在武器基类蓝图中添加三个自定义事件“射击中”，“开始射击”，“停止射击”</p>
</li>
<li><p>射击中状态，是不断有子弹从枪口位置生成的</p>
<ul>
<li><p>生成子弹由“从类生成Actor”解决</p>
</li>
<li><p>生成位置，首先在枪口处创建一个虚拟骨骼，然后由“获取插槽变换”来获取其位置</p>
</li>
</ul>
</li>
<li><p>射击状态，会有抛弹壳的特效</p>
<ul>
<li><p>使用节点“在位置处生成发射器”来实现抛壳特效</p>
</li>
<li><p>创建一个箭头组件，特效生成位置根据此箭头组件位置调整</p>
</li>
</ul>
</li>
<li><p>另外还有枪口的火焰特效</p>
<ul>
<li><p>用“在位置处生成发射器”生成粒子特效</p>
</li>
<li><p>用枪口的虚拟骨骼位置确定生成位置</p>
</li>
</ul>
</li>
<li><p>最后需要设置开枪时候武器的动画（枪栓的移动）</p>
<ul>
<li><p>创建一个“动画序列”类型的变量“武器动画”</p>
</li>
<li><p>用“播放动画”节点选择目标和要播放的动画</p>
</li>
</ul>
</li>
<li><p>接下来是实现“开始射击”</p>
<ul>
<li><p>通过“以事件设置定时器”来调用“射击中”事件</p>
</li>
<li><p>将延迟时间，也就是“Time”引脚提升为变量，命名为“射速”</p>
</li>
<li><p>在执行定时器之前还需要先调用一次“射击中”事件，否则开第一枪会有“射速”的延迟</p>
</li>
<li><p>最后给定时器勾选“Looping”</p>
</li>
</ul>
</li>
<li><p>停止射击</p>
<ul>
<li>在“开始射击”的“以事件设置定时器”的返回值引出“以句柄清除定时器并使之无效”节点，即可停止射击</li>
</ul>
</li>
<li><p>在武器子类中设置在父类中创建的变量</p>
</li>
<li><p>在角色蓝图类的“射击”事件图表中调用“武器实例”的“开始射击”和“停止射击”节点</p>
</li>
</ol>
<h1 id="弹壳落地音效"><a href="#弹壳落地音效" class="headerlink" title="弹壳落地音效"></a>弹壳落地音效</h1><h2 id="知识点-2"><a href="#知识点-2" class="headerlink" title="知识点"></a>知识点</h2><h3 id="音效Cue"><a href="#音效Cue" class="headerlink" title="音效Cue"></a>音效Cue</h3><p>专门针对音效的一种蓝图</p>
<h3 id="随机"><a href="#随机" class="headerlink" title="随机"></a>随机</h3><p>音效Cue中的一个节点，随机播放输入的音效</p>
<h3 id="调制器"><a href="#调制器" class="headerlink" title="调制器"></a>调制器</h3><p>音效Cue中的一个节点，可以在一定范围内随机音量和音高</p>
<h3 id="衰减"><a href="#衰减" class="headerlink" title="衰减"></a>衰减</h3><p>音效Cue中的属性设置，可以使得声音拥有距离感和方向感</p>
<h3 id="分配On-Particle-Collide"><a href="#分配On-Particle-Collide" class="headerlink" title="分配On Particle Collide"></a>分配On Particle Collide</h3><p>当例子特效碰到其他物体的时候，就会触发此事件</p>
<h3 id="Do-N"><a href="#Do-N" class="headerlink" title="Do N"></a>Do N</h3><p>此节点设置某事件可执行N次</p>
<h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><ol>
<li><p>设置音效本身，根据音效创建Cue，然后使得同种类型的三个音效随机播放（为了显得真实，不那么单调）</p>
</li>
<li><p>在武器基类中调用音效</p>
<ul>
<li><p>在实现抛壳特效后面使用分支节点，链接“分配On Particle Collide”</p>
</li>
<li><p>用“Do N”节点，在执行第三次的时候播放结束音效，“延迟”0.5秒之后再重置“Do N”节点</p>
</li>
</ul>
</li>
</ol>
<h1 id="角色装备武器音效"><a href="#角色装备武器音效" class="headerlink" title="角色装备武器音效"></a>角色装备武器音效</h1><h2 id="知识点-3"><a href="#知识点-3" class="headerlink" title="知识点"></a>知识点</h2><h3 id="播放音效2D"><a href="#播放音效2D" class="headerlink" title="播放音效2D"></a>播放音效2D</h3><p>播放一个没有空间感，距离感的音效（就很平面）</p>
<h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><ol>
<li><p>在角色蓝图中“瞄准状态切换”事件图表中添加“播放音效2D”来设置音效</p>
</li>
<li><p>需要修改之前的瞄准和射击事件中的切换状态，以免多次播放音效</p>
<ul>
<li><p>在松开瞄准和松开射击的引脚后都需要判断角色是否持枪</p>
</li>
<li><p>在瞄准更改弹簧臂长度之前需要判断角色是否瞄准</p>
</li>
</ul>
</li>
</ol>
<h1 id="角色跳跃音效"><a href="#角色跳跃音效" class="headerlink" title="角色跳跃音效"></a>角色跳跃音效</h1><h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><ol>
<li>在角色蓝图“跳跃的动画和高度设置”函数内，蒙太奇播放节点前添加“播放音效2D”</li>
</ol>
<h1 id="武器全自动和半自动切换"><a href="#武器全自动和半自动切换" class="headerlink" title="武器全自动和半自动切换"></a>武器全自动和半自动切换</h1><h2 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h2><ol>
<li><p>添加一个按键映射“切换全自动”，按键设置为B</p>
</li>
<li><p>在武器基类蓝图中新建变量“是否全自动”，并在定时器之前判断</p>
</li>
<li><p>在角色蓝图中创建新图表“全自动和半自动切换”</p>
<ul>
<li>修改武器蓝图中的“是否全自动”值</li>
</ul>
</li>
<li><p>在角色射击时切换全自动或半自动需要停止射击</p>
<ul>
<li><p>在射击事件图表中，停止松开鼠标停止射击那一串逻辑，在之前添加一个自定义事件“停止射击”，将其包含进去</p>
</li>
<li><p>在切换全自动&#x2F;半自动状态后面调用“停止射击”事件</p>
</li>
</ul>
</li>
<li><p>全自动和半自动之间的切换取决于角色的操作，但是全自动于半自动之间的表现取决于枪支的动画表现，所以在此我们需要将角色蓝图中设置的全自动于半自动切换引到武器蓝图当中去</p>
<ul>
<li><p>在武器基类中实现和角色蓝图之间的通信（获取类所有Actor）</p>
</li>
<li><p>在武器蓝图“射击”图表中“停止射击”后判断了“是否全自动”，true连接了循环播放动画</p>
</li>
<li><p>那么false链接上角色蓝图中的“停止射击”事件</p>
</li>
<li><p>与此同时，如果直接“停止射击”，则不会播放射击时的角色动画（后坐力动画），所以需要延迟0.1秒之后再“停止射击”</p>
</li>
</ul>
</li>
</ol>
<h1 id="武器后坐力（枪口向上偏移）"><a href="#武器后坐力（枪口向上偏移）" class="headerlink" title="武器后坐力（枪口向上偏移）"></a>武器后坐力（枪口向上偏移）</h1><h2 id="知识点-4"><a href="#知识点-4" class="headerlink" title="知识点"></a>知识点</h2><h3 id="范围内随机浮点"><a href="#范围内随机浮点" class="headerlink" title="范围内随机浮点"></a>范围内随机浮点</h3><p>就是在一定范围内随机取浮点数</p>
<h2 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h2><ol>
<li><p>实现后坐力的效果就是使得玩家的控制器不受玩家控制得向上偏移，有两个需要注意的点</p>
<ul>
<li><p>获得玩家控制器，也就是“获取玩家Pawn”</p>
</li>
<li><p>控制器向上偏移，也就是之前用于控制玩家视口转向的节点“添加控制器Pitch输入”</p>
</li>
<li><p>那么再武器基类蓝图中新建一个事件图表“武器后坐力”，然后新建一个自定义事件，通过“获取玩家Pawn”节点调用“添加控制器Pitch输入”</p>
</li>
<li><p>然后需要将“添加控制器Pitch输入”的val设置为<mark>-0.4</mark>（后面会提升为变量使用）</p>
</li>
</ul>
</li>
<li><p>创建好后坐力之后需要在“射击”图表中调用“后坐力事件”</p>
</li>
<li><p>接下来是动画效果的优化，如果不进行这一步的话，动画效果感觉一抽一抽的</p>
<ul>
<li><p>用时间轴来解决这个问题</p>
</li>
<li><p>添加一个自定义事件“后坐力回弹”</p>
</li>
<li><p>添加一个时间轴</p>
</li>
<li><p>两个自定义事件分别链接上“play from start”和”Reverse”</p>
</li>
<li><p>在finish引脚处调用“后坐力回弹”</p>
</li>
<li><p>创建时间轴轨道，三个关键帧分别为(0,0)，(0.02,1)，(0.1,0)</p>
</li>
<li><p>新建浮点型变量”后坐力pitch”和“后坐力Yaw”</p>
</li>
<li><p>时间轴轨道引出”插值”节点，连接上“Alpha”引脚，“后坐力Picth”连接上B引脚</p>
</li>
<li><p>返回值乘以-1后链接上“添加控制器Pitch”的val引脚</p>
</li>
<li><p>时间轴的Direction引脚引出“switch”节点，快进引脚链接上未乘以-1的“添加玩家控制器pitch”，快退链接上另一个</p>
</li>
<li><p>除了向上后坐力，还有左右偏移</p>
</li>
<li><p>在末尾连上“添加控制器Yaw输入”，val引脚链接“Yaw”乘以-1之后“范围内随机浮点”的值</p>
</li>
</ul>
</li>
<li><p>在父类中添加了“后坐力Pitch”和“后坐力Yaw”，还需要再子类中设置其具体的值</p>
</li>
</ol>
<h1 id="角色换弹动画及音效"><a href="#角色换弹动画及音效" class="headerlink" title="角色换弹动画及音效"></a>角色换弹动画及音效</h1><h2 id="知识点-5"><a href="#知识点-5" class="headerlink" title="知识点"></a>知识点</h2><h3 id="Do-Once"><a href="#Do-Once" class="headerlink" title="Do Once"></a>Do Once</h3><p>和Do N差不多，字面意思啦！</p>
<h3 id="旋转浮点"><a href="#旋转浮点" class="headerlink" title="旋转浮点"></a>旋转浮点</h3><p>根据bool值来进行输出</p>
<p>若true则输出A引脚的值</p>
<p>若false则输出B引脚的值</p>
<h2 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h2><ol>
<li><p>创建三个整数型变量“子弹数量”，“弹夹数量”，“子弹总数量”</p>
</li>
<li><p>在子弹消耗完之后就不可以继续开枪，所以在武器蓝图中的“射击”图表中，“射击中”的开端需要判断子弹数量是否为0，如果为0，则停止播放音效，也停止角色射击动画；如果不为零，则继续射击</p>
<ul>
<li><p>需要使用到“Do Once”和“序列”节点进行配合</p>
</li>
<li><p>“Do Once”用来执行一次“子弹耗尽音效”和“停止射击”</p>
</li>
<li><p>“序列”用来在换弹之后去Reset“Do Once”节点</p>
</li>
</ul>
</li>
<li><p>换弹操作是由角色控制的，所以在操作映射中添加一个换弹操作“R”，然后再角色蓝图中新增一个事件图表“换弹”</p>
<ul>
<li><p>判断角色是否持枪，是否在执行其他状态（判断方法同角色射击蓝图）</p>
</li>
<li><p>判断子弹数量是否大于子弹总数量（弹夹内子弹数量），false则可以换弹</p>
</li>
<li><p>判断弹夹数量是否小于等于0，false则可以换弹</p>
</li>
<li><p>还需要更改枚举值的功能状态（枚举中新增一个功能状态“换弹”）</p>
</li>
<li><p>换弹时需要停止射击</p>
</li>
</ul>
</li>
<li><p>设置换弹动画</p>
<ul>
<li><p>找到换弹动画序列，将其取消根节点运动，提升为蒙太奇动画，设置好插槽“换弹”</p>
</li>
<li><p>在动画蓝图中“功能状态机”里添加新的状态“换弹”，添加变量“是否换弹”用于切换状态</p>
</li>
<li><p>在“换弹”状态中调用“换弹”插槽，和“总状态缓存”，以“每个骨骼的分层混合”来进行半身混合设置</p>
</li>
</ul>
</li>
<li><p>调用换弹动画</p>
<ul>
<li><p>在角色蓝图的“换弹”，停止射击之后切换“是否换弹”，然后调用蒙太奇播放来播放蒙太奇动画</p>
</li>
<li><p>延迟之后将“是否换弹”切换回来，再设置状态为空白</p>
</li>
</ul>
</li>
<li><p>在AKM中设置“子弹数量”，“子弹总数量”，“弹夹数量”</p>
</li>
<li><p>在武器基类蓝图中添加“子弹减少”的功能</p>
<ul>
<li>在武器基类蓝图的最末尾，子弹数量“–”</li>
</ul>
</li>
<li><p>子弹射击完之后需要有一个子弹耗尽的音效</p>
<ul>
<li><p>在角色蓝图类中判断了是否持枪以及自身枚举状态之后，判断子弹数量是否为零</p>
</li>
<li><p>若不为零，则继续正常射击</p>
</li>
<li><p>若为零，则播放子弹耗尽音效</p>
</li>
</ul>
</li>
<li><p>换弹状态不能被射击的“停止瞄准”事件的定时器将状态切换为空白</p>
<ul>
<li><p>所以将其“停止射击”事件修改一下</p>
</li>
<li><p>如果“是否换弹”为false，才可以将状态修改为空白</p>
</li>
<li><p>同样，瞄准状态也是一样的处理方式</p>
</li>
</ul>
</li>
<li><p>换弹的时候角色速度应该没那么快，所以需要在“角色速度判断”函数中修改</p>
<ul>
<li>使用以“是否换弹”为判断条件的“旋转浮点”</li>
</ul>
</li>
</ol>
<h1 id="弹夹附加到手上及丢弃"><a href="#弹夹附加到手上及丢弃" class="headerlink" title="弹夹附加到手上及丢弃"></a>弹夹附加到手上及丢弃</h1><h2 id="知识点-6"><a href="#知识点-6" class="headerlink" title="知识点"></a>知识点</h2><h3 id="动画通知"><a href="#动画通知" class="headerlink" title="动画通知"></a>动画通知</h3><p>之前在拔枪那一节中运用过</p>
<p>动画通知&#x3D;函数</p>
<p>动画的某一帧调用函数</p>
<h3 id="从Actor分离"><a href="#从Actor分离" class="headerlink" title="从Actor分离"></a>从Actor分离</h3><p>字面意思啦！</p>
<h2 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h2><ol>
<li><p>三个动画通知</p>
<ul>
<li><p>把弹夹从枪械上拔下来（弹夹从跟随枪械运动变为跟随手运动，延迟之后松开弹夹使其掉落到地上）</p>
</li>
<li><p>生成一个新的弹夹拿出来（生成新弹夹，附加到手部并跟随运动）</p>
</li>
<li><p>把弹夹插到枪械上（弹夹运动到靠近枪械位置之后，附加到枪械上）</p>
</li>
</ul>
</li>
<li><p>创建动画通知，并添加到动画中</p>
<ul>
<li><p>创建弹夹掉落，换弹结束，生成弹夹三个通知</p>
</li>
<li><p>在动画序列中新建一个通知轨道，将三个通知放入合适的位置</p>
</li>
</ul>
</li>
<li><p>创建弹匣基类</p>
<ul>
<li><p>创建一个Actor蓝图类取名为“BP_MagazineBase”作为弹匣基类</p>
<ul>
<li><p>添加静态网格体组件</p>
</li>
<li><p>设置碰撞预设为自定义，碰撞启用设置为查询和物理，对象类型设置为物理类型（忽略pawn的碰撞响应，不然会卡碰撞）</p>
</li>
</ul>
</li>
<li><p>在武器基类蓝图中的“事件图表”中使用“序列”节点的第二个引脚</p>
<ul>
<li><p>从类生成Actor，将类提升为变量“弹匣”，返回值提升为变量“弹匣引用”</p>
</li>
<li><p>“创建变换”节点引入位置信息</p>
</li>
</ul>
</li>
<li><p>“附加Actor到组件”节点将弹匣引用附加到武器模型上</p>
</li>
</ul>
</li>
<li><p>在子类中设置具体需要附加到的弹匣是哪一个</p>
<ul>
<li>以“BP_MagazineBase”为父类创建子类“BP_AKM_Magazine”，设置具体模型</li>
</ul>
</li>
<li><p>弹匣分离</p>
<ul>
<li><p>在弹匣父类中创建自定义事件“弹匣分离”</p>
</li>
<li><p>使用“从Actor分离”节点，“模拟物理”节点，”延迟“节点，“销毁”节点</p>
</li>
</ul>
</li>
<li><p>调用弹匣分离</p>
<ul>
<li><p>在武器基类蓝图中创建新图表“换弹”</p>
</li>
<li><p>添加三个自定义事件“拔下弹匣”，“生成新弹匣”，“换弹结束”</p>
</li>
<li><p>”拔下弹匣“事件将”弹匣引用“从角色蓝图的网格体上“附加Actor到组件”（将弹匣附加到角色的手上）</p>
</li>
<li><p>编辑“附加Actor到组件”节点，在角色骨骼的手上创建插槽，编辑好插槽位置之后将其名称填写到节点的Socket Name引脚上</p>
</li>
<li><p>延迟0.1秒之后将“弹匣引用”转换为“BP_MagazineBase”，调用“弹匣分离”</p>
</li>
<li><p>最后在动画通知“Notif_ClipDroppedAnimation”中调用角色蓝图中的“武器实例”，再调用“弹匣分离”</p>
</li>
</ul>
</li>
<li><p>生成新弹匣</p>
<ul>
<li><p>从弹匣类生成Actor，然后将其附加到组件</p>
</li>
<li><p>需要将弹匣数量–</p>
</li>
<li><p>最后在动画通知中调用</p>
</li>
</ul>
</li>
<li><p>换弹结束</p>
<ul>
<li><p>将弹匣引用附加到武器实例上，还需要将子弹数量设置为子弹总数量（一个弹匣中的子弹数量）</p>
</li>
<li><p>在动画通知中调用</p>
</li>
</ul>
</li>
</ol>
<h1 id="角色脚步声音效"><a href="#角色脚步声音效" class="headerlink" title="角色脚步声音效"></a>角色脚步声音效</h1><h2 id="知识点-7"><a href="#知识点-7" class="headerlink" title="知识点"></a>知识点</h2><h3 id="由通道检测线条"><a href="#由通道检测线条" class="headerlink" title="由通道检测线条"></a>由通道检测线条</h3><p>将沿给定线条执行碰撞追踪，并返回所有遭遇的命中，直到并包含首次阻挡命中，只返回对特定追踪通道响应的对象。</p>
<p>这就意味着追踪的开始和结束之间有多个带碰撞的Actor 或 组件 与特定的追踪通道发生重叠，而您将接收到所有的 Actor 和组件。</p>
<p>但是，如果首次命中阻挡了特定的追踪通道，则只会接收到这一个内容。</p>
<p>如希望无视追踪通道的重叠或阻挡接受所有内容，则需要使用MultiLineTraceByObject 节点</p>
<h2 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h2><ol>
<li><p>用Cue制作各自类型的脚步声</p>
</li>
<li><p>给角色网格体添加两个箭头组件，分别为“左脚”，“右脚”，并附加到相应骨骼位置</p>
</li>
<li><p>创建一个函数“脚步声判断”</p>
<ul>
<li><p>添加场景组件类型的输入“哪只脚”，获取其“场景位置”</p>
</li>
<li><p>根据“由通道检测线条”节点，起始点为箭头位置，终点为箭头向下50cm（向量-向量）位置</p>
</li>
<li><p>判断是否由返回值，若有，则“获取表面类型”，switch，再“中断命中结果”获取位置信息</p>
</li>
<li><p>根据位置信息播放不同的音效“播放位置处的音效”</p>
</li>
</ul>
</li>
<li><p>调用“脚步声判断”函数</p>
<ul>
<li><p>新建事件图表“脚步声”</p>
</li>
<li><p>新建自定义事件“左脚步声”，“右脚步声”，分别调用函数，参数分别传入“左脚”以及“右脚”</p>
</li>
</ul>
</li>
<li><p>创建动画通知调用“脚步声”事件</p>
<ul>
<li><p>创建左脚，右脚脚步声动画通知</p>
</li>
<li><p>”获取拥有者“，转换为BP_Player，分别调用“左脚步声”，“右脚步声”</p>
</li>
</ul>
</li>
<li><p>最后将动画通知添加到所有和脚步声有关的动画中去</p>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/09/UE4-%E9%A1%B9%E7%9B%AE-%E6%AD%BB%E5%AF%82-%E8%A7%92%E8%89%B2%E6%AD%A6%E5%99%A8%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%80%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="williny">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Williny'home">
      <meta itemprop="description" content="孤独是人生的常态">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Williny'home">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/06/09/UE4-%E9%A1%B9%E7%9B%AE-%E6%AD%BB%E5%AF%82-%E8%A7%92%E8%89%B2%E6%AD%A6%E5%99%A8%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%80%EF%BC%89/" class="post-title-link" itemprop="url">UE4-项目-死寂-角色武器系统（一）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-06-09 10:09:48" itemprop="dateCreated datePublished" datetime="2022-06-09T10:09:48+08:00">2022-06-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-06-14 16:21:08" itemprop="dateModified" datetime="2022-06-14T16:21:08+08:00">2022-06-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/unreal-engine/" itemprop="url" rel="index"><span itemprop="name">unreal engine</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="持枪动画切换"><a href="#持枪动画切换" class="headerlink" title="持枪动画切换"></a>持枪动画切换</h1><p>这一部分的主要目标是实现持枪动画的切换</p>
<ol>
<li><p>实现角色本身的持枪姿势切换</p>
</li>
<li><p>实现角色从默认状态到持枪之间的切换状态（也就是抽枪动画）</p>
</li>
</ol>
<h1 id="角色本身持枪姿势切换"><a href="#角色本身持枪姿势切换" class="headerlink" title="角色本身持枪姿势切换"></a>角色本身持枪姿势切换</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol>
<li><p>给基础状态机添加一个缓存，此时，基础状态机就能同步在其他位置被调用了</p>
</li>
<li><p>编辑基础状态机的基础姿势，在其中添加持枪切换动画（混合空间1D）</p>
</li>
<li><p>添加一个新的功能状态机，在其中使用基础状态机的缓存姿势</p>
</li>
</ol>
<h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><h3 id="保存新的缓存姿势"><a href="#保存新的缓存姿势" class="headerlink" title="保存新的缓存姿势"></a>保存新的缓存姿势</h3><p>此节点可将状态机进行实时备份，相当于让其多了一个分身。</p>
<p>有了此缓存之后，便可在其他位置添加“使用缓存姿势”节点，即可引用原状态机，并对其进行编辑操作</p>
<h3 id="使用缓存姿势"><a href="#使用缓存姿势" class="headerlink" title="使用缓存姿势"></a>使用缓存姿势</h3><p>此节点为上一个节点的引用，可以这样理解：</p>
<ul>
<li><p><strong>保存新的缓存姿势</strong>是声明并定义函数</p>
</li>
<li><p><strong>使用缓存姿势</strong>是调用函数</p>
</li>
</ul>
<h2 id="实现大致步骤"><a href="#实现大致步骤" class="headerlink" title="实现大致步骤"></a>实现大致步骤</h2><ol>
<li><p>创建混合空间1D“WeaponRealse”表示放松状态下的持枪走路-&gt;奔跑状态的切换，并且合理设置最大轴值以及网格区分数量还有采样插值</p>
</li>
<li><p>打开动画蓝图，事件图标，将原本的“瞄准偏移”相关的节点全选，右键“折叠到函数”</p>
<ul>
<li><p>命名为“瞄准偏移计算”</p>
</li>
<li><p>编辑函数，有两个输入值，但其实只需要将其合并为一个</p>
<ul>
<li>因为函数内的两个输入节点，都是“尝试获取Pawn拥有者”节点的输出节点</li>
</ul>
</li>
<li><p>右键函数节点，刷新</p>
</li>
</ul>
</li>
<li><p>打开动画状态图表，对状态机进行一定的修改</p>
<ul>
<li><p>基础状态机-&gt;“保存新的缓存姿势”并命名为“基础状态机缓存”</p>
</li>
<li><p>新建状态机“功能状态机”，代替“基础状态机”接入“插槽跳跃”</p>
</li>
</ul>
</li>
<li><p>编辑“功能状态机”</p>
<ul>
<li><p>添加新状态“基础状态”</p>
</li>
<li><p>编辑“基础状态”，添加“使用缓存姿势“基础状态机缓存””，连接到输出动画姿势</p>
</li>
</ul>
</li>
<li><p>编辑基础状态机中的基础姿势，将武器切换的基础逻辑添加进去</p>
<ul>
<li><p>创建一个新bool变量“是否持枪”默认为false</p>
</li>
<li><p>创建一个“按布尔混合姿势”节点，将“是否持枪”连接上</p>
</li>
<li><p>false姿势链接以“是否蹲伏”为条件的“按布尔混合姿势”节点</p>
</li>
<li><p>true姿势链接刚刚创建的混合空间1D“WeaponRealse”，并连接变量“速度”</p>
</li>
<li><p>最后输出链接“输出动画姿势”</p>
</li>
</ul>
</li>
<li><p>在前面声明了“是否持枪”这个变量，现在，我们需要在<strong>角色蓝图</strong>中对其定义</p>
<ul>
<li><p>新建事件图表“装备武器”</p>
</li>
<li><p>键盘 1作为事件，链接“分支节点”</p>
</li>
<li><p>用动画蓝图节点引出“是否持枪”节点，作为“分支”节点的输入</p>
</li>
<li><p>true则设置“是否持枪”为false</p>
</li>
<li><p>false则设置“是否持枪”为true</p>
</li>
</ul>
</li>
</ol>
<h1 id="装备武器姿势动画实现"><a href="#装备武器姿势动画实现" class="headerlink" title="装备武器姿势动画实现"></a>装备武器姿势动画实现</h1><p>从默认状态到持枪状态之间，是把枪从背后抽出来的，我们现在就要实现这个抽枪和收抢的效果</p>
<h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><ol>
<li><p>在功能状态机中创建新的“装备武器状态”，和基础状态之间进行切换，达到拔枪和收枪的动画效果</p>
</li>
<li><p>拔枪和收枪动画就是正向播放和反向播放的区别，设置该动画的<strong>播放速率</strong>（公开为引脚，并且提升为变量）</p>
</li>
<li><p>然后拔枪动画还得设置“<strong>循环动画</strong>”为false，不然一直会循环播放，当动画不循环播放之后，就可以根据动画剩余时间从持枪状态返回到基础状态</p>
</li>
<li><p>加一个新的bool变量“是否装备武器”来控制拔枪动画的切换（在动画蓝图中声明，在角色蓝图中定义）</p>
</li>
<li><p>需要用“每个骨骼的分层混合”来实现，跑步的时候不会出现停止下来拔枪的效果（角色此时还在向前移动）</p>
</li>
</ol>
<h2 id="知识点-1"><a href="#知识点-1" class="headerlink" title="知识点"></a>知识点</h2><h3 id="每个骨骼的分层混合"><a href="#每个骨骼的分层混合" class="headerlink" title="每个骨骼的分层混合"></a>每个骨骼的分层混合</h3><ul>
<li><p>整体播放引入的“Base Pose”的动画</p>
</li>
<li><p>“分支过滤器”添加指定“骨骼名称”的部分播放引入的“Blend Poses 0”的动画</p>
</li>
<li><p>”网格体空间旋转混合“使得为相对网格体坐标旋转混合，而不是相对世界坐标混合</p>
</li>
</ul>
<h3 id="获取相关剩余动画时间"><a href="#获取相关剩余动画时间" class="headerlink" title="获取相关剩余动画时间"></a>获取相关剩余动画时间</h3><p>字面意思，就是可以获得该动画还剩多少秒结束</p>
<h2 id="实现大致步骤-1"><a href="#实现大致步骤-1" class="headerlink" title="实现大致步骤"></a>实现大致步骤</h2><ol>
<li><p>在功能状态机中创建新状态“装备武器状态”，并于“基础状态”正反向链接</p>
</li>
<li><p>编辑“装备武器状态”</p>
<ul>
<li><p>拖入拔枪动画，将播放速率公开为引脚，并提升为变量“<strong>装备武器方向</strong>”</p>
</li>
<li><p>添加“每个骨骼的分层混合”</p>
</li>
<li><p>添加“使用缓存姿势”作为Base Pose输入</p>
</li>
<li><p>将拔枪动画作为Blend Posses0 输入</p>
</li>
<li><p>添加“每个骨骼分层混合”的分支过滤器，填上骨骼名称，勾选“网格体空间旋转混合”</p>
</li>
<li><p>输出为动画姿势</p>
</li>
</ul>
</li>
<li><p>添加bool变量“<strong>是否装备武器</strong>”</p>
</li>
<li><p>从基础状态切换为装备武器状态的规则为“是否装备武器”为false</p>
</li>
<li><p>从装备武器状态切换为基础状态规则为“获取相关剩余动画时间（装备武器状态）”&lt;0.1</p>
</li>
<li><p>接下来就是在角色蓝图中定义“装备武器方向”和“是否装备武器”</p>
</li>
<li><p>角色蓝图中，持枪时，设置装备武器方向为-1，未持枪时，设置装备武器方向为1</p>
</li>
<li><p>另外，为了使得基础状态切换为装备武器状态之后，下一次切换还可以用“是否装备武器”作为条件，我们需要在最后将“是否装备武器”设置为true之后，延迟0.1秒，设置为false</p>
</li>
</ol>
<h1 id="添加背包（换装系统）"><a href="#添加背包（换装系统）" class="headerlink" title="添加背包（换装系统）"></a>添加背包（换装系统）</h1><p>就是将一个背包添加到角色的背上，随着角色一起运动</p>
<h2 id="知识点-2"><a href="#知识点-2" class="headerlink" title="知识点"></a>知识点</h2><h3 id="设置总姿势组件"><a href="#设置总姿势组件" class="headerlink" title="设置总姿势组件"></a>设置总姿势组件</h3><p>使用条件：两模型必须使用同一个骨骼</p>
<p>将目标引脚的组件添加到New Master Bone Component引脚上</p>
<h2 id="实现大致步骤-2"><a href="#实现大致步骤-2" class="headerlink" title="实现大致步骤"></a>实现大致步骤</h2><ol>
<li><p>找到背包模型，作为组件添加到角色蓝图的网格体上</p>
</li>
<li><p>为了能让背包和角色网格体贴合且匹配：需要满足两者骨骼为同一个</p>
</li>
<li><p>然后设置角色蓝图的“构造脚本”</p>
<ul>
<li>在这里我将其理解为构造函数，功能是相同的</li>
</ul>
</li>
<li><p>添加节点“设置总姿势组件”</p>
<ul>
<li><p>目标为背包模型</p>
</li>
<li><p>New Master Bone Component 链接角色骨骼</p>
</li>
</ul>
</li>
</ol>
<h1 id="添加武器模型"><a href="#添加武器模型" class="headerlink" title="添加武器模型"></a>添加武器模型</h1><p>将武器模型添加到角色的背部</p>
<h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><ol>
<li><p>先创建一个武器基类（父类），在里面编辑一些武器的基本参数</p>
</li>
<li><p>然后根据此基类创建子类，就是具体的武器类型（实例化）</p>
</li>
<li><p>将子类实例化之后附加到虚拟骨骼上（一个装备武器插槽，一个未装备武器插槽）</p>
</li>
</ol>
<h2 id="知识点-3"><a href="#知识点-3" class="headerlink" title="知识点"></a>知识点</h2><h3 id="虚拟骨骼（插槽）"><a href="#虚拟骨骼（插槽）" class="headerlink" title="虚拟骨骼（插槽）"></a>虚拟骨骼（插槽）</h3><p>在角色的骨骼当中新建一个虚拟骨骼（插槽），此插槽是独立于角色骨骼的，我们可以对其位置，朝向等进行修改，不会影响到角色骨骼本身，而且此插槽会随着角色骨骼本身进行运动。</p>
<p>通过添加变量类型“命名”，即可将虚拟骨骼作为一个变量，在蓝图中进行调用！</p>
<h3 id="从类生成Actor"><a href="#从类生成Actor" class="headerlink" title="从类生成Actor"></a>从类生成Actor</h3><p>顾名思义，就是根据给的蓝图类，生成一个实例</p>
<h3 id="附加Actor到组件（attach）"><a href="#附加Actor到组件（attach）" class="headerlink" title="附加Actor到组件（attach）"></a>附加Actor到组件（attach）</h3><p>就是将生成的实例，附加到某个组件上（需要提供附加到的插槽&#x2F;虚拟骨骼）</p>
<p>跟UEC++中的那个成员函数很像</p>
<h2 id="实现大致步骤-3"><a href="#实现大致步骤-3" class="headerlink" title="实现大致步骤"></a>实现大致步骤</h2><ol>
<li><p>创建一个actor类型的蓝图命名为”BP_WeaponBase”</p>
</li>
<li><p>根据父类创建子类“BP_Weapon_AKM”，在细节面板中添加模型</p>
</li>
<li><p>在角色骨骼当中添加两个插槽</p>
<ul>
<li><p>一个在背上“未装备武器插槽”，调整好位置以及旋转</p>
</li>
<li><p>一个在右手上“装备武器插槽”，调整好位置以及旋转</p>
</li>
</ul>
</li>
<li><p>在角色蓝图类中将插槽作为变量存储下来</p>
<ul>
<li><p>添加变量类型“命名”，值为“未装备武器插槽”</p>
</li>
<li><p>添加变量类型“命名”，值未“装备武器插槽”</p>
</li>
</ul>
</li>
<li><p>在角色蓝图的事件图表中，将武器实例添加到角色的背部</p>
<ul>
<li><p>添加“从类生成Actor”，类选择为“BP_Weapon_AKM”</p>
</li>
<li><p>位置变换信息链接“创建变换”节点（这里不用设置位置，因为在后面我们会用虚拟骨骼来具体为其定位到角色的背上）</p>
</li>
<li><p>将“从类生成Actor”的返回值提升为变量，命名为“武器实例”</p>
</li>
<li><p>链接“附加Actor”到组件，目标为角色网格体组件，插槽为“未装备武器插槽”，位置，旋转，缩放规则皆为“对其到目标”</p>
</li>
</ul>
</li>
</ol>
<h1 id="武器跟随角色手部运动"><a href="#武器跟随角色手部运动" class="headerlink" title="武器跟随角色手部运动"></a>武器跟随角色手部运动</h1><p>实现角色拔枪的时候，将背部的枪拔出来，而不是拔空气</p>
<h2 id="知识点-4"><a href="#知识点-4" class="headerlink" title="知识点"></a>知识点</h2><h3 id="AnimNotify（动画通知）"><a href="#AnimNotify（动画通知）" class="headerlink" title="AnimNotify（动画通知）"></a>AnimNotify（动画通知）</h3><p>理解为一个函数，在里面编辑好逻辑代码之后，将这个东西添加到角色的动画的播放序列中的某一帧，当动画播放到那一帧的时候，就会调用此通知。</p>
<h3 id="序列"><a href="#序列" class="headerlink" title="序列"></a>序列</h3><p>执行引脚1之后执行引脚2</p>
<h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><ol>
<li><p>创建一个动画通知编辑其逻辑，使其可以进行拔枪效果</p>
<ul>
<li><p>重载函数“已接收的通知”</p>
</li>
<li><p>获取Mesh Comp的拥有者，也就是角色网格体组件，再将类型转换为角色蓝图</p>
</li>
<li><p>判断一下角色“是否持枪”</p>
</li>
<li><p>如果持枪，就将“武器实例”附加到角色网格体的背部插槽上“装备武器插槽”</p>
</li>
<li><p>如果不持枪，则将武器实例度假岛角色网格体的手部插槽上“未装备武器插槽”</p>
</li>
</ul>
</li>
<li><p>需要注意的是，如果反复拔枪，就会出现拔枪抽搐的情况，这个时候就需要创建一个bool来判定，能否拔枪</p>
</li>
<li><p>将动画通知放到拔枪动画的合适位置</p>
</li>
</ol>
<h2 id="实现大致步骤-4"><a href="#实现大致步骤-4" class="headerlink" title="实现大致步骤"></a>实现大致步骤</h2><ol>
<li><p>添加一个动画通知，命名为”Notif_EquipWeaponAnimation”</p>
</li>
<li><p>打开拔枪动画，在通知栏的合适位置添加”Notif_EquipWeaponAnimation”</p>
</li>
<li><p>编辑”Notif_EquipWeaponAnimation”</p>
<ul>
<li><p>重载函数“已接收的通知”</p>
</li>
<li><p>Mesh Comp引出“获取拥有者”</p>
</li>
<li><p>引出“Is valid”来判断是否有效，然后“类型转换为BP_Player”</p>
</li>
<li><p>引出动画蓝图，“是否持枪”变量，判断角色是否为持枪状态</p>
</li>
<li><p>如果为True，则使用“附加Actor到组件”，目标为武器实例，parent为网格体，插槽为“装备武器插槽”</p>
</li>
<li><p>如果为False，则使用“附加Actor到组件”，目标为武器实例，parent为网格体，插槽为“未装备武器插槽”</p>
</li>
</ul>
</li>
<li><p>实现持枪状态相机偏移</p>
<ul>
<li><p>在两个“设置装备武器方向”节点后分别添加两个“序列”节点，引脚1都链接“是否装备武器”节点</p>
</li>
<li><p>添加新的时间轴，新建轨道，引出插值（15，50）</p>
</li>
<li><p>play和reverse分别和正向播放动画，反向播放动画链接</p>
</li>
<li><p>引入弹簧臂组件，引出获取Socket Office节点和设置Socket Office节点，并且都分割引脚，并且将z轴链接</p>
</li>
<li><p>时间轴的update引脚链接弹簧臂的设置Socket Office（设置插槽偏移）</p>
</li>
<li><p>插值链接Y轴</p>
</li>
</ul>
</li>
<li><p>在角色蓝图，装备武器事件图表中，添加变量“是否可以切换武器”</p>
<ul>
<li><p>默认值为true，在“键盘 1”节点后，通过分支节点进行判断，为true，则设置其为false后进入后面节点</p>
</li>
<li><p>在上一步的时间轴中的finish引脚设置“是否可以切换武器”为true</p>
</li>
</ul>
</li>
</ol>
<h1 id="持枪蹲伏"><a href="#持枪蹲伏" class="headerlink" title="持枪蹲伏"></a>持枪蹲伏</h1><h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><ol>
<li><p>通过状态机里面添加混合空间1D来实现持枪蹲伏效果</p>
<ul>
<li><p>用一个“按布尔混合姿势”来进行判断输出</p>
</li>
<li><p>当“是否蹲伏”为true，输出蹲伏动画</p>
</li>
<li><p>当“是否蹲伏”为false，输出站立动画</p>
</li>
</ul>
</li>
<li><p>后面再加一个“按布尔混合姿势”节点来判断是否持枪</p>
</li>
</ol>
<h2 id="实现大致步骤-5"><a href="#实现大致步骤-5" class="headerlink" title="实现大致步骤"></a>实现大致步骤</h2><ol>
<li><p>创建混合空间1D，命名为“BS_WeaponRealseCrouch”，并添加动画，将其设置好</p>
</li>
<li><p>打开动画蓝图，编辑基础状态机中的基础姿势状态（实现持枪蹲伏效果）</p>
<ul>
<li><p>添加“BS_WeaponRealseCrouch”到蓝图中</p>
</li>
<li><p>再添加一个以“是否蹲伏”为条件的“按布尔混合姿势”节点</p>
</li>
<li><p>true链接持枪蹲伏动画，false链接持枪站立动画</p>
</li>
<li><p>后面链接上以“是否持枪”为判断条件的“按布尔混合姿势”节点，来区分是否持枪的站立和蹲伏动画</p>
</li>
</ul>
</li>
</ol>
<h1 id="持枪跳跃"><a href="#持枪跳跃" class="headerlink" title="持枪跳跃"></a>持枪跳跃</h1><p>之前实现跳跃的时候是编写了一个跳跃函数的，形参有三个蒙太奇动画</p>
<p>现在我们要编辑一下这个跳跃函数，将形参多添加三个“跳跃高度”，因为持枪和未持枪的跳跃高度是不同的！</p>
<h2 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h2><ol>
<li><p>更改“跳跃的动画和高度设置”函数，方便传参</p>
</li>
<li><p>创建持枪跳跃蒙太奇动画，添加插槽</p>
</li>
<li><p>跳跃事件调用“跳跃的动画和高度设置”函数的时候，添加一个以“是否持枪”为判断标准的“分支”节点，分别调用“跳跃的动画和高度设置”函数，并传入不同的参数</p>
</li>
</ol>
<h2 id="实现大致步骤-6"><a href="#实现大致步骤-6" class="headerlink" title="实现大致步骤"></a>实现大致步骤</h2><ol>
<li><p>点击<strong>跳跃动画和高度设置</strong>函数，将三个跳跃高度连接到输入节点，分别命名为“慢跑&#x2F;行走&#x2F;冲刺的跳跃高度”</p>
</li>
<li><p>找到三个状态下的持枪跳跃动画，创建为蒙太奇动画，插槽更改为“跳跃”</p>
</li>
<li><p>打开“角色跳跃”事件图表，断开“跳跃的动画和高度设置”函数的链接</p>
</li>
<li><p>在原本位置上添加一个序列，引脚0链接原本的“延迟”节点</p>
</li>
<li><p>引脚1链接一个“分支”节点，判断条件为“是否持枪”</p>
<ul>
<li><p>true输出为“跳跃的动画和高度设置”（动画为持枪跳跃，高度略低）</p>
</li>
<li><p>false输出为“跳跃的动画和高度设置”（动画为未持枪跳跃，高度略高）</p>
</li>
</ul>
</li>
</ol>
<h1 id="持枪坠落"><a href="#持枪坠落" class="headerlink" title="持枪坠落"></a>持枪坠落</h1><h2 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h2><ol>
<li><p>要修改角色基础状态机，将其从一个基类，变为一个子类。新建一个基类，只包含蹲伏及站立的蓝图逻辑</p>
<ul>
<li><p>因为我们需要编辑”坠落状态“</p>
</li>
<li><p>而编辑坠落，需要和原本的持枪状态进行”每个骨骼的分层混合“，就需要调用缓存</p>
</li>
<li><p>但是自身不能调用自身的缓存，所以就将原本的站立&#x2F;蹲伏姿势独立出去</p>
</li>
<li><p>这样就可以在子类中调用基类的缓存了！</p>
</li>
</ul>
</li>
</ol>
<h2 id="实现大致步骤-7"><a href="#实现大致步骤-7" class="headerlink" title="实现大致步骤"></a>实现大致步骤</h2><ol>
<li><p>重命名原本的“基础状态机”为”总基础状态“，并且同步修改其缓存的名称</p>
</li>
<li><p>新建名为“角色基础状态”的状态机，并且缓存</p>
</li>
<li><p>编辑“角色基础状态”状态机</p>
<ul>
<li><p>新建一个名为“基础状态”的状态</p>
</li>
<li><p>返回“总基础状态”，将其中“基础姿势”的节点全部剪切到“基础状态”中</p>
</li>
<li><p>在“总基础状态机”中的“基础姿势”中“使用总基础状态的缓存”</p>
</li>
</ul>
</li>
<li><p>在总基础状态机中的坠落状态中编辑逻辑代码</p>
<ul>
<li><p>调用”每个骨骼的分层混合“节点</p>
</li>
<li><p>Base为坠落动画，Blend为”角色基础状态缓存“动画</p>
</li>
<li><p>编辑”每个骨骼的分层混合“节点，添加两个新的分支过滤器，骨骼名称分别为角色的左右手臂骨骼</p>
</li>
<li><p>再调用一个以”是否持枪“为判断条件的”按布尔混合姿势“节点</p>
</li>
<li><p>true输出刚刚写好的持枪坠落的混合动画</p>
</li>
<li><p>false输出未持枪坠落动画</p>
</li>
</ul>
</li>
</ol>
<h1 id="BUG-切换武器时跳跃导致切了个寂寞"><a href="#BUG-切换武器时跳跃导致切了个寂寞" class="headerlink" title="BUG-切换武器时跳跃导致切了个寂寞"></a>BUG-切换武器时跳跃导致切了个寂寞</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>在角色切换武器时进行跳跃，导致先进行跳跃，然后角色的切换武器动画做了一半，武器也没有切换到手上&#x2F;背部，但是姿势变为了”持枪“或者”未持枪“</p>
<h2 id="BUG诱因"><a href="#BUG诱因" class="headerlink" title="BUG诱因"></a>BUG诱因</h2><p>跳跃动画是蒙太奇动画，在切换武器时进行跳跃，蒙太奇动画会直接打断切换武器动画</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>使得角色在切换武器时不可跳跃，或者在跳跃时不能切换武器</p>
<p>添加一个枚举，枚举值分别为”空白“，”跳跃“，”装备武器“</p>
<p>只有在枚举值为”空白“的时候，才能”跳跃“或者”装备武器“</p>
<h2 id="实现大致步骤-8"><a href="#实现大致步骤-8" class="headerlink" title="实现大致步骤"></a>实现大致步骤</h2><ol>
<li><p>创建一个名为”Player_FuntionState“的枚举</p>
</li>
<li><p>将之前那个枚举重命名为”Player_MoveSate“</p>
</li>
<li><p>编辑”Player_FuntionState“</p>
<ul>
<li><p>添加枚举值”空白“（什么功能都没有触发）</p>
</li>
<li><p>添加枚举值”跳跃“</p>
</li>
<li><p>添加枚举值”装备武器“</p>
</li>
<li><p>添加枚举值”瞄准“</p>
</li>
</ul>
</li>
<li><p>在角色蓝图类中创建”Player_FuntionState“枚举</p>
</li>
<li><p>在角色跳跃图表中进行编辑</p>
<ul>
<li><p>将”是否可以跳跃“为判断标准的”分支“节点替换为枚举值是否为”空白“的”分支“节点</p>
</li>
<li><p>在执行true之后将枚举值改为”跳跃“</p>
</li>
<li><p>在跳跃事件结束之后，将枚举值改为空白</p>
</li>
<li><p>删除”是否可以跳跃“变量</p>
</li>
</ul>
</li>
<li><p>在装备武器图表中进行编辑</p>
<ul>
<li><p>将”是否可以切换武器“为判断标准的”分支“节点替换为枚举值是否为”空白“的”分支“节点</p>
</li>
<li><p>在执行true之后将枚举值改为”装备武器“</p>
</li>
<li><p>在装备武器事件结束之后，将枚举值改为空白</p>
</li>
<li><p>删除”是否可以切换武器“变量</p>
</li>
</ul>
</li>
</ol>
<h1 id="BUG-坠落时可跳跃以及蹲伏"><a href="#BUG-坠落时可跳跃以及蹲伏" class="headerlink" title="BUG-坠落时可跳跃以及蹲伏"></a>BUG-坠落时可跳跃以及蹲伏</h1><h2 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h2><p>当角色坠落的时候，按空格键会播放跳跃动画，按C键不会播放跳跃动画，但是会出现视角变低的情况</p>
<h2 id="BUG诱因-1"><a href="#BUG诱因-1" class="headerlink" title="BUG诱因"></a>BUG诱因</h2><h3 id="跳跃BUG"><a href="#跳跃BUG" class="headerlink" title="跳跃BUG"></a>跳跃BUG</h3><p><strong>状态机的动画优先级</strong>：优先播放优先级高的动画</p>
<ol>
<li><p>越外层，优先级越高</p>
</li>
<li><p>越靠左，优先级越高</p>
</li>
</ol>
<p>在动画图表中，插槽”跳跃“在最外层，导致优先级比在内层的”坠落“高，在具体播放动画的时候，就会打断”坠落“，优先播放”跳跃“</p>
<h3 id="蹲伏BUG"><a href="#蹲伏BUG" class="headerlink" title="蹲伏BUG"></a>蹲伏BUG</h3><p>没有告诉程序：在空中不能蹲伏</p>
<h2 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="跳跃BUG-1"><a href="#跳跃BUG-1" class="headerlink" title="跳跃BUG"></a>跳跃BUG</h3><p>将”跳跃“插槽放到”角色基础状态“-&gt;”基础状态“的最右边，使其优先级最低</p>
<h3 id="蹲伏BUG-1"><a href="#蹲伏BUG-1" class="headerlink" title="蹲伏BUG"></a>蹲伏BUG</h3><ol>
<li><p>在角色蓝图的蹲伏事件图表中</p>
</li>
<li><p>引用动画蓝图中的变量“是否在空中”作为“分支”节点的判断依据</p>
</li>
<li><p>当值为flase时，才可执行后面的操作</p>
</li>
</ol>
<h1 id="BUG-蹲伏状态直接跳跃"><a href="#BUG-蹲伏状态直接跳跃" class="headerlink" title="BUG-蹲伏状态直接跳跃"></a>BUG-蹲伏状态直接跳跃</h1><h2 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h2><p>在蹲伏的时候，按键盘空格键，就会出现直接进行跳跃的情况</p>
<h2 id="BUG诱因-2"><a href="#BUG诱因-2" class="headerlink" title="BUG诱因"></a>BUG诱因</h2><p>同优先级的动画会直接进行播放</p>
<h2 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h2><p>在跳跃动画播放之前，判断一下是否蹲伏，如果是蹲伏，则先解除蹲伏，然后再进行跳跃</p>
<h2 id="实现大致步骤-9"><a href="#实现大致步骤-9" class="headerlink" title="实现大致步骤"></a>实现大致步骤</h2><ol>
<li><p>在角色蹲伏图表中新增一个自定义事件，链接着”解除蹲伏“节点</p>
</li>
<li><p>在角色跳跃图表中，添加一个以“角色移动组件”的“正在蹲伏”为判断条件的“分支”节点</p>
</li>
<li><p>true则调用“解除蹲伏”事件，false则继续原本逻辑</p>
</li>
</ol>
<h1 id="优化-角色摩擦力"><a href="#优化-角色摩擦力" class="headerlink" title="优化-角色摩擦力"></a>优化-角色摩擦力</h1><h2 id="问题描述-3"><a href="#问题描述-3" class="headerlink" title="问题描述"></a>问题描述</h2><p>在之前设置角色摩擦力为0，会有一个停止行走之后还会向前移动一小段距离的情况（就比较自然），需要优化的地方是，现在角色摩擦力为零，则会导致看起来角色像是在冰面上走一样，就比较难受。</p>
<h2 id="优化思路"><a href="#优化思路" class="headerlink" title="优化思路"></a>优化思路</h2><ol>
<li><p>在角色运动时，将摩擦力设置为默认值8，在角色停止运动时，将摩擦力设置为0</p>
</li>
<li><p>如何判断角色是否运动？</p>
<ul>
<li>根据轴映射的值来判断，如果forword运动和right运动值均为零，则意味着角色已经停止了运动</li>
</ul>
</li>
</ol>
<h2 id="实现大致步骤-10"><a href="#实现大致步骤-10" class="headerlink" title="实现大致步骤"></a>实现大致步骤</h2><ol>
<li><p>在角色蓝图，角色基础移动事件图表中</p>
</li>
<li><p>分别将“输入轴moveforword”和“输入轴moveright”的返回值引出节点“&#x3D;&#x3D;（浮点）”</p>
</li>
<li><p>将两个bool引入节点“and”</p>
</li>
<li><p>将返回的bool作为一个“分支”节点的判断标准</p>
</li>
<li><p>引入角色移动组件-&gt;”set ground friction”节点</p>
</li>
<li><p>true则”set ground friction”为0；false则设置”set ground friction”为8</p>
</li>
</ol>
<h1 id="角色瞄准状态切换"><a href="#角色瞄准状态切换" class="headerlink" title="角色瞄准状态切换"></a>角色瞄准状态切换</h1><p>角色瞄准状态的主要表现形式——视野拉近，角色朝向随着鼠标朝向而不是键盘输入朝向</p>
<h2 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h2><h3 id="视野拉近"><a href="#视野拉近" class="headerlink" title="视野拉近"></a>视野拉近</h3><ol>
<li><p>视野是由弹簧臂进行控制的，想要改变视野，就需要改变弹簧臂长度</p>
</li>
<li><p>另外，还需要判断角色是否处于持枪状态，是否在跳跃过程中，是否在装备武器状态过程中</p>
</li>
<li><p>在判断完成之后，可以通过时间轴来对弹簧臂长度进行控制</p>
</li>
</ol>
<h3 id="角色朝向"><a href="#角色朝向" class="headerlink" title="角色朝向"></a>角色朝向</h3><ol>
<li><p>角色朝向可以根据两个地方进行修改</p>
<ul>
<li><p>角色蓝图类-&gt;类默认值-&gt;Pawn-&gt;使用控制器旋转Yaw【True面向跟随鼠标】</p>
</li>
<li><p>角色移动组件-&gt;角色移动（旋转设置）-&gt;将旋转朝向运动【True面向跟随键盘】</p>
</li>
<li><p>另外，需要注意的是，两个值必须一开一关，因为两者是相冲突的。</p>
</li>
</ul>
</li>
<li><p>所以我们只需要把角色朝向分为两个状态</p>
<ul>
<li><p>瞄准时面向随着鼠标</p>
</li>
<li><p>非瞄准状态面向随着键盘</p>
</li>
</ul>
</li>
</ol>
<h2 id="实现大致步骤-11"><a href="#实现大致步骤-11" class="headerlink" title="实现大致步骤"></a>实现大致步骤</h2><ol>
<li><p>添加一个键盘映射“鼠标右键”</p>
</li>
<li><p>在角色蓝图类中创建两个新图表“瞄准”以及“瞄准状态切换”</p>
</li>
<li><p>在瞄准状态切换图表中做如下操作，分别控制角色瞄准状态的朝向和非瞄准状态的朝向</p>
<ul>
<li><p>添加自定义事件“瞄准状态”以及“放松状态”</p>
</li>
<li><p>瞄准状态-&gt;”set use controller rotation Yaw”（true）-&gt;角色移动组件-&gt;”set Orient rotation to movement”（false）</p>
</li>
<li><p>放松状态-&gt;”set use controller rotation Yaw”（false）-&gt;角色移动组件-&gt;”set Orient rotation to movement”（true）</p>
</li>
</ul>
</li>
<li><p>在瞄准事件图表中进行如下操作，用于改变弹簧臂的长度</p>
<ul>
<li><p>输入操作“瞄准”节点-&gt;以是否持枪未判断依据的分支-&gt;true-&gt;以Player Funtion State 的值是否为空白为判断依据的分支</p>
</li>
<li><p>Pressed链接“瞄准状态”事件，Released链接“放松状态”事件</p>
</li>
<li><p>瞄准状态-&gt;set Player Funtion State（瞄准）</p>
</li>
<li><p>放松状态-&gt;set Player Funtion State（空白）</p>
</li>
<li><p>添加时间轴，新建轨道，瞄准链接play引脚，空白链接reverse引脚</p>
</li>
<li><p>update-&gt;弹簧臂组件（set Target Arm length）</p>
</li>
<li><p>新建轨道-&gt;插值（170，50）-&gt;目标臂长度</p>
</li>
</ul>
</li>
</ol>
<h1 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h1><p>感觉每次整理笔记最耗费时间的就是写实现大致步骤了，有点用处，但是用处不大，最重要的还是思路和知识点的整理，所以说后面的就不再写大致步骤了。把重点放在思路和知识点上吧！</p>
<h1 id="角色瞄准动画"><a href="#角色瞄准动画" class="headerlink" title="角色瞄准动画"></a>角色瞄准动画</h1><p>角色瞄准时，自身的行走状态动画</p>
<h2 id="知识点-5"><a href="#知识点-5" class="headerlink" title="知识点"></a>知识点</h2><h3 id="角色运动八个方向的角度值"><a href="#角色运动八个方向的角度值" class="headerlink" title="角色运动八个方向的角度值"></a>角色运动八个方向的角度值</h3><ul>
<li><p>前方为0，后方为180&#x2F;-180</p>
</li>
<li><p>右边为正数</p>
</li>
<li><p>左边为负数</p>
</li>
</ul>
<p><img src="/UE4-%E9%A1%B9%E7%9B%AE-%E6%AD%BB%E5%AF%82-%E8%A7%92%E8%89%B2%E6%AD%A6%E5%99%A8%E7%B3%BB%E7%BB%9F%5C1.png"></p>
<h3 id="计算方向"><a href="#计算方向" class="headerlink" title="计算方向"></a>计算方向</h3><p>虚幻引擎中内置了一个函数“计算方向”</p>
<p>通过输入的“速度”和“旋转”来进行计算此时的Actor的方向</p>
<h3 id="旋转浮点（select）"><a href="#旋转浮点（select）" class="headerlink" title="旋转浮点（select）"></a>旋转浮点（select）</h3><p>是一个以布尔值为判断依据，输出两个不同值的函数</p>
<ol>
<li><p>如果为true，则输出引脚A</p>
</li>
<li><p>如果为false，则输出引脚B</p>
</li>
</ol>
<h2 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h2><ol>
<li><p>因为角色行走时，是八个方向的动画，我们可以使用混合空间来进行实现状态变化</p>
</li>
<li><p>创建一个混合空间，横坐标为运动方向（也就是运动的八个方向），纵坐标为速度（只需要设置行走速度，因为瞄准时会在后面设置不可冲刺）</p>
</li>
<li><p>在动画蓝图中通过传入速度和旋转到“计算方向”节点来判断角色目前的行走方向</p>
</li>
<li><p>新建一个瞄准状态，和基础状态之间进行切换</p>
<ul>
<li><p>判断条件为一个bool值“是否瞄准”</p>
</li>
<li><p>瞄准状态里面播放之前创建的混合空间</p>
</li>
</ul>
</li>
</ol>
<h2 id="优化-持枪行走速度优化"><a href="#优化-持枪行走速度优化" class="headerlink" title="优化-持枪行走速度优化"></a>优化-持枪行走速度优化</h2><p>根据常识来讲，人在持枪瞄准的时候，不能行走太快，所以在这里我们做一个速度上的限制</p>
<h3 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h3><ol>
<li><p>在之前创建的角色速度判断函数中添加一个判断即可</p>
</li>
<li><p>用“旋转浮点”作为判断节点，判断条件为“是否瞄准”</p>
</li>
<li><p>true则输出150（瞄准时的行走速度）</p>
</li>
<li><p>false则输出原本函数计算的行走速度</p>
</li>
</ol>
<h1 id="BUG-持枪瞄准偏移的手部运动"><a href="#BUG-持枪瞄准偏移的手部运动" class="headerlink" title="BUG-持枪瞄准偏移的手部运动"></a>BUG-持枪瞄准偏移的手部运动</h1><p>之前我们是把瞄准偏移放在状态机的最外围，现在为了实现持枪状态下也可以实现瞄准偏移，将瞄准便宜放在最内层（状态机的优先性）</p>
<h2 id="BUG描述"><a href="#BUG描述" class="headerlink" title="BUG描述"></a>BUG描述</h2><p>当我们把瞄准偏移放在最内侧之后，确实实现了持枪也实现了瞄准偏移的效果，但是这个时候会发现，瞄准偏移的时候，手部运动出现了问题——手没有放在枪械上（原力持枪）</p>
<h2 id="知识点-6"><a href="#知识点-6" class="headerlink" title="知识点"></a>知识点</h2><h3 id="IK（逆向动力学）"><a href="#IK（逆向动力学）" class="headerlink" title="IK（逆向动力学）"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/f980511/article/details/123319383">IK（逆向动力学）</a></h3><p><strong>是一种设置动画的方法，它翻转链操纵的方向。它是从叶子而不是根开始进行工作的。</strong></p>
<h4 id="简单演示"><a href="#简单演示" class="headerlink" title="简单演示"></a>简单演示</h4><p>现在举个手臂的例子。要设置使用正向运动学的手臂的动画，可以旋转大臂使它移离肩膀，然后旋转小臂，手部等等，为每个子对象添加旋转关键点。</p>
<p>要设置使用反向运动学的手臂的动画，可以移动用以定位腕部的目标。手臂的上半部分和下半部分为 IK 解决方案所旋转，使称为<strong>末端效应器</strong>的腕部轴点向着目标移动。</p>
<p><img src="https://img-blog.csdnimg.cn/822f0bb60b7047488df65b35b4cd4369.png"></p>
<p><img src="https://img-blog.csdnimg.cn/27996887b51b4dd69599e8e003fa5cac.gif"></p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>可以理解为，一般的正向动力学是用手臂带动拳头；逆向动力学就是用拳头去带动手臂</p>
<h4 id="节点FABRIK"><a href="#节点FABRIK" class="headerlink" title="节点FABRIK"></a>节点FABRIK</h4><p>这个节点就是虚幻引擎中的IK相关节点</p>
<ol>
<li><p><strong>执行器</strong>选择一个骨骼&#x2F;组件&#x2F;世界场景&#x2F;父骨骼进行参考，让“解算器“参考它进行运动</p>
</li>
<li><p><strong>解算器</strong>选择的IK的”叶子“和”根“</p>
</li>
<li><p>最后在预览视图中可以直接调整<strong>末端效应器</strong>的位置</p>
</li>
</ol>
<h2 id="解决方案-3"><a href="#解决方案-3" class="headerlink" title="解决方案"></a>解决方案</h2><ol>
<li><p>在看了逆向动力学的原理之后，就可以想到，如果我们把手部设置为逆向动力学的末端效应器，跟随着另一只手进行运动，就不会产生之前的问题了</p>
</li>
<li><p>所以在动画图表中，瞄准偏移后添加一个”FABRIK”节点，将其设置好即可</p>
</li>
</ol>
<h1 id="瞄准状态的瞄准偏移动画"><a href="#瞄准状态的瞄准偏移动画" class="headerlink" title="瞄准状态的瞄准偏移动画"></a>瞄准状态的瞄准偏移动画</h1><p>目前为止，瞄准状态只会瞄准正前方，不能瞄准其他方向，现在需要做的事情就是瞄准其他位置的方向，并且为其添加动画</p>
<h2 id="知识点-7"><a href="#知识点-7" class="headerlink" title="知识点"></a>知识点</h2><h3 id="资产操作-gt-通过属性矩阵进行批量资产编辑-gt-AdditiveSettings"><a href="#资产操作-gt-通过属性矩阵进行批量资产编辑-gt-AdditiveSettings" class="headerlink" title="资产操作-&gt;通过属性矩阵进行批量资产编辑-&gt;AdditiveSettings"></a>资产操作-&gt;通过属性矩阵进行批量资产编辑-&gt;AdditiveSettings</h3><p>如果想要把一组动画变为附加动画的时候就要进行如下操作，在此可选择附加操作的参考姿势</p>
<h3 id="AO-瞄准偏移"><a href="#AO-瞄准偏移" class="headerlink" title="AO_瞄准偏移"></a>AO_瞄准偏移</h3><ol>
<li><p>水平坐标（Yaw轴，也就是Z轴）：实际操作中，鼠标往左右移动在游戏中表现为左右摇头，此时鼠标在桌子上按水平坐标移动，游戏中根据Yaw轴旋转（Z轴）</p>
</li>
<li><p>垂直坐标（Pitch轴，也就是Y轴）：实际操作中，鼠标往上下移动在游戏中表现为抬头低头，此时鼠标在桌子上按垂直坐标移动，游戏中根据Pitch轴旋转（Y轴）</p>
</li>
<li><p>选中一个参考姿势后创建一个瞄准偏移，将被参考的姿势放入正中间，其他姿势按效果设置</p>
</li>
</ol>
<h2 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h2><ol>
<li><p>创建一个持枪瞄准偏移</p>
</li>
<li><p>将瞄准偏移放到动画蓝图中的”瞄准状态“状态中，传入Yaw和Pitch即可</p>
</li>
<li><p>然后会出钱之前持枪瞄准偏移的bug，直接复制之前的IK计算到瞄准状态的瞄准偏移那边去，然后设置好末端效应器位置即可</p>
</li>
</ol>
<h1 id="瞄准状态蹲伏"><a href="#瞄准状态蹲伏" class="headerlink" title="瞄准状态蹲伏"></a>瞄准状态蹲伏</h1><h2 id="思路-11"><a href="#思路-11" class="headerlink" title="思路"></a>思路</h2><ol>
<li><p>创建一个混合空间，设置好水平坐标（方向）和垂直坐标（速度）以及动画</p>
</li>
<li><p>添加进”瞄准状态“状态中，使用”按照布尔混合姿势“和站立瞄准状态进行区分</p>
</li>
<li><p>然后那些瞄准偏移和IK就不用额外做了，因为程序按照顺序执行之后，就直接使用了站立瞄准状态的瞄准偏移和IK</p>
</li>
</ol>
<h1 id="BUG-蹲伏站起之后的穿模"><a href="#BUG-蹲伏站起之后的穿模" class="headerlink" title="BUG-蹲伏站起之后的穿模"></a>BUG-蹲伏站起之后的穿模</h1><h2 id="BUG描述-1"><a href="#BUG描述-1" class="headerlink" title="BUG描述"></a>BUG描述</h2><p>在角色遇到一个障碍物的时候，蹲伏通过，在未通过的状态下取消蹲伏，会直接站起来，导致穿模</p>
<h2 id="BUG诱因-3"><a href="#BUG诱因-3" class="headerlink" title="BUG诱因"></a>BUG诱因</h2><p>其实虚幻引擎中内置的”解除蹲伏“函数自带检测上方是否有障碍物阻挡，如果有，则会一直保持蹲伏状态，但是为啥在这里又站起来了呢？</p>
<p>是因为函数认为角色依旧在蹲伏状态，但是我们原本写的代码逻辑中，不管是否蹲伏，都会按照时间轴播放一次动画。</p>
<p>所以是，<strong>角色的灵魂还在蹲伏，身体却站起来了</strong></p>
<h2 id="解决方案-4"><a href="#解决方案-4" class="headerlink" title="解决方案"></a>解决方案</h2><p>让”解除蹲伏“函数发挥真正的作用</p>
<p>之前是在角色蓝图中判断角色”是否蹲伏“，现在我们把角色蓝图中的”是否蹲伏“判断删掉</p>
<p>在动画蓝图中去进行判断</p>
<p>把动画蓝图看作身体，角色蓝图看作灵魂</p>
<p>之前是灵魂代管了一部分身体，出现了不协调的情况，所以现在各自管各自的，就不会出现不协调的情况了</p>
<h2 id="思路-12"><a href="#思路-12" class="headerlink" title="思路"></a>思路</h2><ol>
<li><p>删除角色蓝图中的”解除蹲伏“和”蹲伏“节点后的”设置是否蹲伏“</p>
</li>
<li><p>在动画蓝图中获取角色移动组件-&gt;”正在蹲伏“节点-&gt;设置”是否蹲伏“</p>
</li>
</ol>
<h1 id="射击"><a href="#射击" class="headerlink" title="射击"></a>射击</h1><p>先设置跳跃时不可射击，瞄准时可射击（只有瞄准的时候手臂才是抬起来的）</p>
<h2 id="知识点-8"><a href="#知识点-8" class="headerlink" title="知识点"></a>知识点</h2><h3 id="以函数名设置定时器"><a href="#以函数名设置定时器" class="headerlink" title="以函数名设置定时器"></a>以函数名设置定时器</h3><p>此节点传入一个函数名&#x2F;事件名，设置一个时间，在达到这个时间之后，就会执行那个传入的函数&#x2F;事件</p>
<h3 id="以函数名清除定时器"><a href="#以函数名清除定时器" class="headerlink" title="以函数名清除定时器"></a>以函数名清除定时器</h3><p>根据函数名&#x2F;事件名清楚定时器</p>
<h2 id="思路-13"><a href="#思路-13" class="headerlink" title="思路"></a>思路</h2><ol>
<li><p>添加操作映射”射击“</p>
</li>
<li><p>创建新的事件图表”射击“，在其中调用操作映射”射击“</p>
</li>
<li><p>判断一下”是否持枪“；枚举状态是否为”空白“，或者在”瞄准射击“状态内即可执行”瞄准射击“（在这里把瞄准和射击的状态合并在一起了，但是具体是瞄准操作还是射击操作，用两段逻辑实现）</p>
</li>
<li><p>同时修改一下”瞄准“事件图表中的判断条件，让在”空白“或者”瞄准射击“状态下均可以进行瞄准操作</p>
</li>
<li><p>接下来在”射击“图表中更改当前状态为”瞄准射击“</p>
</li>
<li><p>再判断一下”是否瞄准“状态，因为只有再瞄准状态，角色手臂才是抬起来的</p>
<ul>
<li><p>false则调用”瞄准状态“函数来切换到瞄准状态</p>
</li>
<li><p>true则直接射击，具体射击逻辑下面写</p>
</li>
</ul>
</li>
<li><p>射击的pressed，是否为瞄准状态，如果是，则保留不做任何更改；如果不是，则延迟几秒再把手放下来（切换到”放松状态“，并把枚举值设置为”空白“），为了防止快速点击鼠标左键，出现抽搐的情况</p>
<ul>
<li><p>添加一个bool值”是否瞄准“</p>
</li>
<li><p>pressed链接以”是否瞄准“为判断依据的”分支“节点</p>
</li>
<li><p>true啥也不连（保持现状）</p>
</li>
<li><p>false链接一个”以函数名设置定时器“节点，时间设置为0.7</p>
</li>
</ul>
</li>
<li><p>创建一个自定义事件”停止瞄准“</p>
<ul>
<li><p>Set Player Funtion State为空白</p>
</li>
<li><p>调用”放松状态“函数</p>
</li>
</ul>
</li>
<li><p>在”以函数名设置定时器“节点中调用”停止瞄准“事件</p>
</li>
<li><p>为了防止在先射击再瞄准的时候出现角色在0.7秒后取消了瞄准状态</p>
<ul>
<li><p>在”瞄准“事件图表中，设置”是否瞄准“为true后面调用”以函数名清除定时器“</p>
</li>
<li><p>也就是说，在已经瞄准的状态下，除非我主动进行”不瞄准“的操作，不然不能切换为放松状态，如果不再此处清除定时器，那么定时器就会自动执行”进入放松状态“的逻辑</p>
</li>
</ul>
</li>
</ol>
<h1 id="后坐力动画的添加"><a href="#后坐力动画的添加" class="headerlink" title="后坐力动画的添加"></a>后坐力动画的添加</h1><p>用附加动画来实现后坐力的效果</p>
<h2 id="知识点-9"><a href="#知识点-9" class="headerlink" title="知识点"></a>知识点</h2><h3 id="应用网格体additive动画"><a href="#应用网格体additive动画" class="headerlink" title="应用网格体additive动画"></a>应用网格体additive动画</h3><p>就是附加动画，将additive添加到base上进行一个混合</p>
<h3 id="切换ETimeLineDirection"><a href="#切换ETimeLineDirection" class="headerlink" title="切换ETimeLineDirection"></a>切换ETimeLineDirection</h3><p>用在时间轴的Direction引脚，可以在正向播放和反向播放的时候进行一些操作</p>
<h2 id="思路-14"><a href="#思路-14" class="headerlink" title="思路"></a>思路</h2><ol>
<li><p>找到并设置后坐力的动画</p>
<ul>
<li><p>附加设置-&gt;additive动画类型-&gt;“网格体空间”</p>
</li>
<li><p>附加设置-&gt;基础姿势类型-&gt;”选择的动画帧“</p>
</li>
<li><p>附加设置-&gt;预览动画-&gt;选择站立的持枪瞄准动画</p>
</li>
</ul>
</li>
<li><p>再动画蓝图中”总基础动画“的”基础姿势“中编辑</p>
<ul>
<li><p>添加bool”是否射击“</p>
</li>
<li><p>以”是否射击“为条件”按布尔混合姿势“，false输出原本姿势</p>
</li>
<li><p>将之前设置之后的后坐力动画拖出来，作为”应用网格体空间Additive动画“的Additive引脚，将原本输出动画作为Base引脚</p>
</li>
<li><p>最后将混合好的动画输出作为”按布尔混合姿势“的true引脚</p>
</li>
</ul>
</li>
<li><p>在角色蓝图类中给”是否射击“进行定义</p>
<ul>
<li><p>自定义事件”开始射击“-&gt;”设置是否射击“为true</p>
</li>
<li><p>在以”是否瞄准“为判断依据的”分支“节点的true调用”开始射击“</p>
</li>
<li><p>“瞄准状态”节点后面调用”以函数名设置定时器“调用”开始射击“，延时0.4秒（非瞄准状态下先抬枪，过0.4秒之后开枪）</p>
</li>
<li><p>在pressed引脚”设置是否射击“为false</p>
</li>
<li><p>同时还要再pressed处“以函数名清除定时器”</p>
</li>
</ul>
</li>
<li><p>已经在射击中判断了此时是否瞄准，也要在瞄准中判断是否射击</p>
<ul>
<li><p>在播放完”停止瞄准“动画之后判断是否在射击</p>
</li>
<li><p>如果没在射击，就返回放松状态，否则就不变</p>
</li>
<li><p>实现的是：瞄准射击之后，放弃瞄准，但依旧可以普通射击</p>
</li>
</ul>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/02/%E6%9C%89%E5%85%B3%E7%AE%97%E6%B3%95%E4%B8%AD%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88%E4%B8%89%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="williny">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Williny'home">
      <meta itemprop="description" content="孤独是人生的常态">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Williny'home">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/06/02/%E6%9C%89%E5%85%B3%E7%AE%97%E6%B3%95%E4%B8%AD%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88%E4%B8%89%EF%BC%89/" class="post-title-link" itemprop="url">有关算法中的二叉树（三）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-06-02 08:35:02" itemprop="dateCreated datePublished" datetime="2022-06-02T08:35:02+08:00">2022-06-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-07-05 10:40:25" itemprop="dateModified" datetime="2022-07-05T10:40:25+08:00">2022-07-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="二叉搜索树中的搜索"><a href="#二叉搜索树中的搜索" class="headerlink" title="二叉搜索树中的搜索"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/search-in-a-binary-search-tree/">二叉搜索树中的搜索</a></h1><p>给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。</p>
<p>例如，</p>
<p><img src="https://img-blog.csdnimg.cn/20210204155522476.png" alt="700.二叉搜索树中的搜索"></p>
<p>在上述示例中，如果要找的值是 5，但因为没有节点值为 5，我们应该返回 NULL。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>之前我们讲了都是普通二叉树，那么接下来看看二叉搜索树。</p>
<p>在<a target="_blank" rel="noopener" href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">关于二叉树，你该了解这些！</a>中，我们已经讲过了二叉搜索树。</p>
<p>二叉搜索树是一个有序树：</p>
<ul>
<li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li>
<li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li>
<li>它的左、右子树也分别为二叉搜索树</li>
</ul>
<p>这就决定了，二叉搜索树，递归遍历和迭代遍历和普通二叉树都不一样。</p>
<p>本题，其实就是在二叉搜索树中搜索一个节点。那么我们来看看应该如何遍历。</p>
<h3 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h3><ol>
<li>确定递归函数的参数和返回值</li>
</ol>
<p>递归函数的参数传入的就是根节点和要搜索的数值，返回的就是以这个搜索数值所在的节点。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">searchBST</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span></span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>确定终止条件</li>
</ol>
<p>如果root为空，或者找到这个数值了，就返回root节点。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span> || root-&gt;val == val) <span class="keyword">return</span> root;</span><br></pre></td></tr></table></figure>

<p>看看二叉搜索树的单层递归逻辑有何不同。</p>
<p>因为二叉搜索树的节点是有序的，所以可以有方向的去搜索。</p>
<p>如果root-&gt;val &gt; val，搜索左子树，如果root-&gt;val &lt; val，就搜索右子树，最后如果都没有搜索到，就返回NULL。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (root-&gt;val &gt; val) <span class="keyword">return</span> <span class="built_in">searchBST</span>(root-&gt;left, val); <span class="comment">// 注意这里加了return</span></span><br><span class="line"><span class="keyword">if</span> (root-&gt;val &lt; val) <span class="keyword">return</span> <span class="built_in">searchBST</span>(root-&gt;right, val);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>这里可能会疑惑，在递归遍历的时候，什么时候直接return 递归函数的返回值，什么时候不用加这个 return呢。</p>
<p>我们在<a target="_blank" rel="noopener" href="https://programmercarl.com/0112.%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C.html">二叉树：递归函数究竟什么时候需要返回值，什么时候不要返回值？ </a>中讲了，<mark>如果要搜索一条边，递归函数就要加返回值</mark>，这里也是一样的道理。</p>
<p><strong>因为搜索到目标节点了，就要立即return了，这样才是找到节点就返回（搜索某一条边），如果不加return，就是遍历整棵树了。</strong></p>
<p>整体代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">searchBST</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span> || root-&gt;val == val) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &gt; val) <span class="keyword">return</span> <span class="built_in">searchBST</span>(root-&gt;left, val);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &lt; val) <span class="keyword">return</span> <span class="built_in">searchBST</span>(root-&gt;right, val);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h2><p>一提到二叉树遍历的迭代法，可能立刻想起使用栈来模拟深度遍历，使用队列来模拟广度遍历。</p>
<p>对于二叉搜索树可就不一样了，因为二叉搜索树的特殊性，也就是节点的有序性，可以不使用辅助栈或者队列就可以写出迭代法。</p>
<p>对于一般二叉树，递归过程中还有回溯的过程，例如走一个左方向的分支走到头了，那么要调头，在走右分支。</p>
<p>而<strong>对于二叉搜索树，不需要回溯的过程，因为节点的有序性就帮我们确定了搜索的方向。</strong></p>
<p>例如要搜索元素为3的节点，<strong>我们不需要搜索其他节点，也不需要做回溯，查找的路径已经规划好了。</strong></p>
<p>中间节点如果大于3就向左走，如果小于3就向右走，如图：</p>
<p><img src="https://img-blog.csdnimg.cn/20200812190213280.png" alt="二叉搜索树"></p>
<p>所以迭代法代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">searchBST</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;val &gt; val) root = root-&gt;left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;val &lt; val) root = root-&gt;right;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="验证二叉搜索树"><a href="#验证二叉搜索树" class="headerlink" title="验证二叉搜索树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/validate-binary-search-tree/">验证二叉搜索树</a></h1><p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p>
<p>假设一个二叉搜索树具有如下特征：</p>
<ul>
<li>节点的左子树只包含小于当前节点的数。</li>
<li>节点的右子树只包含大于当前节点的数。</li>
<li>所有左子树和右子树自身必须也是二叉搜索树。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20210203144334501.png" alt="98.验证二叉搜索树"></p>
<h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>要知道中序遍历下，输出的二叉搜索树节点的数值是有序序列。</p>
<p>有了这个特性，<strong>验证二叉搜索树，就相当于变成了判断一个序列是不是递增的了。</strong></p>
<h3 id="递归法-1"><a href="#递归法-1" class="headerlink" title="递归法"></a>递归法</h3><p>可以递归中序遍历将二叉搜索树转变成一个数组，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">traversal</span>(root-&gt;left);</span><br><span class="line">    vec.<span class="built_in">push_back</span>(root-&gt;val); <span class="comment">// 将二叉搜索树转换为有序数组</span></span><br><span class="line">    <span class="built_in">traversal</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后只要比较一下，这个数组是否是有序的，<strong>注意二叉搜索树中不能有重复元素</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">traversal</span>(root);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; vec.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="comment">// 注意要小于等于，搜索树里不能有相同元素</span></span><br><span class="line">    <span class="keyword">if</span> (vec[i] &lt;= vec[i - <span class="number">1</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<p>整体代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">traversal</span>(root-&gt;left);</span><br><span class="line">        vec.<span class="built_in">push_back</span>(root-&gt;val); <span class="comment">// 将二叉搜索树转换为有序数组</span></span><br><span class="line">        <span class="built_in">traversal</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vec.<span class="built_in">clear</span>(); <span class="comment">// 不加这句在leetcode上也可以过，但最好加上</span></span><br><span class="line">        <span class="built_in">traversal</span>(root);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; vec.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 注意要小于等于，搜索树里不能有相同元素</span></span><br><span class="line">            <span class="keyword">if</span> (vec[i] &lt;= vec[i - <span class="number">1</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>以上代码中，我们把二叉树转变为数组来判断，是最直观的，但其实不用转变成数组，可以在递归遍历的过程中直接判断是否有序。</p>
<p>这道题目比较容易陷入两个陷阱：</p>
<ul>
<li>陷阱1</li>
</ul>
<p><strong>不能单纯的比较左节点小于中间节点，右节点大于中间节点就完事了</strong>。</p>
<p>写出了类似这样的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (root-&gt;val &gt; root-&gt;left-&gt;val &amp;&amp; root-&gt;val &lt; root-&gt;right-&gt;val) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们要比较的是 <strong>左子树所有节点小于中间节点，右子树所有节点大于中间节点</strong>。所以以上代码的判断逻辑是错误的。</p>
<p>例如： [10,5,15,null,null,6,20] 这个case：</p>
<p><img src="https://img-blog.csdnimg.cn/20200812191501419.png" alt="二叉搜索树"></p>
<p>节点10大于左节点5，小于右节点15，但右子树里出现了一个6 这就不符合了！</p>
<ul>
<li>陷阱2</li>
</ul>
<p>样例中最小节点 可能是int的最小值，如果这样使用最小的int来比较也是不行的。</p>
<p>此时可以初始化比较元素为longlong的最小值。</p>
<p>问题可以进一步演进：如果样例中根节点的val 可能是longlong的最小值 又要怎么办呢？文中会解答。</p>
<p>了解这些陷阱之后我们来看一下代码应该怎么写：</p>
<p>递归三部曲：</p>
<ul>
<li>确定递归函数，返回值以及参数</li>
</ul>
<p>要定义一个longlong的全局变量，用来比较遍历的节点是否有序，因为后台测试数据中有int最小值，所以定义为longlong的类型，初始化为longlong最小值。</p>
<p>注意递归函数要有bool类型的返回值， 我们在<a target="_blank" rel="noopener" href="https://programmercarl.com/0112.%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C.html">二叉树：递归函数究竟什么时候需要返回值，什么时候不要返回值？</a>中讲了，只有寻找某一条边（或者一个节点）的时候，递归函数会有bool类型的返回值。</p>
<p>其实本题是同样的道理，我们在寻找一个不符合条件的节点，如果没有找到这个节点就遍历了整个树，如果找到不符合的节点了，立刻返回。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">long</span> maxVal = LONG_MIN; <span class="comment">// 因为后台测试数据中有int最小值</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>确定终止条件</li>
</ul>
<p>如果是空节点 是不是二叉搜索树呢？</p>
<p>是的，二叉搜索树也可以为空！</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>确定单层递归的逻辑</li>
</ul>
<p>中序遍历，一直更新maxVal，一旦发现maxVal &gt;&#x3D; root-&gt;val，就返回false，注意元素相同时候也要返回false。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> left = <span class="built_in">isValidBST</span>(root-&gt;left);         <span class="comment">// 左</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 中序遍历，验证遍历的元素是不是从小到大</span></span><br><span class="line"><span class="keyword">if</span> (maxVal &lt; root-&gt;val) maxVal = root-&gt;val; <span class="comment">// 中</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> right = <span class="built_in">isValidBST</span>(root-&gt;right);       <span class="comment">// 右</span></span><br><span class="line"><span class="keyword">return</span> left &amp;&amp; right;</span><br></pre></td></tr></table></figure>

<p>整体代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> maxVal = LONG_MIN; <span class="comment">// 因为后台测试数据中有int最小值</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> left = <span class="built_in">isValidBST</span>(root-&gt;left);</span><br><span class="line">        <span class="comment">// 中序遍历，验证遍历的元素是不是从小到大</span></span><br><span class="line">        <span class="keyword">if</span> (maxVal &lt; root-&gt;val) maxVal = root-&gt;val;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">bool</span> right = <span class="built_in">isValidBST</span>(root-&gt;right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> left &amp;&amp; right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>以上代码是因为后台数据有int最小值测试用例，所以都把maxVal改成了longlong最小值。</p>
<p>如果测试数据中有 longlong的最小值，怎么办？</p>
<p>不可能在初始化一个更小的值了吧。 建议避免 初始化最小值，如下方法取到最左面节点的数值来比较。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode* pre = <span class="literal">NULL</span>; <span class="comment">// 用来记录前一个节点</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">bool</span> left = <span class="built_in">isValidBST</span>(root-&gt;left);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pre != <span class="literal">NULL</span> &amp;&amp; pre-&gt;val &gt;= root-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        pre = root; <span class="comment">// 记录前一个节点</span></span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> right = <span class="built_in">isValidBST</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> left &amp;&amp; right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="二叉搜索树的最小绝对差"><a href="#二叉搜索树的最小绝对差" class="headerlink" title="二叉搜索树的最小绝对差"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-absolute-difference-in-bst/">二叉搜索树的最小绝对差</a></h1><p>给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。</p>
<p>示例：</p>
<p><img src="https://img-blog.csdnimg.cn/20201014223400123.png" alt="530二叉搜索树的最小绝对差"></p>
<p>提示：树中至少有 2 个节点。</p>
<h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>题目中要求在二叉搜索树上任意两节点的差的绝对值的最小值。</p>
<p><strong>注意是二叉搜索树</strong>，二叉搜索树可是有序的。</p>
<p>遇到在二叉搜索树上求什么最值啊，差值之类的，就把它想成在一个有序数组上求最值，求差值，这样就简单多了。</p>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>那么二叉搜索树采用中序遍历，其实就是一个有序数组。</p>
<p><strong>在一个有序数组上求两个数最小差值，这是不是就是一道送分题了。</strong></p>
<p>最直观的想法，就是把二叉搜索树转换成有序数组，然后遍历一遍数组，就统计出来最小差值了。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">traversal</span>(root-&gt;left);</span><br><span class="line">    vec.<span class="built_in">push_back</span>(root-&gt;val); <span class="comment">// 将二叉搜索树转换为有序数组</span></span><br><span class="line">    <span class="built_in">traversal</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMinimumDifference</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vec.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="built_in">traversal</span>(root);</span><br><span class="line">        <span class="keyword">if</span> (vec.<span class="built_in">size</span>() &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> result = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; vec.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 统计有序数组的最小差值</span></span><br><span class="line">            result = <span class="built_in">min</span>(result, vec[i] - vec[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>以上代码是把二叉搜索树转化为有序数组了，其实在二叉搜素树中序遍历的过程中，我们就可以直接计算了。</p>
<p>需要用一个pre节点记录一下cur节点的前一个节点。</p>
<p>如图：</p>
<p><img src="https://img-blog.csdnimg.cn/20210204153247458.png" alt="530.二叉搜索树的最小绝对差"></p>
<p>一些同学不知道在递归中如何记录前一个节点的指针，其实实现起来是很简单的，大家只要看过一次，写过一次，就掌握了。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> result = INT_MAX;</span><br><span class="line">TreeNode* pre;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;left);   <span class="comment">// 左</span></span><br><span class="line">    <span class="keyword">if</span> (pre != <span class="literal">NULL</span>)&#123;       <span class="comment">// 中</span></span><br><span class="line">        result = <span class="built_in">min</span>(result, cur-&gt;val - pre-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">    pre = cur; <span class="comment">// 记录前一个</span></span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;right);  <span class="comment">// 右</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMinimumDifference</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">traversal</span>(root);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p>看过这两篇<a target="_blank" rel="noopener" href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86.html">二叉树：听说递归能做的，栈也能做！</a><a target="_blank" rel="noopener" href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%BB%9F%E4%B8%80%E8%BF%AD%E4%BB%A3%E6%B3%95.html">二叉树：前中后序迭代方式的写法就不能统一一下么？</a></p>
<p>文章之后，不难写出两种中序遍历的迭代法。</p>
<p>下面我给出其中的一种中序遍历的迭代法，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMinimumDifference</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line">        TreeNode* pre = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="type">int</span> result = INT_MAX;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">NULL</span> || !st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur != <span class="literal">NULL</span>) &#123; <span class="comment">// 指针来访问节点，访问到最底层</span></span><br><span class="line">                st.<span class="built_in">push</span>(cur); <span class="comment">// 将访问的节点放进栈</span></span><br><span class="line">                cur = cur-&gt;left;                <span class="comment">// 左</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (pre != <span class="literal">NULL</span>) &#123;              <span class="comment">// 中</span></span><br><span class="line">                    result = <span class="built_in">min</span>(result, cur-&gt;val - pre-&gt;val);</span><br><span class="line">                &#125;</span><br><span class="line">                pre = cur;</span><br><span class="line">                cur = cur-&gt;right;               <span class="comment">// 右</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>遇到在二叉搜索树上求什么最值，求差值之类的，都要思考一下二叉搜索树可是有序的，要利用好这一特点。</strong></p>
<p>同时要学会在递归遍历的过程中如何记录前后两个指针，这也是一个小技巧，学会了还是很受用的。</p>
<h1 id="二叉搜索树中的众数"><a href="#二叉搜索树中的众数" class="headerlink" title="二叉搜索树中的众数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-mode-in-binary-search-tree/">二叉搜索树中的众数</a></h1><p>给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。</p>
<p>假定 BST 有如下定义：</p>
<ul>
<li>结点左子树中所含结点的值小于等于当前结点的值</li>
<li>结点右子树中所含结点的值大于等于当前结点的值</li>
<li>左子树和右子树都是二叉搜索树</li>
</ul>
<p>例如：</p>
<p>给定 BST [1,null,2,2],</p>
<p><img src="https://img-blog.csdnimg.cn/20201014221532206.png" alt="501. 二叉搜索树中的众数"></p>
<p>返回[2].</p>
<p>提示：如果众数超过1个，不需考虑输出顺序</p>
<p>进阶：你可以不使用额外的空间吗？（假设由递归产生的隐式调用栈的开销不被计算在内</p>
<h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>这道题目呢，递归法我从两个维度来讲。</p>
<p>首先如果不是二叉搜索树的话，应该怎么解题，是二叉搜索树，又应该如何解题，两种方式做一个比较，可以加深大家对二叉树的理解。</p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h3 id="递归法-2"><a href="#递归法-2" class="headerlink" title="递归法"></a>递归法</h3><h4 id="如果不是二叉搜索树"><a href="#如果不是二叉搜索树" class="headerlink" title="如果不是二叉搜索树"></a>如果不是二叉搜索树</h4><p>如果不是二叉搜索树，最直观的方法一定是把这个树都遍历了，用map统计频率，把频率排个序，最后取前面高频的元素的集合。</p>
<p>具体步骤如下：</p>
<ol>
<li>这个树都遍历了，用map统计频率</li>
</ol>
<p>至于用前中后序那种遍历也不重要，因为就是要全遍历一遍，怎么个遍历法都行，层序遍历都没毛病！</p>
<p>这里采用前序遍历，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// map&lt;int, int&gt; key:元素，value:出现频率</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">searchBST</span><span class="params">(TreeNode* cur, unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; map)</span> </span>&#123; <span class="comment">// 前序遍历</span></span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    map[cur-&gt;val]++; <span class="comment">// 统计元素频率</span></span><br><span class="line">    <span class="built_in">searchBST</span>(cur-&gt;left, map);</span><br><span class="line">    <span class="built_in">searchBST</span>(cur-&gt;right, map);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>把统计的出来的出现频率（即map中的value）排个序</li>
</ol>
<p>有的同学可能可以想直接对map中的value排序，还真做不到，C++中如果使用std::map或者std::multimap可以对key排序，但不能对value排序。</p>
<p>所以要把map转化数组即vector，再进行排序，当然vector里面放的也是<code>pair&lt;int, int&gt;</code>类型的数据，第一个int为元素，第二个int为出现频率。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="type">static</span> <span class="title">cmp</span> <span class="params">(<span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; a, <span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.second &gt; b.second; <span class="comment">// 按照频率从大到小排序</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; <span class="built_in">vec</span>(map.<span class="built_in">begin</span>(), map.<span class="built_in">end</span>());</span><br><span class="line"><span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), cmp); <span class="comment">// 给频率排个序</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>取前面高频的元素</li>
</ol>
<p>此时数组vector中已经是存放着按照频率排好序的pair，那么把前面高频的元素取出来就可以了。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">result.<span class="built_in">push_back</span>(vec[<span class="number">0</span>].first);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; vec.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="comment">// 取最高的放到result数组中</span></span><br><span class="line">    <span class="keyword">if</span> (vec[i].second == vec[<span class="number">0</span>].second) result.<span class="built_in">push_back</span>(vec[i].first);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure>

<p>整体C++代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">searchBST</span><span class="params">(TreeNode* cur, unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; map)</span> </span>&#123; <span class="comment">// 前序遍历</span></span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    map[cur-&gt;val]++; <span class="comment">// 统计元素频率</span></span><br><span class="line">    <span class="built_in">searchBST</span>(cur-&gt;left, map);</span><br><span class="line">    <span class="built_in">searchBST</span>(cur-&gt;right, map);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="type">static</span> <span class="title">cmp</span> <span class="params">(<span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; a, <span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.second &gt; b.second;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findMode</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; map; <span class="comment">// key:元素，value:出现频率</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> result;</span><br><span class="line">        <span class="built_in">searchBST</span>(root, map);</span><br><span class="line">        vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; <span class="built_in">vec</span>(map.<span class="built_in">begin</span>(), map.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), cmp); <span class="comment">// 给频率排个序</span></span><br><span class="line">        result.<span class="built_in">push_back</span>(vec[<span class="number">0</span>].first);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; vec.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 取最高的放到result数组中</span></span><br><span class="line">            <span class="keyword">if</span> (vec[i].second == vec[<span class="number">0</span>].second) result.<span class="built_in">push_back</span>(vec[i].first);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>所以如果本题没有说是二叉搜索树的话，那么就按照上面的思路写！</strong></p>
<h3 id="是二叉搜索树"><a href="#是二叉搜索树" class="headerlink" title="是二叉搜索树"></a>是二叉搜索树</h3><p><strong>既然是搜索树，它中序遍历就是有序的</strong>。</p>
<p>如图：</p>
<p><img src="https://img-blog.csdnimg.cn/20210204152758889.png" alt="501.二叉搜索树中的众数1"></p>
<p>中序遍历代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">searchBST</span><span class="params">(TreeNode* cur)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">searchBST</span>(cur-&gt;left);       <span class="comment">// 左</span></span><br><span class="line">    （处理节点）                <span class="comment">// 中</span></span><br><span class="line">    <span class="built_in">searchBST</span>(cur-&gt;right);      <span class="comment">// 右</span></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遍历有序数组的元素出现频率，从头遍历，那么一定是相邻两个元素作比较，然后就把出现频率最高的元素输出就可以了。</p>
<p>关键是在有序数组上的话，好搞，在树上怎么搞呢？</p>
<p>这就考察对树的操作了。</p>
<p>在<a target="_blank" rel="noopener" href="https://programmercarl.com/0530.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE.html">二叉树：搜索树的最小绝对差</a>中我们就使用了pre指针和cur指针的技巧，这次又用上了。</p>
<p>弄一个指针指向前一个节点，这样每次cur（当前节点）才能和pre（前一个节点）作比较。</p>
<p>而且初始化的时候pre &#x3D; NULL，这样当pre为NULL时候，我们就知道这是比较的第一个元素。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (pre == <span class="literal">NULL</span>) &#123; <span class="comment">// 第一个节点</span></span><br><span class="line">    count = <span class="number">1</span>; <span class="comment">// 频率为1</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pre-&gt;val == cur-&gt;val) &#123; <span class="comment">// 与前一个节点数值相同</span></span><br><span class="line">    count++;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 与前一个节点数值不同</span></span><br><span class="line">    count = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">pre = cur; <span class="comment">// 更新上一个节点</span></span><br></pre></td></tr></table></figure>

<p>此时又有问题了，因为要求最大频率的元素集合（注意是集合，不是一个元素，可以有多个众数），如果是数组上大家一般怎么办？</p>
<p>应该是先遍历一遍数组，找出最大频率（maxCount），然后再重新遍历一遍数组把出现频率为maxCount的元素放进集合。（因为众数有多个）</p>
<p>这种方式遍历了两遍数组。</p>
<p>那么我们遍历两遍二叉搜索树，把众数集合算出来也是可以的。</p>
<p>但这里其实只需要遍历一次就可以找到所有的众数。</p>
<p>那么如何只遍历一遍呢？</p>
<p>如果 频率count 等于 maxCount（最大频率），当然要把这个元素加入到结果集中（以下代码为result数组），代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (count == maxCount) &#123; <span class="comment">// 如果和最大值相同，放进result中</span></span><br><span class="line">    result.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>是不是感觉这里有问题，result怎么能轻易就把元素放进去了呢，万一，这个maxCount此时还不是真正最大频率呢。</p>
<p>所以下面要做如下操作：</p>
<p>频率count 大于 maxCount的时候，不仅要更新maxCount，而且要清空结果集（以下代码为result数组），因为结果集之前的元素都失效了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (count &gt; maxCount) &#123; <span class="comment">// 如果计数大于最大值</span></span><br><span class="line">    maxCount = count;   <span class="comment">// 更新最大频率</span></span><br><span class="line">    result.<span class="built_in">clear</span>();     <span class="comment">// 很关键的一步，不要忘记清空result，之前result里的元素都失效了</span></span><br><span class="line">    result.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关键代码都讲完了，完整代码如下：（<strong>只需要遍历一遍二叉搜索树，就求出了众数的集合</strong>）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> maxCount; <span class="comment">// 最大频率</span></span><br><span class="line">    <span class="type">int</span> count; <span class="comment">// 统计频率</span></span><br><span class="line">    TreeNode* pre;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">searchBST</span><span class="params">(TreeNode* cur)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">searchBST</span>(cur-&gt;left);       <span class="comment">// 左</span></span><br><span class="line">                                    <span class="comment">// 中</span></span><br><span class="line">        <span class="keyword">if</span> (pre == <span class="literal">NULL</span>) &#123; <span class="comment">// 第一个节点</span></span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pre-&gt;val == cur-&gt;val) &#123; <span class="comment">// 与前一个节点数值相同</span></span><br><span class="line">            count++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 与前一个节点数值不同</span></span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = cur; <span class="comment">// 更新上一个节点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (count == maxCount) &#123; <span class="comment">// 如果和最大值相同，放进result中</span></span><br><span class="line">            result.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (count &gt; maxCount) &#123; <span class="comment">// 如果计数大于最大值频率</span></span><br><span class="line">            maxCount = count;   <span class="comment">// 更新最大频率</span></span><br><span class="line">            result.<span class="built_in">clear</span>();     <span class="comment">// 很关键的一步，不要忘记清空result，之前result里的元素都失效了</span></span><br><span class="line">            result.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">searchBST</span>(cur-&gt;right);      <span class="comment">// 右</span></span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findMode</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        maxCount = <span class="number">0</span>;</span><br><span class="line">        TreeNode* pre = <span class="literal">NULL</span>; <span class="comment">// 记录前一个节点</span></span><br><span class="line">        result.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">searchBST</span>(root);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="二叉树的最近公共祖先"><a href="#二叉树的最近公共祖先" class="headerlink" title="二叉树的最近公共祖先"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">二叉树的最近公共祖先</a></h1><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
<p>例如，给定如下二叉树:  root &#x3D; [3,5,1,6,2,0,8,null,null,7,4]</p>
<p><img src="https://img-blog.csdnimg.cn/20201016173414722.png" alt="236. 二叉树的最近公共祖先"></p>
<p>示例 1: </p>
<p>输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 1 </p>
<p>输出: 3 </p>
<p>解释: 节点 5 和节点 1 的最近公共祖先是节点 3。</p>
<p>示例 2: 输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 4 </p>
<p>输出: 5 </p>
<p>解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。</p>
<p>说明:</p>
<ul>
<li>所有节点的值都是唯一的。</li>
<li>p、q 为不同节点且均存在于给定的二叉树中。</li>
</ul>
<h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>遇到这个题目首先想的是要是能自底向上查找就好了，这样就可以找到公共祖先了。</p>
<p>那么二叉树如何可以自底向上查找呢？</p>
<p>回溯啊，二叉树回溯的过程就是从低到上。</p>
<p>后序遍历就是天然的回溯过程，最先处理的一定是叶子节点。</p>
<p>接下来就看如何判断一个节点是节点q和节点p的公共公共祖先呢。</p>
<p><strong>首先最容易想到的一个情况：如果找到一个节点，发现左子树出现结点p，右子树出现节点q，或者 左子树出现结点q，右子树出现节点p，那么该节点就是节点p和q的最近公共祖先。</strong></p>
<p><strong>但是很多人容易忽略一个情况，就是节点本身p(q)，它拥有一个子孙节点q(p)。</strong></p>
<p>使用后序遍历，回溯的过程，就是从低向上遍历节点，一旦发现满足第一种情况的节点，就是最近公共节点了。</p>
<p><strong>但是如果p或者q本身就是最近公共祖先呢？其实只需要找到一个节点是p或者q的时候，直接返回当前节点，无需继续递归子树。如果接下来的遍历中找到了后继节点满足第一种情况则修改返回值为后继节点，否则，继续返回已找到的节点即可。为什么满足第一种情况的节点一定是p或q的后继节点呢?大家可以仔细思考一下。</strong></p>
<p>递归三部曲：</p>
<ul>
<li>确定递归函数返回值以及参数</li>
</ul>
<p>需要递归函数返回值，来告诉我们是否找到节点q或者p，那么返回值为bool类型就可以了。</p>
<p>但我们还要返回最近公共节点，可以利用上题目中返回值是TreeNode * ，那么如果遇到p或者q，就把q或者p返回，返回值不为空，就说明找到了q或者p。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>确定终止条件</li>
</ul>
<p>如果找到了 节点p或者q，或者遇到空节点，就返回。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (root == q || root == p || root == <span class="literal">NULL</span>) <span class="keyword">return</span> root;</span><br></pre></td></tr></table></figure>

<ul>
<li>确定单层递归逻辑</li>
</ul>
<p>值得注意的是 本题函数有返回值，是因为回溯的过程需要递归函数的返回值做判断，但本题我们依然要遍历树的所有节点。</p>
<p>我们在<a target="_blank" rel="noopener" href="https://programmercarl.com/0112.%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C.html">二叉树：递归函数究竟什么时候需要返回值，什么时候不要返回值？</a>中说了 递归函数有返回值就是要遍历某一条边，但有返回值也要看如何处理返回值！</p>
<p>如果递归函数有返回值，如何区分要搜索一条边，还是搜索整个树呢？</p>
<p>搜索一条边的写法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (递归函数(root-&gt;left)) <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (递归函数(root-&gt;right)) <span class="keyword">return</span> ;</span><br></pre></td></tr></table></figure>

<p>搜索整个树写法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">left = 递归函数(root-&gt;left);</span><br><span class="line">right = 递归函数(root-&gt;right);</span><br><span class="line">left与right的逻辑处理;</span><br></pre></td></tr></table></figure>

<p>看出区别了没？</p>
<p><strong>在递归函数有返回值的情况下：如果要搜索一条边，递归函数返回值不为空的时候，立刻返回，如果搜索整个树，直接用一个变量left、right接住返回值，这个left、right后序还有逻辑处理的需要，也就是后序遍历中处理中间节点的逻辑（也是回溯）</strong>。</p>
<p>那么为什么要遍历整棵树呢？直观上来看，找到最近公共祖先，直接一路返回就可以了。</p>
<p>如图：</p>
<p><img src="https://img-blog.csdnimg.cn/2021020415105872.png" alt="236.二叉树的最近公共祖先"></p>
<p>就像图中一样直接返回7，多美滋滋。</p>
<p>但事实上还要遍历根节点右子树（即使此时已经找到了目标节点了），也就是图中的节点4、15、20。</p>
<p>因为在如下代码的后序遍历中，如果想利用left和right做逻辑处理， 不能立刻返回，而是要等left与right逻辑处理完之后才能返回。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">left = 递归函数(root-&gt;left);</span><br><span class="line">right = 递归函数(root-&gt;right);</span><br><span class="line">left与right的逻辑处理;</span><br></pre></td></tr></table></figure>

<p>所以此时大家要知道我们要遍历整棵树。知道这一点，对本题就有一定深度的理解了。</p>
<p>那么先用left和right接住左子树和右子树的返回值，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* left = <span class="built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);</span><br><span class="line">TreeNode* right = <span class="built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);</span><br></pre></td></tr></table></figure>

<p><strong>如果left 和 right都不为空，说明此时root就是最近公共节点。这个比较好理解</strong></p>
<p><strong>如果left为空，right不为空，就返回right，说明目标节点是通过right返回的，反之依然</strong>。</p>
<p>这里有的同学就理解不了了，为什么left为空，right不为空，目标节点通过right返回呢？</p>
<p>如图：</p>
<p><img src="https://img-blog.csdnimg.cn/20210204151125844.png" alt="236.二叉树的最近公共祖先1"></p>
<p>图中节点10的左子树返回null，右子树返回目标值7，那么此时节点10的处理逻辑就是把右子树的返回值（最近公共祖先7）返回上去！</p>
<p>这里点也很重要，可能刷过这道题目的同学，都不清楚结果究竟是如何从底层一层一层传到头结点的。</p>
<p>那么如果left和right都为空，则返回left或者right都是可以的，也就是返回空。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (left == <span class="literal">NULL</span> &amp;&amp; right != <span class="literal">NULL</span>) <span class="keyword">return</span> right;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (left != <span class="literal">NULL</span> &amp;&amp; right == <span class="literal">NULL</span>) <span class="keyword">return</span> left;</span><br><span class="line"><span class="keyword">else</span>  &#123; <span class="comment">//  (left == NULL &amp;&amp; right == NULL)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么寻找最小公共祖先，完整流程图如下：</p>
<p><img src="https://img-blog.csdnimg.cn/202102041512582.png" alt="236.二叉树的最近公共祖先2"></p>
<p><strong>从图中，大家可以看到，我们是如何回溯遍历整棵二叉树，将结果返回给头结点的！</strong></p>
<p>整体代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == q || root == p || root == <span class="literal">NULL</span>) <span class="keyword">return</span> root;</span><br><span class="line">        TreeNode* left = <span class="built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);</span><br><span class="line">        TreeNode* right = <span class="built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);</span><br><span class="line">        <span class="keyword">if</span> (left != <span class="literal">NULL</span> &amp;&amp; right != <span class="literal">NULL</span>) <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left == <span class="literal">NULL</span> &amp;&amp; right != <span class="literal">NULL</span>) <span class="keyword">return</span> right;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left != <span class="literal">NULL</span> &amp;&amp; right == <span class="literal">NULL</span>) <span class="keyword">return</span> left;</span><br><span class="line">        <span class="keyword">else</span>  &#123; <span class="comment">//  (left == NULL &amp;&amp; right == NULL)</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>这道题目刷过的同学未必真正了解这里面回溯的过程，以及结果是如何一层一层传上去的。</p>
<p><strong>那么我给大家归纳如下三点</strong>：</p>
<ol>
<li><p>求最小公共祖先，需要从底向上遍历，那么二叉树，只能通过后序遍历（即：回溯）实现从低向上的遍历方式。</p>
</li>
<li><p>在回溯的过程中，必然要遍历整棵二叉树，即使已经找到结果了，依然要把其他节点遍历完，因为要使用递归函数的返回值（也就是代码中的left和right）做逻辑判断。</p>
</li>
<li><p>要理解如果返回值left为空，right不为空为什么要返回right，为什么可以用返回right传给上一层结果。</p>
</li>
</ol>
<p>可以说这里每一步，都是有难度的，都需要对二叉树，递归和回溯有一定的理解。</p>
<p>本题没有给出迭代法，因为迭代法不适合模拟回溯的过程。理解递归的解法就够了。</p>
<h1 id="二叉搜索树的最近公共祖先"><a href="#二叉搜索树的最近公共祖先" class="headerlink" title="二叉搜索树的最近公共祖先"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/">二叉搜索树的最近公共祖先</a></h1><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
<p>例如，给定如下二叉搜索树:  root &#x3D; [6,2,8,0,4,7,9,null,null,3,5]</p>
<p><img src="https://img-blog.csdnimg.cn/20201018172243602.png" alt="235. 二叉搜索树的最近公共祖先"></p>
<p>示例 1:</p>
<ul>
<li>输入: root &#x3D; [6,2,8,0,4,7,9,null,null,3,5], p &#x3D; 2, q &#x3D; 8</li>
<li>输出: 6</li>
<li>解释: 节点 2 和节点 8 的最近公共祖先是 6。</li>
</ul>
<p>示例 2:</p>
<ul>
<li>输入: root &#x3D; [6,2,8,0,4,7,9,null,null,3,5], p &#x3D; 2, q &#x3D; 4</li>
<li>输出: 2</li>
<li>解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。</li>
</ul>
<p>说明:</p>
<ul>
<li>所有节点的值都是唯一的。</li>
<li>p、q 为不同节点且均存在于给定的二叉搜索树中。</li>
</ul>
<h2 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h2><p>做过<a target="_blank" rel="noopener" href="https://programmercarl.com/0236.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html">二叉树：公共祖先问题</a>题目的同学应该知道，利用回溯从底向上搜索，遇到一个节点的左子树里有p，右子树里有q，那么当前节点就是最近公共祖先。</p>
<p>那么本题是二叉搜索树，二叉搜索树是有序的，那得好好利用一下这个特点。</p>
<p>在有序树里，如果判断一个节点的左子树里有p，右子树里有q呢？</p>
<p>其实只要从上到下遍历的时候，cur节点是数值在[p, q]区间中则说明该节点cur就是最近公共祖先了。</p>
<p>理解这一点，本题就很好解了。</p>
<p>和<a target="_blank" rel="noopener" href="https://programmercarl.com/0236.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html">二叉树：公共祖先问题</a>不同，普通二叉树求最近公共祖先需要使用回溯，从底向上来查找，二叉搜索树就不用了，因为搜索树有序（相当于自带方向），那么只要从上向下遍历就可以了。</p>
<p>那么我们可以采用前序遍历（其实这里没有中节点的处理逻辑，遍历顺序无所谓了）。</p>
<p>如图所示：p为节点3，q为节点5</p>
<p><img src="https://img-blog.csdnimg.cn/20210204150858927.png" alt="235.二叉搜索树的最近公共祖先"></p>
<p>可以看出直接按照指定的方向，就可以找到节点4，为最近公共祖先，而且不需要遍历整棵树，找到结果直接返回！</p>
<h2 id="递归法-3"><a href="#递归法-3" class="headerlink" title="递归法"></a>递归法</h2><p>递归三部曲如下：</p>
<ul>
<li>确定递归函数返回值以及参数</li>
</ul>
<p>参数就是当前节点，以及两个结点 p、q。</p>
<p>返回值是要返回最近公共祖先，所以是TreeNode * 。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">traversal</span><span class="params">(TreeNode* cur, TreeNode* p, TreeNode* q)</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>确定终止条件</li>
</ul>
<p>遇到空返回就可以了，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span> cur;</span><br></pre></td></tr></table></figure>

<p>其实都不需要这个终止条件，因为题目中说了p、q 为不同节点且均存在于给定的二叉搜索树中。也就是说一定会找到公共祖先的，所以并不存在遇到空的情况。</p>
<ul>
<li>确定单层递归的逻辑</li>
</ul>
<p>在遍历二叉搜索树的时候就是寻找区间[p-&gt;val, q-&gt;val]（注意这里是左闭右闭）</p>
<p>那么如果 cur-&gt;val 大于 p-&gt;val，同时 cur-&gt;val 大于q-&gt;val，那么就应该向左遍历（说明目标区间在左子树上）。</p>
<p><strong>需要注意的是此时不知道p和q谁大，所以两个都要判断</strong></p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (cur-&gt;val &gt; p-&gt;val &amp;&amp; cur-&gt;val &gt; q-&gt;val) &#123;</span><br><span class="line">    TreeNode* left = <span class="built_in">traversal</span>(cur-&gt;left, p, q);</span><br><span class="line">    <span class="keyword">if</span> (left != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>细心的同学会发现，在这里调用递归函数的地方，把递归函数的返回值left，直接return</strong>。</p>
<p>在<a target="_blank" rel="noopener" href="https://programmercarl.com/0236.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html">二叉树：公共祖先问题</a>中，如果递归函数有返回值，如何区分要搜索一条边，还是搜索整个树。</p>
<p>搜索一条边的写法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (递归函数(root-&gt;left)) <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">if</span> (递归函数(root-&gt;right)) <span class="keyword">return</span> ;</span><br></pre></td></tr></table></figure>

<p>搜索整个树写法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">left = 递归函数(root-&gt;left);</span><br><span class="line">right = 递归函数(root-&gt;right);</span><br><span class="line">left与right的逻辑处理;</span><br></pre></td></tr></table></figure>

<p>本题就是标准的搜索一条边的写法，遇到递归函数的返回值，如果不为空，立刻返回。</p>
<p>如果 cur-&gt;val 小于 p-&gt;val，同时 cur-&gt;val 小于 q-&gt;val，那么就应该向右遍历（目标区间在右子树）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (cur-&gt;val &lt; p-&gt;val &amp;&amp; cur-&gt;val &lt; q-&gt;val) &#123;</span><br><span class="line">    TreeNode* right = <span class="built_in">traversal</span>(cur-&gt;right, p, q);</span><br><span class="line">    <span class="keyword">if</span> (right != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>剩下的情况，就是cur节点在区间（p-&gt;val &lt;&#x3D; cur-&gt;val &amp;&amp; cur-&gt;val &lt;&#x3D; q-&gt;val）或者 （q-&gt;val &lt;&#x3D; cur-&gt;val &amp;&amp; cur-&gt;val &lt;&#x3D; p-&gt;val）中，那么cur就是最近公共祖先了，直接返回cur。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> cur;</span><br></pre></td></tr></table></figure>

<p>那么整体递归代码如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">traversal</span><span class="params">(TreeNode* cur, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span> cur;</span><br><span class="line">                                                        <span class="comment">// 中</span></span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;val &gt; p-&gt;val &amp;&amp; cur-&gt;val &gt; q-&gt;val) &#123;   <span class="comment">// 左</span></span><br><span class="line">            TreeNode* left = <span class="built_in">traversal</span>(cur-&gt;left, p, q);</span><br><span class="line">            <span class="keyword">if</span> (left != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;val &lt; p-&gt;val &amp;&amp; cur-&gt;val &lt; q-&gt;val) &#123;   <span class="comment">// 右</span></span><br><span class="line">            TreeNode* right = <span class="built_in">traversal</span>(cur-&gt;right, p, q);</span><br><span class="line">            <span class="keyword">if</span> (right != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">traversal</span>(root, p, q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="迭代法-1"><a href="#迭代法-1" class="headerlink" title="迭代法"></a>迭代法</h3><p>对于二叉搜索树的迭代法，大家应该在<a target="_blank" rel="noopener" href="https://programmercarl.com/0700.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2.html">二叉树：二叉搜索树登场！</a>就了解了。</p>
<p>利用其有序性，迭代的方式还是比较简单的，解题思路在递归中已经分析了。</p>
<p>迭代代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(root) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;val &gt; p-&gt;val &amp;&amp; root-&gt;val &gt; q-&gt;val) &#123;</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;val &lt; p-&gt;val &amp;&amp; root-&gt;val &lt; q-&gt;val) &#123;</span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="二叉搜索树中的插入操作"><a href="#二叉搜索树中的插入操作" class="headerlink" title="二叉搜索树中的插入操作"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/">二叉搜索树中的插入操作</a></h1><p>给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据保证，新值和原始二叉搜索树中的任意节点值都不同。</p>
<p>注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回任意有效的结果。</p>
<p><img src="https://img-blog.csdnimg.cn/20201019173259554.png" alt="701.二叉搜索树中的插入操作"></p>
<p>提示：</p>
<ul>
<li>给定的树上的节点数介于 0 和 10^4 之间</li>
<li>每个节点都有一个唯一整数值，取值范围从 0 到 10^8</li>
<li>-10^8 &lt;&#x3D; val &lt;&#x3D; 10^8</li>
<li>新值和原始二叉搜索树中的任意节点值都不同</li>
</ul>
<h2 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h2><p>其实这道题目其实是一道简单题目，<strong>但是题目中的提示：有多种有效的插入方式，还可以重构二叉搜索树，一下子吓退了不少人</strong>，瞬间感觉题目复杂了很多。</p>
<p>其实<strong>可以不考虑题目中提示所说的改变树的结构的插入方式。</strong></p>
<p>如下演示视频中可以看出：只要按照二叉搜索树的规则去遍历，遇到空节点就插入节点就可以了。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gnbk63ina5g30eo08waja.gif" alt="701.二叉搜索树中的插入操作"></p>
<p>例如插入元素10 ，需要找到末尾节点插入便可，一样的道理来插入元素15，插入元素0，插入元素6，<strong>需要调整二叉树的结构么？ 并不需要。</strong>。</p>
<p>只要遍历二叉搜索树，找到空节点 插入元素就可以了，那么这道题其实就简单了。</p>
<p>接下来就是遍历二叉搜索树的过程了。</p>
<h3 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h3><p>递归三部曲：</p>
<ul>
<li>确定递归函数参数以及返回值</li>
</ul>
<p>参数就是根节点指针，以及要插入元素，这里递归函数要不要有返回值呢？</p>
<p>可以有，也可以没有，但递归函数如果没有返回值的话，实现是比较麻烦的，下面也会给出其具体实现代码。</p>
<p><strong>有返回值的话，可以利用返回值完成新加入的节点与其父节点的赋值操作</strong>。（下面会进一步解释）</p>
<p>递归函数的返回类型为节点类型TreeNode * 。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">insertIntoBST</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>确定终止条件</li>
</ul>
<p>终止条件就是找到遍历的节点为null的时候，就是要插入节点的位置了，并把插入的节点返回。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    TreeNode* node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里把添加的节点返回给上一层，就完成了父子节点的赋值操作了，详细再往下看。</p>
<ul>
<li>确定单层递归的逻辑</li>
</ul>
<p>此时要明确，需要遍历整棵树么？</p>
<p>别忘了这是搜索树，遍历整棵搜索树简直是对搜索树的侮辱，哈哈。</p>
<p>搜索树是有方向了，可以根据插入元素的数值，决定递归方向。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (root-&gt;val &gt; val) root-&gt;left = <span class="built_in">insertIntoBST</span>(root-&gt;left, val);</span><br><span class="line"><span class="keyword">if</span> (root-&gt;val &lt; val) root-&gt;right = <span class="built_in">insertIntoBST</span>(root-&gt;right, val);</span><br><span class="line"><span class="keyword">return</span> root;  </span><br></pre></td></tr></table></figure>

<p><strong>到这里，大家应该能感受到，如何通过递归函数返回值完成了新加入节点的父子关系赋值操作了，下一层将加入节点返回，本层用root-&gt;left或者root-&gt;right将其接住</strong>。</p>
<p>整体代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">insertIntoBST</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            TreeNode* node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &gt; val) root-&gt;left = <span class="built_in">insertIntoBST</span>(root-&gt;left, val);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &lt; val) root-&gt;right = <span class="built_in">insertIntoBST</span>(root-&gt;right, val);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看出代码并不复杂。</p>
<p>刚刚说了递归函数不用返回值也可以，找到插入的节点位置，直接让其父节点指向插入节点，结束递归，也是可以的。</p>
<p>那么递归函数定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* parent; <span class="comment">// 记录遍历节点的父节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur, <span class="type">int</span> val)</span></span></span><br></pre></td></tr></table></figure>

<p>没有返回值，需要记录上一个节点（parent），遇到空节点了，就让parent左孩子或者右孩子指向新插入的节点。然后结束递归。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TreeNode* parent;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            TreeNode* node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">            <span class="keyword">if</span> (val &gt; parent-&gt;val) parent-&gt;right = node;</span><br><span class="line">            <span class="keyword">else</span> parent-&gt;left = node;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        parent = cur;</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;val &gt; val) <span class="built_in">traversal</span>(cur-&gt;left, val);</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;val &lt; val) <span class="built_in">traversal</span>(cur-&gt;right, val);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">insertIntoBST</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">traversal</span>(root, val);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看出还是麻烦一些的。</p>
<p>我之所以举这个例子，是想说明通过递归函数的返回值完成父子节点的赋值是可以带来便利的。</p>
<p><strong>网上千变一律的代码，可能会误导大家认为通过递归函数返回节点 这样的写法是天经地义，其实这里是有优化的！</strong></p>
<h3 id="迭代-1"><a href="#迭代-1" class="headerlink" title="迭代"></a>迭代</h3><p>再来看看迭代法，对二叉搜索树迭代写法不熟悉，可以看这篇：<a target="_blank" rel="noopener" href="https://programmercarl.com/0700.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2.html">二叉树：二叉搜索树登场！</a></p>
<p>在迭代法遍历的过程中，需要记录一下当前遍历的节点的父节点，这样才能做插入节点的操作。</p>
<p>在<a target="_blank" rel="noopener" href="https://programmercarl.com/0530.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE.html">二叉树：搜索树的最小绝对差 </a>和<a target="_blank" rel="noopener" href="https://programmercarl.com/0501.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%97%E6%95%B0.html">二叉树：我的众数是多少？</a>中，都是用了记录pre和cur两个指针的技巧，本题也是一样的。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">insertIntoBST</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            TreeNode* node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line">        TreeNode* parent = root; <span class="comment">// 这个很重要，需要记录上一个节点，否则无法赋值新节点</span></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            parent = cur;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;val &gt; val) cur = cur-&gt;left;</span><br><span class="line">            <span class="keyword">else</span> cur = cur-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">        <span class="keyword">if</span> (val &lt; parent-&gt;val) parent-&gt;left = node;<span class="comment">// 此时是用parent节点的进行赋值</span></span><br><span class="line">        <span class="keyword">else</span> parent-&gt;right = node;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>首先在二叉搜索树中的插入操作，大家不用恐惧其重构搜索树，其实根本不用重构。</p>
<p>然后在递归中，我们重点讲了如果通过递归函数的返回值完成新加入节点和其父节点的赋值操作，并强调了搜索树的有序性。</p>
<p>最后依然给出了迭代的方法，迭代的方法就需要记录当前遍历节点的父节点了，这个和没有返回值的递归函数实现的代码逻辑是一样的。</p>
<h1 id="删除二叉搜索树中的节点"><a href="#删除二叉搜索树中的节点" class="headerlink" title="删除二叉搜索树中的节点"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/delete-node-in-a-bst/">删除二叉搜索树中的节点</a></h1><p>给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p>
<p>一般来说，删除节点可分为两个步骤：</p>
<p>首先找到需要删除的节点； 如果找到了，删除它。 说明： 要求算法时间复杂度为 $O(h)$，h 为树的高度。</p>
<p>示例:</p>
<p><img src="https://img-blog.csdnimg.cn/20201020171048265.png" alt="450.删除二叉搜索树中的节点"></p>
<h2 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h2><p>搜索树的节点删除要比节点增加复杂的多，有很多情况需要考虑，做好心里准备。</p>
<h3 id="递归-2"><a href="#递归-2" class="headerlink" title="递归"></a>递归</h3><p>递归三部曲：</p>
<ul>
<li>确定递归函数参数以及返回值</li>
</ul>
<p>说到递归函数的返回值，在<a target="_blank" rel="noopener" href="https://programmercarl.com/0701.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C.html">二叉树：搜索树中的插入操作</a>中通过递归返回值来加入新节点， 这里也可以通过递归返回值删除节点。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">deleteNode</span><span class="params">(TreeNode* root, <span class="type">int</span> key)</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>确定终止条件</li>
</ul>
<p>遇到空返回，其实这也说明没找到删除的节点，遍历到空节点直接返回了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> root;</span><br></pre></td></tr></table></figure>

<ul>
<li>确定单层递归的逻辑</li>
</ul>
<p>这里就把二叉搜索树中删除节点遇到的情况都搞清楚。</p>
<p>有以下五种情况：</p>
<ul>
<li>第一种情况：没找到删除的节点，遍历到空节点直接返回了</li>
<li>找到删除的节点<ul>
<li>第二种情况：左右孩子都为空（叶子节点），直接删除节点， 返回NULL为根节点</li>
<li>第三种情况：删除节点的左孩子为空，右孩子不为空，删除节点，右孩子补位，返回右孩子为根节点</li>
<li>第四种情况：删除节点的右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子为根节点</li>
<li>第五种情况：左右孩子节点都不为空，则将删除节点的左子树头结点（左孩子）放到删除节点的右子树的最左面节点的左孩子上，返回删除节点右孩子为新的根节点。</li>
</ul>
</li>
</ul>
<p>第五种情况有点难以理解，看下面动画：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gnbj3k596mg30dq0aigyz.gif" alt="450.删除二叉搜索树中的节点"></p>
<p>动画中棵二叉搜索树中，删除元素7， 那么删除节点（元素7）的左孩子就是5，删除节点（元素7）的右子树的最左面节点是元素8。</p>
<p>将删除节点（元素7）的左孩子放到删除节点（元素7）的右子树的最左面节点（元素8）的左孩子上，就是把5为根节点的子树移到了8的左孩子的位置。</p>
<p>要删除的节点（元素7）的右孩子（元素9）为新的根节点。.</p>
<p>这样就完成删除元素7的逻辑，最好动手画一个图，尝试删除一个节点试试。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (root-&gt;val == key) &#123;</span><br><span class="line">    <span class="comment">// 第二种情况：左右孩子都为空（叶子节点），直接删除节点， 返回NULL为根节点</span></span><br><span class="line">    <span class="comment">// 第三种情况：其左孩子为空，右孩子不为空，删除节点，右孩子补位 ，返回右孩子为根节点</span></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left == <span class="literal">nullptr</span>) <span class="keyword">return</span> root-&gt;right;</span><br><span class="line">    <span class="comment">// 第四种情况：其右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子为根节点</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;right == <span class="literal">nullptr</span>) <span class="keyword">return</span> root-&gt;left;</span><br><span class="line">    <span class="comment">// 第五种情况：左右孩子节点都不为空，则将删除节点的左子树放到删除节点的右子树的最左面节点的左孩子的位置</span></span><br><span class="line">    <span class="comment">// 并返回删除节点右孩子为新的根节点。</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        TreeNode* cur = root-&gt;right; <span class="comment">// 找右子树最左面的节点</span></span><br><span class="line">        <span class="keyword">while</span>(cur-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            cur = cur-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;left = root-&gt;left; <span class="comment">// 把要删除的节点（root）左子树放在cur的左孩子的位置</span></span><br><span class="line">        TreeNode* tmp = root;   <span class="comment">// 把root节点保存一下，下面来删除</span></span><br><span class="line">        root = root-&gt;right;     <span class="comment">// 返回旧root的右孩子作为新root</span></span><br><span class="line">        <span class="keyword">delete</span> tmp;             <span class="comment">// 释放节点内存（这里不写也可以，但C++最好手动释放一下吧）</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里相当于把新的节点返回给上一层，上一层就要用 root-&gt;left 或者 root-&gt;right接住，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (root-&gt;val &gt; key) root-&gt;left = <span class="built_in">deleteNode</span>(root-&gt;left, key);</span><br><span class="line"><span class="keyword">if</span> (root-&gt;val &lt; key) root-&gt;right = <span class="built_in">deleteNode</span>(root-&gt;right, key);</span><br><span class="line"><span class="keyword">return</span> root;</span><br></pre></td></tr></table></figure>

<p><strong>整体代码如下：（注释中：情况1，2，3，4，5和上面分析严格对应）</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">deleteNode</span><span class="params">(TreeNode* root, <span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> root; <span class="comment">// 第一种情况：没找到删除的节点，遍历到空节点直接返回了</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val == key) &#123;</span><br><span class="line">            <span class="comment">// 第二种情况：左右孩子都为空（叶子节点），直接删除节点， 返回NULL为根节点</span></span><br><span class="line">            <span class="keyword">if</span> (root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="comment">///! 内存释放</span></span><br><span class="line">                <span class="keyword">delete</span> root;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 第三种情况：其左孩子为空，右孩子不为空，删除节点，右孩子补位 ，返回右孩子为根节点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;left == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">auto</span> retNode = root-&gt;right;</span><br><span class="line">                <span class="comment">///! 内存释放</span></span><br><span class="line">                <span class="keyword">delete</span> root;</span><br><span class="line">                <span class="keyword">return</span> retNode;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 第四种情况：其右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子为根节点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">auto</span> retNode = root-&gt;left;</span><br><span class="line">                <span class="comment">///! 内存释放</span></span><br><span class="line">                <span class="keyword">delete</span> root;</span><br><span class="line">                <span class="keyword">return</span> retNode;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 第五种情况：左右孩子节点都不为空，则将删除节点的左子树放到删除节点的右子树的最左面节点的左孩子的位置</span></span><br><span class="line">            <span class="comment">// 并返回删除节点右孩子为新的根节点。</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                TreeNode* cur = root-&gt;right; <span class="comment">// 找右子树最左面的节点</span></span><br><span class="line">                <span class="keyword">while</span>(cur-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    cur = cur-&gt;left;</span><br><span class="line">                &#125;</span><br><span class="line">                cur-&gt;left = root-&gt;left; <span class="comment">// 把要删除的节点（root）左子树放在cur的左孩子的位置</span></span><br><span class="line">                TreeNode* tmp = root;   <span class="comment">// 把root节点保存一下，下面来删除</span></span><br><span class="line">                root = root-&gt;right;     <span class="comment">// 返回旧root的右孩子作为新root</span></span><br><span class="line">                <span class="keyword">delete</span> tmp;             <span class="comment">// 释放节点内存（这里不写也可以，但C++最好手动释放一下吧）</span></span><br><span class="line">                <span class="keyword">return</span> root;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &gt; key) root-&gt;left = <span class="built_in">deleteNode</span>(root-&gt;left, key);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &lt; key) root-&gt;right = <span class="built_in">deleteNode</span>(root-&gt;right, key);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="迭代法-2"><a href="#迭代法-2" class="headerlink" title="迭代法"></a>迭代法</h3><p>删除节点的迭代法还是复杂一些的，但其本质我在递归法里都介绍了，最关键就是删除节点的操作（动画模拟的过程）</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 将目标节点（删除节点）的左子树放到 目标节点的右子树的最左面节点的左孩子位置上</span></span><br><span class="line">    <span class="comment">// 并返回目标节点右孩子为新的根节点</span></span><br><span class="line">    <span class="comment">// 是动画里模拟的过程</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deleteOneNode</span><span class="params">(TreeNode* target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="literal">nullptr</span>) <span class="keyword">return</span> target;</span><br><span class="line">        <span class="keyword">if</span> (target-&gt;right == <span class="literal">nullptr</span>) <span class="keyword">return</span> target-&gt;left;</span><br><span class="line">        TreeNode* cur = target-&gt;right;</span><br><span class="line">        <span class="keyword">while</span> (cur-&gt;left) &#123;</span><br><span class="line">            cur = cur-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;left = target-&gt;left;</span><br><span class="line">        <span class="keyword">return</span> target-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">deleteNode</span><span class="params">(TreeNode* root, <span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> root;</span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line">        TreeNode* pre = <span class="literal">nullptr</span>; <span class="comment">// 记录cur的父节点，用来删除cur</span></span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;val == key) <span class="keyword">break</span>;</span><br><span class="line">            pre = cur;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;val &gt; key) cur = cur-&gt;left;</span><br><span class="line">            <span class="keyword">else</span> cur = cur-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pre == <span class="literal">nullptr</span>) &#123; <span class="comment">// 如果搜索树只有头结点</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">deleteOneNode</span>(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// pre 要知道是删左孩子还是右孩子</span></span><br><span class="line">        <span class="keyword">if</span> (pre-&gt;left &amp;&amp; pre-&gt;left-&gt;val == key) &#123;</span><br><span class="line">            pre-&gt;left = <span class="built_in">deleteOneNode</span>(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pre-&gt;right &amp;&amp; pre-&gt;right-&gt;val == key) &#123;</span><br><span class="line">            pre-&gt;right = <span class="built_in">deleteOneNode</span>(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><p>读完本篇，大家会发现二叉搜索树删除节点比增加节点复杂的多。</p>
<p><strong>因为二叉搜索树添加节点只需要在叶子上添加就可以的，不涉及到结构的调整，而删除节点操作涉及到结构的调整</strong>。</p>
<p>这里我们依然使用递归函数的返回值来完成把节点从二叉树中移除的操作。</p>
<p><strong>这里最关键的逻辑就是第五种情况（删除一个左右孩子都不为空的节点），这种情况一定要想清楚</strong>。</p>
<p>而且就算想清楚了，对应的代码也未必可以写出来，所以<strong>这道题目即考察思维逻辑，也考察代码能力</strong>。</p>
<p>递归中我给出了两种写法，推荐大家学会第一种（利用搜索树的特性）就可以了，第二种递归写法其实是比较绕的。</p>
<p>最后我也给出了相应的迭代法，就是模拟递归法中的逻辑来删除节点，但需要一个pre记录cur的父节点，方便做删除操作。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/31/UE4-%E8%93%9D%E5%9B%BE-%E8%93%9D%E5%9B%BE%E9%80%9A%E4%BF%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="williny">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Williny'home">
      <meta itemprop="description" content="孤独是人生的常态">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Williny'home">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/05/31/UE4-%E8%93%9D%E5%9B%BE-%E8%93%9D%E5%9B%BE%E9%80%9A%E4%BF%A1/" class="post-title-link" itemprop="url">UE4-蓝图-蓝图通信</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-05-31 10:35:46 / 修改时间：11:27:32" itemprop="dateCreated datePublished" datetime="2022-05-31T10:35:46+08:00">2022-05-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/unreal-engine/" itemprop="url" rel="index"><span itemprop="name">unreal engine</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="蓝图之间的通信-x2F-访问"><a href="#蓝图之间的通信-x2F-访问" class="headerlink" title="蓝图之间的通信&#x2F;访问"></a>蓝图之间的通信&#x2F;访问</h1><h2 id="通过实例进行通信"><a href="#通过实例进行通信" class="headerlink" title="通过实例进行通信"></a>通过实例进行通信</h2><p>例如有两个蓝图类</p>
<p>一个为A，另一个为B</p>
<p>现在需要两者之间进行通信</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul>
<li><p>在A蓝图中调用“Get All Actor Of Class”节点，选择B类</p>
</li>
<li><p>Out Actor引脚引出要访问的具体实例</p>
<ul>
<li>具体实例时存储在一个数组中的，在选择实例的时候，选择其在数组中的引脚即可</li>
</ul>
</li>
<li><p>选择好实例之后，在由此实例引出事件（或者函数）来达到两者交互的效果</p>
</li>
</ul>
<h3 id="通过管理模式进行访问"><a href="#通过管理模式进行访问" class="headerlink" title="通过管理模式进行访问"></a>通过管理模式进行访问</h3><p>通过蓝图类B的实例来生成一个蓝图类A的实例</p>
<p>用这种方法生成的Actor，只能通过其父类来进行访问</p>
<ol>
<li><p>首先在蓝图类A内定义一个自定义事件”TTTT”打印字符串“hello”</p>
</li>
<li><p>在蓝图B类中调用“从类中生成Actor”，选择蓝图A类</p>
</li>
<li><p>设置缩放，旋转，位置信息</p>
</li>
<li><p>将返回值，也就是生成的Actor提升为变量（也可以不提升）</p>
</li>
<li><p>通过该变量调用类A中的TTTT事件</p>
</li>
</ol>
<p><img src="D:\R_programme\Blog\source_posts\UE4-蓝图-蓝图通信\1.png"></p>
<p><img src="D:\R_programme\Blog\source_posts\UE4-蓝图-蓝图通信\2.png"></p>
<h2 id="蓝图接口访问"><a href="#蓝图接口访问" class="headerlink" title="蓝图接口访问"></a>蓝图接口访问</h2><p>蓝图接口就类似与C++中的代理？</p>
<p>我们在父类中不知道子类中的情况，但是依旧可以直接调用子类中的函数</p>
<ol>
<li><p>在资源管理器中创建接口，但在接口内只需要<mark>声明</mark>函数名称</p>
</li>
<li><p>在蓝图-&gt;类设置-&gt;接口-&gt;添加接口</p>
</li>
<li><p>调用出接口的节点之后，对其进行<mark>定义</mark></p>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/31/UE4-%E8%93%9D%E5%9B%BE-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%BA%8B%E4%BB%B6%E6%8E%A5%E5%8F%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="williny">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Williny'home">
      <meta itemprop="description" content="孤独是人生的常态">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Williny'home">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/05/31/UE4-%E8%93%9D%E5%9B%BE-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%BA%8B%E4%BB%B6%E6%8E%A5%E5%8F%A3/" class="post-title-link" itemprop="url">UE4-蓝图-服务端事件接口</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-05-31 09:09:09 / 修改时间：10:24:08" itemprop="dateCreated datePublished" datetime="2022-05-31T09:09:09+08:00">2022-05-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/unreal-engine/" itemprop="url" rel="index"><span itemprop="name">unreal engine</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="服务端事件接口"><a href="#服务端事件接口" class="headerlink" title="服务端事件接口"></a>服务端事件接口</h1><p>也就是GameMode里面可在蓝图中重载的一些函数的意义与用法</p>
<p>这些可重载的函数在C++中已经实现过了，一旦在蓝图中重载，则不再实现C++中已实现的功能！</p>
<p><img src="D:\R_programme\Blog\source_posts\UE4-蓝图-服务端事件接口\1.png"></p>
<h2 id="生成默认pawn，针对"><a href="#生成默认pawn，针对" class="headerlink" title="生成默认pawn，针对"></a>生成默认pawn，针对</h2><p>此函数意味着在游戏开始时生成一个玩家控制的pawn</p>
<p><img src="D:\R_programme\Blog\source_posts\UE4-蓝图-服务端事件接口\2.png"></p>
<p>重新实现之后的蓝图逻辑如下</p>
<p><img src="D:\R_programme\Blog\source_posts\UE4-蓝图-服务端事件接口\3.png"></p>
<h2 id="后台登陆时"><a href="#后台登陆时" class="headerlink" title="后台登陆时"></a>后台登陆时</h2><p>这个事件就是在玩家成功登录服务器的时候可进行的操作，可以连接一个打印字符串</p>
<p>来进行提示“登录成功！”之类的操作</p>
<p><img src="D:\R_programme\Blog\source_posts\UE4-蓝图-服务端事件接口\4.png"></p>
<p><img src="D:\R_programme\Blog\source_posts\UE4-蓝图-服务端事件接口\5.png"></p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>感觉需要讲解的东西也不多</p>
<p>大多都是需要我们重载“在进行某操作之后会发生的事情”</p>
<p>只要大概了解一下这些东西吧，需要在蓝图中重载的时候就进行调用即可</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/30/UE4-%E9%A1%B9%E7%9B%AE-%E6%AD%BB%E5%AF%82-%E8%A7%92%E8%89%B2%E7%A7%BB%E5%8A%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="williny">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Williny'home">
      <meta itemprop="description" content="孤独是人生的常态">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Williny'home">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/05/30/UE4-%E9%A1%B9%E7%9B%AE-%E6%AD%BB%E5%AF%82-%E8%A7%92%E8%89%B2%E7%A7%BB%E5%8A%A8/" class="post-title-link" itemprop="url">UE4-项目-死寂-角色移动</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-05-30 14:08:41" itemprop="dateCreated datePublished" datetime="2022-05-30T14:08:41+08:00">2022-05-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-06-02 09:18:23" itemprop="dateModified" datetime="2022-06-02T09:18:23+08:00">2022-06-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/unreal-engine/" itemprop="url" rel="index"><span itemprop="name">unreal engine</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><h2 id="实现角色的基础移动效果"><a href="#实现角色的基础移动效果" class="headerlink" title="实现角色的基础移动效果"></a>实现角色的基础移动效果</h2><p>在本节，只需要实现基本的前后左右移动，鼠标控制视野即可</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li><p>弹簧臂启用“使用pawn控制旋转”——能让弹簧臂跟着鼠标的移动进行旋转</p>
</li>
<li><p>角色蓝图类禁用“使用控制器旋转Yaw”，角色移动组件启用“将旋转朝向运动”——让角色不会始终背对我们</p>
</li>
</ol>
<h3 id="大致实现步骤"><a href="#大致实现步骤" class="headerlink" title="大致实现步骤"></a>大致实现步骤</h3><ol>
<li><p>设置映射</p>
<ul>
<li><p>轴映射-&gt;键盘的moveforword，moveright</p>
</li>
<li><p>轴映射-&gt;鼠标的mouseX，mouseY</p>
</li>
</ul>
</li>
<li><p>创建以Charactor为父类的蓝图</p>
<ul>
<li><p>添加弹簧臂组件和摄像机组件</p>
</li>
<li><p>添加角色模型</p>
</li>
</ul>
</li>
<li><p>编写弹簧臂控制器输入蓝图逻辑</p>
<ul>
<li><p>调用轴映射事件-&gt;添加控制Yaw（x）与pitch（y）输入</p>
</li>
<li><p>弹簧臂细节面板-&gt;摄像机设置-&gt;使用pawn控制旋转</p>
</li>
</ul>
</li>
<li><p>将玩家放入世界中</p>
<ul>
<li>细节面板-&gt;posses（自动控制玩家）-&gt;玩家0</li>
</ul>
</li>
<li><p>编写角色基础移动蓝图逻辑</p>
<ul>
<li><p>获取控制旋转-&gt;z轴-&gt;创建旋转体-&gt;获取向前&#x2F;向右向量</p>
</li>
<li><p>调用moveforword&#x2F;moveright轴映射事件</p>
</li>
<li><p>添加移动输入-&gt;连接Scale Value以及World Direction引脚</p>
</li>
</ul>
</li>
<li><p>调整弹簧臂臂长，高度，偏角</p>
</li>
<li><p>调整角色移动朝向随着轴映射</p>
<ul>
<li><p>蓝图类-&gt;类默认设置-&gt;Pawn-&gt;使用控制器旋转Yaw取消勾选</p>
</li>
<li><p>角色移动组件 -&gt;细节面板-&gt;角色移动（设置旋转）-&gt;将旋转朝向运动勾选</p>
</li>
</ul>
</li>
</ol>
<p><img src="D:\R_programme\Blog\source_posts\UE4-项目-第三人称-角色移动\1.png"></p>
<p><img src="/UE4-%E9%A1%B9%E7%9B%AE-%E7%AC%AC%E4%B8%89%E4%BA%BA%E7%A7%B0-%E8%A7%92%E8%89%B2%E7%A7%BB%E5%8A%A8%5C2.png"></p>
<p><img src="/UE4-%E9%A1%B9%E7%9B%AE-%E7%AC%AC%E4%B8%89%E4%BA%BA%E7%A7%B0-%E8%A7%92%E8%89%B2%E7%A7%BB%E5%8A%A8%5C3.png"></p>
<img title="" src="UE4-项目-第三人称-角色移动/4.png" alt="" width="734">

<h2 id="添加角色动画"><a href="#添加角色动画" class="headerlink" title="添加角色动画"></a>添加角色动画</h2><h3 id="实现大致步骤"><a href="#实现大致步骤" class="headerlink" title="实现大致步骤"></a>实现大致步骤</h3><ol>
<li><p>创建混合空间1D</p>
<ul>
<li><p>设置水平坐标（名称，最大最小值，网格分区数量）</p>
</li>
<li><p>设置采样插值</p>
</li>
<li><p>添加动画资产</p>
</li>
</ul>
</li>
<li><p>创建蓝图动画</p>
<ul>
<li><p>添加新状态机</p>
</li>
<li><p>添加新状态，并编辑</p>
</li>
<li><p>在资产管理器中将之前创建的混合空间1D拖入</p>
</li>
<li><p>将“速度”提升为变量</p>
</li>
<li><p>编辑事件图表</p>
</li>
<li><p>尝试获取Pawn拥有者-&gt;Is Valid&#x2F;获取速度</p>
</li>
<li><p>事件蓝图更新动画连接Is Valid-&gt;set 速度</p>
</li>
<li><p>尝试获取Pawn拥有者-&gt;获取速度-&gt;长度向量-&gt;set 速度</p>
</li>
</ul>
</li>
<li><p>角色蓝图-&gt;网格体组件-&gt;动画-&gt;动画类-&gt;选择刚刚设置好的动画蓝图</p>
</li>
</ol>
<p><img src="/UE4-%E9%A1%B9%E7%9B%AE-%E7%AC%AC%E4%B8%89%E4%BA%BA%E7%A7%B0-%E8%A7%92%E8%89%B2%E7%A7%BB%E5%8A%A8%5C5.png"></p>
<p><img src="/UE4-%E9%A1%B9%E7%9B%AE-%E7%AC%AC%E4%B8%89%E4%BA%BA%E7%A7%B0-%E8%A7%92%E8%89%B2%E7%A7%BB%E5%8A%A8%5C6.png"></p>
<p><img src="/UE4-%E9%A1%B9%E7%9B%AE-%E7%AC%AC%E4%B8%89%E4%BA%BA%E7%A7%B0-%E8%A7%92%E8%89%B2%E7%A7%BB%E5%8A%A8%5C7.png"></p>
<p><img src="/UE4-%E9%A1%B9%E7%9B%AE-%E7%AC%AC%E4%B8%89%E4%BA%BA%E7%A7%B0-%E8%A7%92%E8%89%B2%E7%A7%BB%E5%8A%A8%5C7.png"></p>
<p><img src="/UE4-%E9%A1%B9%E7%9B%AE-%E7%AC%AC%E4%B8%89%E4%BA%BA%E7%A7%B0-%E8%A7%92%E8%89%B2%E7%A7%BB%E5%8A%A8%5C8.png"></p>
<p><img src="/UE4-%E9%A1%B9%E7%9B%AE-%E7%AC%AC%E4%B8%89%E4%BA%BA%E7%A7%B0-%E8%A7%92%E8%89%B2%E7%A7%BB%E5%8A%A8%5C9.png"></p>
<p><img src="/UE4-%E9%A1%B9%E7%9B%AE-%E7%AC%AC%E4%B8%89%E4%BA%BA%E7%A7%B0-%E8%A7%92%E8%89%B2%E7%A7%BB%E5%8A%A8%5C10.png"></p>
<h2 id="实现行走，慢跑（默认状态），冲刺的切换"><a href="#实现行走，慢跑（默认状态），冲刺的切换" class="headerlink" title="实现行走，慢跑（默认状态），冲刺的切换"></a>实现行走，慢跑（默认状态），冲刺的切换</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol>
<li><p>行走，慢跑，冲刺是三种已经确定了的状态，这三种状态影响了角色的移动速度，所以我们需要写一个能设置角色速度的函数</p>
</li>
<li><p>将行走，慢跑，冲刺带入switch循环中，分别执行设置角色速度</p>
<ul>
<li><p>为了能更方便遍历这三种状态，我们可以将这三种状态创建为一个枚举</p>
</li>
<li><p>用switch来遍历此枚举</p>
</li>
<li><p>最后输出每个状态相应的速度</p>
</li>
</ul>
</li>
<li><p>我们需要用按键CTRL和shift来控制三个状态的切换，所以我们设置按键映射之后，调用CTRL和shift事件，并且根据pressed和released来设置枚举的状态</p>
</li>
<li><p>最后为了能实时切换三种状态，需要帧更新时调用“角色速度判断”函数，并将速度设置为角色的最大行走速度</p>
</li>
</ol>
<h3 id="实现大致步骤-1"><a href="#实现大致步骤-1" class="headerlink" title="实现大致步骤"></a>实现大致步骤</h3><ol>
<li><p>添加一个枚举“Player_williny_state”</p>
<ul>
<li>显示命名为“慢跑”，“行走”，“切换”</li>
</ul>
</li>
<li><p>在角色蓝图中添加一个“Player_williny_state”类型的变量</p>
</li>
<li><p>添加一个名为“角色速度判断”的函数，并编辑该函数</p>
<ul>
<li><p>Player_williny_state-&gt;switch（三个引脚）-&gt;set max walk speed（三个节点）-&gt;返回节点-&gt;添加一个引脚“输出速度”-&gt;获取角色速度</p>
</li>
<li><p>角色速度判断-&gt;Player_williny_state</p>
</li>
</ul>
</li>
<li><p>绑定按键映射“行走”-&gt;ctrl，“冲刺”-&gt;shift</p>
</li>
<li><p>添加一个名为“角色行走与冲刺”的事件图表</p>
<ul>
<li><p>行走事件pressed-&gt;设置Player_williny_state-&gt;行走</p>
</li>
<li><p>行走事件release-&gt;设置Player_williny_stete-&gt;慢跑</p>
</li>
<li><p>冲刺事件pressed-&gt;设置Player_williny_state-&gt;冲刺</p>
</li>
<li><p>冲刺事件release-&gt;设置Player_williny_state-&gt;慢跑</p>
</li>
</ul>
</li>
<li><p>回到初始事件图表</p>
<ul>
<li><p>角色移动组件-&gt;set max walk speed</p>
</li>
<li><p>事件Tick-&gt;角色速度判断-&gt;set max walk speed</p>
</li>
</ul>
</li>
</ol>
<p><img src="/UE4-%E9%A1%B9%E7%9B%AE-%E7%AC%AC%E4%B8%89%E4%BA%BA%E7%A7%B0-%E8%A7%92%E8%89%B2%E7%A7%BB%E5%8A%A8%5C11.png"></p>
<p><img src="/UE4-%E9%A1%B9%E7%9B%AE-%E7%AC%AC%E4%B8%89%E4%BA%BA%E7%A7%B0-%E8%A7%92%E8%89%B2%E7%A7%BB%E5%8A%A8%5C12.png"></p>
<p><img src="/UE4-%E9%A1%B9%E7%9B%AE-%E7%AC%AC%E4%B8%89%E4%BA%BA%E7%A7%B0-%E8%A7%92%E8%89%B2%E7%A7%BB%E5%8A%A8%5C13.png"></p>
<p><img src="/UE4-%E9%A1%B9%E7%9B%AE-%E7%AC%AC%E4%B8%89%E4%BA%BA%E7%A7%B0-%E8%A7%92%E8%89%B2%E7%A7%BB%E5%8A%A8%5C14.png"></p>
<h2 id="实现角色的跳跃"><a href="#实现角色的跳跃" class="headerlink" title="实现角色的跳跃"></a>实现角色的跳跃</h2><p>实现角色的跳跃，大致思路在于写一个跳跃函数，在玩家按下“空格键”的时候就调用该函数</p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol>
<li><p>创建一个函数来控制跳跃高度和跳跃动画的切换</p>
<ul>
<li><p>该函数需要考虑到不同移动速度下的动画以及跳跃高度不同</p>
</li>
<li><p>为了提升该函数的复用性，可将动画资产提升为该函数的形参，在调用函数时传入</p>
</li>
</ul>
</li>
<li><p>在设置好跳跃高度之后，调用角色移动组件的“set Jump Z Velocity”，将跳跃高度传给该节点，再由这个高度引出蒙太奇动画的播放，最后调用虚幻引擎内置节点“跳跃”</p>
</li>
<li><p>在按下空格键时调用该函数，另外要注意调用函数最小时间间隔的设置（以防不停跳跃，导致不同重复播放跳跃动画）</p>
<ul>
<li>所以需要创建一个bool变量来判断“是否可以跳跃”</li>
</ul>
</li>
</ol>
<h3 id="实现跳跃需要注意事项"><a href="#实现跳跃需要注意事项" class="headerlink" title="实现跳跃需要注意事项"></a>实现跳跃需要注意事项</h3><ol>
<li><p>跳跃动画的切换</p>
</li>
<li><p>跳跃高度</p>
</li>
<li><p>在行走，慢跑，冲刺状态下的跳跃动画有所不同</p>
</li>
<li><p>跳跃之后需要延迟0.5秒方可执行下一个跳跃，以防一直跳个不停（还挺鬼畜的）</p>
</li>
<li><p>动画的根节点运动</p>
</li>
<li><p>蒙太奇动画资产提升为变量，并且连接在函数输入节点上——是为了在函数外部给该变量赋不同的值，类似于将其变为C++函数中的形参</p>
</li>
<li><p>基础状态机连接插槽后再连接输出姿势</p>
</li>
</ol>
<h3 id="实现大致步骤-2"><a href="#实现大致步骤-2" class="headerlink" title="实现大致步骤"></a>实现大致步骤</h3><ol>
<li><p>创建函数“跳跃的动画和高度设置”</p>
</li>
<li><p>创建一个浮点型变量“跳跃高度”</p>
</li>
<li><p>网格体组件-&gt;获取动画实例-&gt;蒙太奇播放-&gt;动画资产提升为变量“跳跃动画”</p>
</li>
<li><p>角色移动组件-&gt;set Jump Z Velocity     获取跳跃高度-&gt;set Jump Z Velocity</p>
</li>
<li><p>跳跃的动画和高度设置-&gt;switch慢跑&#x2F;行走&#x2F;冲刺-&gt;设置“跳跃高度”-&gt;set“跳跃动画”-&gt;set Jump Z Velocity-&gt;蒙太奇播放-&gt;跳跃</p>
</li>
<li><p>创建图表“角色跳跃”，绑定按键映射空格为“跳跃”</p>
</li>
<li><p>创建bool类型变量“是否可以跳跃”</p>
</li>
<li><p>跳跃-&gt;分支true-&gt;set 是否可以跳跃（false）-&gt;跳跃的动画和高度设置-&gt;延迟（0.5s）-&gt;set 是否可以跳跃（true）</p>
</li>
<li><p>获取是否可以跳跃-&gt;分支</p>
</li>
<li><p>将跳跃动画提升为蒙太奇动画之后，需要给他们添加插槽“跳跃”</p>
</li>
<li><p>在角色蓝图动画内，基础状态机连接插槽，插槽名称改为“跳跃”</p>
</li>
</ol>
<p><img src="D:\R_programme\Blog\source_posts\UE4-项目-第三人称-角色移动\15.png"></p>
<p><img src="D:\R_programme\Blog\source_posts\UE4-项目-第三人称-角色移动\16.png"></p>
<h2 id="角色坠落效果"><a href="#角色坠落效果" class="headerlink" title="角色坠落效果"></a>角色坠落效果</h2><p>实现该效果，就是需要判断角色是否“在掉落”，如果在掉落的状态中，则播放坠落动画</p>
<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ol>
<li><p>判断角色是否在坠落中</p>
</li>
<li><p>如果角色在坠落中，还需要判断角色是否在跳跃中，以免跳跃动画和坠落动画相继播放</p>
</li>
<li><p>另外在此处还需要注意“延迟节点”的时长</p>
</li>
<li><p>涉及到蓝图之间的通信</p>
<ul>
<li><p>动画蓝图中需要两个bool值“是否在空中”以及“是否在跳跃”来判断能否播放坠落动画</p>
</li>
<li><p>而与此同时，在角色蓝图中，我们需要设置“是否在跳跃”在true和false之间切换</p>
</li>
<li><p>最后动画蓝图需要获取角色蓝图中切换过的“是否在跳跃”这个值，来进行动画的播放</p>
</li>
</ul>
</li>
</ol>
<h3 id="实现大致步骤-3"><a href="#实现大致步骤-3" class="headerlink" title="实现大致步骤"></a>实现大致步骤</h3><ol>
<li><p>动画蓝图-&gt;基础状态机-&gt;添加状态“坠落”-&gt;“坠落”和“Walk_Jog_Run”之间双向连接</p>
</li>
<li><p>编辑“坠落”状态-&gt;在资产库中调用坠落动画-&gt;输出动画姿势</p>
</li>
<li><p>编辑“Walk_Jog_Run”到“坠落”规则</p>
<ul>
<li><p>添加bool变量“是否在空中”，“是否在跳跃”</p>
</li>
<li><p>是否在跳跃-&gt;not-&gt;and-&gt;结果</p>
</li>
<li><p>是否在空中-&gt;and-&gt;结果</p>
</li>
</ul>
</li>
<li><p>编辑“坠落”到“Walk_Jog_Run”规则</p>
<ul>
<li>是否在空中-&gt;not-&gt;结果</li>
</ul>
</li>
<li><p>在上面，我们只是声明了两个bool，但是没有定义（赋予它们具体的意义），接下来，我们需要给这两个bool分别定义</p>
<ol>
<li><p>定义“是否在空中”</p>
<ul>
<li><p>动画蓝图-&gt;事件图表-&gt;尝试获取Pawn拥有者-&gt;获取移动组件-&gt;正在掉落-&gt;set 是否在空中</p>
</li>
<li><p>正在掉落节点：如果正在掉落，则返回true，否则返回false</p>
</li>
</ul>
</li>
<li><p>定义“是否在跳跃”</p>
<ul>
<li><p>需要进行蓝图通信</p>
</li>
<li><p>角色蓝图-&gt;事件图表-&gt;事件开始运行-&gt;类型转换为“动画蓝图名称”</p>
</li>
<li><p>网格体组件-&gt;获取动画实例-&gt;类型转换为“动画蓝图名称”-&gt;提升为变量”As BP Player Anim”</p>
</li>
</ul>
</li>
</ol>
</li>
<li><p>接下来，我们需要在角色跳跃的时候，来对”是否在跳跃“进行设置</p>
<ul>
<li><p>As BP Player Anim-&gt;set 是否在跳跃</p>
</li>
<li><p>角色跳跃事件图表-&gt;set 是否可以跳跃-&gt;set 是否在跳跃-&gt;跳跃的动画和高度设置</p>
</li>
<li><p>将As BP Player Anim-&gt;set 是否在跳跃添加到蓝图末尾</p>
</li>
</ul>
</li>
</ol>
<h3 id="延迟时长的设置"><a href="#延迟时长的设置" class="headerlink" title="延迟时长的设置"></a>延迟时长的设置</h3><p>在”角色跳跃“事件中，我们需要把延迟设置为1s，否则会出现跳跃到一半，就开始播放坠落的蓝图动画！</p>
<p>原因</p>
<ol>
<li><p>跳跃动作总共需要耗时1s，在这一秒内，我们需要一直播放跳跃动画，所以延迟得是1s</p>
</li>
<li><p>但如果延迟小于1s（假设为0.5s），则会出现在跳到一半的时候就设置”是否在跳跃“为false</p>
</li>
<li><p>那么状态机那边就会出现跳跃的前0.5秒在播放跳跃动画，还没落地的后0.5秒播放坠落动画的情况</p>
</li>
</ol>
<p><img src="D:\R_programme\Blog\source_posts\UE4-项目-第三人称-角色移动\17.png"></p>
<p><img src="D:\R_programme\Blog\source_posts\UE4-项目-第三人称-角色移动\18.png"></p>
<p><img src="D:\R_programme\Blog\source_posts\UE4-项目-第三人称-角色移动\19.png"></p>
<p><img src="D:\R_programme\Blog\source_posts\UE4-项目-第三人称-角色移动\20.png"></p>
<p><img src="D:\R_programme\Blog\source_posts\UE4-项目-第三人称-角色移动\21.png"></p>
<p><img src="D:\R_programme\Blog\source_posts\UE4-项目-第三人称-角色移动\22.png"></p>
<p><img src="D:\R_programme\Blog\source_posts\UE4-项目-第三人称-角色移动\23.png"></p>
<h2 id="角色的蹲伏"><a href="#角色的蹲伏" class="headerlink" title="角色的蹲伏"></a>角色的蹲伏</h2><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>角色的动作变换需要运用到的知识点</p>
<ol>
<li><p>混合空间1D——设置角色动画</p>
</li>
<li><p>状态机调用混合空间1D</p>
<ul>
<li>通过“按布尔混合姿势”以及一个bool值在不同情况下调用混合空间1D</li>
</ul>
</li>
<li><p>蓝图通信</p>
<ul>
<li>网格体的动画实例转换为动画蓝图的实例，再提升为变量</li>
<li>再由此实例调用其中的函数或者访问其中的变量，实现蓝图间通信的效果</li>
</ul>
</li>
<li><p>弹簧臂需要调用“As BP Player Anim”节点来进行修改Z轴的位置，来达到，蹲伏后高度变换的效果</p>
</li>
</ol>
<h3 id="实现大致步骤-4"><a href="#实现大致步骤-4" class="headerlink" title="实现大致步骤"></a>实现大致步骤</h3><ol>
<li><p>添加操作映射“按键C”</p>
</li>
<li><p>添加新的事件图表“角色蹲伏”</p>
</li>
<li><p>点击移动组件，设置”可蹲伏“”蹲伏半高“”最大蹲伏行走速度“”蹲伏后可走出平台true“</p>
</li>
<li><p>在角色蓝图中添加蓝图节点逻辑</p>
</li>
<li><p>创建蹲伏的混合空间1D“BS_NoWeaponCrouch”</p>
</li>
<li><p>在基础姿势中创建bool“是否蹲伏”用于判断输出哪个动画（切换时间要改成0.3）</p>
<ul>
<li><p>节点“按波尔混合姿势”</p>
</li>
<li><p>“是否蹲伏”为True时输出“BS_NoWeaponCrouch”</p>
</li>
<li><p>“是否蹲伏”为false时输出“BS_NoWeapon”</p>
</li>
<li><p>切换时间设置为0.3s</p>
</li>
</ul>
</li>
<li><p>前面声明了bool”是否蹲伏“，现在在角色蓝图类中定义它（赋予它真正的含义）</p>
<ul>
<li>在角色蓝图中获取”As BP Player Anim“引出”设置蹲伏“（蓝图通信）</li>
</ul>
</li>
<li><p>修改蹲伏时的视角高度</p>
<ul>
<li><p>添加时间轴”蹲伏的高度变化“（时间长度为0.3s）</p>
</li>
<li><p>添加弹簧臂组件，引出”set Socket Offset“来使得弹簧臂相对于插槽的位置进行偏移</p>
</li>
</ul>
</li>
</ol>
<p><img src="D:\R_programme\Blog\source_posts\UE4-项目-第三人称-角色移动\24.png"></p>
<p><img src="D:\R_programme\Blog\source_posts\UE4-项目-第三人称-角色移动\25.png"></p>
<p><img src="D:\R_programme\Blog\source_posts\UE4-项目-第三人称-角色移动\26.png"></p>
<p><img src="D:\R_programme\Blog\source_posts\UE4-项目-第三人称-角色移动\27.png"></p>
<h2 id="瞄准偏移"><a href="#瞄准偏移" class="headerlink" title="瞄准偏移"></a>瞄准偏移</h2><p>实现效果就是，角色的脸跟随摄像机的面向转动</p>
<h3 id="附加动画"><a href="#附加动画" class="headerlink" title="附加动画"></a>附加动画</h3><p>就相当于一个插件，既可以让原动画继续播放，又可以在原动画的基础上实现拓展的功能</p>
<ol>
<li><p>全选所有单帧动画，右键-&gt;资产操作-&gt;通过矩阵进行批量编辑-&gt;选择基础姿势动画</p>
</li>
<li><p>创建瞄准偏移动画</p>
<ul>
<li><p>设置水平坐标（yaw，-90，90，2）围绕Z轴旋转</p>
</li>
<li><p>设置垂直坐标（pitch，-90，90，2）围绕Y轴旋转</p>
</li>
<li><p>在坐标轴内添加附加动画</p>
</li>
<li><p>附加设置-&gt;预览基础姿势-&gt;选择一个“被附加”的动作</p>
</li>
</ul>
</li>
<li><p>在状态机内添加此瞄准偏移动画</p>
<ul>
<li>需要注意蓝图动画的层级关系</li>
</ul>
</li>
<li><p>蓝图动画内对旋转脑阔的逻辑进行编写</p>
<ul>
<li><p>明确思路：旋转的实现方式是：获取将要旋转到的偏转角度信息，减去原本的偏转角度信息，然后将其值带入到一个可以让其逐帧变换到的节点中</p>
</li>
<li><p>目标旋转信息-&gt;摄像机的旋转信息</p>
</li>
<li><p>原本旋转信息-&gt;Actor的旋转信息</p>
</li>
<li><p>两者求插值（旋转体）</p>
</li>
<li><p>然后将此旋转体拆分：因为在这个旋转中，只有pitch轴（y）和yaw轴（z）进行了旋转</p>
</li>
<li><p>另外，我们需要限制其旋转角度，不能让脑阔直接转到后脑勺的位置，所以要将pitch和yaw值进行“限制角度”，设置为（-75，75）即可</p>
</li>
<li><p>接下来根据pitch和yaw的旋转至信息“创建旋转体”</p>
</li>
<li><p>以上的步骤就达到了“获取目标旋转信息”的目的（还做了旋转角度的限制）</p>
</li>
<li><p>接下来以上面的旋转体返回值引入“R插值到”节点的“目标”引脚</p>
</li>
<li><p>而“当前引脚”，则用pitch和yaw创建一个旋转体，引入即可</p>
</li>
<li><p>为了pitch和yaw可以实时变化，将输出引脚引出分别set两个值</p>
</li>
<li><p>最后，需要解决的问题是，当我们想看看自己的脸的时候，不能让角色的脸不正对着我们（导致这个bug的原因是：相对于最初的角度，我们摄像机偏离角度过高，脑阔直接抵达了（-75，75）这个区间）</p>
</li>
<li><p>解决思路：当我们看自己的脸的时候，记住这个摄像机偏离角度，让脑阔偏离角度为零。</p>
</li>
<li><p>只涉及到yaw轴的偏转，所以需要对yaw的插值求绝对值在大于等于120的时候，将yaw轴的值设置为0</p>
</li>
<li><p>另外yaw的值设为0，也需要用到“F插值到”来进行计算，免得转得很僵硬</p>
</li>
</ul>
</li>
<li><p>有关蓝图动画状态机的层级关系：动画的附加关系，层级大的可以覆盖层级小的</p>
<ul>
<li><p>越往内，层级越小</p>
</li>
<li><p>越往右，层级越小</p>
</li>
</ul>
</li>
</ol>
<p><img src="D:\R_programme\Blog\source_posts\UE4-项目-第三人称-角色移动\28.png"></p>
<p><img src="D:\R_programme\Blog\source_posts\UE4-项目-第三人称-角色移动\29.png"></p>
<p><img src="D:\R_programme\Blog\source_posts\UE4-项目-第三人称-角色移动\30.png"></p>
<p><img src="D:\R_programme\Blog\source_posts\UE4-项目-第三人称-角色移动\31.png"></p>
<p><img src="D:\R_programme\Blog\source_posts\UE4-项目-第三人称-角色移动\32.png"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/29/%E6%9C%89%E5%85%B3%E7%AE%97%E6%B3%95%E4%B8%AD%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88%E4%BA%8C%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="williny">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Williny'home">
      <meta itemprop="description" content="孤独是人生的常态">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Williny'home">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/05/29/%E6%9C%89%E5%85%B3%E7%AE%97%E6%B3%95%E4%B8%AD%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88%E4%BA%8C%EF%BC%89/" class="post-title-link" itemprop="url">有关算法中的二叉树（二）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-05-29 16:24:34" itemprop="dateCreated datePublished" datetime="2022-05-29T16:24:34+08:00">2022-05-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-06-02 09:15:54" itemprop="dateModified" datetime="2022-06-02T09:15:54+08:00">2022-06-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="二叉树的所有路径"><a href="#二叉树的所有路径" class="headerlink" title="二叉树的所有路径"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-paths/">二叉树的所有路径</a></h1><p>给定一个二叉树，返回所有从根节点到叶子节点的路径。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<p>示例: <img src="https://img-blog.csdnimg.cn/2021020415161576.png" alt="257.二叉树的所有路径1"></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题目要求从根节点到叶子的路径，所以需要前序遍历，这样才方便让父节点指向孩子节点，找到对应的路径。</p>
<p>在这道题目中将第一次涉及到回溯，因为我们要把路径记录下来，需要回溯来回退一一个路径在进入另一个路径。</p>
<p>前序遍历以及回溯的过程如图：</p>
<p><img src="https://img-blog.csdnimg.cn/20210204151702443.png" alt="257.二叉树的所有路径"></p>
<p>我们先使用递归的方式，来做前序遍历。<strong>要知道递归和回溯就是一家的，本题也需要回溯。</strong></p>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><ol>
<li>递归函数函数参数以及返回值</li>
</ol>
<p>要传入根节点，记录每一条路径的path，和存放结果集的result，这里递归不需要返回值，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur, vector&lt;<span class="type">int</span>&gt;&amp; path, vector&lt;string&gt;&amp; result)</span></span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>确定递归终止条件</li>
</ol>
<p>再写递归的时候都习惯了这么写：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (cur == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    终止处理逻辑</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是本题的终止条件这样写会很麻烦，因为本题要找到叶子节点，就开始结束的处理逻辑了（把路径放进result里）。</p>
<p><strong>那么什么时候算是找到了叶子节点？</strong> 是当 cur不为空，其左右孩子都为空的时候，就找到叶子节点。</p>
<p>所以本题的终止条件是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (cur-&gt;left == <span class="literal">NULL</span> &amp;&amp; cur-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    终止处理逻辑</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么没有判断cur是否为空呢，因为下面的逻辑可以控制空节点不入循环。</p>
<p>再来看一下终止处理的逻辑。</p>
<p>这里使用vector 结构path来记录路径，所以要把vector 结构的path转为string格式，在把这个string 放进 result里。</p>
<p><strong>那么为什么使用了vector 结构来记录路径呢？</strong> 因为在下面处理单层递归逻辑的时候，要做回溯，使用vector方便来做回溯。</p>
<p>可能有的同学问了，我看有些人的代码也没有回溯啊。</p>
<p><strong>其实是有回溯的，只不过隐藏在函数调用时的参数赋值里</strong>，下文我还会提到。</p>
<p>这里我们先使用vector结构的path容器来记录路径，那么终止处理逻辑如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (cur-&gt;left == <span class="literal">NULL</span> &amp;&amp; cur-&gt;right == <span class="literal">NULL</span>) &#123; <span class="comment">// 遇到叶子节点</span></span><br><span class="line">    string sPath;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; path.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123; <span class="comment">// 将path里记录的路径转为string格式</span></span><br><span class="line">        sPath += <span class="built_in">to_string</span>(path[i]);</span><br><span class="line">        sPath += <span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sPath += <span class="built_in">to_string</span>(path[path.<span class="built_in">size</span>() - <span class="number">1</span>]); <span class="comment">// 记录最后一个节点（叶子节点）</span></span><br><span class="line">    result.<span class="built_in">push_back</span>(sPath); <span class="comment">// 收集一个路径</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>确定单层递归逻辑</li>
</ol>
<p>因为是前序遍历，需要先处理中间节点，中间节点就是我们要记录路径上的节点，先放进path中。</p>
<p><code>path.push_back(cur-&gt;val);</code></p>
<p>然后是递归和回溯的过程，上面说过没有判断cur是否为空，那么在这里递归的时候，如果为空就不进行下一层递归了。</p>
<p>所以递归前要加上判断语句，下面要递归的节点是否为空，如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (cur-&gt;left) &#123;</span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;left, path, result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (cur-&gt;right) &#123;</span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;right, path, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时还没完，递归完，要做回溯啊，因为path 不能一直加入节点，它还要删节点，然后才能加入新的节点。</p>
<p>那么回溯要怎么回溯呢，一些同学会这么写，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (cur-&gt;left) &#123;</span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;left, path, result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (cur-&gt;right) &#123;</span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;right, path, result);</span><br><span class="line">&#125;</span><br><span class="line">path.<span class="built_in">pop_back</span>();</span><br></pre></td></tr></table></figure>

<p>这个回溯就要很大的问题，我们知道，<strong>回溯和递归是一一对应的，有一个递归，就要有一个回溯</strong>，这么写的话相当于把递归和回溯拆开了， 一个在花括号里，一个在花括号外。</p>
<p><strong>所以回溯要和递归永远在一起，世界上最遥远的距离是你在花括号里，而我在花括号外！</strong></p>
<p>那么代码应该这么写：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (cur-&gt;left) &#123;</span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;left, path, result);</span><br><span class="line">    path.<span class="built_in">pop_back</span>(); <span class="comment">// 回溯</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (cur-&gt;right) &#123;</span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;right, path, result);</span><br><span class="line">    path.<span class="built_in">pop_back</span>(); <span class="comment">// 回溯</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么本题整体代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur, vector&lt;<span class="type">int</span>&gt;&amp; path, vector&lt;string&gt;&amp; result)</span> </span>&#123;</span><br><span class="line">        path.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">        <span class="comment">// 这才到了叶子节点</span></span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;left == <span class="literal">NULL</span> &amp;&amp; cur-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            string sPath;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; path.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">                sPath += <span class="built_in">to_string</span>(path[i]);<span class="comment">//倒数第二个后面还有-&gt;</span></span><br><span class="line">                sPath += <span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sPath += <span class="built_in">to_string</span>(path[path.<span class="built_in">size</span>() - <span class="number">1</span>]);<span class="comment">//最后一个没有-&gt;</span></span><br><span class="line">            result.<span class="built_in">push_back</span>(sPath);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;left) &#123;</span><br><span class="line">            <span class="built_in">traversal</span>(cur-&gt;left, path, result);</span><br><span class="line">            path.<span class="built_in">pop_back</span>(); <span class="comment">// 回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;right) &#123;</span><br><span class="line">            <span class="built_in">traversal</span>(cur-&gt;right, path, result);</span><br><span class="line">            path.<span class="built_in">pop_back</span>(); <span class="comment">// 回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">binaryTreePaths</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; result;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> result;</span><br><span class="line">        <span class="built_in">traversal</span>(root, path, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如上的C++代码充分体现了回溯。</p>
<p>那么如上代码可以精简成如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur, string path, vector&lt;string&gt;&amp; result)</span> </span>&#123;</span><br><span class="line">        path += <span class="built_in">to_string</span>(cur-&gt;val); <span class="comment">// 中</span></span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;left == <span class="literal">NULL</span> &amp;&amp; cur-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;left) <span class="built_in">traversal</span>(cur-&gt;left, path + <span class="string">&quot;-&gt;&quot;</span>, result); <span class="comment">// 左</span></span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;right) <span class="built_in">traversal</span>(cur-&gt;right, path + <span class="string">&quot;-&gt;&quot;</span>, result); <span class="comment">// 右</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">binaryTreePaths</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; result;</span><br><span class="line">        string path;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> result;</span><br><span class="line">        <span class="built_in">traversal</span>(root, path, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如上代码精简了不少，也隐藏了不少东西。</p>
<p>注意在函数定义的时候<code>void traversal(TreeNode* cur, string path, vector&lt;string&gt;&amp; result)</code> ，定义的是<code>string path</code>，每次都是复制赋值，不用使用引用，否则就无法做到回溯的效果。</p>
<p>那么在如上代码中，<strong>貌似没有看到回溯的逻辑，其实不然，回溯就隐藏在<code>traversal(cur-&gt;left, path + &quot;-&gt;&quot;, result);</code>中的 <code>path + &quot;-&gt;&quot;</code>。</strong> 每次函数调用完，path依然是没有加上”-&gt;” 的，这就是回溯了。</p>
<p>为了把这份精简代码的回溯过程展现出来，大家可以试一试把：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (cur-&gt;left) <span class="built_in">traversal</span>(cur-&gt;left, path + <span class="string">&quot;-&gt;&quot;</span>, result); <span class="comment">// 左  回溯就隐藏在这里</span></span><br></pre></td></tr></table></figure>

<p>改成如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">path += <span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line"><span class="built_in">traversal</span>(cur-&gt;left, path, result); <span class="comment">// 左</span></span><br></pre></td></tr></table></figure>

<p>即$：$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (cur-&gt;left) &#123;</span><br><span class="line">    path += <span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;left, path, result); <span class="comment">// 左</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (cur-&gt;right) &#123;</span><br><span class="line">    path += <span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;right, path, result); <span class="comment">// 右</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时就没有回溯了，这个代码就是通过不了的了。</p>
<p>如果想把回溯加上，就要 在上面代码的基础上，加上回溯，就可以AC了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (cur-&gt;left) &#123;</span><br><span class="line">    path += <span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;left, path, result); <span class="comment">// 左</span></span><br><span class="line">    path.<span class="built_in">pop_back</span>(); <span class="comment">// 回溯</span></span><br><span class="line">    path.<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (cur-&gt;right) &#123;</span><br><span class="line">    path += <span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;right, path, result); <span class="comment">// 右</span></span><br><span class="line">    path.<span class="built_in">pop_back</span>(); <span class="comment">// 回溯</span></span><br><span class="line">    path.<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>大家应该可以感受出来，如果把 <code>path + &quot;-&gt;&quot;</code>作为函数参数就是可以的，因为并有没有改变path的数值，执行完递归函数之后，path依然是之前的数值（相当于回溯了）</strong></p>
<p><strong>综合以上，第二种递归的代码虽然精简但把很多重要的点隐藏在了代码细节里，第一种递归写法虽然代码多一些，但是把每一个逻辑处理都完整的展现了出来了。</strong></p>
<h2 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h2><p>至于非递归的方式，我们可以依然可以使用前序遍历的迭代方式来模拟遍历路径的过程，对该迭代方式不了解的同学，可以看文章<a target="_blank" rel="noopener" href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86.html">二叉树：听说递归能做的，栈也能做！</a>和<a target="_blank" rel="noopener" href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%BB%9F%E4%B8%80%E8%BF%AD%E4%BB%A3%E6%B3%95.html">二叉树：前中后序迭代方式统一写法</a>。</p>
<p>这里除了模拟递归需要一个栈，同时还需要一个栈来存放对应的遍历路径。</p>
<p>C++代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">binaryTreePaths</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; treeSt;<span class="comment">// 保存树的遍历节点</span></span><br><span class="line">        stack&lt;string&gt; pathSt;   <span class="comment">// 保存遍历路径的节点</span></span><br><span class="line">        vector&lt;string&gt; result;  <span class="comment">// 保存最终路径集合</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> result;</span><br><span class="line">        treeSt.<span class="built_in">push</span>(root);</span><br><span class="line">        pathSt.<span class="built_in">push</span>(<span class="built_in">to_string</span>(root-&gt;val));</span><br><span class="line">        <span class="keyword">while</span> (!treeSt.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* node = treeSt.<span class="built_in">top</span>(); treeSt.<span class="built_in">pop</span>(); <span class="comment">// 取出节点 中</span></span><br><span class="line">            string path = pathSt.<span class="built_in">top</span>();pathSt.<span class="built_in">pop</span>();    <span class="comment">// 取出该节点对应的路径</span></span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left == <span class="literal">NULL</span> &amp;&amp; node-&gt;right == <span class="literal">NULL</span>) &#123; <span class="comment">// 遇到叶子节点</span></span><br><span class="line">                result.<span class="built_in">push_back</span>(path);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right) &#123; <span class="comment">// 右</span></span><br><span class="line">                treeSt.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">                pathSt.<span class="built_in">push</span>(path + <span class="string">&quot;-&gt;&quot;</span> + <span class="built_in">to_string</span>(node-&gt;right-&gt;val));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left) &#123; <span class="comment">// 左</span></span><br><span class="line">                treeSt.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                pathSt.<span class="built_in">push</span>(path + <span class="string">&quot;-&gt;&quot;</span> + <span class="built_in">to_string</span>(node-&gt;left-&gt;val));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="左叶子之和"><a href="#左叶子之和" class="headerlink" title="左叶子之和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sum-of-left-leaves/">左叶子之和</a></h1><p>计算给定二叉树的所有左叶子之和。</p>
<p>示例：</p>
<p><img src="https://img-blog.csdnimg.cn/20210204151927654.png" alt="404.左叶子之和1"></p>
<h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p><strong>首先要注意是判断左叶子，不是二叉树左侧节点，所以不要上来想着层序遍历。</strong></p>
<p>因为题目中其实没有说清楚左叶子究竟是什么节点，那么我来给出左叶子的明确定义：<strong>如果左节点不为空，且左节点没有左右孩子，那么这个节点的左节点就是左叶子</strong></p>
<p>大家思考一下如下图中二叉树，左叶子之和究竟是多少？</p>
<p><img src="https://img-blog.csdnimg.cn/20210204151949672.png" alt="404.左叶子之和"></p>
<p><strong>其实是0，因为这棵树根本没有左叶子！</strong></p>
<p>那么<strong>判断当前节点是不是左叶子是无法判断的，必须要通过节点的父节点来判断其左孩子是不是左叶子。</strong></p>
<p>如果该节点的左节点不为空，该节点的左节点的左节点为空，该节点的左节点的右节点为空，则找到了一个左叶子，判断代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (node-&gt;left != <span class="literal">NULL</span> &amp;&amp; node-&gt;left-&gt;left == <span class="literal">NULL</span> &amp;&amp; node-&gt;left-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    左叶子节点处理逻辑</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h3><p>递归的遍历顺序为后序遍历（左右中），是因为要通过递归函数的返回值来累加求取左叶子数值之和。。</p>
<p>递归三部曲：</p>
<ol>
<li>确定递归函数的参数和返回值</li>
</ol>
<p>判断一个树的左叶子节点之和，那么一定要传入树的根节点，递归函数的返回值为数值之和，所以为int</p>
<p>使用题目中给出的函数就可以了。</p>
<ol start="2">
<li>确定终止条件</li>
</ol>
<p>依然是</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>确定单层递归的逻辑</li>
</ol>
<p>当遇到左叶子节点的时候，记录数值，然后通过递归求取左子树左叶子之和，和 右子树左叶子之和，相加便是整个树的左叶子之和。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> leftValue = <span class="built_in">sumOfLeftLeaves</span>(root-&gt;left);    <span class="comment">// 左</span></span><br><span class="line"><span class="type">int</span> rightValue = <span class="built_in">sumOfLeftLeaves</span>(root-&gt;right);  <span class="comment">// 右</span></span><br><span class="line">                                                <span class="comment">// 中</span></span><br><span class="line"><span class="type">int</span> midValue = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (root-&gt;left &amp;&amp; !root-&gt;left-&gt;left &amp;&amp; !root-&gt;left-&gt;right) &#123;</span><br><span class="line">    midValue = root-&gt;left-&gt;val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> sum = midValue + leftValue + rightValue;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br></pre></td></tr></table></figure>

<p>整体递归代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> leftValue = <span class="built_in">sumOfLeftLeaves</span>(root-&gt;left);    <span class="comment">// 左</span></span><br><span class="line">        <span class="type">int</span> rightValue = <span class="built_in">sumOfLeftLeaves</span>(root-&gt;right);  <span class="comment">// 右</span></span><br><span class="line">                                                        <span class="comment">// 中</span></span><br><span class="line">        <span class="type">int</span> midValue = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left &amp;&amp; !root-&gt;left-&gt;left &amp;&amp; !root-&gt;left-&gt;right) &#123; <span class="comment">// 中</span></span><br><span class="line">            midValue = root-&gt;left-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> sum = midValue + leftValue + rightValue;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>以上代码精简之后如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> midValue = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left != <span class="literal">NULL</span> &amp;&amp; root-&gt;left-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;left-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            midValue = root-&gt;left-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> midValue + <span class="built_in">sumOfLeftLeaves</span>(root-&gt;left) + <span class="built_in">sumOfLeftLeaves</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="迭代法-1"><a href="#迭代法-1" class="headerlink" title="迭代法"></a>迭代法</h2><p>本题迭代法使用前中后序都是可以的，只要把左叶子节点统计出来，就可以了，那么参考文章 <a target="_blank" rel="noopener" href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86.html">二叉树：听说递归能做的，栈也能做！</a>和<a target="_blank" rel="noopener" href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%BB%9F%E4%B8%80%E8%BF%AD%E4%BB%A3%E6%B3%95.html">二叉树：迭代法统一写法</a>中的写法，可以写出一个前序遍历的迭代法。</p>
<p>判断条件都是一样的，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        st.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* node = st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left != <span class="literal">NULL</span> &amp;&amp; node-&gt;left-&gt;left == <span class="literal">NULL</span> &amp;&amp; node-&gt;left-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                result += node-&gt;left-&gt;val;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right) st.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left) st.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="找树左下角的值"><a href="#找树左下角的值" class="headerlink" title="找树左下角的值"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-bottom-left-tree-value/">找树左下角的值</a></h1><p>给定一个二叉树，在树的最后一行找到最左边的值。</p>
<p>示例 1:</p>
<p><img src="https://img-blog.csdnimg.cn/20210204152956836.png" alt="513.找树左下角的值"></p>
<p>示例 2:</p>
<p><img src="https://img-blog.csdnimg.cn/20210204153017586.png" alt="513.找树左下角的值1"></p>
<h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>本地要找出树的最后一行找到最左边的值。此时大家应该想起用层序遍历是非常简单的了，反而用递归的话会比较难一点。</p>
<p>我们依然还是先介绍递归法。</p>
<h3 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h3><p>咋眼一看，这道题目用递归的话就就一直向左遍历，最后一个就是答案呗？</p>
<p>没有这么简单，一直向左遍历到最后一个，它未必是最后一行啊。</p>
<p>我们来分析一下题目：在树的<strong>最后一行</strong>找到<strong>最左边的值</strong>。</p>
<p>首先要是最后一行，然后是最左边的值。</p>
<p>如果使用递归法，如何判断是最后一行呢，其实就是深度最大的叶子节点一定是最后一行。</p>
<p>如果对二叉树深度和高度还有点疑惑的话，请看：<a target="_blank" rel="noopener" href="https://programmercarl.com/0110.%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.html">110.平衡二叉树</a>。</p>
<p>所以要找深度最大的叶子节点。</p>
<p>那么如果找最左边的呢？可以使用前序遍历，这样才先优先左边搜索，然后记录深度最大的叶子节点，此时就是树的最后一行最左边的值。</p>
<p>递归三部曲：</p>
<ol>
<li>确定递归函数的参数和返回值</li>
</ol>
<p>参数必须有要遍历的树的根节点，还有就是一个int型的变量用来记录最长深度。 这里就不需要返回值了，所以递归函数的返回类型为void。</p>
<p>本题还需要类里的两个全局变量，maxLen用来记录最大深度，maxleftValue记录最大深度最左节点的数值。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> maxLen = INT_MIN;   <span class="comment">// 全局变量 记录最大深度</span></span><br><span class="line"><span class="type">int</span> maxleftValue;       <span class="comment">// 全局变量 最大深度最左节点的数值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* root, <span class="type">int</span> leftLen)</span></span></span><br></pre></td></tr></table></figure>

<p>有的同学可能疑惑，为啥不能递归函数的返回值返回最长深度呢？</p>
<p>其实很多同学都对递归函数什么时候要有返回值，什么时候不能有返回值很迷茫。</p>
<p><strong>如果需要遍历整棵树，递归函数就不能有返回值。如果需要遍历某一条固定路线，递归函数就一定要有返回值！</strong></p>
<p>初学者可能对这个结论不太理解，别急，后面我会安排一道题目专门讲递归函数的返回值问题。这里大家暂时先了解一下。</p>
<p>本题我们是要遍历整个树找到最深的叶子节点，需要遍历整棵树，所以递归函数没有返回值。</p>
<ol start="2">
<li>确定终止条件</li>
</ol>
<p>当遇到叶子节点的时候，就需要统计一下最大的深度了，所以需要遇到叶子节点来更新最大深度。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (leftLen &gt; maxLen) &#123;</span><br><span class="line">        maxLen = leftLen;           <span class="comment">// 更新最大深度</span></span><br><span class="line">        maxleftValue = root-&gt;val;   <span class="comment">// 最大深度最左面的数值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>确定单层递归的逻辑</li>
</ol>
<p>在找最大深度的时候，递归的过程中依然要使用回溯，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">                    <span class="comment">// 中</span></span><br><span class="line"><span class="keyword">if</span> (root-&gt;left) &#123;   <span class="comment">// 左</span></span><br><span class="line">    leftLen++; <span class="comment">// 深度加一</span></span><br><span class="line">    <span class="built_in">traversal</span>(root-&gt;left, leftLen);</span><br><span class="line">    leftLen--; <span class="comment">// 回溯，深度减一</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (root-&gt;right) &#123; <span class="comment">// 右</span></span><br><span class="line">    leftLen++; <span class="comment">// 深度加一</span></span><br><span class="line">    <span class="built_in">traversal</span>(root-&gt;right, leftLen);</span><br><span class="line">    leftLen--; <span class="comment">// 回溯，深度减一</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br></pre></td></tr></table></figure>

<p>完整代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> maxLen = INT_MIN;</span><br><span class="line">    <span class="type">int</span> maxleftValue;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* root, <span class="type">int</span> leftLen)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (leftLen &gt; maxLen) &#123;</span><br><span class="line">                maxLen = leftLen;</span><br><span class="line">                maxleftValue = root-&gt;val;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left) &#123;</span><br><span class="line">            leftLen++;</span><br><span class="line">            <span class="built_in">traversal</span>(root-&gt;left, leftLen);</span><br><span class="line">            leftLen--; <span class="comment">// 回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right) &#123;</span><br><span class="line">            leftLen++;</span><br><span class="line">            <span class="built_in">traversal</span>(root-&gt;right, leftLen);</span><br><span class="line">            leftLen--; <span class="comment">// 回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">traversal</span>(root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> maxleftValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当然回溯的地方可以精简，精简代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> maxLen = INT_MIN;</span><br><span class="line">    <span class="type">int</span> maxleftValue;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* root, <span class="type">int</span> leftLen)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (leftLen &gt; maxLen) &#123;</span><br><span class="line">                maxLen = leftLen;</span><br><span class="line">                maxleftValue = root-&gt;val;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left) &#123;</span><br><span class="line">            <span class="built_in">traversal</span>(root-&gt;left, leftLen + <span class="number">1</span>); <span class="comment">// 隐藏着回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right) &#123;</span><br><span class="line">            <span class="built_in">traversal</span>(root-&gt;right, leftLen + <span class="number">1</span>); <span class="comment">// 隐藏着回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">traversal</span>(root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> maxleftValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="迭代法-2"><a href="#迭代法-2" class="headerlink" title="迭代法"></a>迭代法</h3><p>本题使用层序遍历再合适不过了，比递归要好理解的多！</p>
<p>只需要记录最后一行第一个节点的数值就可以了。</p>
<p>如果对层序遍历不了解，看这篇<a target="_blank" rel="noopener" href="https://programmercarl.com/0102.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86.html">二叉树：层序遍历登场！ </a>，这篇里也给出了层序遍历的模板，稍作修改就一过刷了这道题了。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) result = node-&gt;val; <span class="comment">// 记录最后一行第一个元素</span></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="路径总和"><a href="#路径总和" class="headerlink" title="路径总和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-sum/">路径总和</a></h1><p>给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<p>示例:  给定如下二叉树，以及目标和 sum &#x3D; 22，</p>
<p><img src="https://img-blog.csdnimg.cn/20210203160355234.png" alt="112.路径总和1"></p>
<p>返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5-&gt;4-&gt;11-&gt;2。</p>
<h1 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h1><p>这道题我们要遍历从根节点到叶子节点的的路径看看总和是不是目标和。</p>
<h2 id="递归-2"><a href="#递归-2" class="headerlink" title="递归"></a>递归</h2><p>可以使用深度优先遍历的方式（本题前中后序都可以，无所谓，因为中节点也没有处理逻辑）来遍历二叉树</p>
<ol>
<li>确定递归函数的参数和返回类型</li>
</ol>
<p>参数：需要二叉树的根节点，还需要一个计数器，这个计数器用来计算二叉树的一条边之和是否正好是目标和，计数器为int型。</p>
<p>再来看返回值，递归函数什么时候需要返回值？什么时候不需要返回值？这里总结如下三点：</p>
<ul>
<li>如果需要搜索整棵二叉树且不用处理递归返回值，递归函数就不要返回值。（这种情况就是本文下半部分介绍的113.路径总和ii）</li>
<li>如果需要搜索整棵二叉树且需要处理递归返回值，递归函数就需要返回值。 （这种情况我们在<a target="_blank" rel="noopener" href="https://programmercarl.com/0236.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html">236. 二叉树的最近公共祖先 </a>中介绍）</li>
<li>如果要搜索其中一条符合条件的路径，那么递归一定需要返回值，因为遇到符合条件的路径了就要及时返回。（本题的情况）</li>
</ul>
<p>而本题我们要找一条符合条件的路径，所以递归函数需要返回值，及时返回，那么返回类型是什么呢？</p>
<p>如图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/2021020316051216.png" alt="112.路径总和"></p>
<p>图中可以看出，遍历的路线，并不要遍历整棵树，所以递归函数需要返回值，可以用bool类型表示。</p>
<p>所以代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">traversal</span><span class="params">(treenode* cur, <span class="type">int</span> count)</span>   <span class="comment">// 注意函数的返回类型</span></span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>确定终止条件</li>
</ol>
<p>首先计数器如何统计这一条路径的和呢？</p>
<p>不要去累加然后判断是否等于目标和，那么代码比较麻烦，可以用递减，让计数器count初始为目标和，然后每次减去遍历路径节点上的数值。</p>
<p>如果最后count &#x3D;&#x3D; 0，同时到了叶子节点的话，说明找到了目标和。</p>
<p>如果遍历到了叶子节点，count不为0，就是没找到。</p>
<p>递归终止条件代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!cur-&gt;left &amp;&amp; !cur-&gt;right &amp;&amp; count == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 遇到叶子节点，并且计数为0</span></span><br><span class="line"><span class="keyword">if</span> (!cur-&gt;left &amp;&amp; !cur-&gt;right) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 遇到叶子节点而没有找到合适的边，直接返回</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>确定单层递归的逻辑</li>
</ol>
<p>因为终止条件是判断叶子节点，所以递归的过程中就不要让空节点进入递归了。</p>
<p>递归函数是有返回值的，如果递归函数返回true，说明找到了合适的路径，应该立刻返回。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (cur-&gt;left) &#123; <span class="comment">// 左 （空节点不遍历）</span></span><br><span class="line">    <span class="comment">// 遇到叶子节点返回true，则直接返回true</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">traversal</span>(cur-&gt;left, count - cur-&gt;left-&gt;val)) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 注意这里有回溯的逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (cur-&gt;right) &#123; <span class="comment">// 右 （空节点不遍历）</span></span><br><span class="line">    <span class="comment">// 遇到叶子节点返回true，则直接返回true</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">traversal</span>(cur-&gt;right, count - cur-&gt;right-&gt;val)) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 注意这里有回溯的逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<p>以上代码中是包含着回溯的，没有回溯，如何后撤重新找另一条路径呢。</p>
<p>回溯隐藏在<code>traversal(cur-&gt;left, count - cur-&gt;left-&gt;val)</code>这里， 因为把<code>count - cur-&gt;left-&gt;val</code> 直接作为参数传进去，函数结束，count的数值没有改变。</p>
<p>为了把回溯的过程体现出来，可以改为如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (cur-&gt;left) &#123; <span class="comment">// 左</span></span><br><span class="line">    count -= cur-&gt;left-&gt;val; <span class="comment">// 递归，处理节点;</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">traversal</span>(cur-&gt;left, count)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    count += cur-&gt;left-&gt;val; <span class="comment">// 回溯，撤销处理结果</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (cur-&gt;right) &#123; <span class="comment">// 右</span></span><br><span class="line">    count -= cur-&gt;right-&gt;val;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">traversal</span>(cur-&gt;right, count)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    count += cur-&gt;right-&gt;val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<p>整体代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">traversal</span><span class="params">(treenode* cur, <span class="type">int</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!cur-&gt;left &amp;&amp; !cur-&gt;right &amp;&amp; count == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 遇到叶子节点，并且计数为0</span></span><br><span class="line">        <span class="keyword">if</span> (!cur-&gt;left &amp;&amp; !cur-&gt;right) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 遇到叶子节点直接返回</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;left) &#123; <span class="comment">// 左</span></span><br><span class="line">            count -= cur-&gt;left-&gt;val; <span class="comment">// 递归，处理节点;</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">traversal</span>(cur-&gt;left, count)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            count += cur-&gt;left-&gt;val; <span class="comment">// 回溯，撤销处理结果</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;right) &#123; <span class="comment">// 右</span></span><br><span class="line">            count -= cur-&gt;right-&gt;val; <span class="comment">// 递归，处理节点;</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">traversal</span>(cur-&gt;right, count)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            count += cur-&gt;right-&gt;val; <span class="comment">// 回溯，撤销处理结果</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">haspathsum</span><span class="params">(treenode* root, <span class="type">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == null) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">traversal</span>(root, sum - root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>以上代码精简之后如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">haspathsum</span><span class="params">(treenode* root, <span class="type">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == null) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; sum == root-&gt;val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">haspathsum</span>(root-&gt;left, sum - root-&gt;val) || <span class="built_in">haspathsum</span>(root-&gt;right, sum - root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><p>如果使用栈模拟递归的话，那么如果做回溯呢？</p>
<p><strong>此时栈里一个元素不仅要记录该节点指针，还要记录从头结点到该节点的路径数值总和。</strong></p>
<p>c++就我们用pair结构来存放这个栈里的元素。</p>
<p>定义为：<code>pair&lt;treenode*, int&gt;</code> pair&lt;节点指针，路径数值&gt;</p>
<p>这个为栈里的一个元素。</p>
<p>如下代码是使用栈模拟的前序遍历，如下：（详细注释）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">haspathsum</span><span class="params">(treenode* root, <span class="type">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == null) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 此时栈里要放的是pair&lt;节点指针，路径数值&gt;</span></span><br><span class="line">        stack&lt;pair&lt;treenode*, <span class="type">int</span>&gt;&gt; st;</span><br><span class="line">        st.<span class="built_in">push</span>(<span class="built_in">pair</span>&lt;treenode*, <span class="type">int</span>&gt;(root, root-&gt;val));</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            pair&lt;treenode*, <span class="type">int</span>&gt; node = st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="comment">// 如果该节点是叶子节点了，同时该节点的路径数值等于sum，那么就返回true</span></span><br><span class="line">            <span class="keyword">if</span> (!node.first-&gt;left &amp;&amp; !node.first-&gt;right &amp;&amp; sum == node.second) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 右节点，压进去一个节点的时候，将该节点的路径数值也记录下来</span></span><br><span class="line">            <span class="keyword">if</span> (node.first-&gt;right) &#123;</span><br><span class="line">                st.<span class="built_in">push</span>(<span class="built_in">pair</span>&lt;treenode*, <span class="type">int</span>&gt;(node.first-&gt;right, node.second + node.first-&gt;right-&gt;val));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 左节点，压进去一个节点的时候，将该节点的路径数值也记录下来</span></span><br><span class="line">            <span class="keyword">if</span> (node.first-&gt;left) &#123;</span><br><span class="line">                st.<span class="built_in">push</span>(<span class="built_in">pair</span>&lt;treenode*, <span class="type">int</span>&gt;(node.first-&gt;left, node.second + node.first-&gt;left-&gt;val));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="路径总和ii"><a href="#路径总和ii" class="headerlink" title="路径总和ii"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-sum-ii/">路径总和ii</a></h1><p>给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<p>示例: 给定如下二叉树，以及目标和 sum &#x3D; 22，</p>
<p><img src="https://img-blog.csdnimg.cn/20210203160854654.png" alt="113.路径总和ii1.png"></p>
<h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>113.路径总和ii要遍历整个树，找到所有路径，<strong>所以递归函数不要返回值！</strong></p>
<p>如图：</p>
<p><img src="https://img-blog.csdnimg.cn/20210203160922745.png" alt="113.路径总和ii"></p>
<p>为了尽可能的把细节体现出来，我写出如下代码（<strong>这份代码并不简洁，但是逻辑非常清晰</strong>）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    <span class="comment">// 递归函数不需要返回值，因为我们要遍历整个树</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(treenode* cur, <span class="type">int</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!cur-&gt;left &amp;&amp; !cur-&gt;right &amp;&amp; count == <span class="number">0</span>) &#123; <span class="comment">// 遇到了叶子节点且找到了和为sum的路径</span></span><br><span class="line">            result.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!cur-&gt;left &amp;&amp; !cur-&gt;right) <span class="keyword">return</span> ; <span class="comment">// 遇到叶子节点而没有找到合适的边，直接返回</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;left) &#123; <span class="comment">// 左 （空节点不遍历）</span></span><br><span class="line">            path.<span class="built_in">push_back</span>(cur-&gt;left-&gt;val);</span><br><span class="line">            count -= cur-&gt;left-&gt;val;</span><br><span class="line">            <span class="built_in">traversal</span>(cur-&gt;left, count);    <span class="comment">// 递归</span></span><br><span class="line">            count += cur-&gt;left-&gt;val;        <span class="comment">// 回溯</span></span><br><span class="line">            path.<span class="built_in">pop_back</span>();                <span class="comment">// 回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;right) &#123; <span class="comment">// 右 （空节点不遍历）</span></span><br><span class="line">            path.<span class="built_in">push_back</span>(cur-&gt;right-&gt;val);</span><br><span class="line">            count -= cur-&gt;right-&gt;val;</span><br><span class="line">            <span class="built_in">traversal</span>(cur-&gt;right, count);   <span class="comment">// 递归</span></span><br><span class="line">            count += cur-&gt;right-&gt;val;       <span class="comment">// 回溯</span></span><br><span class="line">            path.<span class="built_in">pop_back</span>();                <span class="comment">// 回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">pathsum</span>(treenode* root, <span class="type">int</span> sum) &#123;</span><br><span class="line">        result.<span class="built_in">clear</span>();</span><br><span class="line">        path.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">if</span> (root == null) <span class="keyword">return</span> result;</span><br><span class="line">        path.<span class="built_in">push_back</span>(root-&gt;val); <span class="comment">// 把根节点放进路径</span></span><br><span class="line">        <span class="built_in">traversal</span>(root, sum - root-&gt;val);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="从中序与后序遍历序列构造二叉树"><a href="#从中序与后序遍历序列构造二叉树" class="headerlink" title="从中序与后序遍历序列构造二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">从中序与后序遍历序列构造二叉树</a></h1><p>根据一棵树的中序遍历与后序遍历构造二叉树。</p>
<p>注意: 你可以假设树中没有重复的元素。</p>
<p>例如，给出</p>
<p>中序遍历 inorder &#x3D; [9,3,15,20,7] 后序遍历 postorder &#x3D; [9,15,7,20,3] 返回如下的二叉树：</p>
<p><img src="https://img-blog.csdnimg.cn/20210203154316774.png" alt="106. 从中序与后序遍历序列构造二叉树1"></p>
<h2 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h2><p>首先回忆一下如何根据两个顺序构造一个唯一的二叉树，相信理论知识大家应该都清楚，就是以 后序数组的最后一个元素为切割点，先切中序数组，根据中序数组，反过来在切后序数组。一层一层切下去，每次后序数组最后一个元素就是节点元素。</p>
<p>如果让我们肉眼看两个序列，画一棵二叉树的话，应该分分钟都可以画出来。</p>
<p>流程如图：</p>
<p><img src="https://img-blog.csdnimg.cn/20210203154249860.png" alt="106.从中序与后序遍历序列构造二叉树"></p>
<p>那么代码应该怎么写呢？</p>
<p>说到一层一层切割，就应该想到了递归。</p>
<p>来看一下一共分几步：</p>
<ul>
<li><p>第一步：如果数组大小为零的话，说明是空节点了。</p>
</li>
<li><p>第二步：如果不为空，那么取后序数组最后一个元素作为节点元素。</p>
</li>
<li><p>第三步：找到后序数组最后一个元素在中序数组的位置，作为切割点</p>
</li>
<li><p>第四步：切割<strong>中序数组</strong>，切成中序左数组和中序右数组 （顺序别搞反了，一定是先切中序数组）</p>
</li>
<li><p>第五步：切割后序数组，切成后序左数组和后序右数组</p>
</li>
<li><p>第六步：递归处理左区间和右区间</p>
</li>
</ul>
<p>不难写出如下代码：（先把框架写出来）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">traversal</span> <span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; inorder, vector&lt;<span class="type">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一步</span></span><br><span class="line">    <span class="keyword">if</span> (postorder.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二步：后序遍历数组最后一个元素，就是当前的中间节点</span></span><br><span class="line">    <span class="type">int</span> rootValue = postorder[postorder.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">    TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(rootValue);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 叶子节点</span></span><br><span class="line">    <span class="keyword">if</span> (postorder.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第三步：找切割点</span></span><br><span class="line">    <span class="type">int</span> delimiterIndex;</span><br><span class="line">    <span class="keyword">for</span> (delimiterIndex = <span class="number">0</span>; delimiterIndex &lt; inorder.<span class="built_in">size</span>(); delimiterIndex++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (inorder[delimiterIndex] == rootValue) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第四步：切割中序数组，得到 中序左数组和中序右数组</span></span><br><span class="line">    <span class="comment">// 第五步：切割后序数组，得到 后序左数组和后序右数组</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第六步</span></span><br><span class="line">    root-&gt;left = <span class="built_in">traversal</span>(中序左数组, 后序左数组);</span><br><span class="line">    root-&gt;right = <span class="built_in">traversal</span>(中序右数组, 后序右数组);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>难点大家应该发现了，就是如何切割，以及边界值找不好很容易乱套。</strong></p>
<p>此时应该注意确定切割的标准，是左闭右开，还有左开右闭，还是左闭右闭，这个就是不变量，要在递归中保持这个不变量。</p>
<p><strong>在切割的过程中会产生四个区间，把握不好不变量的话，一会左闭右开，一会左闭右闭，必然乱套！</strong></p>
<p>我在<a target="_blank" rel="noopener" href="https://programmercarl.com/0035.%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE.html">数组：每次遇到二分法，都是一看就会，一写就废</a>和<a target="_blank" rel="noopener" href="https://programmercarl.com/0059.%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5II.html">数组：这个循环可以转懵很多人！</a>中都强调过循环不变量的重要性，在二分查找以及螺旋矩阵的求解中，坚持循环不变量非常重要，本题也是。</p>
<p>首先要切割中序数组，为什么先切割中序数组呢？</p>
<p>切割点在后序数组的最后一个元素，就是用这个元素来切割中序数组的，所以必要先切割中序数组。</p>
<p>中序数组相对比较好切，找到切割点（后序数组的最后一个元素）在中序数组的位置，然后切割，如下代码中我坚持左闭右开的原则：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找到中序遍历的切割点</span></span><br><span class="line"><span class="type">int</span> delimiterIndex;</span><br><span class="line"><span class="keyword">for</span> (delimiterIndex = <span class="number">0</span>; delimiterIndex &lt; inorder.<span class="built_in">size</span>(); delimiterIndex++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (inorder[delimiterIndex] == rootValue) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 左闭右开区间：[0, delimiterIndex)</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">leftInorder</span><span class="params">(inorder.begin(), inorder.begin() + delimiterIndex)</span></span>;</span><br><span class="line"><span class="comment">// [delimiterIndex + 1, end)</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rightInorder</span><span class="params">(inorder.begin() + delimiterIndex + <span class="number">1</span>, inorder.end() )</span></span>;</span><br></pre></td></tr></table></figure>

<p>接下来就要切割后序数组了。</p>
<p>首先后序数组的最后一个元素指定不能要了，这是切割点 也是 当前二叉树中间节点的元素，已经用了。</p>
<p>后序数组的切割点怎么找？</p>
<p>后序数组没有明确的切割元素来进行左右切割，不像中序数组有明确的切割点，切割点左右分开就可以了。</p>
<p><strong>此时有一个很重的点，就是中序数组大小一定是和后序数组的大小相同的（这是必然）。</strong></p>
<p>中序数组我们都切成了左中序数组和右中序数组了，那么后序数组就可以按照左中序数组的大小来切割，切成左后序数组和右后序数组。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// postorder 舍弃末尾元素，因为这个元素就是中间节点，已经用过了</span></span><br><span class="line">postorder.<span class="built_in">resize</span>(postorder.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 左闭右开，注意这里使用了左中序数组大小作为切割点：[0, leftInorder.size)</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">leftPostorder</span><span class="params">(postorder.begin(), postorder.begin() + leftInorder.size())</span></span>;</span><br><span class="line"><span class="comment">// [leftInorder.size(), end)</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rightPostorder</span><span class="params">(postorder.begin() + leftInorder.size(), postorder.end())</span></span>;</span><br></pre></td></tr></table></figure>

<p>此时，中序数组切成了左中序数组和右中序数组，后序数组切割成左后序数组和右后序数组。</p>
<p>接下来可以递归了，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root-&gt;left = <span class="built_in">traversal</span>(leftInorder, leftPostorder);</span><br><span class="line">root-&gt;right = <span class="built_in">traversal</span>(rightInorder, rightPostorder);</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">traversal</span> <span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; inorder, vector&lt;<span class="type">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (postorder.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 后序遍历数组最后一个元素，就是当前的中间节点</span></span><br><span class="line">        <span class="type">int</span> rootValue = postorder[postorder.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(rootValue);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 叶子节点</span></span><br><span class="line">        <span class="keyword">if</span> (postorder.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到中序遍历的切割点</span></span><br><span class="line">        <span class="type">int</span> delimiterIndex;</span><br><span class="line">        <span class="keyword">for</span> (delimiterIndex = <span class="number">0</span>; delimiterIndex &lt; inorder.<span class="built_in">size</span>(); delimiterIndex++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inorder[delimiterIndex] == rootValue) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 切割中序数组</span></span><br><span class="line">        <span class="comment">// 左闭右开区间：[0, delimiterIndex)</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">leftInorder</span><span class="params">(inorder.begin(), inorder.begin() + delimiterIndex)</span></span>;</span><br><span class="line">        <span class="comment">// [delimiterIndex + 1, end)</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rightInorder</span><span class="params">(inorder.begin() + delimiterIndex + <span class="number">1</span>, inorder.end() )</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// postorder 舍弃末尾元素</span></span><br><span class="line">        postorder.<span class="built_in">resize</span>(postorder.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 切割后序数组</span></span><br><span class="line">        <span class="comment">// 依然左闭右开，注意这里使用了左中序数组大小作为切割点</span></span><br><span class="line">        <span class="comment">// [0, leftInorder.size)</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">leftPostorder</span><span class="params">(postorder.begin(), postorder.begin() + leftInorder.size())</span></span>;</span><br><span class="line">        <span class="comment">// [leftInorder.size(), end)</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rightPostorder</span><span class="params">(postorder.begin() + leftInorder.size(), postorder.end())</span></span>;</span><br><span class="line"></span><br><span class="line">        root-&gt;left = <span class="built_in">traversal</span>(leftInorder, leftPostorder);</span><br><span class="line">        root-&gt;right = <span class="built_in">traversal</span>(rightInorder, rightPostorder);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; inorder, vector&lt;<span class="type">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (inorder.<span class="built_in">size</span>() == <span class="number">0</span> || postorder.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">traversal</span>(inorder, postorder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="最大二叉树"><a href="#最大二叉树" class="headerlink" title="最大二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-binary-tree/">最大二叉树</a></h1><p>给定一个不含重复元素的整数数组。一个以此数组构建的最大二叉树定义如下：</p>
<ul>
<li>二叉树的根是数组中的最大元素。</li>
<li>左子树是通过数组中最大值左边部分构造出的最大二叉树。</li>
<li>右子树是通过数组中最大值右边部分构造出的最大二叉树。</li>
</ul>
<p>通过给定的数组构建最大二叉树，并且输出这个树的根节点。</p>
<p>示例 ：</p>
<p><img src="https://img-blog.csdnimg.cn/20210204154534796.png" alt="654.最大二叉树"></p>
<p>提示：</p>
<p>给定的数组的大小在 [1, 1000] 之间。</p>
<h2 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h2><p>最大二叉树的构建过程如下：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gnbjuvioezg30dw0921ck.gif" alt="654.最大二叉树"></p>
<p><strong>构造树一般采用的是前序遍历</strong>，因为先构造中间节点，然后递归构造左子树和右子树。</p>
<ol>
<li>确定递归函数的参数和返回值</li>
</ol>
<p>参数就是传入的是存放元素的数组，返回该数组构造的二叉树的头结点，返回类型是指向节点的指针。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">constructMaximumBinaryTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>确定终止条件</li>
</ol>
<p>题目中说了输入的数组大小一定是大于等于1的，所以我们不用考虑小于1的情况，那么当递归遍历的时候，如果传入的数组大小为1，说明遍历到了叶子节点了。</p>
<p>那么应该定义一个新的节点，并把这个数组的数值赋给新的节点，然后返回这个节点。 这表示一个数组大小是1的时候，构造了一个新的节点，并返回。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">    node-&gt;val = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>确定单层递归的逻辑</li>
</ol>
<p>这里有三步工作</p>
<ul>
<li>先要找到数组中最大的值和对应的下标， 最大的值构造根节点，下标用来下一步分割数组。</li>
</ul>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> maxValue = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> maxValueIndex = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[i] &gt; maxValue) &#123;</span><br><span class="line">        maxValue = nums[i];</span><br><span class="line">        maxValueIndex = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">TreeNode* node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">0</span>);</span><br><span class="line">node-&gt;val = maxValue;</span><br></pre></td></tr></table></figure>

<ul>
<li>最大值所在的下标左区间 构造左子树</li>
</ul>
<p>这里要判断maxValueIndex &gt; 0，因为要保证左区间至少有一个数值。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (maxValueIndex &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">newVec</span><span class="params">(nums.begin(), nums.begin() + maxValueIndex)</span></span>;</span><br><span class="line">    node-&gt;left = <span class="built_in">constructMaximumBinaryTree</span>(newVec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>最大值所在的下标右区间 构造右子树</li>
</ul>
<p>判断maxValueIndex &lt; (nums.size() - 1)，确保右区间至少有一个数值。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (maxValueIndex &lt; (nums.<span class="built_in">size</span>() - <span class="number">1</span>)) &#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">newVec</span><span class="params">(nums.begin() + maxValueIndex + <span class="number">1</span>, nums.end())</span></span>;</span><br><span class="line">    node-&gt;right = <span class="built_in">constructMaximumBinaryTree</span>(newVec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样我们就分析完了，整体代码如下：（详细注释）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">constructMaximumBinaryTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        TreeNode* node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">            node-&gt;val = nums[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到数组中最大的值和对应的下标</span></span><br><span class="line">        <span class="type">int</span> maxValue = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> maxValueIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; maxValue) &#123;</span><br><span class="line">                maxValue = nums[i];</span><br><span class="line">                maxValueIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;val = maxValue;</span><br><span class="line">        <span class="comment">// 最大值所在的下标左区间 构造左子树</span></span><br><span class="line">        <span class="keyword">if</span> (maxValueIndex &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">newVec</span><span class="params">(nums.begin(), nums.begin() + maxValueIndex)</span></span>;</span><br><span class="line">            node-&gt;left = <span class="built_in">constructMaximumBinaryTree</span>(newVec);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最大值所在的下标右区间 构造右子树</span></span><br><span class="line">        <span class="keyword">if</span> (maxValueIndex &lt; (nums.<span class="built_in">size</span>() - <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">newVec</span><span class="params">(nums.begin() + maxValueIndex + <span class="number">1</span>, nums.end())</span></span>;</span><br><span class="line">            node-&gt;right = <span class="built_in">constructMaximumBinaryTree</span>(newVec);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>以上代码比较冗余，效率也不高，每次还要切割的时候每次都要定义新的vector（也就是数组），但逻辑比较清晰。</p>
<p>和文章<a target="_blank" rel="noopener" href="https://programmercarl.com/0106.%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91.html">二叉树：构造二叉树登场！</a>中一样的优化思路，就是每次分隔不用定义新的数组，而是通过下标索引直接在原数组上操作。</p>
<p>优化后代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 在左闭右开区间[left, right)，构造二叉树</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">traversal</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分割点下标：maxValueIndex</span></span><br><span class="line">        <span class="type">int</span> maxValueIndex = left;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = left + <span class="number">1</span>; i &lt; right; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[maxValueIndex]) maxValueIndex = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(nums[maxValueIndex]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左闭右开：[left, maxValueIndex)</span></span><br><span class="line">        root-&gt;left = <span class="built_in">traversal</span>(nums, left, maxValueIndex);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左闭右开：[maxValueIndex + 1, right)</span></span><br><span class="line">        root-&gt;right = <span class="built_in">traversal</span>(nums, maxValueIndex + <span class="number">1</span>, right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">constructMaximumBinaryTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">traversal</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="合并二叉树"><a href="#合并二叉树" class="headerlink" title="合并二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-two-binary-trees/">合并二叉树</a></h1><p>给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。</p>
<p>你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。</p>
<p>示例 1:</p>
<p><img src="https://img-blog.csdnimg.cn/20210204153634809.png" alt="617.合并二叉树"></p>
<p>注意: 合并必须从两个树的根节点开始。</p>
<h2 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h2><p>相信这道题目很多同学疑惑的点是如何同时遍历两个二叉树呢？</p>
<p>其实和遍历一个树逻辑是一样的，只不过传入两个树的节点，同时操作。</p>
<h2 id="递归-3"><a href="#递归-3" class="headerlink" title="递归"></a>递归</h2><p>二叉树使用递归，就要想使用前中后哪种遍历方式？</p>
<p><strong>本题使用哪种遍历都是可以的！</strong></p>
<p>我们下面以前序遍历为例。</p>
<p>动画如下：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gnbjjq8h16g30e20cwnpd.gif" alt="617.合并二叉树"></p>
<p>那么我们来按照递归三部曲来解决：</p>
<ol>
<li><strong>确定递归函数的参数和返回值：</strong></li>
</ol>
<p>首先那么要合入两个二叉树，那么参数至少是要传入两个二叉树的根节点，返回值就是合并之后二叉树的根节点。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* t1, TreeNode* t2)</span> </span>&#123;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>确定终止条件：</strong></li>
</ol>
<p>因为是传入了两个树，那么就有两个树遍历的节点t1 和 t2，如果t1 &#x3D;&#x3D; NULL 了，两个树合并就应该是 t2 了啊（如果t2也为NULL也无所谓，合并之后就是NULL）。</p>
<p>反过来如果t2 &#x3D;&#x3D; NULL，那么两个数合并就是t1（如果t1也为NULL也无所谓，合并之后就是NULL）。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (t1 == <span class="literal">NULL</span>) <span class="keyword">return</span> t2; <span class="comment">// 如果t1为空，合并之后就应该是t2</span></span><br><span class="line"><span class="keyword">if</span> (t2 == <span class="literal">NULL</span>) <span class="keyword">return</span> t1; <span class="comment">// 如果t2为空，合并之后就应该是t1</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>确定单层递归的逻辑：</strong></li>
</ol>
<p>单层递归的逻辑就比较好些了，这里我们用重复利用一下t1这个树，t1就是合并之后树的根节点（就是修改了原来树的结构）。</p>
<p>那么单层递归中，就要把两棵树的元素加到一起。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t1-&gt;val += t2-&gt;val;</span><br></pre></td></tr></table></figure>

<p>接下来t1 的左子树是：合并 t1左子树 t2左子树之后的左子树。</p>
<p>t1 的右子树：是 合并 t1右子树 t2右子树之后的右子树。</p>
<p>最终t1就是合并之后的根节点。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t1-&gt;left = <span class="built_in">mergeTrees</span>(t1-&gt;left, t2-&gt;left);</span><br><span class="line">t1-&gt;right = <span class="built_in">mergeTrees</span>(t1-&gt;right, t2-&gt;right);</span><br><span class="line"><span class="keyword">return</span> t1;</span><br></pre></td></tr></table></figure>

<p>此时前序遍历，完整代码就写出来了，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* t1, TreeNode* t2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="literal">NULL</span>) <span class="keyword">return</span> t2; <span class="comment">// 如果t1为空，合并之后就应该是t2</span></span><br><span class="line">        <span class="keyword">if</span> (t2 == <span class="literal">NULL</span>) <span class="keyword">return</span> t1; <span class="comment">// 如果t2为空，合并之后就应该是t1</span></span><br><span class="line">        <span class="comment">// 修改了t1的数值和结构</span></span><br><span class="line">        t1-&gt;val += t2-&gt;val;                             <span class="comment">// 中</span></span><br><span class="line">        t1-&gt;left = <span class="built_in">mergeTrees</span>(t1-&gt;left, t2-&gt;left);      <span class="comment">// 左</span></span><br><span class="line">        t1-&gt;right = <span class="built_in">mergeTrees</span>(t1-&gt;right, t2-&gt;right);   <span class="comment">// 右</span></span><br><span class="line">        <span class="keyword">return</span> t1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>那么中序遍历也是可以的，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* t1, TreeNode* t2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="literal">NULL</span>) <span class="keyword">return</span> t2; <span class="comment">// 如果t1为空，合并之后就应该是t2</span></span><br><span class="line">        <span class="keyword">if</span> (t2 == <span class="literal">NULL</span>) <span class="keyword">return</span> t1; <span class="comment">// 如果t2为空，合并之后就应该是t1</span></span><br><span class="line">        <span class="comment">// 修改了t1的数值和结构</span></span><br><span class="line">        t1-&gt;left = <span class="built_in">mergeTrees</span>(t1-&gt;left, t2-&gt;left);      <span class="comment">// 左</span></span><br><span class="line">        t1-&gt;val += t2-&gt;val;                             <span class="comment">// 中</span></span><br><span class="line">        t1-&gt;right = <span class="built_in">mergeTrees</span>(t1-&gt;right, t2-&gt;right);   <span class="comment">// 右</span></span><br><span class="line">        <span class="keyword">return</span> t1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>后序遍历依然可以，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* t1, TreeNode* t2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="literal">NULL</span>) <span class="keyword">return</span> t2; <span class="comment">// 如果t1为空，合并之后就应该是t2</span></span><br><span class="line">        <span class="keyword">if</span> (t2 == <span class="literal">NULL</span>) <span class="keyword">return</span> t1; <span class="comment">// 如果t2为空，合并之后就应该是t1</span></span><br><span class="line">        <span class="comment">// 修改了t1的数值和结构</span></span><br><span class="line">        t1-&gt;left = <span class="built_in">mergeTrees</span>(t1-&gt;left, t2-&gt;left);      <span class="comment">// 左</span></span><br><span class="line">        t1-&gt;right = <span class="built_in">mergeTrees</span>(t1-&gt;right, t2-&gt;right);   <span class="comment">// 右</span></span><br><span class="line">        t1-&gt;val += t2-&gt;val;                             <span class="comment">// 中</span></span><br><span class="line">        <span class="keyword">return</span> t1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>但是前序遍历是最好理解的，我建议大家用前序遍历来做就OK。</strong></p>
<p>如上的方法修改了t1的结构，当然也可以不修改t1和t2的结构，重新定一个树。</p>
<p>不修改输入树的结构，前序遍历，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* t1, TreeNode* t2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="literal">NULL</span>) <span class="keyword">return</span> t2;</span><br><span class="line">        <span class="keyword">if</span> (t2 == <span class="literal">NULL</span>) <span class="keyword">return</span> t1;</span><br><span class="line">        <span class="comment">// 重新定义新的节点，不修改原有两个树的结构</span></span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">0</span>);</span><br><span class="line">        root-&gt;val = t1-&gt;val + t2-&gt;val;</span><br><span class="line">        root-&gt;left = <span class="built_in">mergeTrees</span>(t1-&gt;left, t2-&gt;left);</span><br><span class="line">        root-&gt;right = <span class="built_in">mergeTrees</span>(t1-&gt;right, t2-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="迭代法-3"><a href="#迭代法-3" class="headerlink" title="迭代法"></a>迭代法</h2><p>使用迭代法，如何同时处理两棵树呢？</p>
<p>思路我们在<a target="_blank" rel="noopener" href="https://programmercarl.com/0101.%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91.html">二叉树：我对称么？</a>中的迭代法已经讲过一次了，求二叉树对称的时候就是把两个树的节点同时加入队列进行比较。</p>
<p>本题我们也使用队列，模拟的层序遍历，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* t1, TreeNode* t2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="literal">NULL</span>) <span class="keyword">return</span> t2;</span><br><span class="line">        <span class="keyword">if</span> (t2 == <span class="literal">NULL</span>) <span class="keyword">return</span> t1;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(t1);</span><br><span class="line">        que.<span class="built_in">push</span>(t2);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* node1 = que.<span class="built_in">front</span>(); que.<span class="built_in">pop</span>();</span><br><span class="line">            TreeNode* node2 = que.<span class="built_in">front</span>(); que.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="comment">// 此时两个节点一定不为空，val相加</span></span><br><span class="line">            node1-&gt;val += node2-&gt;val;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果两棵树左节点都不为空，加入队列</span></span><br><span class="line">            <span class="keyword">if</span> (node1-&gt;left != <span class="literal">NULL</span> &amp;&amp; node2-&gt;left != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                que.<span class="built_in">push</span>(node1-&gt;left);</span><br><span class="line">                que.<span class="built_in">push</span>(node2-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果两棵树右节点都不为空，加入队列</span></span><br><span class="line">            <span class="keyword">if</span> (node1-&gt;right != <span class="literal">NULL</span> &amp;&amp; node2-&gt;right != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                que.<span class="built_in">push</span>(node1-&gt;right);</span><br><span class="line">                que.<span class="built_in">push</span>(node2-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当t1的左节点 为空 t2左节点不为空，就赋值过去</span></span><br><span class="line">            <span class="keyword">if</span> (node1-&gt;left == <span class="literal">NULL</span> &amp;&amp; node2-&gt;left != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                node1-&gt;left = node2-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当t1的右节点 为空 t2右节点不为空，就赋值过去</span></span><br><span class="line">            <span class="keyword">if</span> (node1-&gt;right == <span class="literal">NULL</span> &amp;&amp; node2-&gt;right != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                node1-&gt;right = node2-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>声明</p>
<p>本博客整理思路来自《代码随想录》题目来自leetcode</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/27/UE4-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="williny">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Williny'home">
      <meta itemprop="description" content="孤独是人生的常态">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Williny'home">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/05/27/UE4-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/" class="post-title-link" itemprop="url">UE4-智能指针</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-05-27 14:59:42" itemprop="dateCreated datePublished" datetime="2022-05-27T14:59:42+08:00">2022-05-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-07-06 16:15:24" itemprop="dateModified" datetime="2022-07-06T16:15:24+08:00">2022-07-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/unreal-engine/" itemprop="url" rel="index"><span itemprop="name">unreal engine</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p><strong>虚幻智能指针库</strong> 为C++11智能指针的自定义实现，旨在减轻内存分配和追踪的负担。</p>
<p>该实现包括行业标准 <strong>共享指针</strong>、<strong>弱指针</strong> 和 <strong>唯一指针</strong>。</p>
<p>其还可添加 <strong>共享引用</strong>，此类引用的行为与不可为空的共享指针相同。</p>
<p>虚幻Objects使用更适合游戏代码的单独内存追踪系统，因此这些类无法与 <code>UObject</code> 系统同时使用。</p>
<h2 id="人话"><a href="#人话" class="headerlink" title="人话"></a>人话</h2><p>就是魔改了原本C++11中的智能指针，使得更加适合虚幻引擎</p>
<h1 id="智能指针类型"><a href="#智能指针类型" class="headerlink" title="智能指针类型"></a>智能指针类型</h1><p>智能指针可影响其包含或引用对象的寿命。不同智能指针对对象有不同的限制和影响。下表可用于协助决定各类型智能指针的适用情况：</p>
<table>
<thead>
<tr>
<th>智能指针类型</th>
<th>适用情形</th>
</tr>
</thead>
<tbody><tr>
<td>共享指针(<code>TSharedPtr</code>)</td>
<td>共享指针拥有其引用的对象，无限防止该对象被删除，并在无共享指针或共享引用引用其时，最终处理其的删除。共享指针可为空白，意味其不引用任何对象。任何非空共享指针都可对其引用的对象生成共享引用。</td>
</tr>
<tr>
<td>共享引用(<code>TSharedRed</code>)</td>
<td>共享引用的行为与共享指针类似，即其拥有自身引用的对象。对于空对象而言，其存在不同；共享引用须固定引用非空对象。共享指针无此类限制，因此共享引用可固定转换为共享指针，且该共享指针固定引用有效对象。要确认引用的对象是非空，或者要表明共享对象所有权时，请使用共享引用。</td>
</tr>
<tr>
<td>弱指针(<code>TWeakPtr</code>)</td>
<td>弱指针类与共享指针类似，但不拥有其引用的对象，因此不影响其生命周期。此属性中断引用循环，因此十分有用，但也意味弱指针可在无预警的情况下随时变为空。因此，弱指针可生成指向其引用对象的共享指针，确保程序员能对该对象进行安全临时访问。</td>
</tr>
<tr>
<td><strong>唯一指针</strong>（<code>TUniquePtr</code>）</td>
<td>唯一指针仅会显式拥有其引用的对象。仅有一个唯一指针指向给定资源，因此唯一指针可转移所有权，但无法共享。复制唯一指针的任何尝试都将导致编译错误。唯一指针超出范围时，其将自动删除其所引用的对象。</td>
</tr>
</tbody></table>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>对唯一指针引用的对象进行共享指针或共享引用的操作十分危险。即使其他智能指针继续引用该对象，此操作不会取消唯一指针自身被销毁时删除该对象的行为。同样，不应为共享指针或共享引用引用的对象创建唯一指针。</p>
<table>
<thead>
<tr>
<th>优点</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>防止内存泄漏</strong></td>
<td>共享引用不存在时，智能指针（弱指针除外）会自动删除对象。</td>
</tr>
<tr>
<td><strong>弱引用</strong></td>
<td>弱指针会中断引用循环并阻止悬挂指针。</td>
</tr>
<tr>
<td><strong>可选择的线程安全</strong>）</td>
<td>虚幻智能指针库包括线程安全代码，可跨线程管理引用计数。如无需线程安全，可用其换取更好性能。</td>
</tr>
<tr>
<td><strong>运行时安全</strong></td>
<td>共享引用从不为空，可固定随时取消引用。</td>
</tr>
<tr>
<td><strong>授予意图</strong></td>
<td>可轻松区分对象所有者和观察者。</td>
</tr>
<tr>
<td><strong>内存</strong></td>
<td>智能指针在64位下仅为C++指针大小的两倍（加上共享的16字节引用控制器）。唯一指针除外，其与C++指针大小相同。</td>
</tr>
</tbody></table>
<h1 id="TSharedPtr"><a href="#TSharedPtr" class="headerlink" title="TSharedPtr"></a>TSharedPtr</h1><p>同C++11的共享指针没有区别</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用普通指针右值初始化（不建议用普通指针左值初始化） </span></span><br><span class="line"><span class="function">TSharedPtr&lt;<span class="type">int</span>&gt; <span class="title">sp1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">111</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 强烈建议用MakeShared接口 </span></span><br><span class="line">TSharedPtr&lt;<span class="type">int</span>&gt; sp2 = <span class="built_in">MakeShared</span>&lt;<span class="type">int</span>&gt;(<span class="number">222</span>);</span><br><span class="line"><span class="function">TSharedPtr&lt;<span class="type">int</span>&gt; <span class="title">sp3</span><span class="params">(MakeShared&lt;<span class="type">int</span>&gt;(<span class="number">333</span>))</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h2><ol>
<li>尽量不要在一个函数的生命周期去声明一个临时的共享指针（性能开销大！）</li>
</ol>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建共享指针的基本类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TaskA</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ATaskActor::TaskAA</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//将普通的指针转换为只能指针，也就是使用MakeTShareable接口</span></span><br><span class="line">    Task_a=<span class="built_in">MakeShareable</span>(<span class="keyword">new</span> <span class="built_in">TaskA</span>());<span class="comment">//根据TaskA类创建一个共享指针Task_a</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用已经创建好的Task_a</span></span><br><span class="line">    <span class="keyword">if</span>(Task_a.<span class="built_in">IsValid</span>()||Task_a.<span class="built_in">Get</span>())&#123;<span class="comment">//两者任选其一，推荐后者，因为使用后者之后不需要再引用具体值的时候使用.Get()了</span></span><br><span class="line">    Task_a.<span class="built_in">Get</span>()-&gt;a;<span class="comment">//必须要加上.Get()，否则容易引起断言崩溃</span></span><br><span class="line">    Task_a.<span class="built_in">Reset</span>();<span class="comment">//销毁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="TWeakPtr-弱指针"><a href="#TWeakPtr-弱指针" class="headerlink" title="TWeakPtr 弱指针"></a>TWeakPtr 弱指针</h1><p>同C++11的弱指针也没啥区别</p>
<p>注意：</p>
<ul>
<li>TWeakPtr 对内存并没有实际所有权，如果指向的<strong>共享内存被释放</strong>，<strong>TWeakPtr 也会变成空对象</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">TSharedPtr&lt;<span class="type">int</span>&gt; sp = <span class="built_in">MakeShared</span>&lt;<span class="type">int</span>&gt;(<span class="number">666</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多种创建方式 </span></span><br><span class="line">TWeakPtr&lt;<span class="type">int</span>&gt; wp1 = sp;</span><br><span class="line"><span class="function">TWeakPtr&lt;<span class="type">int</span>&gt; <span class="title">wp2</span><span class="params">(sp)</span></span>;</span><br><span class="line">TWeakPtr&lt;<span class="type">int</span>&gt; wp3 = wp2;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TWeakPtr 也可以指向 TSharedRef </span></span><br><span class="line">TSharedRef&lt;<span class="type">int</span>&gt; sr = <span class="built_in">MakeShared</span>&lt;<span class="type">int</span>&gt;(<span class="number">888</span>);</span><br><span class="line"><span class="function">TWeakPtr&lt;<span class="type">int</span>&gt; <span class="title">wp4</span><span class="params">(sr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个TSharedPtr，若其指向内存已被释放，则返回一个空智能指针对象 </span></span><br><span class="line"><span class="comment">// 特别注意，既然返回了一个TSharedPtr，其引用计数自然要加1</span></span><br><span class="line">TSharedPtr&lt;<span class="type">int</span>&gt; _sp = wp1.<span class="built_in">Pin</span>();</span><br></pre></td></tr></table></figure>

<p>和标准C++的 weak_ptr 一样，<strong>TWeakPtr 主要也是为了解决 TSharedPtr 环形引用的问题：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">B</span>;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">A</span>() &#123; <span class="built_in">UE_LOG</span>(LogTemp, Log, <span class="built_in">TEXT</span>(<span class="string">&quot;Construct class A&quot;</span>)); &#125;</span><br><span class="line">        ~<span class="built_in">A</span>() &#123; <span class="built_in">UE_LOG</span>(LogTemp, Log, <span class="built_in">TEXT</span>(<span class="string">&quot;Destruct class A&quot;</span>)); &#125;</span><br><span class="line">        TSharedPtr&lt;B&gt; m_spB;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">B</span>() &#123; <span class="built_in">UE_LOG</span>(LogTemp, Log, <span class="built_in">TEXT</span>(<span class="string">&quot;Construct class B&quot;</span>)); &#125;</span><br><span class="line">        ~<span class="built_in">B</span>() &#123; <span class="built_in">UE_LOG</span>(LogTemp, Log, <span class="built_in">TEXT</span>(<span class="string">&quot;Destruct class B&quot;</span>)); &#125;</span><br><span class="line">        TSharedPtr&lt;A&gt; m_spA;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> spA = <span class="built_in">MakeShared</span>&lt;A&gt;();</span><br><span class="line">    <span class="keyword">auto</span> spB = <span class="built_in">MakeShared</span>&lt;B&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发生了环形引用，两个对象的指针成员互相指向彼此的实例 </span></span><br><span class="line">    spA-&gt;m_spB = spB;</span><br><span class="line">    spB-&gt;m_spA = spA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 离开作用域后两个局部对象并没有析构，日志输出：</span></span><br><span class="line"><span class="comment">// LogTemp: Construct class A</span></span><br><span class="line"><span class="comment">// LogTemp: Construct class B</span></span><br></pre></td></tr></table></figure>

<p>因为A的实例中，有成员指向了B的实例，而B的实例，又有成员指向了A的实例，形成了一个环，导致彼此都不能正确释放（<strong>都在等待指向彼此的指针成员指向的对象释放完成</strong>）</p>
<p>从而造成内存泄漏，此时就需要 TWeakPtr 上场了，只需要将A或B或二者类的定义中的指针成员由 TSharedPtr 改成 TWeakPtr 即可。因为 <strong>TWeakPtr 只引用不计数</strong>的特性，<strong>当拥有 TWeakPtr 成员的对象析构时，不会因为 TWeakPtr 所指向的内存还未释放而导致析构失败：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">B</span>;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">A</span>() &#123; <span class="built_in">UE_LOG</span>(LogTemp, Log, <span class="built_in">TEXT</span>(<span class="string">&quot;Construct class A&quot;</span>)); &#125;</span><br><span class="line">        ~<span class="built_in">A</span>() &#123; <span class="built_in">UE_LOG</span>(LogTemp, Log, <span class="built_in">TEXT</span>(<span class="string">&quot;Destruct class A&quot;</span>)); &#125;</span><br><span class="line">        <span class="comment">// 类A,B更改其一即可，这里二者都改成了弱引用 </span></span><br><span class="line">        TWeakPtr&lt;B&gt; m_spB;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">B</span>() &#123; <span class="built_in">UE_LOG</span>(LogTemp, Log, <span class="built_in">TEXT</span>(<span class="string">&quot;Construct class B&quot;</span>)); &#125;</span><br><span class="line">        ~<span class="built_in">B</span>() &#123; <span class="built_in">UE_LOG</span>(LogTemp, Log, <span class="built_in">TEXT</span>(<span class="string">&quot;Destruct class B&quot;</span>)); &#125;</span><br><span class="line">        <span class="comment">// 类A,B更改其一即可，这里二者都改成了弱引用 </span></span><br><span class="line">        TWeakPtr&lt;A&gt; m_spA;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> spA = <span class="built_in">MakeShared</span>&lt;A&gt;();</span><br><span class="line">    <span class="keyword">auto</span> spB = <span class="built_in">MakeShared</span>&lt;B&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发生了环形引用，但 TWeakPtr 只引用不计数 </span></span><br><span class="line">    spA-&gt;m_spB = spB;</span><br><span class="line">    spB-&gt;m_spA = spA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 离开作用域析构时，TWeakPtr 不会导致析构失败，日志输出：</span></span><br><span class="line"><span class="comment">// LogTemp: Construct class A</span></span><br><span class="line"><span class="comment">// LogTemp: Construct class B</span></span><br><span class="line"><span class="comment">// LogTemp: Destruct class B</span></span><br><span class="line"><span class="comment">// LogTemp: Destruct class A</span></span><br></pre></td></tr></table></figure>

<h1 id="TSharedRef-共享引用"><a href="#TSharedRef-共享引用" class="headerlink" title="TSharedRef 共享引用"></a>TSharedRef 共享引用</h1><p>虚幻引擎中独有的一种不可为空的智能指针</p>
<ol>
<li><p>不可为空</p>
</li>
<li><p>必须初始化（必须声明的时候就赋值！）</p>
</li>
<li><p>必须指向非空对象</p>
</li>
<li><p>无Reset() 和 IsValid() 接口</p>
</li>
<li><p><strong>只有 TSharedPtr 才能利用 ToSharedRef() 接口将共享指针转换为共享引用</strong>，和原 TSharedPtr 共享内存，且 TSharedPtr 中的共享引用计数器</p>
</li>
<li><p>共享指针和共享引用可以隐式直接转换</p>
</li>
<li><p>SharedReferenceCount 属性值会自增加，此时，如果将 TSharedPtr 重置，和TWeakPtr不同的是 <strong>TSharedRef 仍保有内存所有权</strong>，不会为空。</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用普通指针右值初始化（不建议用普通指针左值初始化） </span></span><br><span class="line"><span class="function">TSharedRef&lt;<span class="type">int</span>&gt; <span class="title">sr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">555</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 强烈建议用MakeShared接口 </span></span><br><span class="line">TSharedRef&lt;<span class="type">int</span>&gt; sr2 = <span class="built_in">MakeShared</span>&lt;<span class="type">int</span>&gt;(<span class="number">666</span>);</span><br><span class="line"><span class="function">TSharedRef&lt;<span class="type">int</span>&gt; <span class="title">sr3</span><span class="params">(MakeShared&lt;<span class="type">int</span>&gt;(<span class="number">777</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 仅 TSharedPtr 可通过 ToSharedRef() 接口转换为 TSharedRef </span></span><br><span class="line"><span class="comment">// 且原 TSharedPtr 重置不影响 TSharedRef 指向内存 </span></span><br><span class="line">TSharedPtr&lt;<span class="type">int</span>&gt; sp = <span class="built_in">MakeShared</span>&lt;<span class="type">int</span>&gt;(<span class="number">666</span>);</span><br><span class="line"><span class="comment">// sp 和 sr4 共享内存，引用计数自加 </span></span><br><span class="line">TSharedRef&lt;<span class="type">int</span>&gt; sr4 = sp.<span class="built_in">ToSharedRef</span>(); </span><br><span class="line"><span class="comment">// 重置sp后引用计数减少，但 sr4 仍然非空（这里不同于TWeakPtr） </span></span><br><span class="line">sp.<span class="built_in">Reset</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// TSharedRef 在指向空对象时会触发断言：</span></span><br><span class="line"><span class="comment">// 1、未初始化指向一个非空对象，执行时触发断言 </span></span><br><span class="line">TSharedRef&lt;<span class="type">int</span>&gt; srEmpty1; </span><br><span class="line"><span class="comment">// 2、指向的是一个空对象，执行时触发断言 </span></span><br><span class="line">TSharedPtr&lt;<span class="type">int</span>&gt; spEmpty;</span><br><span class="line">TSharedRef&lt;<span class="type">int</span>&gt; srEmpty2 = spEmpty.<span class="built_in">ToSharedRef</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//访问共享引用中的元素</span></span><br><span class="line">sr1-&gt;a;</span><br></pre></td></tr></table></figure>

<h2 id="注意-2"><a href="#注意-2" class="headerlink" title="注意"></a>注意</h2><p>在声明类的时候继承自<code>TSharedFromThis&lt;&gt;</code>可以使得获取此类的时候直接生成共享引用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TaskA</span>:<span class="keyword">public</span> TAharedFromThis&lt;TaskA&gt;</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TaskA* cur=<span class="keyword">new</span> <span class="built_in">TaskA</span>();</span><br><span class="line">TShareRef&lt;TaskA&gt; Task_c=cur-&gt;<span class="built_in">AsShared</span>();</span><br></pre></td></tr></table></figure>

<h1 id="TUniquePtr唯一指针"><a href="#TUniquePtr唯一指针" class="headerlink" title="TUniquePtr唯一指针"></a>TUniquePtr唯一指针</h1><ol>
<li><p>强调对<strong>内存所有权的唯一性</strong></p>
</li>
<li><p>TUniquePtr 在构造时<strong>必须显示的调用构造函数</strong>（除非是默认构造），并且<strong>不能有赋值&#x2F;拷贝操作</strong>，其拷贝&#x2F;赋值重载被关键字 &#x3D;delete 标记</p>
</li>
<li><p>只能通过 <strong>MoveTemp() 转移内存所有权</strong>，类似C++中的std::move()</p>
</li>
<li><p>其指向的内存仅会被唯一的一个 TWeakPtr 所指向。</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TUniquePtr 带参构造函数被关键字 explicit 标记 </span></span><br><span class="line"><span class="function">TUniquePtr&lt;<span class="type">int</span>&gt; <span class="title">up1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">666</span>))</span></span>;</span><br><span class="line"><span class="comment">// 强烈建议用MakeShared接口 </span></span><br><span class="line"><span class="function">TUniquePtr&lt;<span class="type">int</span>&gt; <span class="title">up2</span><span class="params">(MakeUnique&lt;<span class="type">int</span>&gt;(<span class="number">888</span>))</span></span>;</span><br><span class="line">TUniquePtr&lt;<span class="type">int</span>&gt; up3 = <span class="built_in">MakeUnique</span>&lt;<span class="type">int</span>&gt;(<span class="number">888</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝/赋值重载被关键字 =delete 标记 </span></span><br><span class="line">TUniquePtr&lt;<span class="type">int</span>&gt; up4 = up1; <span class="comment">// 编译报错，尝试引用已删除的函数 </span></span><br><span class="line"><span class="function">TUniquePtr&lt;<span class="type">int</span>&gt; <span class="title">up5</span><span class="params">(up2)</span></span>; <span class="comment">// 编译报错，尝试引用已删除的函数 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只能通过 MoveTemp() 转移内存所有权， </span></span><br><span class="line"><span class="comment">// 转移后 up1 指向内存转交给 up6，</span></span><br><span class="line"><span class="comment">// 同时指针变量 up1 被析构 </span></span><br><span class="line">TUniquePtr&lt;<span class="type">int</span>&gt; up6 = <span class="built_in">MoveTemp</span>(up1);</span><br></pre></td></tr></table></figure>

<p><strong>需要特别注意的是：</strong></p>
<p><strong>①</strong> 虽然不能有赋值&#x2F;拷贝操作，却能<strong>通过函数返回值来赋值</strong>，本质上相当于<strong>重新构造</strong>，重新构造后会<strong>析构之前占用的内存</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TUniquePtr&lt;<span class="type">int</span>&gt; up = <span class="built_in">MakeUnique</span>&lt;<span class="type">int</span>&gt;(<span class="number">666</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> GetUniquePtr = [](<span class="type">int</span> _value) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">MakeUnique</span>&lt;<span class="type">int</span>&gt;(_value);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">up = <span class="built_in">GetUniquePtr</span>(<span class="number">888</span>);</span><br></pre></td></tr></table></figure>

<p><strong>②</strong> 可以声明以 TUniquePtr 为元素类型的容器，不过元素赋值还是只能通过移动语义，且<strong>不能使用容器的初始化列表来初始化</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">TUniquePtr&lt;<span class="type">int</span>&gt; up = <span class="built_in">MakeUnique</span>&lt;<span class="type">int</span>&gt;(<span class="number">666</span>);</span><br><span class="line"><span class="keyword">auto</span> GetUniquePtr = [](<span class="type">int</span> _value) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">MakeUnique</span>&lt;<span class="type">int</span>&gt;(_value);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 即使通过转移语义或函数返回值，也不能用初始化列表 </span></span><br><span class="line">TArray&lt;TUniquePtr&lt;<span class="type">int</span>&gt;&gt; upArr = &#123;</span><br><span class="line">    <span class="comment">// 编译报错，尝试引用已删除的函数 </span></span><br><span class="line">    <span class="built_in">MoveTemp</span>(up), <span class="built_in">GetUniquePtr</span>(<span class="number">888</span>)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给数组中 TUniquePtr 元素赋值：</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> idx = <span class="number">0</span>; idx &lt; <span class="number">10</span>; ++idx)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1、定义临时 TUniquePtr 变量然后用移动语义 </span></span><br><span class="line">    <span class="keyword">auto</span> tempUp = <span class="built_in">MakeUnique</span>&lt;<span class="type">int</span>&gt;(idx + <span class="number">1</span>);</span><br><span class="line">    upArr.<span class="built_in">Emplace</span>(<span class="built_in">MoveTemp</span>(tempUp));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、 通过函数返回值赋值 </span></span><br><span class="line">    upArr.<span class="built_in">Emplace</span>(<span class="built_in">GetUniquePtr</span>(idx + <span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="辅助类和函数"><a href="#辅助类和函数" class="headerlink" title="辅助类和函数"></a>辅助类和函数</h1><p>UE4的智能指针库提供了很多<strong>辅助类和函数</strong>，目的是为了使用智能指针时更加<strong>方便直观</strong>。主要有以下几种：</p>
<table>
<thead>
<tr>
<th>助手</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>类</td>
<td></td>
</tr>
<tr>
<td><code>TSharedFromThis</code></td>
<td>在添加 <code>AsShared</code> 或 <code>SharedThis</code> 函数的 <code>TSharedFromThis</code> 中衍生类。利用此类函数可获取对象的 <code>TSharedRef</code>。</td>
</tr>
<tr>
<td>函数</td>
<td></td>
</tr>
<tr>
<td><code>MakeShared</code> 和 <code>MakeShareable</code></td>
<td>在常规C++指针中创建共享指针。<code>MakeShared</code> 会在单个内存块中分配新的对象实例和引用控制器，但要求对象提交公共构造函数。<code>MakeShareable</code> 的效率较低，但即使对象的构造函数为私有，其仍可运行。利用此操作可拥有非自己创建的对象，并在删除对象时支持自定义行为。</td>
</tr>
<tr>
<td><code>StaticCastSharedRef</code> 和 <code>StaticCastSharedPtr</code></td>
<td>静态投射效用函数，通常用于向下投射到衍生类型。</td>
</tr>
<tr>
<td><code>ConstCastSharedRef</code> 和 <code>ConstCastSharedPtr</code></td>
<td>将 <code>const</code> 智能引用或智能指针分别转换为 <code>mutable</code> 智能引用或智能指针。</td>
</tr>
</tbody></table>
<h2 id="TSharedFromeThis类"><a href="#TSharedFromeThis类" class="headerlink" title="TSharedFromeThis类"></a>TSharedFromeThis类</h2><p>如果要访问某个类实例的this指针，<strong>不建议直接将this指针返回</strong></p>
<p>因为this指针是普通指针，对其进行delete操作是合法的，这会导致很多不好的后果，比如指针被<strong>重复释放</strong>，<strong>操作野指针</strong>等</p>
<p>既然不能返回this指针，可能会考虑将其包装为智能指针返回，但这样会导致该类的实例被析构两次，因为包装成智能指针返回相当于创建了一个智能指针变量，该变量生命周期受操作系统控制，类的实例也是如此，返回的智能指针变量和类的实例相当于是指向了同一块内存，故而在析构它们时会导致内存被重复释放</p>
<p>TSharedFromThis，和C++中的 <strong>std::shared_from_this()</strong> 类似，就是用来解决这个问题的，让**类公有继承自TSharedFromTthis<ClassName>**，使得能够安全使用类实例的this指针，其内部有一个 <strong>TWeakPtr</strong> 指针，若要获取类实例的this指针，它提供两类接口 <strong><mark>AsShared()</mark></strong> 和 <strong><mark>SharedThis()</mark><strong>，它们会</strong>通过 TWeakPtr 返回一个 TSharedRef</strong>；</p>
<p><strong>需要注意的是：</strong></p>
<p>① <strong>调用AsShared() 的对象必须是一个智能指针</strong>，否则仍然不能保证使用this裸指针或对内存重复释放，在UE4中会触发断言；</p>
<p>② 在<strong>类外部调用静态方法 SharedThis() 时，当前操作模块的类也必须公有继承其自身的TSharedFromThis</strong>；</p>
<p>③ 和C++类似，AsShared() 和 SharedThis() <strong>不能在构造函数内部使用</strong>，否则会触发断言；</p>
<p><strong>使用示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> : <span class="keyword">public</span> TSharedFromThis&lt;MyClass&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TSharedRef&lt;MyClass&gt; <span class="title">SharedMyself</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">SharedThis</span>(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通指针或对象，使用TSharedFromThis内的方法会触发断言 </span></span><br><span class="line">TSharedPtr&lt;MyClass&gt; ptr = <span class="built_in">MakeShared</span>&lt;MyClass&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过接口获取类实例的智能引用，维护的是同一块内存，同一个计数器 </span></span><br><span class="line">TSharedRef&lt;MyClass&gt; pRef1 = ptr-&gt;<span class="built_in">AsShared</span>();</span><br><span class="line">TSharedRef&lt;MyClass&gt; pRef2 = ptr-&gt;<span class="built_in">SharedMyself</span>();</span><br><span class="line"><span class="comment">// 在类外部使用该接口，那么操作模块的类也必须继承其自身的TSharedFromThis </span></span><br><span class="line">TSharedRef&lt;MyClass&gt; pRef3 = <span class="built_in">SharedThis</span>(ptr.<span class="built_in">Get</span>());</span><br></pre></td></tr></table></figure>

<h2 id="MakeShared（包括用于TUniquePtr的MakeUnique）函数"><a href="#MakeShared（包括用于TUniquePtr的MakeUnique）函数" class="headerlink" title="MakeShared（包括用于TUniquePtr的MakeUnique）函数"></a>MakeShared（包括用于TUniquePtr的MakeUnique）函数</h2><p>类似于C++中的 std::make_shared ，比直接用普通指针创建效率更高，因为智能指针内存包含两部分，除了数据本身的内存之外，还有一个控制块内存，<strong>普通指针</strong>创建时，会<strong>分别申请两次内存</strong>，而使用 <strong>MakedShared 只需要进行一次内存申请</strong>，因而效率更高。</p>
<h2 id="MakeShareable函数"><a href="#MakeShareable函数" class="headerlink" title="MakeShareable函数"></a>MakeShareable函数</h2><p>主要针对<strong>将一个普通指针转换为智能指针</strong>，而 TSharedPtr 需要在定义时显示调用构造函数才可以将一个普通指针传入（仍然不建议提前定义一个指针变量然后用来初始化指针智能），与之不同的是，<strong>MakeShareabel 支持自定义删除对象的行为</strong>，将自定义删除处理通过参数传入。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MakeShareable 自定义删除行为是一个右值引用 </span></span><br><span class="line"><span class="keyword">auto</span> DelFunc = [](<span class="type">int</span>* _ptr) &#123;</span><br><span class="line">    <span class="comment">// 删除申请的内存，</span></span><br><span class="line">    <span class="comment">// TSharedPtr 作为局部变量由操作系统控制生命周期 </span></span><br><span class="line">    <span class="keyword">delete</span> _ptr;</span><br><span class="line">    _ptr = <span class="literal">nullptr</span>;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TSharedPtr&lt;<span class="type">int</span>&gt; sp;</span><br><span class="line">sp = <span class="built_in">MakeShareable</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">666</span>), <span class="built_in">MoveTemp</span>(DelF));</span><br></pre></td></tr></table></figure>

<h2 id="StaticCastSharedRef和StaticCastSharedPtr函数"><a href="#StaticCastSharedRef和StaticCastSharedPtr函数" class="headerlink" title="StaticCastSharedRef和StaticCastSharedPtr函数"></a>StaticCastSharedRef和StaticCastSharedPtr函数</h2><p>类似于C++中的 static_cast，但<strong>只用于派生类的转换：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 始终注意UE4智能指针只能用于非UObject类群 </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BaseClass</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DerivedClass</span> : <span class="keyword">public</span> BaseClass &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 共享指针派生类静态转换 </span></span><br><span class="line">TSharedPtr&lt;BaseClass&gt; pBase1 = <span class="built_in">MakeShared</span>&lt;DerivedClass&gt;();</span><br><span class="line">TSharedPtr&lt;DerivedClass&gt; pDerived1 = </span><br><span class="line">    <span class="built_in">StaticCastSharedPtr</span>&lt;DerivedClass&gt;(pBase1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 共享引用派生类静态转换 </span></span><br><span class="line">TSharedRef&lt;BaseClass&gt; pBase2 = <span class="built_in">MakeShared</span>&lt;DerivedClass&gt;();</span><br><span class="line">TSharedRef&lt;DerivedClass&gt; pDerived2 =</span><br><span class="line">    <span class="built_in">StaticCastSharedRef</span>&lt;DerivedClass&gt;(pBase2);</span><br></pre></td></tr></table></figure>

<h2 id="ConstCastSharedRef和ConstCastSharedPtr函数"><a href="#ConstCastSharedRef和ConstCastSharedPtr函数" class="headerlink" title="ConstCastSharedRef和ConstCastSharedPtr函数"></a>ConstCastSharedRef<strong>和</strong>ConstCastSharedPtr函数</h2><p>用于<strong>将 const 类型的智能指针转换为非 const 类型</strong>，转换后两个指针指向的是同一块内存，不会申请新内存，如果修改转换后的非const类型的值，那么原来的const类型的值也会同步被修改：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">TSharedPtr&lt;<span class="type">const</span> <span class="type">int</span>&gt; sp1 = <span class="built_in">MakeShared</span>&lt;<span class="type">const</span> <span class="type">int</span>&gt;(<span class="number">666</span>);</span><br><span class="line"><span class="comment">// sp2 和 sp1 指向同一一块内存，并不会重新申请新内存 </span></span><br><span class="line">TSharedPtr&lt;<span class="type">int</span>&gt; sp2 = <span class="built_in">ConstCastSharedPtr</span>&lt;<span class="type">int</span>&gt;(sp1);</span><br><span class="line"><span class="comment">// 常量指针 sp1 的值也会同步被修改</span></span><br><span class="line">(*sp2) = <span class="number">888</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于指针引用也是类似 </span></span><br><span class="line">TSharedRef&lt;<span class="type">const</span> <span class="type">int</span>&gt; sr1 = <span class="built_in">MakeShared</span>&lt;<span class="type">const</span> <span class="type">int</span>&gt;(<span class="number">666</span>);</span><br><span class="line">TSharedRef&lt;<span class="type">int</span>&gt; sr2 = <span class="built_in">ConstCastSharedRef</span>&lt;<span class="type">int</span>&gt;(sr1);</span><br><span class="line"><span class="comment">// 常量引用 sr1 的值也会同步被修改 </span></span><br><span class="line">(*sr2) = <span class="number">888</span>; </span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">williny</span>
</div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  





</body>
</html>
