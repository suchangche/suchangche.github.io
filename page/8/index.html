<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.1.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.0.0/css/all.min.css" integrity="sha256-jTIdiMuX/e3DGJUGwl3pKSxuc6YOuqtJYkM0bGQESA4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.10.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="孤独是人生的常态">
<meta property="og:type" content="website">
<meta property="og:title" content="Williny&#39;home">
<meta property="og:url" content="http://example.com/page/8/index.html">
<meta property="og:site_name" content="Williny&#39;home">
<meta property="og:description" content="孤独是人生的常态">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="williny">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/8/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/8/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Williny'home</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Williny'home</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="williny"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">williny</p>
  <div class="site-description" itemprop="description">孤独是人生的常态</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">92</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/suchangche" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;suchangche" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:469478061@qq.com" title="E-Mail → mailto:469478061@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/03/UE4-%E7%AC%AC%E4%B8%80%E4%BA%BA%E7%A7%B0FPS-%E6%80%9D%E8%B7%AF%E5%B0%8F%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="williny">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Williny'home">
      <meta itemprop="description" content="孤独是人生的常态">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Williny'home">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/05/03/UE4-%E7%AC%AC%E4%B8%80%E4%BA%BA%E7%A7%B0FPS-%E6%80%9D%E8%B7%AF%E5%B0%8F%E7%BB%93/" class="post-title-link" itemprop="url">UE4-第一人称FPS-思路小结</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-05-03 08:55:06" itemprop="dateCreated datePublished" datetime="2022-05-03T08:55:06+08:00">2022-05-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-05-30 20:55:14" itemprop="dateModified" datetime="2022-05-30T20:55:14+08:00">2022-05-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/unreal-engine/" itemprop="url" rel="index"><span itemprop="name">unreal engine</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>之前的都是讲解官方文档的代码，属于是微观层面的分析。</p>
<p>现在我们已经跟着官方文档做出了一个简单的第一人称FPS，如果我们要跳出官方的引导，自己做一个的话，从宏观层面的思路分析就很有必要了！</p>
<p>在这里，我基于官方文档的开发流程，将大致思路整理一下</p>
<h1 id="建立项目"><a href="#建立项目" class="headerlink" title="建立项目"></a>建立项目</h1><p>这就很好理解，建立一个空项目嘛！</p>
<h1 id="添加日志信息"><a href="#添加日志信息" class="headerlink" title="添加日志信息"></a>添加日志信息</h1><p>就是在屏幕上打印出日志信息</p>
<h2 id="重载StartPlay"><a href="#重载StartPlay" class="headerlink" title="重载StartPlay()"></a>重载StartPlay()</h2><p>在头文件中声明StartPlay()</p>
<p>然后再cpp文件中使用AddOnScreenDebugMessage()定义</p>
<h1 id="将C-游戏模式类扩展到蓝图"><a href="#将C-游戏模式类扩展到蓝图" class="headerlink" title="将C++游戏模式类扩展到蓝图"></a>将C++游戏模式类扩展到蓝图</h1><p>基于<strong>FPSProjectGameModeBase</strong>创建蓝图类<strong>BP_FPSGameModeBase</strong></p>
<h1 id="修改游戏默认模式"><a href="#修改游戏默认模式" class="headerlink" title="修改游戏默认模式"></a>修改游戏默认模式</h1><p>将<strong>BP_FPSGameModeBase</strong>设置为默认游戏模式</p>
<h1 id="创建角色"><a href="#创建角色" class="headerlink" title="创建角色"></a>创建角色</h1><p>基于Character创建一个C++类</p>
<p>在BeginPlay()函数中添加AddOnScreenDebugMessage()函数来确认正在使用FPSCharacter</p>
<h1 id="扩展C-FPS角色类到蓝图"><a href="#扩展C-FPS角色类到蓝图" class="headerlink" title="扩展C++FPS角色类到蓝图"></a>扩展C++FPS角色类到蓝图</h1><p>将<strong>FPSCharacter</strong>扩展为<strong>BP_FPSCharacter</strong></p>
<p>编辑-&gt;项目设置-&gt;地图和模式-&gt;默认Pawn类</p>
<p>设置为<strong>BP_FPSCharacter</strong></p>
<h1 id="设置映射"><a href="#设置映射" class="headerlink" title="设置映射"></a>设置映射</h1><p>编辑-&gt;项目设置-&gt;输入-&gt;绑定-&gt;轴映射&#x2F;按键映射</p>
<h1 id="实现映射"><a href="#实现映射" class="headerlink" title="实现映射"></a>实现映射</h1><p>在头文件中声明移动函数，变量为映射输入值，也就是Value</p>
<p>然后在cpp文件最下方定义函数</p>
<p>需要注意的是，实现跳跃的函数在内置文件中已经存在，我们只需要确定StartJump和StopJump即可</p>
<h1 id="绑定映射"><a href="#绑定映射" class="headerlink" title="绑定映射"></a>绑定映射</h1><p>在cpp文件中的<code>SetupPlayerInputComponent</code>函数内使用BindAxis()和BindAction()实现绑定映射</p>
<h1 id="导入网格体"><a href="#导入网格体" class="headerlink" title="导入网格体"></a>导入网格体</h1><p>打开<strong>BP_FPSCharacter</strong>图标，组件选项卡中点击网格体组件，细节面板中添加刚刚角色的网格体文件。</p>
<p>修改网格体位置，使得与胶囊体组件契合。</p>
<h1 id="更改摄像机视角"><a href="#更改摄像机视角" class="headerlink" title="更改摄像机视角"></a>更改摄像机视角</h1><p>添加摄像机与胶囊提组件头文件</p>
<p>头文件中声明，cpp中定义</p>
<ul>
<li><p>创建第一人称摄像机组件后，将其附加到胶囊体组件上</p>
</li>
<li><p>更改摄像机位置（SetRelativeLocation()），启用Pawn控制摄像机旋转（bUsePawnControlRotation）</p>
</li>
</ul>
<h1 id="添加第一人称网格体"><a href="#添加第一人称网格体" class="headerlink" title="添加第一人称网格体"></a>添加第一人称网格体</h1><p>头文件中声明FPSMesh</p>
<p>cpp文件中在构造函数内</p>
<ul>
<li><p>创建FPSMesh组件</p>
</li>
<li><p>设置仅所属玩家可以看见此网格体</p>
</li>
<li><p>将FPS网格体附加到FPS摄像机</p>
</li>
<li><p>禁用某些环境阴影，让地上的影子看不到这个第一人称手臂</p>
</li>
<li><p>隐藏所属角色的现有第三人称网格体</p>
</li>
</ul>
<p>最后在蓝图组件的细节面板中添加第一人称手臂资源，再适当地修改位置和旋转角度</p>
<h1 id="添加设计操作映射"><a href="#添加设计操作映射" class="headerlink" title="添加设计操作映射"></a>添加设计操作映射</h1><p>绑定操作映射</p>
<h1 id="添加发射物类"><a href="#添加发射物类" class="headerlink" title="添加发射物类"></a>添加发射物类</h1><p>以Actor为父类创建C++类</p>
<h1 id="添加USpere组件"><a href="#添加USpere组件" class="headerlink" title="添加USpere组件"></a>添加USpere组件</h1><ul>
<li><p>在头文件中添加#include “Components&#x2F;SphereComponent.h”</p>
</li>
<li><p>在头文件中声明球体碰撞组件</p>
</li>
<li><p>在cpp文件中定义碰撞组件</p>
<ul>
<li><p>创建为场景组件类型的根组件</p>
</li>
<li><p>创建球体碰撞组件</p>
</li>
<li><p>设置球体的碰撞半径</p>
</li>
<li><p>将根组件设置为碰撞组件</p>
</li>
</ul>
</li>
</ul>
<h1 id="添加发射物移动组件"><a href="#添加发射物移动组件" class="headerlink" title="添加发射物移动组件"></a>添加发射物移动组件</h1><ul>
<li><p>在头文件中添加#include “GameFramework&#x2F;ProjectileMovementComponent.h”</p>
</li>
<li><p>在头文件中声明发射物移动组件</p>
</li>
<li><p>在cpp文件中定义发射物移动组件</p>
<ul>
<li><p>创建移动组件</p>
</li>
<li><p>将移动组件的更新组件设置为之前定义好的碰撞组件</p>
</li>
<li><p>初始化移动组件速度</p>
</li>
<li><p>初始化移动组件最大速度</p>
</li>
<li><p>打开沿某方向高速旋转开关bRotationFollowsVelocity&#x3D;true</p>
</li>
<li><p>打开允许反弹开关bShouldBounce&#x3D;true</p>
</li>
<li><p>设置弹力大小Bounciness&#x3D;0.3f</p>
</li>
<li><p>设置发射物受到的重力大小ProjectileGravityScale&#x3D;0.0</p>
</li>
</ul>
</li>
</ul>
<h1 id="设置发射物初始方向"><a href="#设置发射物初始方向" class="headerlink" title="设置发射物初始方向"></a>设置发射物初始方向</h1><p>在头文件中声明初始化发射方向的函数</p>
<p>在cpp文件中定义该函数</p>
<p><code>ProjectileMovementComponent-&gt;Velocity = ShootDirection * ProjectileMovementComponent-&gt;InitialSpeed;</code></p>
<p>此处的Velocity可以看作是一个合成力，由方向和速度一同定义</p>
<h1 id="绑定发射输入操作"><a href="#绑定发射输入操作" class="headerlink" title="绑定发射输入操作"></a>绑定发射输入操作</h1><p>在FPSCharacter.h中声明Fire()</p>
<p>在cpp文件中绑定输入操作，并且定义该函数</p>
<p>{在这里可以先不写函数体，因为还没有定义发射物生成位置}</p>
<h1 id="定义发射物生成位置"><a href="#定义发射物生成位置" class="headerlink" title="定义发射物生成位置"></a>定义发射物生成位置</h1><p>在FPSCharacter.h中声明枪口相对于摄像机位置的偏移函数MuzzleOffset</p>
<p>在FPSCharacter.h中protected:下声明要生成的发射物类{TSubclassOf&lt;父类&gt;类名}</p>
<h1 id="实现射击函数"><a href="#实现射击函数" class="headerlink" title="实现射击函数"></a>实现射击函数</h1><p>将FPSCharacter.h中引用FPSProjectile.h文件</p>
<p>在cpp文件中定义Fire()函数</p>
<ul>
<li><p>生成一个发射物类</p>
<ul>
<li><p>获取摄像机位置，将MuzzleOffset位置设置在摄像机前方一点</p>
</li>
<li><p>将MuzzleOffset的相对位置转换成世界位置FTransform().TransformVector()</p>
</li>
<li><p>动态更新摄像机的Pitch角度，看起来就像后坐力一样</p>
</li>
<li><p>获取当前世界</p>
</li>
<li><p>设置一个FActorSpawnParameters</p>
</li>
<li><p>在世界内生成新的Actor（发射物）</p>
</li>
<li><p>设置发射物的初始轨迹</p>
</li>
</ul>
</li>
</ul>
<h1 id="添加发射物网格体及其材质"><a href="#添加发射物网格体及其材质" class="headerlink" title="添加发射物网格体及其材质"></a>添加发射物网格体及其材质</h1><p>导入网格体资源后</p>
<p>在FPSProjectile.h中声明发射物网格体以及其发射材质</p>
<p>在cpp文件中定义发射物网格体以及其材质</p>
<p>后面还要将网格体和材质的相对路径给填写进去</p>
<h1 id="设置发射物的碰撞和声明周期"><a href="#设置发射物的碰撞和声明周期" class="headerlink" title="设置发射物的碰撞和声明周期"></a>设置发射物的碰撞和声明周期</h1><p>在FPSProjectile.cpp中设置发射物生命周期</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">InitialLifeSpan = <span class="number">3.0f</span>;</span><br></pre></td></tr></table></figure>

<h1 id="编辑发射物的碰撞设置"><a href="#编辑发射物的碰撞设置" class="headerlink" title="编辑发射物的碰撞设置"></a>编辑发射物的碰撞设置</h1><p>编辑-&gt;项目设置-&gt;引擎-&gt;碰撞-&gt;展开预设</p>
<p>在对象通道中新建对象通道，将默认相应设置为Block</p>
<h1 id="使用新碰撞通道的设置"><a href="#使用新碰撞通道的设置" class="headerlink" title="使用新碰撞通道的设置"></a>使用新碰撞通道的设置</h1><p>在FPSProjectile.cpp的构造函数中添加</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将球体的碰撞配置文件名称设置为&quot;Projectile&quot;。</span></span><br><span class="line">CollisionComponent-&gt;BodyInstance.<span class="built_in">SetCollisionProfileName</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;Projectile&quot;</span>));</span><br></pre></td></tr></table></figure>

<h1 id="使发射物对碰撞做出相应"><a href="#使发射物对碰撞做出相应" class="headerlink" title="使发射物对碰撞做出相应"></a>使发射物对碰撞做出相应</h1><p>在FPSProjectile.h中声明放发射物击中物体时会调用的函数</p>
<p>参数为</p>
<p><code>void OnHit(UPrimitiveComponent* HitComponent, AActor* OtherActor, UPrimitiveComponent* OtherComponent, FVector NormalImpulse, const FHitResult&amp; Hit)</code></p>
<p>在cpp文件中定义函数</p>
<ul>
<li><p>如果另一个actor不是本身且另一个组件实现模拟物理的话</p>
</li>
<li><p>另一个组件调用AddImpulseAtLocation(ProjectileMovementComponent-&gt;Velocity * 100.0f, Hit.ImpactPoint)</p>
</li>
<li><p>然后Destroy()</p>
</li>
<li><p>在 <code>FPSProjectile</code> 构造函数中，将以下代码行添加到 <code>BodyInstance.SetCollisionProfileName</code> 下方：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 组件击中某物时调用的事件。</span></span><br><span class="line">CollisionComponent-&gt;OnComponentHit.<span class="built_in">AddDynamic</span>(<span class="keyword">this</span>, &amp;AFPSProjectile::OnHit);</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="添加十字准星"><a href="#添加十字准星" class="headerlink" title="添加十字准星"></a>添加十字准星</h1><p>导入十字准星资产，基于HUD创建C++类</p>
<ol>
<li><p><code>FPSHUD.h</code>，添加以下受保护的变量：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">   <span class="comment">// 将被绘制在屏幕中心。</span></span><br><span class="line">   <span class="built_in">UPROPERTY</span>(EditDefaultsOnly)</span><br><span class="line">   UTexture2D* CrosshairTexture;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 <code>FPSHUD.h</code> 中添加以下函数声明：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="comment">// HUD绘制的主要调用。</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">DrawHUD</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将以下头文件添加到FPSHUD.h中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Engine/Canvas.h&quot;</span> </span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在cpp中实现DrawHUD函数</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSHUD::DrawHUD</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">DrawHUD</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (CrosshairTexture)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 找出我们的画布的中心点。</span></span><br><span class="line">        <span class="function">FVector2D <span class="title">Center</span><span class="params">(Canvas-&gt;ClipX * <span class="number">0.5f</span>, Canvas-&gt;ClipY * <span class="number">0.5f</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 偏移纹理大小的一半，以便纹理中心与画布中心对齐。</span></span><br><span class="line">        <span class="function">FVector2D <span class="title">CrossHairDrawPosition</span><span class="params">(Center.X - (CrosshairTexture-&gt;GetSurfaceWidth() * <span class="number">0.5f</span>), Center.Y - (CrosshairTexture-&gt;GetSurfaceHeight() * <span class="number">0.5f</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在中心点绘制十字准星。</span></span><br><span class="line">        <span class="function">FCanvasTileItem <span class="title">TileItem</span><span class="params">(CrossHairDrawPosition, CrosshairTexture-&gt;Resource, FLinearColor::White)</span></span>;</span><br><span class="line">        TileItem.BlendMode = SE_BLEND_Translucent;</span><br><span class="line">        Canvas-&gt;<span class="built_in">DrawItem</span>(TileItem);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="设置默认的HUD"><a href="#设置默认的HUD" class="headerlink" title="设置默认的HUD"></a>设置默认的HUD</h1><p>扩展HUD类到蓝图类中后</p>
<p>编辑-&gt;项目设置-&gt;地图和模式-&gt;默认HUD</p>
<p>选择蓝图HUD</p>
<p>打开HUD蓝图，选择导入的十字准星纹理资产</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/02/UE4-%E7%AC%AC%E4%B8%80%E4%BA%BA%E7%A7%B0FPS-%E4%BB%A3%E7%A0%81%E8%AE%B2%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="williny">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Williny'home">
      <meta itemprop="description" content="孤独是人生的常态">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Williny'home">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/05/02/UE4-%E7%AC%AC%E4%B8%80%E4%BA%BA%E7%A7%B0FPS-%E4%BB%A3%E7%A0%81%E8%AE%B2%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89/" class="post-title-link" itemprop="url">UE4-第一人称FPS-代码讲解（二）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-05-02 14:04:54 / 修改时间：16:11:43" itemprop="dateCreated datePublished" datetime="2022-05-02T14:04:54+08:00">2022-05-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/unreal-engine/" itemprop="url" rel="index"><span itemprop="name">unreal engine</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>此部分主要讲解如何给角色添加动画，依旧是官方案例。</p>
<p>这段说是代码讲解，但其实是蓝图讲解了。</p>
<p>没关系，蓝图是可视化编程，也算是代码哈哈哈！</p>
<p>ok话不多说，我们开始！</p>
<h1 id="设置事件图表"><a href="#设置事件图表" class="headerlink" title="设置事件图表"></a>设置事件图表</h1><p>在事件图表中添加两个新的bool型变量IsRunning和IsFalling之后，我们编辑动画的事件图标，来保证我们的动画过度变量在游戏运行时能被正确触发</p>
<h2 id="Event-Blueprint-Update-Animation"><a href="#Event-Blueprint-Update-Animation" class="headerlink" title="Event Blueprint Update Animation"></a>Event Blueprint Update Animation</h2><p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/4/EventBlueprintUpdateAnimationNode.jpg" alt="EventBlueprintUpdateAnimationNode.png"></p>
<p>这玩意在4.27.2版本中是有中文名称的，当然，直接搜索英文名也是可以直接得到的</p>
<p>中文名称是<strong>事件蓝图更新动画</strong></p>
<p>这玩意有啥用呢？</p>
<p><strong>事件蓝图更新动画：用于在每次更新动画时更新我们的状态变量（IsRunning和IsFalling），使变量和游戏状态同步。</strong></p>
<p>简单来说就是，这是一个函数，参数是动画的更新（从走变成跑），返回值是状态变量（IsRunning和IsFalling）</p>
<h2 id="Try-Get-Pawn-Owner"><a href="#Try-Get-Pawn-Owner" class="headerlink" title="Try Get Pawn Owner"></a>Try Get Pawn Owner</h2><p>同样，在4.27.2版本中的中文名是尝试获取Pawn拥有者</p>
<p>获取拥有这个动画实例的Pawn</p>
<ol>
<li>先获取到动画蓝图所属的组件（<code>OwnerComponent</code>）</li>
<li>然后再获取<code>OwnerComponent</code>的所属<code>OwnerActor</code></li>
<li>最后还要把<code>OwnerActor</code>(<code>AActor</code>类型)向下强制类型转换成<code>APawn</code>。</li>
</ol>
<h2 id="Cast-to-Character"><a href="#Cast-to-Character" class="headerlink" title="Cast to Character"></a>Cast to Character</h2><p>强制转换类型为Character</p>
<h2 id="Get-Character-Movement"><a href="#Get-Character-Movement" class="headerlink" title="Get Character Movement"></a>Get Character Movement</h2><p>获取角色运动情况</p>
<h2 id="Get-Movement-Mode"><a href="#Get-Movement-Mode" class="headerlink" title="Get Movement Mode"></a>Get Movement Mode</h2><p>获取角色运动状态</p>
<h2 id="Equal-enum"><a href="#Equal-enum" class="headerlink" title="Equal(enum)"></a>Equal(enum)</h2><p>查询角色移动状态（下拉菜单中可选择具体移动状态）</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/4/SelectFalling.jpg" alt="SelectFalling.png"></p>
<h2 id="Get-Velocity"><a href="#Get-Velocity" class="headerlink" title="Get Velocity"></a>Get Velocity</h2><p>中文为获取速度</p>
<h2 id="VectorLength"><a href="#VectorLength" class="headerlink" title="VectorLength"></a>VectorLength</h2><p>获取向量长度，就是这东西可以获取速度（力，加速度）的具体数值</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/4/VectorLength.jpg" alt="VectorLength.png"></p>
<h2 id="gt-float"><a href="#gt-float" class="headerlink" title="&gt;(float)"></a>&gt;(float)</h2><p>一个判断语句，看从前一个结点获取的数值是否大于某个设置的常量（这里常量是0）</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/4/ConnectedIsRunning.jpg" alt="ConnectedIsRunning.png"></p>
<h1 id="添加动画状态机"><a href="#添加动画状态机" class="headerlink" title="添加动画状态机"></a>添加动画状态机</h1><h2 id="Add-State"><a href="#Add-State" class="headerlink" title="Add State"></a>Add State</h2><p>就是像图表中添加状态，分别命名为Idle，Run，JumpStart，JumpEnd，JumpLoop</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/4/AnimationSMGraph.jpg" alt="AnimationSMGraph.png"></p>
<p>双击进各个状态内后开始编辑它们</p>
<p>在里面右键-&gt;<strong>play 动画名称</strong></p>
<p>中文标识是播放 <strong>动画名称</strong></p>
<p>将其连接到Output Animation Pose上，也就是表现为这个动画状态</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/4/ConnectedIdleNode.jpg" alt="ConnectedIdleNode.png"></p>
<p>现在从entry中拖出引线连接到idle（因为初始状态是待机状态嘛）</p>
<p>然后根据逻辑尝试，把剩下的几个状态连接起来</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/4/JumpEndtoIdle.jpg" alt="JumpEndtoIdle.png"></p>
<p>最后是这个效果</p>
<h1 id="添加过度"><a href="#添加过度" class="headerlink" title="添加过度"></a>添加过度</h1><p>双击那个圆球，就可以编辑两个状态的过度了</p>
<p>其中的逻辑很简单</p>
<h2 id="待机切换到奔跑状态"><a href="#待机切换到奔跑状态" class="headerlink" title="待机切换到奔跑状态"></a>待机切换到奔跑状态</h2><p>只需要把之前我们已经定义了的变量Is Running（值为true）拖入其中，然后在讲其脱出引线连接到result上即可</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/4/IsRunningtoResult.jpg" alt="IsRunningtoResult.png"></p>
<h2 id="奔跑状态切换到待机状态"><a href="#奔跑状态切换到待机状态" class="headerlink" title="奔跑状态切换到待机状态"></a>奔跑状态切换到待机状态</h2><p>这个和上一个差不多，不过我们需要将Is Running判断一下为false再输出到result</p>
<p>所以，我们将Is Running拖出一条引线，然后创建一个<strong>Not Boolean</strong>结点判断这个bool变量是否为false，如果成立，则将其输出为result</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/4/IsNotRunningtoResult.jpg" alt="IsNotRunningtoResult.png"></p>
<h2 id="奔跑状态切换到跳跃开始"><a href="#奔跑状态切换到跳跃开始" class="headerlink" title="奔跑状态切换到跳跃开始"></a>奔跑状态切换到跳跃开始</h2><p>我们输入的bool变量为Is falling，为啥呢？因为起跳到跳到顶点的这个过程，其实还是受到重力的影响的吧？重力还是会拖拽着你falling，只不过是被你的弹跳力抵消成为一个向上的合力了，本质上你还是falling的状态</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/4/IsFallingtoResult.jpg" alt="IsFallingtoResult.png"></p>
<h2 id="跳跃开始到跳跃循环"><a href="#跳跃开始到跳跃循环" class="headerlink" title="跳跃开始到跳跃循环"></a>跳跃开始到跳跃循环</h2><p>我们需要判断跳跃开始动画的剩余时间，如果该时间小于0.1，则我们输出result，也就是进入到跳跃循环的动画当中。</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/4/TimeRemaining.jpg" alt="TimeRemaining.png"></p>
<p>接下来就是关联动画蓝图和角色蓝图了，按照官网的步骤一点点来就完事了，我这里就不做过多赘述了。</p>
<p>另外提一嘴，这动画效果是真的细微啊，不仔细看还真看不出来。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/01/%E6%9C%89%E5%85%B3%E7%AE%97%E6%B3%95%E4%B8%AD%E7%9A%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E4%BA%8C%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="williny">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Williny'home">
      <meta itemprop="description" content="孤独是人生的常态">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Williny'home">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/05/01/%E6%9C%89%E5%85%B3%E7%AE%97%E6%B3%95%E4%B8%AD%E7%9A%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E4%BA%8C%EF%BC%89/" class="post-title-link" itemprop="url">有关算法中的动态规划（二）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-05-01 09:51:25" itemprop="dateCreated datePublished" datetime="2022-05-01T09:51:25+08:00">2022-05-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-05-10 08:55:14" itemprop="dateModified" datetime="2022-05-10T08:55:14+08:00">2022-05-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>由于动态规划的例题过多，于是多开一章！</p>
<h1 id="零钱兑换"><a href="#零钱兑换" class="headerlink" title="零钱兑换"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/coin-change/">零钱兑换</a></h1><p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p>
<p>你可以认为每种硬币的数量是无限的。</p>
<p>示例 1： 输入：coins &#x3D; [1, 2, 5], amount &#x3D; 11 输出：3 解释：11 &#x3D; 5 + 5 + 1</p>
<p>示例 2： 输入：coins &#x3D; [2], amount &#x3D; 3 输出：-1</p>
<p>示例 3： 输入：coins &#x3D; [1], amount &#x3D; 0 输出：0</p>
<p>示例 4： 输入：coins &#x3D; [1], amount &#x3D; 1 输出：1</p>
<p>示例 5： 输入：coins &#x3D; [1], amount &#x3D; 2 输出：2</p>
<p>提示：</p>
<ul>
<li>1 &lt;&#x3D; coins.length &lt;&#x3D; 12</li>
<li>1 &lt;&#x3D; coins[i] &lt;&#x3D; 2^31 - 1</li>
<li>0 &lt;&#x3D; amount &lt;&#x3D; 10^4</li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题目中说每种硬币的数量是无限的，可以看出是典型的完全背包问题。</p>
<p>动规五部曲分析如下：</p>
<ol>
<li>确定dp数组以及下标的含义</li>
</ol>
<p><strong>dp[j]：凑足总额为j所需钱币的最少个数为dp[j]</strong></p>
<ol start="2">
<li>确定递推公式</li>
</ol>
<p>得到dp[j]（考虑coins[i]），只有一个来源，dp[j - coins[i]]（没有考虑coins[i]）。</p>
<p>凑足总额为j - coins[i]的最少个数为dp[j - coins[i]]，那么只需要加上一个钱币coins[i]即dp[j - coins[i]] + 1就是dp[j]（考虑coins[i]）</p>
<p>所以dp[j] 要取所有 dp[j - coins[i]] + 1 中最小的。</p>
<p>递推公式：<strong>dp[j] &#x3D; min(dp[j - coins[i]] + 1, dp[j]);</strong></p>
<ol start="3">
<li>dp数组如何初始化</li>
</ol>
<p>首先凑足总金额为0所需钱币的个数一定是0，那么dp[0] &#x3D; 0;</p>
<p>其他下标对应的数值呢？</p>
<p>考虑到递推公式的特性，dp[j]<strong>必须初始化为一个最大的数</strong>，否则就会在min(dp[j - coins[i]] + 1, dp[j])比较的过程中被初始值覆盖。</p>
<p>所以下标非0的元素都是应该是最大值。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(amount + <span class="number">1</span>, INT_MAX)</span></span>;</span><br><span class="line">dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>确定遍历顺序</li>
</ol>
<p>本题求钱币最小个数，<strong>那么钱币有顺序和没有顺序都可以，都不影响钱币的最小个数</strong>。</p>
<p>所以本题并不强调集合是组合还是排列。</p>
<p><strong>如果求组合数就是外层for循环遍历物品，内层for遍历背包</strong>。</p>
<p><strong>如果求排列数就是外层for遍历背包，内层for循环遍历物品</strong>。</p>
<p>在动态规划专题我们讲过了求组合数是<a target="_blank" rel="noopener" href="https://programmercarl.com/0518.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2II.html">动态规划：518.零钱兑换II</a>，求排列数是<a target="_blank" rel="noopener" href="https://programmercarl.com/0377.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%E2%85%A3.html">动态规划：377. 组合总和 Ⅳ </a>。</p>
<p><strong>所以本题的两个for循环的关系是：外层for循环遍历物品，内层for遍历背包或者外层for遍历背包，内层for循环遍历物品都是可以的！</strong></p>
<p>那么我采用coins放在外循环，target在内循环的方式。</p>
<p>本题钱币数量可以无限使用，那么是完全背包。所以遍历的内循环是正序</p>
<p>综上所述，遍历顺序为：coins（物品）放在外循环，target（背包）在内循环。且内循环正序。</p>
<ol start="5">
<li>举例推导dp数组</li>
</ol>
<p>以输入：coins &#x3D; [1, 2, 5], amount &#x3D; 5为例</p>
<p><img src="https://img-blog.csdnimg.cn/20210201111833906.jpg" alt="322.零钱兑换"></p>
<p>dp[amount]为最终结果。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(amount + <span class="number">1</span>, INT_MAX)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; coins.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = coins[i]; j &lt;= amount; j++) &#123; <span class="comment">// 遍历背包</span></span><br><span class="line">                <span class="keyword">if</span> (dp[j - coins[i]] != INT_MAX) &#123; <span class="comment">// 如果dp[j - coins[i]]是初始值则跳过</span></span><br><span class="line">                    dp[j] = <span class="built_in">min</span>(dp[j - coins[i]] + <span class="number">1</span>, dp[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dp[amount] == INT_MAX) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://programmercarl.com/0518.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2II.html">动态规划：518.零钱兑换II </a>中求的是组合数，<a target="_blank" rel="noopener" href="https://programmercarl.com/0377.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%E2%85%A3.html">动态规划：377. 组合总和 Ⅳ</a>中求的是排列数。</p>
<p><strong>而本题是要求最少硬币数量，硬币是组合数还是排列数都无所谓！所以两个for循环先后顺序怎样都可以！</strong></p>
<h1 id="完全平方数"><a href="#完全平方数" class="headerlink" title="完全平方数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/perfect-squares/">完全平方数</a></h1><p>给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。</p>
<p>给你一个整数 n ，返回和为 n 的完全平方数的 最少数量 。</p>
<p>完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。</p>
<p>示例 1： 输入：n &#x3D; 12 输出：3 解释：12 &#x3D; 4 + 4 + 4</p>
<p>示例 2： 输入：n &#x3D; 13 输出：2 解释：13 &#x3D; 4 + 9</p>
<p>提示：</p>
<ul>
<li>1 &lt;&#x3D; n &lt;&#x3D; 10^4</li>
</ul>
<h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>可能刚看这种题感觉没啥思路，又平方和的，又最小数的。</p>
<p><strong>我来把题目翻译一下：完全平方数就是物品（可以无限件使用），凑个正整数n就是背包，问凑满这个背包最少有多少物品？</strong></p>
<p>感受出来了没，这么浓厚的完全背包氛围，而且和昨天的题目<a target="_blank" rel="noopener" href="https://programmercarl.com/0322.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2.html">动态规划：322. 零钱兑换 </a>就是一样一样的！</p>
<p>动规五部曲分析如下：</p>
<ol>
<li>确定dp数组（dp table）以及下标的含义</li>
</ol>
<p><strong>dp[j]：和为j的完全平方数的最少数量为dp[j]</strong></p>
<ol start="2">
<li>确定递推公式</li>
</ol>
<p>dp[j] 可以由dp[j - i * i]推出， dp[j - i * i] + 1 便可以凑成dp[j]。</p>
<p>此时我们要选择最小的dp[j]，所以递推公式：dp[j] &#x3D; min(dp[j - i * i] + 1, dp[j]);</p>
<ol start="3">
<li>dp数组如何初始化</li>
</ol>
<p>dp[0]表示 和为0的完全平方数的最小数量，那么dp[0]一定是0。</p>
<p>有同学问题，那0 * 0 也算是一种啊，为啥dp[0] 就是 0呢？</p>
<p>看题目描述，找到若干个完全平方数（比如 1, 4, 9, 16, …），题目描述中可没说要从0开始，dp[0]&#x3D;0完全是为了递推公式。</p>
<p>非0下标的dp[j]应该是多少呢？</p>
<p>从递归公式dp[j] &#x3D; min(dp[j - i * i] + 1, dp[j]);中可以看出每次dp[j]都要选最小的，<strong>所以非0下标的dp[j]一定要初始为最大值，这样dp[j]在递推的时候才不会被初始值覆盖</strong>。</p>
<ol start="4">
<li>确定遍历顺序</li>
</ol>
<p>我们知道这是完全背包，</p>
<p>如果求组合数就是外层for循环遍历物品，内层for遍历背包。</p>
<p>如果求排列数就是外层for遍历背包，内层for循环遍历物品。</p>
<p>在<a target="_blank" rel="noopener" href="https://programmercarl.com/0322.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2.html">动态规划：322. 零钱兑换 </a>中我们就深入探讨了这个问题，本题也是一样的，是求最小数！</p>
<p><strong>所以本题外层for遍历背包，内层for遍历物品，还是外层for遍历物品，内层for遍历背包，都是可以的！</strong></p>
<p>我这里先给出外层遍历背包，内层遍历物品的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, INT_MAX)</span></span>;</span><br><span class="line">dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123; <span class="comment">// 遍历背包</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j * j &lt;= i; j++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">        dp[i] = <span class="built_in">min</span>(dp[i - j * j] + <span class="number">1</span>, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<ol start="5">
<li>举例推导dp数组</li>
</ol>
<p>已输入n为5例，dp状态图如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20210202112617341.jpg" alt="279.完全平方数"></p>
<p>dp[0] &#x3D; 0 dp[1] &#x3D; min(dp[0] + 1) &#x3D; 1 dp[2] &#x3D; min(dp[1] + 1) &#x3D; 2 dp[3] &#x3D; min(dp[2] + 1) &#x3D; 3 dp[4] &#x3D; min(dp[3] + 1, dp[0] + 1) &#x3D; 1 dp[5] &#x3D; min(dp[4] + 1, dp[1] + 1) &#x3D; 2</p>
<p>最后的dp[n]为最终结果。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numSquares</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, INT_MAX)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123; <span class="comment">// 遍历背包</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j * j &lt;= i; j++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">                dp[i] = <span class="built_in">min</span>(dp[i - j * j] + <span class="number">1</span>, dp[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="单词拆分"><a href="#单词拆分" class="headerlink" title="单词拆分"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/word-break/">单词拆分</a></h1><p>给定一个非空字符串 s 和一个包含非空单词的列表 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。</p>
<p>说明：</p>
<p>拆分时可以重复使用字典中的单词。</p>
<p>你可以假设字典中没有重复的单词。</p>
<p>示例 1： </p>
<p>输入: s &#x3D; “leetcode”, wordDict &#x3D; [“leet”, “code”] </p>
<p>输出: true </p>
<p>解释: 返回 true 因为 “leetcode” 可以被拆分成 “leet code”。</p>
<p>示例 2： </p>
<p>输入: s &#x3D; “applepenapple”, wordDict &#x3D; [“apple”, “pen”] </p>
<p>输出: true </p>
<p>解释: 返回 true 因为 “applepenapple” 可以被拆分成 “apple pen apple”。   </p>
<p>注意你可以重复使用字典中的单词。</p>
<p>示例 3： </p>
<p>输入: s &#x3D; “catsandog”, wordDict &#x3D; [“cats”, “dog”, “sand”, “and”, “cat”] </p>
<p>输出: false</p>
<h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><h3 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h3><p>看到这道题目的时候，大家应该回想起我们之前讲解回溯法专题的时候，讲过的一道题目<a target="_blank" rel="noopener" href="https://programmercarl.com/0131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.html">回溯算法：分割回文串 </a>，就是枚举字符串的所有分割情况。</p>
<p><a target="_blank" rel="noopener" href="https://programmercarl.com/0131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.html">回溯算法：分割回文串 </a>：是枚举分割后的所有子串，判断是否回文。</p>
<p>本道是枚举分割所有字符串，判断是否在字典里出现过。</p>
<p>那么这里我也给出回溯法C++代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">backtracking</span> <span class="params">(<span class="type">const</span> string&amp; s, <span class="type">const</span> unordered_set&lt;string&gt;&amp; wordSet, <span class="type">int</span> startIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (startIndex &gt;= s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            string word = s.<span class="built_in">substr</span>(startIndex, i - startIndex + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (wordSet.<span class="built_in">find</span>(word) != wordSet.<span class="built_in">end</span>() &amp;&amp; <span class="built_in">backtracking</span>(s, wordSet, i + <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">wordBreak</span><span class="params">(string s, vector&lt;string&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="function">unordered_set&lt;string&gt; <span class="title">wordSet</span><span class="params">(wordDict.begin(), wordDict.end())</span></span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">backtracking</span>(s, wordSet, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>单词就是物品，字符串s就是背包，单词能否组成字符串s，就是问物品能不能把背包装满。</p>
<p>拆分时可以重复使用字典中的单词，说明就是一个完全背包！</p>
<p>动规五部曲分析如下：</p>
<ol>
<li>确定dp数组以及下标的含义</li>
</ol>
<p><strong>dp[i] : 字符串长度为i的话，dp[i]为true，表示可以拆分为一个或多个在字典中出现的单词</strong></p>
<ol start="2">
<li>确定递推公式</li>
</ol>
<p>如果确定dp[j] 是true，且 [j, i] 这个区间的子串出现在字典里，那么dp[i]一定是true。（j &lt; i ）。</p>
<p>所以递推公式是 if([j, i] 这个区间的子串出现在字典里 &amp;&amp; dp[j]是true) 那么 dp[i] &#x3D; true。</p>
<ol start="3">
<li>dp数组如何初始化</li>
</ol>
<p>从递归公式中可以看出，dp[i] 的状态依靠 dp[j]是否为true，那么dp[0]就是递归的根基，dp[0]一定要为true，否则递归下去后面都都是false了。</p>
<p>那么dp[0]有没有意义呢？</p>
<p>dp[0]表示如果字符串为空的话，说明出现在字典里。</p>
<p>但题目中说了“给定一个非空字符串 s” 所以测试数据中不会出现i为0的情况，那么dp[0]初始为true完全就是为了推导公式。</p>
<p>下标非0的dp[i]初始化为false，只要没有被覆盖说明都是不可拆分为一个或多个在字典中出现的单词。</p>
<ol start="4">
<li>确定遍历顺序</li>
</ol>
<p>题目中说是拆分为一个或多个在字典中出现的单词，所以这是完全背包。</p>
<p>还要讨论两层for循环的前后循序。</p>
<p><strong>如果求组合数就是外层for循环遍历物品，内层for遍历背包</strong>。</p>
<p><strong>如果求排列数就是外层for遍历背包，内层for循环遍历物品</strong>。</p>
<p>对这个结论还有疑问的同学可以看这篇<a target="_blank" rel="noopener" href="https://programmercarl.com/%E5%91%A8%E6%80%BB%E7%BB%93/20210204%E5%8A%A8%E8%A7%84%E5%91%A8%E6%9C%AB%E6%80%BB%E7%BB%93.html">本周小结！（动态规划系列五）</a>，这篇本周小节中，我做了如下总结：</p>
<p>求组合数：<a target="_blank" rel="noopener" href="https://programmercarl.com/0518.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2II.html">动态规划：518.零钱兑换II</a>求排列数：<a target="_blank" rel="noopener" href="https://programmercarl.com/0377.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C.html">动态规划：377. 组合总和 Ⅳ</a>、<a target="_blank" rel="noopener" href="https://programmercarl.com/0070.%E7%88%AC%E6%A5%BC%E6%A2%AF%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E7%89%88%E6%9C%AC.html">动态规划：70. 爬楼梯进阶版（完全背包）</a>求最小数：<a target="_blank" rel="noopener" href="https://programmercarl.com/0322.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2.html">动态规划：322. 零钱兑换</a>、<a target="_blank" rel="noopener" href="https://programmercarl.com/0279.%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0.html">动态规划：279.完全平方数</a></p>
<p>本题最终要求的是是否都出现过，所以对出现单词集合里的元素是组合还是排列，并不在意！</p>
<p><strong>那么本题使用求排列的方式，还是求组合的方式都可以</strong>。</p>
<p>即：外层for循环遍历物品，内层for遍历背包 或者 外层for遍历背包，内层for循环遍历物品 都是可以的。</p>
<p>但本题还有特殊性，因为是要求子串，最好是遍历背包放在外循环，将遍历物品放在内循环。</p>
<p>如果要是外层for循环遍历物品，内层for遍历背包，就需要把所有的子串都预先放在一个容器里。（如果不理解的话，可以自己尝试这么写一写就理解了）</p>
<p><strong>所以最终我选择的遍历顺序为：遍历背包放在外循环，将遍历物品放在内循环。内循环从前到后</strong>。</p>
<ol start="5">
<li>举例推导dp[i]</li>
</ol>
<p>以输入: s &#x3D; “leetcode”, wordDict &#x3D; [“leet”, “code”]为例，dp状态如图：</p>
<p><img src="https://img-blog.csdnimg.cn/20210202162652727.jpg" alt="139.单词拆分"></p>
<p>dp[s.size()]就是最终结果。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">wordBreak</span><span class="params">(string s, vector&lt;string&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="function">unordered_set&lt;string&gt; <span class="title">wordSet</span><span class="params">(wordDict.begin(), wordDict.end())</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">dp</span><span class="params">(s.size() + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= s.<span class="built_in">size</span>(); i++) &#123;   <span class="comment">// 遍历背包</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;       <span class="comment">// 遍历物品</span></span><br><span class="line">                string word = s.<span class="built_in">substr</span>(j, i - j); <span class="comment">//substr(起始位置，截取的个数)</span></span><br><span class="line">                <span class="keyword">if</span> (wordSet.<span class="built_in">find</span>(word) != wordSet.<span class="built_in">end</span>() &amp;&amp; dp[j]) &#123;</span><br><span class="line">                    dp[i] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="多重背包理论基础"><a href="#多重背包理论基础" class="headerlink" title="多重背包理论基础"></a>多重背包理论基础</h1><p>对于多重背包，我在力扣上还没发现对应的题目，所以这里就做一下简单介绍，大家大概了解一下。</p>
<p>有N种物品和一个容量为V 的背包。<strong>第i种物品最多有Mi件可用</strong>，每件耗费的空间是Ci ，价值是Wi 。求解将哪些物品装入背包可使这些物品的耗费的空间 总和不超过背包容量，且价值总和最大。</p>
<p>多重背包和01背包是非常像的， 为什么和01背包像呢？</p>
<p>每件物品最多有Mi件可用，把Mi件摊开，其实就是一个01背包问题了。</p>
<p>例如：</p>
<p>背包最大重量为10。</p>
<p>物品为：</p>
<table>
<thead>
<tr>
<th></th>
<th>重量</th>
<th>价值</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>物品0</td>
<td>1</td>
<td>15</td>
<td>2</td>
</tr>
<tr>
<td>物品1</td>
<td>3</td>
<td>20</td>
<td>3</td>
</tr>
<tr>
<td>物品2</td>
<td>4</td>
<td>30</td>
<td>2</td>
</tr>
</tbody></table>
<p>问背包能背的物品最大价值是多少？</p>
<p>和如下情况有区别么？</p>
<table>
<thead>
<tr>
<th></th>
<th>重量</th>
<th>价值</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>物品0</td>
<td>1</td>
<td>15</td>
<td>1</td>
</tr>
<tr>
<td>物品0</td>
<td>1</td>
<td>15</td>
<td>1</td>
</tr>
<tr>
<td>物品1</td>
<td>3</td>
<td>20</td>
<td>1</td>
</tr>
<tr>
<td>物品1</td>
<td>3</td>
<td>20</td>
<td>1</td>
</tr>
<tr>
<td>物品1</td>
<td>3</td>
<td>20</td>
<td>1</td>
</tr>
<tr>
<td>物品2</td>
<td>4</td>
<td>30</td>
<td>1</td>
</tr>
<tr>
<td>物品2</td>
<td>4</td>
<td>30</td>
<td>1</td>
</tr>
</tbody></table>
<p>毫无区别，这就转成了一个01背包问题了，且每个物品只用一次。</p>
<p>这种方式来实现多重背包的代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_multi_pack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; weight = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; value = &#123;<span class="number">15</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="type">int</span> bagWeight = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (nums[i] &gt; <span class="number">1</span>) &#123; <span class="comment">// nums[i]保留到1，把其他物品都展开</span></span><br><span class="line">            weight.<span class="built_in">push_back</span>(weight[i]);</span><br><span class="line">            value.<span class="built_in">push_back</span>(value[i]);</span><br><span class="line">            nums[i]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(bagWeight + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; weight.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = bagWeight; j &gt;= weight[i]; j--) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">            dp[j] = <span class="built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= bagWeight; j++) &#123;</span><br><span class="line">            cout &lt;&lt; dp[j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[bagWeight] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test_multi_pack</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(m × n × k)，m：物品种类个数，n背包容量，k单类物品数量</li>
</ul>
<p>也有另一种实现方式，就是把每种商品遍历的个数放在01背包里面在遍历一遍。</p>
<p>代码如下：（详看注释）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_multi_pack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; weight = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; value = &#123;<span class="number">15</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="type">int</span> bagWeight = <span class="number">10</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(bagWeight + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; weight.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = bagWeight; j &gt;= weight[i]; j--) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">            <span class="comment">// 以上为01背包，然后加一个遍历个数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= nums[i] &amp;&amp; (j - k * weight[i]) &gt;= <span class="number">0</span>; k++) &#123; <span class="comment">// 遍历个数</span></span><br><span class="line">                dp[j] = <span class="built_in">max</span>(dp[j], dp[j - k * weight[i]] + k * value[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 打印一下dp数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= bagWeight; j++) &#123;</span><br><span class="line">            cout &lt;&lt; dp[j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[bagWeight] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test_multi_pack</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(m × n × k)，m：物品种类个数，n背包容量，k单类物品数量</li>
</ul>
<p>从代码里可以看出是01背包里面在加一个for循环遍历一个每种商品的数量。 和01背包还是如出一辙的。</p>
<p>当然还有那种二进制优化的方法，其实就是把每种物品的数量，打包成一个个独立的包。</p>
<p>和以上在循环遍历上有所不同，因为是分拆为各个包最后可以组成一个完整背包，具体原理我就不做过多解释了，大家了解一下就行，面试的话基本不会考完这个深度了，感兴趣可以自己深入研究一波。</p>
<h1 id="打家劫舍"><a href="#打家劫舍" class="headerlink" title="打家劫舍"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/house-robber/">打家劫舍</a></h1><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p>
<p>示例 1：</p>
<p>输入：[1,2,3,1] </p>
<p>输出：4 </p>
<p>解释：偷窃 1 号房屋 (金额 &#x3D; 1) ，然后偷窃 3 号房屋 (金额 &#x3D; 3)。   偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 </p>
<p>示例 2： </p>
<p>输入：[2,7,9,3,1] </p>
<p>输出：12 </p>
<p>解释：偷窃 1 号房屋 (金额 &#x3D; 2), 偷窃 3 号房屋 (金额 &#x3D; 9)，接着偷窃 5 号房屋 (金额 &#x3D; 1)。   偷窃到的最高金额 &#x3D; 2 + 9 + 1 &#x3D; 12 。</p>
<p>提示：</p>
<ul>
<li>0 &lt;&#x3D; nums.length &lt;&#x3D; 100</li>
<li>0 &lt;&#x3D; nums[i] &lt;&#x3D; 400</li>
</ul>
<h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>打家劫舍是dp解决的经典问题，动规五部曲分析如下：</p>
<ol>
<li>确定dp数组（dp table）以及下标的含义</li>
</ol>
<p>**dp[i]：考虑下标i（包括i）以内的房屋，最多可以偷窃的金额为dp[i]**。</p>
<ol start="2">
<li>确定递推公式</li>
</ol>
<p>决定dp[i]的因素就是第i房间偷还是不偷。</p>
<p>如果偷第i房间，那么dp[i] &#x3D; dp[i - 2] + nums[i] ，即：第i-1房一定是不考虑的，找出 下标i-2（包括i-2）以内的房屋，最多可以偷窃的金额为dp[i-2] 加上第i房间偷到的钱。</p>
<p>如果不偷第i房间，那么dp[i] &#x3D; dp[i - 1]，即考虑i-1房，（<strong>注意这里是考虑，并不是一定要偷i-1房，这是很多同学容易混淆的点</strong>）</p>
<p>然后dp[i]取最大值，即dp[i] &#x3D; max(dp[i - 2] + nums[i], dp[i - 1]);</p>
<ol start="3">
<li>dp数组如何初始化</li>
</ol>
<p>从递推公式dp[i] &#x3D; max(dp[i - 2] + nums[i], dp[i - 1]);可以看出，递推公式的基础就是dp[0] 和 dp[1]</p>
<p>从dp[i]的定义上来讲，dp[0] 一定是 nums[0]，dp[1]就是nums[0]和nums[1]的最大值即：dp[1] &#x3D; max(nums[0], nums[1]);</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">dp[<span class="number">1</span>] = <span class="built_in">max</span>(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>确定遍历顺序</li>
</ol>
<p>dp[i] 是根据dp[i - 2] 和 dp[i - 1] 推导出来的，那么一定是从前到后遍历！</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    dp[i] = <span class="built_in">max</span>(dp[i - <span class="number">2</span>] + nums[i], dp[i - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>举例推导dp数组</li>
</ol>
<p>以示例二，输入[2,7,9,3,1]为例。</p>
<p><img src="https://img-blog.csdnimg.cn/20210221170954115.jpg" alt="198.打家劫舍"></p>
<p>红框dp[nums.size() - 1]为结果。</p>
<p>以上分析完毕，C++代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="built_in">max</span>(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(dp[i - <span class="number">2</span>] + nums[i], dp[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[nums.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="打家劫舍II"><a href="#打家劫舍II" class="headerlink" title="打家劫舍II"></a>打家劫舍II</h1><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，能够偷窃到的最高金额。</p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [2,3,2] 输出：3 解释：你不能先偷窃 1 号房屋（金额 &#x3D; 2），然后偷窃 3 号房屋（金额 &#x3D; 2）, 因为他们是相邻的。</p>
<p>示例 2： 输入：nums &#x3D; [1,2,3,1] 输出：4 解释：你可以先偷窃 1 号房屋（金额 &#x3D; 1），然后偷窃 3 号房屋（金额 &#x3D; 3）。偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。</p>
<p>示例 3： 输入：nums &#x3D; [0] 输出：0</p>
<p>提示：</p>
<ul>
<li>1 &lt;&#x3D; nums.length &lt;&#x3D; 100</li>
<li>0 &lt;&#x3D; nums[i] &lt;&#x3D; 1000</li>
</ul>
<h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>这道题目和<a target="_blank" rel="noopener" href="https://programmercarl.com/0198.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D.html">198.打家劫舍 </a>是差不多的，唯一区别就是成环了。</p>
<p>对于一个数组，成环的话主要有如下三种情况：</p>
<ul>
<li>情况一：考虑不包含首尾元素</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20210129160748643.jpg" alt="213.打家劫舍II"></p>
<ul>
<li>情况二：考虑包含首元素，不包含尾元素</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20210129160821374.jpg" alt="213.打家劫舍II1"></p>
<ul>
<li>情况三：考虑包含尾元素，不包含首元素</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20210129160842491.jpg" alt="213.打家劫舍II2"></p>
<p>**注意我这里用的是”考虑”**，例如情况三，虽然是考虑包含尾元素，但不一定要选尾部元素！ 对于情况三，取nums[1] 和 nums[3]就是最大的。</p>
<p><strong>而情况二 和 情况三 都包含了情况一了，所以只考虑情况二和情况三就可以了</strong>。</p>
<p>分析到这里，本题其实比较简单了。 剩下的和<a target="_blank" rel="noopener" href="https://programmercarl.com/0198.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D.html">198.打家劫舍</a>就是一样的了。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意注释中的情况二情况三，以及把198.打家劫舍的代码抽离出来了</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> result1 = <span class="built_in">robRange</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">2</span>); <span class="comment">// 情况二</span></span><br><span class="line">        <span class="type">int</span> result2 = <span class="built_in">robRange</span>(nums, <span class="number">1</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>); <span class="comment">// 情况三</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(result1, result2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 198.打家劫舍的逻辑</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">robRange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (end == start) <span class="keyword">return</span> nums[start];</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">        dp[start] = nums[start];</span><br><span class="line">        dp[start + <span class="number">1</span>] = <span class="built_in">max</span>(nums[start], nums[start + <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = start + <span class="number">2</span>; i &lt;= end; i++) &#123;</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(dp[i - <span class="number">2</span>] + nums[i], dp[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[end];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="打家劫舍-III"><a href="#打家劫舍-III" class="headerlink" title="打家劫舍 III"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/house-robber-iii/">打家劫舍 III</a></h1><p>在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。</p>
<p>计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。</p>
<p><img src="https://img-blog.csdnimg.cn/20210223173849619.png" alt="337.打家劫舍III"></p>
<h2 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h2><p><strong>本题一定是要后序遍历，因为通过递归函数的返回值来做下一步计算</strong>。</p>
<p>与198.打家劫舍，213.打家劫舍II一样，关键是要讨论当前节点抢还是不抢。</p>
<p>如果抢了当前节点，两个孩子就不能动，如果没抢当前节点，就可以考虑抢左右孩子（<strong>注意这里说的是“考虑”</strong>）</p>
<p>动态规划其实就是使用状态转移容器来记录状态的变化，这里可以使用一个长度为2的数组，记录当前节点偷与不偷所得到的的最大金钱。</p>
<p><strong>这道题目算是树形dp的入门题目，因为是在树上进行状态转移，我们在讲解二叉树的时候说过递归三部曲，那么下面我以递归三部曲为框架，其中融合动规五部曲的内容来进行讲解</strong>。</p>
<ol>
<li>确定递归函数的参数和返回值</li>
</ol>
<p>这里我们要求一个节点 偷与不偷的两个状态所得到的金钱，那么返回值就是一个长度为2的数组。</p>
<p>参数为当前节点，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">robTree</span><span class="params">(TreeNode* cur)</span> </span>&#123;</span><br></pre></td></tr></table></figure>

<p>其实这里的返回数组就是dp数组。</p>
<p>所以dp数组（dp table）以及下标的含义：下标为0记录不偷该节点所得到的的最大金钱，下标为1记录偷该节点所得到的的最大金钱。</p>
<p><strong>所以本题dp数组就是一个长度为2的数组！</strong></p>
<p>那么有同学可能疑惑，长度为2的数组怎么标记树中每个节点的状态呢？</p>
<p><strong>别忘了在递归的过程中，系统栈会保存每一层递归的参数</strong>。</p>
<p>如果还不理解的话，就接着往下看，看到代码就理解了哈。</p>
<ol start="2">
<li>确定终止条件</li>
</ol>
<p>在遍历的过程中，如果遇到空节点的话，很明显，无论偷还是不偷都是0，所以就返回</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt;&#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>这也相当于dp数组的初始化</p>
<ol start="3">
<li>确定遍历顺序</li>
</ol>
<p>首先明确的是使用后序遍历。 因为通过递归函数的返回值来做下一步计算。</p>
<p>通过递归左节点，得到左节点偷与不偷的金钱。</p>
<p>通过递归右节点，得到右节点偷与不偷的金钱。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下标0：不偷，下标1：偷</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; left = <span class="built_in">robTree</span>(cur-&gt;left); <span class="comment">// 左</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; right = <span class="built_in">robTree</span>(cur-&gt;right); <span class="comment">// 右</span></span><br><span class="line"><span class="comment">// 中</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>确定单层递归的逻辑</li>
</ol>
<p>如果是偷当前节点，那么左右孩子就不能偷，val1 &#x3D; cur-&gt;val + left[0] + right[0]; （<strong>如果对下标含义不理解就在回顾一下dp数组的含义</strong>）</p>
<p>如果不偷当前节点，那么左右孩子就可以偷，至于到底偷不偷一定是选一个最大的，所以：val2 &#x3D; max(left[0], left[1]) + max(right[0], right[1]);</p>
<p>最后当前节点的状态就是{val2, val1}; 即：{不偷当前节点得到的最大金钱，偷当前节点得到的最大金钱}</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; left = <span class="built_in">robTree</span>(cur-&gt;left); <span class="comment">// 左</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; right = <span class="built_in">robTree</span>(cur-&gt;right); <span class="comment">// 右</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 偷cur</span></span><br><span class="line"><span class="type">int</span> val1 = cur-&gt;val + left[<span class="number">0</span>] + right[<span class="number">0</span>];</span><br><span class="line"><span class="comment">// 不偷cur</span></span><br><span class="line"><span class="type">int</span> val2 = <span class="built_in">max</span>(left[<span class="number">0</span>], left[<span class="number">1</span>]) + <span class="built_in">max</span>(right[<span class="number">0</span>], right[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">return</span> &#123;val2, val1&#125;;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>举例推导dp数组</li>
</ol>
<p>以示例1为例，dp数组状态如下：（<strong>注意用后序遍历的方式推导</strong>）</p>
<p><img src="https://code-thinking.cdn.bcebos.com/pics/337.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DIII.jpg" alt="337.打家劫舍III"></p>
<p><strong>最后头结点就是 取下标0 和 下标1的最大值就是偷得的最大金钱</strong>。</p>
<p>递归三部曲与动规五部曲分析完毕，C++代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result = <span class="built_in">robTree</span>(root);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(result[<span class="number">0</span>], result[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 长度为2的数组，0：不偷，1：偷</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">robTree</span><span class="params">(TreeNode* cur)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt;&#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; left = <span class="built_in">robTree</span>(cur-&gt;left);</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; right = <span class="built_in">robTree</span>(cur-&gt;right);</span><br><span class="line">        <span class="comment">// 偷cur</span></span><br><span class="line">        <span class="type">int</span> val1 = cur-&gt;val + left[<span class="number">0</span>] + right[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 不偷cur</span></span><br><span class="line">        <span class="type">int</span> val2 = <span class="built_in">max</span>(left[<span class="number">0</span>], left[<span class="number">1</span>]) + <span class="built_in">max</span>(right[<span class="number">0</span>], right[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> &#123;val2, val1&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：$O(n)$，每个节点只遍历了一次</li>
<li>空间复杂度：$O(\log n)$，算上递推系统栈的空间</li>
</ul>
<h1 id="买卖股票的最佳时机"><a href="#买卖股票的最佳时机" class="headerlink" title="买卖股票的最佳时机"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">买卖股票的最佳时机</a></h1><p>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。</p>
<p>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p>
<p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p>
<p>示例 1：<br>输入：[7,1,5,3,6,4]<br>输出：5<br>解释：在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出，最大利润 &#x3D; 6-1 &#x3D; 5 。注意利润不能是 7-1 &#x3D; 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</p>
<p>示例 2：<br>输入：prices &#x3D; [7,6,4,3,1]<br>输出：0<br>解释：在这种情况下, 没有交易完成, 所以最大利润为 0。</p>
<h2 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h2><p>动规五部曲分析如下：</p>
<ol>
<li>确定dp数组（dp table）以及下标的含义</li>
</ol>
<p>dp[i][0] 表示第i天持有股票所得最多现金 ，<strong>这里可能有同学疑惑，本题中只能买卖一次，持有股票之后哪还有现金呢？</strong></p>
<p>其实一开始现金是0，那么加入第i天买入股票现金就是 -prices[i]， 这是一个负数。</p>
<p>dp[i][1] 表示第i天不持有股票所得最多现金</p>
<p><strong>注意这里说的是“持有”，“持有”不代表就是当天“买入”！也有可能是昨天就买入了，今天保持持有的状态</strong></p>
<p>很多同学把“持有”和“买入”没分区分清楚。</p>
<p>在下面递推公式分析中，我会进一步讲解。</p>
<ol start="2">
<li>确定递推公式</li>
</ol>
<p>如果第i天持有股票即dp[i][0]， 那么可以由两个状态推出来</p>
<ul>
<li>第i-1天就持有股票，那么就保持现状，所得现金就是昨天持有股票的所得现金 即：dp[i - 1][0]</li>
<li>第i天买入股票，所得现金就是买入今天的股票后所得现金即：-prices[i]</li>
</ul>
<p>那么dp[i][0]应该选所得现金最大的，所以<strong>dp[i][0] &#x3D; max(dp[i - 1][0], -prices[i])</strong>;</p>
<p>如果第i天不持有股票即dp[i][1]， 也可以由两个状态推出来</p>
<ul>
<li>第i-1天就不持有股票，那么就保持现状，所得现金就是昨天不持有股票的所得现金 即：dp[i - 1][1]</li>
<li>第i天卖出股票，所得现金就是按照今天股票佳价格卖出后所得现金即：prices[i] + dp[i - 1][0]</li>
</ul>
<p>同样dp[i][1]取最大的，<strong>dp[i][1] &#x3D; max(dp[i - 1][1], prices[i] + dp[i - 1][0])</strong>;</p>
<p>这样递归公式我们就分析完了</p>
<ol start="3">
<li>dp数组如何初始化</li>
</ol>
<p>由递推公式 dp[i][0] &#x3D; max(dp[i - 1][0], -prices[i]); 和 dp[i][1] &#x3D; max(dp[i - 1][1], prices[i] + dp[i - 1][0]);可以看出</p>
<p>其基础都是要从dp[0][0]和dp[0][1]推导出来。</p>
<p>那么dp[0][0]表示第0天持有股票，此时的持有股票就一定是买入股票了，因为不可能有前一天推出来，所以dp[0][0] -&#x3D; prices[0];</p>
<p>dp[0][1]表示第0天不持有股票，不持有股票那么现金就是0，所以dp[0][1] &#x3D; 0;</p>
<ol start="4">
<li>确定遍历顺序</li>
</ol>
<p>从递推公式可以看出dp[i]都是有dp[i - 1]推导出来的，那么一定是从前向后遍历。</p>
<ol start="5">
<li>举例推导dp数组</li>
</ol>
<p>以示例1，输入：[7,1,5,3,6,4]为例，dp数组状态如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20210224225642465.png" alt="121.买卖股票的最佳时机"></p>
<p>dp[5][1]就是最终结果。</p>
<p>为什么不是dp[5][0]呢？</p>
<p><strong>因为本题中不持有股票状态所得金钱一定比持有股票状态得到的多！</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 版本一</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(len, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] -= prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>], -prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>], prices[i] + dp[i - <span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="买卖股票的最佳时机II"><a href="#买卖股票的最佳时机II" class="headerlink" title="买卖股票的最佳时机II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">买卖股票的最佳时机II</a></h1><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p>
<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p>示例 1:<br>输入: [7,1,5,3,6,4]<br>输出: 7<br>解释: 在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 3 天（股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5-1 &#x3D; 4。随后，在第 4 天（股票价格 &#x3D; 3）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出, 这笔交易所能获得利润 &#x3D; 6-3 &#x3D; 3 。</p>
<p>示例 2:<br>输入: [1,2,3,4,5]<br>输出: 4<br>解释: 在第 1 天（股票价格 &#x3D; 1）的时候买入，在第 5 天 （股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5-1 &#x3D; 4 。注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</p>
<p>示例 3:<br>输入: [7,6,4,3,1]<br>输出: 0<br>解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</p>
<p>提示：</p>
<ul>
<li>1 &lt;&#x3D; prices.length &lt;&#x3D; 3 * 10 ^ 4</li>
<li>0 &lt;&#x3D; prices[i] &lt;&#x3D; 10 ^ 4</li>
</ul>
<h1 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h1><p>本题和<a target="_blank" rel="noopener" href="https://programmercarl.com/0121.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA.html">121. 买卖股票的最佳时机</a>的唯一区别本题股票可以买卖多次了（注意只有一只股票，所以再次购买前要出售掉之前的股票）</p>
<p>在动规五部曲中，这个区别主要是体现在递推公式上，其他都和<a target="_blank" rel="noopener" href="https://programmercarl.com/0121.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA.html">121. 买卖股票的最佳时机 </a>一样一样的。</p>
<p>所以我们重点讲一讲递推公式。</p>
<p>这里重申一下dp数组的含义：</p>
<ul>
<li>dp[i][0] 表示第i天持有股票所得现金。</li>
<li>dp[i][1] 表示第i天不持有股票所得最多现金</li>
</ul>
<p>如果第i天持有股票即dp[i][0]， 那么可以由两个状态推出来</p>
<ul>
<li>第i-1天就持有股票，那么就保持现状，所得现金就是昨天持有股票的所得现金 即：dp[i - 1][0]</li>
<li>第i天买入股票，所得现金就是昨天不持有股票的所得现金减去 今天的股票价格 即：dp[i - 1][1] - prices[i]</li>
</ul>
<p>注意这里和<a target="_blank" rel="noopener" href="https://programmercarl.com/0121.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA.html">121. 买卖股票的最佳时机 </a>唯一不同的地方，就是推导dp[i][0]的时候，第i天买入股票的情况。</p>
<p>在<a target="_blank" rel="noopener" href="https://programmercarl.com/0121.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA.html">121. 买卖股票的最佳时机</a>中，因为股票全程只能买卖一次，所以如果买入股票，那么第i天持有股票即dp[i][0]一定就是 -prices[i]。</p>
<p>而本题，因为一只股票可以买卖多次，所以当第i天买入股票的时候，所持有的现金可能有之前买卖过的利润。</p>
<p>那么第i天持有股票即dp[i][0]，如果是第i天买入股票，所得现金就是昨天不持有股票的所得现金 减去 今天的股票价格 即：dp[i - 1][1] - prices[i]。</p>
<p>在来看看如果第i天不持有股票即dp[i][1]的情况， 依然可以由两个状态推出来</p>
<ul>
<li>第i-1天就不持有股票，那么就保持现状，所得现金就是昨天不持有股票的所得现金 即：dp[i - 1][1]</li>
<li>第i天卖出股票，所得现金就是按照今天股票佳价格卖出后所得现金即：prices[i] + dp[i - 1][0]</li>
</ul>
<p><strong>注意这里和<a target="_blank" rel="noopener" href="https://programmercarl.com/0121.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA.html">121. 买卖股票的最佳时机 </a>就是一样的逻辑，卖出股票收获利润（可能是负值）天经地义！</strong></p>
<p>代码如下：（注意代码中的注释，标记了和121.买卖股票的最佳时机唯一不同的地方）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = prices.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(len, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] -= prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] - prices[i]); <span class="comment">// 注意这里是和121. 买卖股票的最佳时机唯一不同的地方。</span></span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="买卖股票的最佳时机III"><a href="#买卖股票的最佳时机III" class="headerlink" title="买卖股票的最佳时机III"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/">买卖股票的最佳时机III</a></h1><p>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。</p>
<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p>示例 1: 输入：prices &#x3D; [3,3,5,0,0,3,1,4] 输出：6 解释：在第 4 天（股票价格 &#x3D; 0）的时候买入，在第 6 天（股票价格 &#x3D; 3）的时候卖出，这笔交易所能获得利润 &#x3D; 3-0 &#x3D; 3 。随后，在第 7 天（股票价格 &#x3D; 1）的时候买入，在第 8 天 （股票价格 &#x3D; 4）的时候卖出，这笔交易所能获得利润 &#x3D; 4-1 &#x3D; 3。</p>
<p>示例 2： 输入：prices &#x3D; [1,2,3,4,5] 输出：4 解释：在第 1 天（股票价格 &#x3D; 1）的时候买入，在第 5 天 （股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5-1 &#x3D; 4。注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</p>
<p>示例 3： 输入：prices &#x3D; [7,6,4,3,1] 输出：0 解释：在这个情况下, 没有交易完成, 所以最大利润为0。</p>
<p>示例 4： 输入：prices &#x3D; [1] 输出：0</p>
<p>提示：</p>
<ul>
<li>1 &lt;&#x3D; prices.length &lt;&#x3D; 10^5</li>
<li>0 &lt;&#x3D; prices[i] &lt;&#x3D; 10^5</li>
</ul>
<h2 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h2><p>这道题目相对 <a target="_blank" rel="noopener" href="https://programmercarl.com/0121.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA.html">121.买卖股票的最佳时机 </a>和 <a target="_blank" rel="noopener" href="https://programmercarl.com/0122.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII.html">122.买卖股票的最佳时机II </a>难了不少。</p>
<p>关键在于至多买卖两次，这意味着<strong>可以买卖一次，可以买卖两次，也可以不买卖</strong>。</p>
<p>接来下我用动态规划五部曲详细分析一下：</p>
<ol>
<li>确定dp数组以及下标的含义</li>
</ol>
<p>一天一共就有五个状态，</p>
<ol start="0">
<li>没有操作</li>
<li>第一次买入</li>
<li>第一次卖出</li>
<li>第二次买入</li>
<li>第二次卖出</li>
</ol>
<p>dp[i][j]中 i表示第i天，j为 [0 - 4] 五个状态，dp[i][j]表示第i天状态j所剩最大现金。</p>
<ol start="2">
<li>确定递推公式</li>
</ol>
<p>需要注意：dp[i][1]，<strong>表示的是第i天，买入股票的状态，并不是说一定要第i天买入股票，这是很多同学容易陷入的误区</strong>。</p>
<p>达到dp[i][1]状态，有两个具体操作：</p>
<ul>
<li>操作一：第i天买入股票了，那么dp[i][1] &#x3D; dp[i-1][0] - prices[i]</li>
<li>操作二：第i天没有操作，而是沿用前一天买入的状态，即：dp[i][1] &#x3D; dp[i - 1][1]</li>
</ul>
<p>那么dp[i][1]究竟选 dp[i-1][0] - prices[i]，还是dp[i - 1][1]呢？</p>
<p>一定是选最大的，所以 dp[i][1] &#x3D; max(dp[i-1][0] - prices[i], dp[i - 1][1]);</p>
<p>同理dp[i][2]也有两个操作：</p>
<ul>
<li>操作一：第i天卖出股票了，那么dp[i][2] &#x3D; dp[i - 1][1] + prices[i]</li>
<li>操作二：第i天没有操作，沿用前一天卖出股票的状态，即：dp[i][2] &#x3D; dp[i - 1][2]</li>
</ul>
<p>所以dp[i][2] &#x3D; max(dp[i - 1][1] + prices[i], dp[i - 1][2])</p>
<p>同理可推出剩下状态部分：</p>
<p>dp[i][3] &#x3D; max(dp[i - 1][3], dp[i - 1][2] - prices[i]);</p>
<p>dp[i][4] &#x3D; max(dp[i - 1][4], dp[i - 1][3] + prices[i]);</p>
<ol start="3">
<li>dp数组如何初始化</li>
</ol>
<p>第0天没有操作，这个最容易想到，就是0，即：dp[0][0] &#x3D; 0;</p>
<p>第0天做第一次买入的操作，dp[0][1] &#x3D; -prices[0];</p>
<p>第0天做第一次卖出的操作，这个初始值应该是多少呢？</p>
<p>首先卖出的操作一定是收获利润，整个股票买卖最差情况也就是没有盈利即全程无操作现金为0，</p>
<p>从递推公式中可以看出每次是取最大值，那么既然是收获利润如果比0还小了就没有必要收获这个利润了。</p>
<p>所以dp[0][2] &#x3D; 0;</p>
<p>第0天第二次买入操作，初始值应该是多少呢？应该不少同学疑惑，第一次还没买入呢，怎么初始化第二次买入呢？</p>
<p>第二次买入依赖于第一次卖出的状态，其实相当于第0天第一次买入了，第一次卖出了，然后在买入一次（第二次买入），那么现在手头上没有现金，只要买入，现金就做相应的减少。</p>
<p>所以第二次买入操作，初始化为：dp[0][3] &#x3D; -prices[0];</p>
<p>同理第二次卖出初始化dp[0][4] &#x3D; 0;</p>
<ol start="4">
<li>确定遍历顺序</li>
</ol>
<p>从递归公式其实已经可以看出，一定是从前向后遍历，因为dp[i]，依靠dp[i - 1]的数值。</p>
<ol start="5">
<li>举例推导dp数组</li>
</ol>
<p>以输入[1,2,3,4,5]为例</p>
<p><img src="https://img-blog.csdnimg.cn/20201228181724295.png" alt="123.买卖股票的最佳时机III"></p>
<p>大家可以看到红色框为最后两次卖出的状态。</p>
<p>现在最大的时候一定是卖出的状态，而两次卖出的状态现金最大一定是最后一次卖出。</p>
<p>所以最终最大利润是dp[4][4]</p>
<p>以上五部都分析完了，不难写出如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(prices.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">5</span>, <span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">3</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">            dp[i][<span class="number">2</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">2</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i][<span class="number">3</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">3</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>] - prices[i]);</span><br><span class="line">            dp[i][<span class="number">4</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">4</span>], dp[i - <span class="number">1</span>][<span class="number">3</span>] + prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[prices.<span class="built_in">size</span>() - <span class="number">1</span>][<span class="number">4</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="买卖股票的最佳时机IV"><a href="#买卖股票的最佳时机IV" class="headerlink" title="买卖股票的最佳时机IV"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/">买卖股票的最佳时机IV</a></h1><p>给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。</p>
<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p>示例 1： 输入：k &#x3D; 2, prices &#x3D; [2,4,1] 输出：2 解释：在第 1 天 (股票价格 &#x3D; 2) 的时候买入，在第 2 天 (股票价格 &#x3D; 4) 的时候卖出，这笔交易所能获得利润 &#x3D; 4-2 &#x3D; 2。</p>
<p>示例 2： 输入：k &#x3D; 2, prices &#x3D; [3,2,6,5,0,3] 输出：7 解释：在第 2 天 (股票价格 &#x3D; 2) 的时候买入，在第 3 天 (股票价格 &#x3D; 6) 的时候卖出, 这笔交易所能获得利润 &#x3D; 6-2 &#x3D; 4。随后，在第 5 天 (股票价格 &#x3D; 0) 的时候买入，在第 6 天 (股票价格 &#x3D; 3) 的时候卖出, 这笔交易所能获得利润 &#x3D; 3-0 &#x3D; 3 。</p>
<p>提示：</p>
<ul>
<li>0 &lt;&#x3D; k &lt;&#x3D; 100</li>
<li>0 &lt;&#x3D; prices.length &lt;&#x3D; 1000</li>
<li>0 &lt;&#x3D; prices[i] &lt;&#x3D; 1000</li>
</ul>
<h2 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h2><p>这道题目可以说是<a target="_blank" rel="noopener" href="https://programmercarl.com/0123.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIII.html">动态规划：123.买卖股票的最佳时机III</a>的进阶版，这里要求至多有k次交易。</p>
<p>动规五部曲，分析如下：</p>
<ol>
<li>确定dp数组以及下标的含义</li>
</ol>
<p>在<a target="_blank" rel="noopener" href="https://programmercarl.com/0123.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIII.html">动态规划：123.买卖股票的最佳时机III </a>中，我是定义了一个二维dp数组，本题其实依然可以用一个二维dp数组。</p>
<p>使用二维数组 dp[i][j] ：第i天的状态为j，所剩下的最大现金是dp[i][j]</p>
<p>j的状态表示为：</p>
<ul>
<li>0 表示不操作</li>
<li>1 第一次买入</li>
<li>2 第一次卖出</li>
<li>3 第二次买入</li>
<li>4 第二次卖出</li>
<li>…..</li>
</ul>
<p><strong>大家应该发现规律了吧 ，除了0以外，偶数就是卖出，奇数就是买入</strong>。</p>
<p>题目要求是至多有K笔交易，那么j的范围就定义为 2 * k + 1 就可以了。</p>
<p>所以二维dp数组的C++定义为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(prices.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span> * k + <span class="number">1</span>, <span class="number">0</span>));</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>确定递推公式</li>
</ol>
<p>还要强调一下：dp[i][1]，<strong>表示的是第i天，买入股票的状态，并不是说一定要第i天买入股票，这是很多同学容易陷入的误区</strong>。</p>
<p>达到dp[i][1]状态，有两个具体操作：</p>
<ul>
<li>操作一：第i天买入股票了，那么dp[i][1] &#x3D; dp[i - 1][0] - prices[i]</li>
<li>操作二：第i天没有操作，而是沿用前一天买入的状态，即：dp[i][1] &#x3D; dp[i - 1][1]</li>
</ul>
<p>选最大的，所以 dp[i][1] &#x3D; max(dp[i - 1][0] - prices[i], dp[i - 1][1]);</p>
<p>同理dp[i][2]也有两个操作：</p>
<ul>
<li>操作一：第i天卖出股票了，那么dp[i][2] &#x3D; dp[i - 1][1] + prices[i]</li>
<li>操作二：第i天没有操作，沿用前一天卖出股票的状态，即：dp[i][2] &#x3D; dp[i - 1][2]</li>
</ul>
<p>所以dp[i][2] &#x3D; max(dp[i - 1][1] + prices[i], dp[i - 1][2])</p>
<p>同理可以类比剩下的状态，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span> * k - <span class="number">1</span>; j += <span class="number">2</span>) &#123;</span><br><span class="line">    dp[i][j + <span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j + <span class="number">1</span>], dp[i - <span class="number">1</span>][j] - prices[i]);</span><br><span class="line">    dp[i][j + <span class="number">2</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j + <span class="number">2</span>], dp[i - <span class="number">1</span>][j + <span class="number">1</span>] + prices[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本题和<a target="_blank" rel="noopener" href="https://programmercarl.com/0123.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIII.html">动态规划：123.买卖股票的最佳时机III</a>最大的区别就是这里要类比j为奇数是买，偶数是卖的状态。</p>
<ol start="3">
<li>dp数组如何初始化</li>
</ol>
<p>第0天没有操作，这个最容易想到，就是0，即：dp[0][0] &#x3D; 0;</p>
<p>第0天做第一次买入的操作，dp[0][1] &#x3D; -prices[0];</p>
<p>第0天做第一次卖出的操作，这个初始值应该是多少呢？</p>
<p>首先卖出的操作一定是收获利润，整个股票买卖最差情况也就是没有盈利即全程无操作现金为0，</p>
<p>从递推公式中可以看出每次是取最大值，那么既然是收获利润如果比0还小了就没有必要收获这个利润了。</p>
<p>所以dp[0][2] &#x3D; 0;</p>
<p>第0天第二次买入操作，初始值应该是多少呢？</p>
<p>不用管第几次，现在手头上没有现金，只要买入，现金就做相应的减少。</p>
<p>第二次买入操作，初始化为：dp[0][3] &#x3D; -prices[0];</p>
<p><strong>所以同理可以推出dp[0][j]当j为奇数的时候都初始化为 -prices[0]</strong></p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; <span class="number">2</span> * k; j += <span class="number">2</span>) &#123;</span><br><span class="line">    dp[<span class="number">0</span>][j] = -prices[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在初始化的地方同样要类比j为偶数是卖、奇数是买的状态</strong>。</p>
<ol start="4">
<li>确定遍历顺序</li>
</ol>
<p>从递归公式其实已经可以看出，一定是从前向后遍历，因为dp[i]，依靠dp[i - 1]的数值。</p>
<ol start="5">
<li>举例推导dp数组</li>
</ol>
<p>以输入[1,2,3,4,5]，k&#x3D;2为例。</p>
<p><img src="https://img-blog.csdnimg.cn/20201229100358221.png" alt="188.买卖股票的最佳时机IV"></p>
<p>最后一次卖出，一定是利润最大的，dp[prices.size() - 1][2 * k]即红色部分就是最后求解。</p>
<p>以上分析完毕，C++代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(<span class="type">int</span> k, vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (prices.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(prices.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span> * k + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; <span class="number">2</span> * k; j += <span class="number">2</span>) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = -prices[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt; prices.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span> * k - <span class="number">1</span>; j += <span class="number">2</span>) &#123;</span><br><span class="line">                dp[i][j + <span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j + <span class="number">1</span>], dp[i - <span class="number">1</span>][j] - prices[i]);</span><br><span class="line">                dp[i][j + <span class="number">2</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j + <span class="number">2</span>], dp[i - <span class="number">1</span>][j + <span class="number">1</span>] + prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[prices.<span class="built_in">size</span>() - <span class="number">1</span>][<span class="number">2</span> * k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="最佳买卖股票时机含冷冻期"><a href="#最佳买卖股票时机含冷冻期" class="headerlink" title="最佳买卖股票时机含冷冻期"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/">最佳买卖股票时机含冷冻期</a></h1><p>给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。</p>
<p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p>
<ul>
<li>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</li>
<li>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</li>
</ul>
<p>示例: 输入: [1,2,3,0,2] 输出: 3 解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]</p>
<h2 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h2><p>相对于<a target="_blank" rel="noopener" href="https://programmercarl.com/0122.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89.html">动态规划：122.买卖股票的最佳时机II </a>，本题加上了一个冷冻期</p>
<p>在<a target="_blank" rel="noopener" href="https://programmercarl.com/0122.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89.html">动态规划：122.买卖股票的最佳时机II </a>中有两个状态，持有股票后的最多现金，和不持有股票的最多现金。</p>
<p>动规五部曲，分析如下：</p>
<ol>
<li>确定dp数组以及下标的含义</li>
</ol>
<p>dp[i][j]，第i天状态为j，所剩的最多现金为dp[i][j]。</p>
<p><strong>其实本题很多同学搞的比较懵，是因为出现冷冻期之后，状态其实是比较复杂度</strong>，例如今天买入股票、今天卖出股票、今天是冷冻期，都是不能操作股票的。 具体可以区分出如下四个状态：</p>
<ul>
<li>状态一：买入股票状态（今天买入股票，或者是之前就买入了股票然后没有操作）</li>
<li>卖出股票状态，这里就有两种卖出股票状态<ul>
<li>状态二：两天前就卖出了股票，度过了冷冻期，一直没操作，今天保持卖出股票状态</li>
<li>状态三：今天卖出了股票</li>
</ul>
</li>
<li>状态四：今天为冷冻期状态，但冷冻期状态不可持续，只有一天！</li>
</ul>
<p>j的状态为：</p>
<ul>
<li>0：状态一</li>
<li>1：状态二</li>
<li>2：状态三</li>
<li>3：状态四</li>
</ul>
<p>很多题解为什么讲的比较模糊，是因为把这四个状态合并成三个状态了，其实就是把状态二和状态四合并在一起了。</p>
<p>从代码上来看确实可以合并，但从逻辑上分析合并之后就很难理解了，所以我下面的讲解是按照这四个状态来的，把每一个状态分析清楚。</p>
<p><strong>注意这里的每一个状态，例如状态一，是买入股票状态并不是说今天已经就买入股票，而是说保存买入股票的状态即：可能是前几天买入的，之后一直没操作，所以保持买入股票的状态</strong>。</p>
<ol start="2">
<li>确定递推公式</li>
</ol>
<p>达到买入股票状态（状态一）即：dp[i][0]，有两个具体操作：</p>
<ul>
<li>操作一：前一天就是持有股票状态（状态一），dp[i][0] &#x3D; dp[i - 1][0]</li>
<li>操作二：今天买入了，有两种情况<ul>
<li>前一天是冷冻期（状态四），dp[i - 1][3] - prices[i]</li>
<li>前一天是保持卖出股票状态（状态二），dp[i - 1][1] - prices[i]</li>
</ul>
</li>
</ul>
<p>所以操作二取最大值，即：max(dp[i - 1][3], dp[i - 1][1]) - prices[i]</p>
<p>那么dp[i][0] &#x3D; max(dp[i - 1][0], max(dp[i - 1][3], dp[i - 1][1]) - prices[i]);</p>
<p>达到保持卖出股票状态（状态二）即：dp[i][1]，有两个具体操作：</p>
<ul>
<li>操作一：前一天就是状态二</li>
<li>操作二：前一天是冷冻期（状态四）</li>
</ul>
<p>dp[i][1] &#x3D; max(dp[i - 1][1], dp[i - 1][3]);</p>
<p>达到今天就卖出股票状态（状态三），即：dp[i][2] ，只有一个操作：</p>
<ul>
<li>操作一：昨天一定是买入股票状态（状态一），今天卖出</li>
</ul>
<p>即：dp[i][2] &#x3D; dp[i - 1][0] + prices[i];</p>
<p>达到冷冻期状态（状态四），即：dp[i][3]，只有一个操作：</p>
<ul>
<li>操作一：昨天卖出了股票（状态三）</li>
</ul>
<p>dp[i][3] &#x3D; dp[i - 1][2];</p>
<p>综上分析，递推代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>], <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">3</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>]) - prices[i]);</span><br><span class="line">dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">3</span>]);</span><br><span class="line">dp[i][<span class="number">2</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i];</span><br><span class="line">dp[i][<span class="number">3</span>] = dp[i - <span class="number">1</span>][<span class="number">2</span>];</span><br></pre></td></tr></table></figure>



<ol start="3">
<li>dp数组如何初始化</li>
</ol>
<p>这里主要讨论一下第0天如何初始化。</p>
<p>如果是持有股票状态（状态一）那么：dp[0][0] &#x3D; -prices[0]，买入股票所剩现金为负数。</p>
<p>保持卖出股票状态（状态二），第0天没有卖出dp[0][1]初始化为0就行，</p>
<p>今天卖出了股票（状态三），同样dp[0][2]初始化为0，因为最少收益就是0，绝不会是负数。</p>
<p>同理dp[0][3]也初始为0。</p>
<ol start="4">
<li>确定遍历顺序</li>
</ol>
<p>从递归公式上可以看出，dp[i] 依赖于 dp[i-1]，所以是从前向后遍历。</p>
<ol start="5">
<li>举例推导dp数组</li>
</ol>
<p>以 [1,2,3,0,2] 为例，dp数组如下：</p>
<p><img src="https://img-blog.csdnimg.cn/2021032317451040.png" alt="309.最佳买卖股票时机含冷冻期"></p>
<p>最后结果是取 状态二，状态三，和状态四的最大值，不少同学会把状态四忘了，状态四是冷冻期，最后一天如果是冷冻期也可能是最大值。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">4</span>, <span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] -= prices[<span class="number">0</span>]; <span class="comment">// 持股票</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>], <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">3</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>]) - prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">3</span>]);</span><br><span class="line">            dp[i][<span class="number">2</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i];</span><br><span class="line">            dp[i][<span class="number">3</span>] = dp[i - <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp[n - <span class="number">1</span>][<span class="number">3</span>],<span class="built_in">max</span>(dp[n - <span class="number">1</span>][<span class="number">1</span>], dp[n - <span class="number">1</span>][<span class="number">2</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="买卖股票的最佳时机含手续费"><a href="#买卖股票的最佳时机含手续费" class="headerlink" title="买卖股票的最佳时机含手续费"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">买卖股票的最佳时机含手续费</a></h1><p>给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。</p>
<p>你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</p>
<p>返回获得利润的最大值。</p>
<p>注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。</p>
<p>示例 1: 输入: prices &#x3D; [1, 3, 2, 8, 4, 9], fee &#x3D; 2 输出: 8</p>
<p>解释: 能够达到的最大利润: 在此处买入 prices[0] &#x3D; 1 在此处卖出 prices[3] &#x3D; 8 在此处买入 prices[4] &#x3D; 4 在此处卖出 prices[5] &#x3D; 9 总利润: ((8 - 1) - 2) + ((9 - 4) - 2) &#x3D; 8.</p>
<p>注意:</p>
<ul>
<li>0 &lt; prices.length &lt;&#x3D; 50000.</li>
<li>0 &lt; prices[i] &lt; 50000.</li>
<li>0 &lt;&#x3D; fee &lt; 50000.</li>
</ul>
<h2 id="思路-11"><a href="#思路-11" class="headerlink" title="思路"></a>思路</h2><p>在讲解贪心专题的时候，我们已经讲过本题了<a target="_blank" rel="noopener" href="https://programmercarl.com/0714.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9.html">贪心算法：买卖股票的最佳时机含手续费</a></p>
<p>使用贪心算法，的性能是：</p>
<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)</li>
</ul>
<p>那么我们再来看看是使用动规的方法如何解题。</p>
<p>相对于<a target="_blank" rel="noopener" href="https://programmercarl.com/0122.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89.html">动态规划：122.买卖股票的最佳时机II </a>，本题只需要在计算卖出操作的时候减去手续费就可以了，代码几乎是一样的。</p>
<p>唯一差别在于递推公式部分，所以本篇也就不按照动规五部曲详细讲解了，主要讲解一下递推公式部分。</p>
<p>这里重申一下dp数组的含义：</p>
<p>dp[i][0] 表示第i天持有股票所省最多现金。 dp[i][1] 表示第i天不持有股票所得最多现金</p>
<p>如果第i天持有股票即dp[i][0]， 那么可以由两个状态推出来</p>
<ul>
<li>第i-1天就持有股票，那么就保持现状，所得现金就是昨天持有股票的所得现金 即：dp[i - 1][0]</li>
<li>第i天买入股票，所得现金就是昨天不持有股票的所得现金减去 今天的股票价格 即：dp[i - 1][1] - prices[i]</li>
</ul>
<p>所以：dp[i][0] &#x3D; max(dp[i - 1][0], dp[i - 1][1] - prices[i]);</p>
<p>在来看看如果第i天不持有股票即dp[i][1]的情况， 依然可以由两个状态推出来</p>
<ul>
<li>第i-1天就不持有股票，那么就保持现状，所得现金就是昨天不持有股票的所得现金 即：dp[i - 1][1]</li>
<li>第i天卖出股票，所得现金就是按照今天股票价格卖出后所得现金，<strong>注意这里需要有手续费了</strong>即：dp[i - 1][0] + prices[i] - fee</li>
</ul>
<p>所以：dp[i][1] &#x3D; max(dp[i - 1][1], dp[i - 1][0] + prices[i] - fee);</p>
<p>本题和<a target="_blank" rel="noopener" href="https://programmercarl.com/0122.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89.html">动态规划：122.买卖股票的最佳时机II </a>的区别就是这里需要多一个减去手续费的操作。</p>
<p>以上分析完毕，C++代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices, <span class="type">int</span> fee)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] -= prices[<span class="number">0</span>]; <span class="comment">// 持股票</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] - prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i] - fee);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp[n - <span class="number">1</span>][<span class="number">0</span>], dp[n - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>















































<p>声明：</p>
<p>本博客整理主要参考《代码随想录》，题目来自leetcode</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/29/UE4-%E7%AC%AC%E4%B8%80%E4%BA%BA%E7%A7%B0FPS-%E4%BB%A3%E7%A0%81%E8%AE%B2%E8%A7%A3%EF%BC%88%E4%B8%80%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="williny">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Williny'home">
      <meta itemprop="description" content="孤独是人生的常态">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Williny'home">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/04/29/UE4-%E7%AC%AC%E4%B8%80%E4%BA%BA%E7%A7%B0FPS-%E4%BB%A3%E7%A0%81%E8%AE%B2%E8%A7%A3%EF%BC%88%E4%B8%80%EF%BC%89/" class="post-title-link" itemprop="url">UE4-第一人称FPS-代码讲解（一）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-04-29 14:38:10" itemprop="dateCreated datePublished" datetime="2022-04-29T14:38:10+08:00">2022-04-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-05-02 14:07:27" itemprop="dateModified" datetime="2022-05-02T14:07:27+08:00">2022-05-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/unreal-engine/" itemprop="url" rel="index"><span itemprop="name">unreal engine</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>案例是来自官方文档的<a target="_blank" rel="noopener" href="https://docs.unrealengine.com/4.27/zh-CN/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/1/">第一人称射击游戏教程</a>，详细实施步骤可以看我之前的博客，或者直接取官网查看，此处仅仅讲解实现项目的代码</p>
<h1 id="添加日志消息"><a href="#添加日志消息" class="headerlink" title="添加日志消息"></a>添加日志消息</h1><h2 id="FPSProjectGameMode-h"><a href="#FPSProjectGameMode-h" class="headerlink" title="FPSProjectGameMode.h"></a>FPSProjectGameMode.h</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CoreMinimal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GameFramework/GameModeBase.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;FPSProjectGameModeBase.generated.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FPSPROJECT_API</span> AFPSProjectGameModeBase : <span class="keyword">public</span> AGameModeBase</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于重载StartPlay()函数</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">StartPlay</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这一段没啥好说的，唯一修改的地方就是在此声明StartPlay()函数，使我们可以将其重载</p>
<h2 id="FPSProjectGameModeBase-cpp"><a href="#FPSProjectGameModeBase-cpp" class="headerlink" title="FPSProjectGameModeBase.cpp"></a>FPSProjectGameModeBase.cpp</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Epic Games, Inc版权所有。保留所有权利。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;FPSProjectGameMode.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSProjectGameModeBase::StartPlay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Super::<span class="built_in">StartPlay</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">check</span>(GEngine != <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示调试消息五秒。 </span></span><br><span class="line"><span class="comment">// -1&quot;键&quot;值参数防止该消息被更新或刷新。</span></span><br><span class="line">GEngine-&gt;<span class="built_in">AddOnScreenDebugMessage</span>(<span class="number">-1</span>, <span class="number">5.0f</span>, FColor::Yellow, <span class="built_in">TEXT</span>(<span class="string">&quot;Hello World, this is FPSGameModeBase!&quot;</span>));</span><br></pre></td></tr></table></figure>

<h3 id="check"><a href="#check" class="headerlink" title="check()"></a><a target="_blank" rel="noopener" href="https://docs.unrealengine.com/5.0/zh-CN/asserts-in-unreal-engine/">check()</a></h3><p>check()为断言</p>
<p>在C和C++编程中，<code>assert</code> 可在开发期间帮助检测和诊断不正常或无效的运行时条件。</p>
<p>这些条件通常检查是否指针为非空、除数为非零、函数并非递归运行，或代码要求的其他重要假设。但每次检查会使得效率十分低下。某些情况下，<code>assert</code> 会在延迟崩溃发生之前发现导致该崩溃的bug，例如删除未来tick所需的对象，协助开发人员发现引起崩溃的根本原因。</p>
<p><code>assert</code> 的关键特性之一是不存在于发布代码中，这意味着不但不会影响发布产品的性能，也没有任何副作用。对 <code>assert</code> 最简单的理解就是：**”断言”必须一律为true，否则程序会停止运行**。</p>
<p>虚幻引擎4（UE4）提供 <code>assert</code> 等同项的三个不同族系：<code>check</code>、<code>verify</code> 和 <code>ensure</code>。各个功能的行为略有不同，但它们都是开发期间使用的诊断工具，目标大致相同。</p>
<p>Check族系最接近基础 <code>assert</code>，因为当第一个参数得出的值为false时，此族系的成员会停止执行，且默认不会在发布版本中运行。以下Check宏可用：</p>
<table>
<thead>
<tr>
<th>宏</th>
<th>参数</th>
<th>行为</th>
</tr>
</thead>
<tbody><tr>
<td><code>check</code> 或 <code>checkSlow</code></td>
<td><code>Expression</code></td>
<td>若 <code>Expression</code> 为false，停止执行</td>
</tr>
<tr>
<td><code>checkf</code> 或 <code>checkfSlow</code></td>
<td><code>Expression</code>、<code>FormattedText</code>、<code>...</code></td>
<td>若 <code>Expression</code> 为false，则停止执行并将 <code>FormattedText</code> 输出到日志</td>
</tr>
<tr>
<td><code>checkCode</code></td>
<td><code>Code</code></td>
<td>在运行一次的do-while循环结构中执行 <code>Code</code>；主要用于准备另一个Check所需的信息</td>
</tr>
<tr>
<td><code>checkNoEntry</code></td>
<td>（无）</td>
<td>若此行被hit，则停止执行，类似于 <code>check(false)</code>，但主要用于应不可到达的代码路径</td>
</tr>
<tr>
<td><code>checkNoReentry</code></td>
<td>（无）</td>
<td>若此行被hit超过一次，则停止执行</td>
</tr>
<tr>
<td><code>checkNoRecursion</code></td>
<td>（无）</td>
<td>若此行被hit超过一次而未离开作用域，则停止执行</td>
</tr>
<tr>
<td><code>unimplemented</code></td>
<td>（无）</td>
<td>若此行被hit，则停止执行，类似于 <code>check(false)</code>，但主要用于应被覆盖而不会被调用的虚拟函数</td>
</tr>
</tbody></table>
<h3 id="GEngine"><a href="#GEngine" class="headerlink" title="GEngine"></a>GEngine</h3><p>看作一个全局指针，并且是只读的。</p>
<p>其经常使用为拿到当前的World: </p>
<ul>
<li><p>使用的成员方法为:GetWorldFromContextObject</p>
</li>
<li><p>参数为World的一个Uobject</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!GEngine || !GEngine-&gt;<span class="built_in">UseSound</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">UWorld* ThisWorld = GEngine-&gt;<span class="built_in">GetWorldFromContextObject</span>(WorldContextObject, EGetWorldErrorMode::L</span><br></pre></td></tr></table></figure>

<h2 id="AddOnScreenDebugMessage"><a href="#AddOnScreenDebugMessage" class="headerlink" title="AddOnScreenDebugMessage()"></a>AddOnScreenDebugMessage()</h2><p>在屏幕上打印试错信息</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GEngine-&gt;<span class="built_in">AddOnScreenDebugMessage</span>(<span class="number">-1</span>, <span class="number">5.0f</span>, FColor::Yellow, <span class="built_in">TEXT</span>(<span class="string">&quot;Hello World, this is FPSGameMode!&quot;</span>));</span><br></pre></td></tr></table></figure>

<p><code>AddOnScreenDebugMessage(uint64 Key, float TimeToDisplay, FColor DisplayColor, const FString&amp; DebugMessage, bool bNewerOnTop, const FVector2D&amp; TextScale)</code></p>
<ul>
<li><p>第一个参数默认为-1</p>
</li>
<li><p>第二个参数是debug显示时间</p>
</li>
<li><p>第三个参数是显示颜色</p>
</li>
<li><p>第四个参数是显示信息</p>
</li>
<li><p>第五个参数是是否在上面显示更新的消息（可不填）</p>
</li>
<li><p>第六个是显示字体大小（可不填）</p>
</li>
</ul>
<h1 id="实现角色移动"><a href="#实现角色移动" class="headerlink" title="实现角色移动"></a>实现角色移动</h1><h2 id="FPSCharacter-h"><a href="#FPSCharacter-h" class="headerlink" title="FPSCharacter.h"></a>FPSCharacter.h</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CoreMinimal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GameFramework/Character.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;FPSCharacter.generated.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FPSPROJECT_API</span> AFPSCharacter : <span class="keyword">public</span> ACharacter</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 为此角色的属性设置默认值</span></span><br><span class="line">    <span class="built_in">AFPSCharacter</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// 当游戏开始或重生（Spawn）时被调用</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BeginPlay</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 每一帧都被调用</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Tick</span><span class="params">( <span class="type">float</span> DeltaTime )</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 被调用，将功能与输入绑定</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SetupPlayerInputComponent</span><span class="params">(<span class="keyword">class</span> UInputComponent* PlayerInputComponent)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理用于前后移动的输入。</span></span><br><span class="line">    <span class="built_in">UFUNCTION</span>()</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">MoveForward</span><span class="params">(<span class="type">float</span> Value)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理用于左右移动的输入。</span></span><br><span class="line">    <span class="built_in">UFUNCTION</span>()</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">MoveRight</span><span class="params">(<span class="type">float</span> Value)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>声明前进和左右移动的函数，参数为Value，来自于在编辑界面中绑定的那个值</p>
<h2 id="FPSCharacter-cpp"><a href="#FPSCharacter-cpp" class="headerlink" title="FPSCharacter.cpp"></a>FPSCharacter.cpp</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;FPSCharacter.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置默认值</span></span><br><span class="line">AFPSCharacter::<span class="built_in">AFPSCharacter</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 将此角色设置为每帧调用Tick()。  如果不需要此特性，可以关闭以提升性能。</span></span><br><span class="line">    PrimaryActorTick.bCanEverTick = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当游戏开始或重生（Spawn）时被调用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::BeginPlay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">BeginPlay</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">check</span>(GEngine != <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 显示调试消息五秒。 </span></span><br><span class="line">    <span class="comment">// -1&quot;键&quot;值参数可以防止更新或刷新消息。</span></span><br><span class="line">      GEngine-&gt;<span class="built_in">AddOnScreenDebugMessage</span>(<span class="number">-1</span>, <span class="number">5.0f</span>, FColor::Red, <span class="built_in">TEXT</span>(<span class="string">&quot;We are using FPSCharacter.&quot;</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每一帧都被调用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::Tick</span><span class="params">( <span class="type">float</span> DeltaTime )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">Tick</span>( DeltaTime );</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 被调用，将功能与输入绑定</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::SetupPlayerInputComponent</span><span class="params">(UInputComponent* PlayerInputComponent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">SetupPlayerInputComponent</span>(PlayerInputComponent);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置&quot;移动&quot;绑定。</span></span><br><span class="line">    PlayerInputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="string">&quot;MoveForward&quot;</span>, <span class="keyword">this</span>, &amp;AFPSCharacter::MoveForward);</span><br><span class="line">    PlayerInputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="string">&quot;MoveRight&quot;</span>, <span class="keyword">this</span>, &amp;AFPSCharacter::MoveRight);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::MoveForward</span><span class="params">(<span class="type">float</span> Value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 找出&quot;前进&quot;方向，并记录玩家想向该方向移动。</span></span><br><span class="line">    FVector Direction = <span class="built_in">FRotationMatrix</span>(Controller-&gt;<span class="built_in">GetControlRotation</span>()).<span class="built_in">GetScaledAxis</span>(EAxis::X);</span><br><span class="line">    <span class="built_in">AddMovementInput</span>(Direction, Value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::MoveRight</span><span class="params">(<span class="type">float</span> Value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 找出&quot;右侧&quot;方向，并记录玩家想向该方向移动。</span></span><br><span class="line">    FVector Direction = <span class="built_in">FRotationMatrix</span>(Controller-&gt;<span class="built_in">GetControlRotation</span>()).<span class="built_in">GetScaledAxis</span>(EAxis::Y);</span><br><span class="line">    <span class="built_in">AddMovementInput</span>(Direction, Value);</span><br><span class="line">&#125;<span class="built_in">mponent</span>(PlayerInputComponent);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看移动函数，功能和输入绑定那块我们一会儿回过头来再看！</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::MoveForward</span><span class="params">(<span class="type">float</span> Value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 找出&quot;前进&quot;方向，并记录玩家想向该方向移动。</span></span><br><span class="line">    FVector Direction = <span class="built_in">FRotationMatrix</span>(Controller-&gt;<span class="built_in">GetControlRotation</span>()).<span class="built_in">GetScaledAxis</span>(EAxis::X);</span><br><span class="line">    <span class="built_in">AddMovementInput</span>(Direction, Value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本函数首先通过<code>GetScaledAxis(EAxis::X)</code>获取方向，比如此处是沿X轴（在编辑器中X轴代表前方，Y轴代表右方）</p>
<p>再通过<code>Controller-&gt;GetControlRotation()</code>获取管理员的旋转方位作为<code>FRotationMatrix()</code>的值并记录在变量Direction中</p>
<p>最后<code>AddMovementInput(Direction, Value)</code>函数实现向前移动</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 被调用，将功能与输入绑定</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::SetupPlayerInputComponent</span><span class="params">(UInputComponent* PlayerInputComponent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">SetupPlayerInputComponent</span>(PlayerInputComponent);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置&quot;移动&quot;绑定。</span></span><br><span class="line">    PlayerInputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="string">&quot;MoveForward&quot;</span>, <span class="keyword">this</span>, &amp;AFPSCharacter::MoveForward);</span><br><span class="line">    PlayerInputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="string">&quot;MoveRight&quot;</span>, <span class="keyword">this</span>, &amp;AFPSCharacter::MoveRight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再回过头来看绑定操作</p>
<p>很眼熟是不是？和我之前那篇博客里面实现小球的移动的绑定方式一模一样</p>
<p>在这里简述一下</p>
<p><code>BindAxis</code>绑定轴映射，与编辑-&gt;项目设置-&gt;输入-&gt;轴映射里面的命名必须一致</p>
<p>第一个参数为事件，此事件作用于第二个参数所指定的指针，由第三个参数（一个函数）来实现这个事件！</p>
<h1 id="实现鼠标摄像机控制"><a href="#实现鼠标摄像机控制" class="headerlink" title="实现鼠标摄像机控制"></a>实现鼠标摄像机控制</h1><h2 id="FPSCharacter-cpp-1"><a href="#FPSCharacter-cpp-1" class="headerlink" title="FPSCharacter.cpp"></a>FPSCharacter.cpp</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 被调用，将功能与输入绑定</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::SetupPlayerInputComponent</span><span class="params">(UInputComponent* PlayerInputComponent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">SetupPlayerInputComponent</span>(PlayerInputComponent);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置&quot;移动&quot;绑定。</span></span><br><span class="line">    PlayerInputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="string">&quot;MoveForward&quot;</span>, <span class="keyword">this</span>, &amp;AFPSCharacter::MoveForward);</span><br><span class="line">    PlayerInputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="string">&quot;MoveRight&quot;</span>, <span class="keyword">this</span>, &amp;AFPSCharacter::MoveRight);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置&quot;观看&quot;绑定。</span></span><br><span class="line">    PlayerInputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="string">&quot;Turn&quot;</span>, <span class="keyword">this</span>, &amp;AFPSCharacter::AddControllerYawInput);</span><br><span class="line">    PlayerInputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="string">&quot;LookUp&quot;</span>, <span class="keyword">this</span>, &amp;AFPSCharacter::AddControllerPitchInput);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里只需要设置鼠标对应的轴映射即可，与上文的移动绑定并无太大区别</p>
<h1 id="实现角色跳跃"><a href="#实现角色跳跃" class="headerlink" title="实现角色跳跃"></a>实现角色跳跃</h1><h2 id="FPSCharacter-h-1"><a href="#FPSCharacter-h-1" class="headerlink" title="FPSCharacter.h"></a>FPSCharacter.h</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CoreMinimal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GameFramework/Character.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;FPSCharacter.generated.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FPSPROJECT_API</span> AFPSCharacter : <span class="keyword">public</span> ACharacter</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 为此角色的属性设置默认值</span></span><br><span class="line">    <span class="built_in">AFPSCharacter</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// 当游戏开始或重生（Spawn）时被调用</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BeginPlay</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 每一帧都被调用</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Tick</span><span class="params">( <span class="type">float</span> DeltaTime )</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 被调用，将功能与输入绑定</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SetupPlayerInputComponent</span><span class="params">(<span class="keyword">class</span> UInputComponent* PlayerInputComponent)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理用于前后移动的输入。</span></span><br><span class="line">    <span class="built_in">UFUNCTION</span>()</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">MoveForward</span><span class="params">(<span class="type">float</span> Value)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理用于左右移动的输入。</span></span><br><span class="line">    <span class="built_in">UFUNCTION</span>()</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">MoveRight</span><span class="params">(<span class="type">float</span> Value)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按下键时，设置跳跃标记。</span></span><br><span class="line">    <span class="built_in">UFUNCTION</span>()</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">StartJump</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放键时，清除跳跃标记。</span></span><br><span class="line">    <span class="built_in">UFUNCTION</span>()</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">StopJump</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在Acharacter基类接口文件中，已经有了支持跳跃的成员方法。</p>
<p>角色跳跃与<code>bPressedJump</code>变量绑定，因此我们只需要在跳跃惭怍按下时将该布尔值设置为true，在跳跃操作释放时将该布尔值设置为false</p>
<p>现在我们通过StartJump()和StopJump()两个函数来完成改变布尔值的操作</p>
<p>于是我们首先在FPSCharacter.h中声明两个函数的声明</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按下键时，设置跳跃标记。</span></span><br><span class="line"><span class="built_in">UFUNCTION</span>()</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StartJump</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放键时，清除跳跃标记。</span></span><br><span class="line"><span class="built_in">UFUNCTION</span>()</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StopJump</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>接来下，我们在FPSCharacter.cpp中将其定义</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::StartJump</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bPressedJump = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::StopJump</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bPressedJump = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，我们对其进行按键绑定</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置&quot;操作&quot;绑定。</span></span><br><span class="line">PlayerInputComponent-&gt;<span class="built_in">BindAction</span>(<span class="string">&quot;Jump&quot;</span>, IE_Pressed, <span class="keyword">this</span>, &amp;AFPSCharacter::StartJump);</span><br><span class="line">PlayerInputComponent-&gt;<span class="built_in">BindAction</span>(<span class="string">&quot;Jump&quot;</span>, IE_Released, <span class="keyword">this</span>, &amp;AFPSCharacter::StopJump);</span><br></pre></td></tr></table></figure>

<p>BindAction()函数在我的前一篇博客中也做了详细讲解</p>
<p>这里提醒一下IE_Preesed和IE_Released分别代表了按压按键和松开按键的行为</p>
<h1 id="更改摄像机视角"><a href="#更改摄像机视角" class="headerlink" title="更改摄像机视角"></a>更改摄像机视角</h1><p>在此步骤中，你将设置FPS摄像机，这样你可以调整摄像机的属性（例如位置和视野）</p>
<p>在FPSCharacter.h中添加头文件</p>
<p><code>Camera/CameraComponent.h</code>摄像机组件</p>
<p><code>Components/CapsuleComonent.h</code> 胶囊体组件</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Camera/CameraComponent.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Components/CapsuleComponent.h&quot;</span></span></span><br></pre></td></tr></table></figure>

<h2 id="FPSCharacter-h-2"><a href="#FPSCharacter-h-2" class="headerlink" title="FPSCharacter.h"></a>FPSCharacter.h</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FPS摄像机。</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(VisibleAnywhere)</span><br><span class="line">UCameraComponent* FPSCameraComponent;</span><br></pre></td></tr></table></figure>

<p>声明一个摄像机组件，并且使其可视化</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CoreMinimal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GameFramework/Character.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Camera/CameraComponent.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Components/CapsuleComponent.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;FPSCharacter.generated.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FPSPROJECT_API</span> AFPSCharacter : <span class="keyword">public</span> ACharacter</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 为此角色的属性设置默认值</span></span><br><span class="line"><span class="built_in">AFPSCharacter</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="comment">// 当游戏开始或重生（Spawn）时被调用</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BeginPlay</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:     </span><br><span class="line"><span class="comment">// 每一帧都被调用</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Tick</span><span class="params">( <span class="type">float</span> DeltaTime )</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 被调用，将功能与输入绑定</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SetupPlayerInputComponent</span><span class="params">(<span class="keyword">class</span> UInputComponent* PlayerInputComponent)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理用于前后移动的输入。</span></span><br><span class="line"><span class="built_in">UFUNCTION</span>()</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MoveForward</span><span class="params">(<span class="type">float</span> Value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理用于左右移动的输入。</span></span><br><span class="line"><span class="built_in">UFUNCTION</span>()</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MoveRight</span><span class="params">(<span class="type">float</span> Value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按下键时，设置跳跃标记。</span></span><br><span class="line"><span class="built_in">UFUNCTION</span>()</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StartJump</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放键时，清除跳跃标记。</span></span><br><span class="line"><span class="built_in">UFUNCTION</span>()</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StopJump</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// FPS摄像机</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(VisibleAnywhere)</span><br><span class="line">UCameraComponent* FPSCameraComponent;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="FPSCharacter-cpp-2"><a href="#FPSCharacter-cpp-2" class="headerlink" title="FPSCharacter.cpp"></a>FPSCharacter.cpp</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建第一人称摄像机组件。</span></span><br><span class="line">FPSCameraComponent = <span class="built_in">CreateDefaultSubobject</span>&lt;UCameraComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;FirstPersonCamera&quot;</span>));</span><br><span class="line"><span class="built_in">check</span>(FPSCameraComponent != <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将摄像机组件附加到我们的胶囊体组件。</span></span><br><span class="line">FPSCameraComponent-&gt;<span class="built_in">SetupAttachment</span>(<span class="built_in">CastChecked</span>&lt;USceneComponent, UCapsuleComponent&gt;(<span class="built_in">GetCapsuleComponent</span>()));</span><br></pre></td></tr></table></figure>

<p>创建FPSCameraComponent组件</p>
<p>加上一个断言，保证创建成功</p>
<p>然后将摄像机组件附加到胶囊体，但这个时候会出现类型不匹配的问题</p>
<p>SetupAttachment()函数里面的参数必须是一个场景类型的组件，而此时我们想要将摄像机组件附加到一个胶囊体类型的组件上面。</p>
<p>所以我们需要将胶囊体类型组件进行强制转换。</p>
<p>有两种方式</p>
<p>方式一：</p>
<p>直接进行强制转换</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FPSCameraComponent-&gt;<span class="built_in">SetupAttachment</span>((USceneComponent *)<span class="built_in">GetCapsuleComponent</span>());</span><br></pre></td></tr></table></figure>

<p>方式二：</p>
<p>通过<code>CastCheck&lt;目标类型,原类型&gt;(组件)</code>进行强制转换</p>
<p>通过这个函数有什么好处呢？就是强制转换成功就照常进行，但如果强制转换失败，则会抛出异常</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FPSCameraComponent-&gt;<span class="built_in">SetupAttachment</span>(<span class="built_in">CastChecked</span>&lt;USceneComponent, UCapsuleComponent&gt;(<span class="built_in">GetCapsuleComponent</span>()));</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将摄像机置于略高于眼睛上方的位置。</span></span><br><span class="line">FPSCameraComponent-&gt;<span class="built_in">SetRelativeLocation</span>(<span class="built_in">FVector</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">50.0f</span> + BaseEyeHeight));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启用Pawn控制摄像机旋转。</span></span><br><span class="line">FPSCameraComponent-&gt;bUsePawnControlRotation = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<p><code>SetRelativeLocation</code> 用于设置组件的默认值。不过，上一个值仍然会在设置在编辑器中。为纠正这点，请打开蓝图编辑器。点击 <code>FPSCameraComponent</code>，然后在 <strong>细节</strong> 面板中找到 <strong>变换 -&gt; 位置（Transform -&gt; Location）</strong> 数值。点击这个值旁边的 <strong>重置为默认（Reset to Default）</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;FPSCharacter.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置默认值</span></span><br><span class="line">AFPSCharacter::<span class="built_in">AFPSCharacter</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 将此角色设置为每帧调用Tick()。  如果不需要此特性，可以关闭以提升性能。</span></span><br><span class="line">    PrimaryActorTick.bCanEverTick = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建第一人称摄像机组件。</span></span><br><span class="line">    FPSCameraComponent = <span class="built_in">CreateDefaultSubobject</span>&lt;UCameraComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;FirstPersonCamera&quot;</span>));</span><br><span class="line">    <span class="built_in">check</span>(FPSCameraComponent != <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将摄像机组件附加到我们的胶囊体组件。</span></span><br><span class="line">    FPSCameraComponent-&gt;<span class="built_in">SetupAttachment</span>(<span class="built_in">CastChecked</span>&lt;USceneComponent, UCapsuleComponent&gt;(<span class="built_in">GetCapsuleComponent</span>()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将摄像机置于略高于眼睛上方的位置。</span></span><br><span class="line">    FPSCameraComponent-&gt;<span class="built_in">SetRelativeLocation</span>(<span class="built_in">FVector</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">50.0f</span> + BaseEyeHeight));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启用Pawn控制摄像机旋转。</span></span><br><span class="line">    FPSCameraComponent-&gt;bUsePawnControlRotation = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当游戏开始或重生（Spawn）时被调用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::BeginPlay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">BeginPlay</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">check</span>(GEngine != <span class="literal">nullptr</span>)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 显示调试消息五秒。 </span></span><br><span class="line">     <span class="comment">// -1&quot;键&quot;值（第一个参数）表示我们从不需要更新或刷新此消息。</span></span><br><span class="line">      GEngine-&gt;<span class="built_in">AddOnScreenDebugMessage</span>(<span class="number">-1</span>, <span class="number">5.0f</span>, FColor::Red, <span class="built_in">TEXT</span>(<span class="string">&quot;We are using FPSCharacter.&quot;</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每一帧都被调用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::Tick</span><span class="params">( <span class="type">float</span> DeltaTime )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">Tick</span>( DeltaTime );</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 被调用，将功能与输入绑定</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::SetupPlayerInputComponent</span><span class="params">(UInputComponent* PlayerInputComponent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">SetupPlayerInputComponent</span>(PlayerInputComponent);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置&quot;移动&quot;绑定。</span></span><br><span class="line">    PlayerInputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="string">&quot;MoveForward&quot;</span>, <span class="keyword">this</span>, &amp;AFPSCharacter::MoveForward);</span><br><span class="line">    PlayerInputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="string">&quot;MoveRight&quot;</span>, <span class="keyword">this</span>, &amp;AFPSCharacter::MoveRight);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置&quot;观看&quot;绑定。</span></span><br><span class="line">    PlayerInputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="string">&quot;Turn&quot;</span>, <span class="keyword">this</span>, &amp;AFPSCharacter::AddControllerYawInput);</span><br><span class="line">    PlayerInputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="string">&quot;LookUp&quot;</span>, <span class="keyword">this</span>, &amp;AFPSCharacter::AddControllerPitchInput);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置&quot;操作&quot;绑定。</span></span><br><span class="line">    PlayerInputComponent-&gt;<span class="built_in">BindAction</span>(<span class="string">&quot;Jump&quot;</span>, IE_Pressed, <span class="keyword">this</span>, &amp;AFPSCharacter::StartJump);</span><br><span class="line">    PlayerInputComponent-&gt;<span class="built_in">BindAction</span>(<span class="string">&quot;Jump&quot;</span>, IE_Released, <span class="keyword">this</span>, &amp;AFPSCharacter::StopJump);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::MoveForward</span><span class="params">(<span class="type">float</span> Value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 找出&quot;前进&quot;方向，并记录玩家想向该方向移动。</span></span><br><span class="line">    FVector Direction = <span class="built_in">FRotationMatrix</span>(Controller-&gt;<span class="built_in">GetControlRotation</span>()).<span class="built_in">GetScaledAxis</span>(EAxis::X);</span><br><span class="line">    <span class="built_in">AddMovementInput</span>(Direction, Value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::MoveRight</span><span class="params">(<span class="type">float</span> Value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 找出&quot;右侧&quot;方向，并记录玩家想向该方向移动。</span></span><br><span class="line">    FVector Direction = <span class="built_in">FRotationMatrix</span>(Controller-&gt;<span class="built_in">GetControlRotation</span>()).<span class="built_in">GetScaledAxis</span>(EAxis::Y);</span><br><span class="line">    <span class="built_in">AddMovementInput</span>(Direction, Value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::StartJump</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bPressedJump = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::StopJump</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bPressedJump = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="将第一人称网格体添加到角色中"><a href="#将第一人称网格体添加到角色中" class="headerlink" title="将第一人称网格体添加到角色中"></a>将第一人称网格体添加到角色中</h1><h2 id="FPSCharacter-h-3"><a href="#FPSCharacter-h-3" class="headerlink" title="FPSCharacter.h"></a>FPSCharacter.h</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一人称网格体（手臂），仅对所属玩家可见。</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(VisibleDefaultsOnly, Category = Mesh)</span><br><span class="line">USkeletalMeshComponent* FPSMesh;</span><br></pre></td></tr></table></figure>

<p>在头文件中声明第一人称网格体，将其命名为FPSMesh</p>
<h2 id="FPSCharacter-cpp-3"><a href="#FPSCharacter-cpp-3" class="headerlink" title="FPSCharacter.cpp"></a>FPSCharacter.cpp</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为所属玩家创建第一人称网格体组件。</span></span><br><span class="line">FPSMesh = <span class="built_in">CreateDefaultSubobject</span>&lt;USkeletalMeshComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;FirstPersonMesh&quot;</span>));</span><br><span class="line"><span class="built_in">check</span>(FPSMesh != <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 仅所属玩家可以看见此网格体。</span></span><br><span class="line">FPSMesh-&gt;<span class="built_in">SetOnlyOwnerSee</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 FPS 网格体附加到 FPS 摄像机。</span></span><br><span class="line">FPSMesh-&gt;<span class="built_in">SetupAttachment</span>(FPSCameraComponent);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 禁用某些环境阴影以便实现只有单个网格体的感觉。</span></span><br><span class="line">FPSMesh-&gt;bCastDynamicShadow = <span class="literal">false</span>;</span><br><span class="line">FPSMesh-&gt;CastShadow = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<p>定义第一人称网格体</p>
<p>做一个断言</p>
<p>将第一人称网格体设定为仅所属玩家可见</p>
<p>将第一人称网格体附加到摄像机上</p>
<p>将第一人称网格体（手臂）的阴影禁用掉，这样就不会在地面上看到一个人有四条手臂的情况了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将第一人称网格体设置为仅所属玩家可见</span></span><br><span class="line"><span class="built_in">GetMesh</span>()-&gt;<span class="built_in">SetOwnerNoSee</span>(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<p>将手臂设置为仅自己可见，免得到时候其他玩家看到你一个人前面悬浮着一双手！</p>
<p>这一处官网的解释是：所属玩家看不到常规（第三人称）全身网格体。</p>
<p>我觉得是有问题的，像我这样理解的话更清楚直白</p>
<h1 id="将发射物添加到游戏"><a href="#将发射物添加到游戏" class="headerlink" title="将发射物添加到游戏"></a>将发射物添加到游戏</h1><h2 id="FPSProjectile-h"><a href="#FPSProjectile-h" class="headerlink" title="FPSProjectile.h"></a>FPSProjectile.h</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Components/SphereComponent.h&quot;</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 球体碰撞组件。</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(VisibleDefaultsOnly, Category = Projectile)</span><br><span class="line">USphereComponent* CollisionComponent;</span><br></pre></td></tr></table></figure>

<p>这就很常规，首先引入头文件，然后声明球体碰撞逐渐，并将其命名为CollisionComponent</p>
<h2 id="FPSProjectile-cpp"><a href="#FPSProjectile-cpp" class="headerlink" title="FPSProjectile.cpp"></a>FPSProjectile.cpp</h2><p>在构造函数中添加</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!RootComponent)</span><br><span class="line">&#123;</span><br><span class="line">RootComponent = <span class="built_in">CreateDefaultSubobject</span>&lt;USceneComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;ProjectileSceneComponent&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!CollisionComponent)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 用球体进行简单的碰撞展示。</span></span><br><span class="line">CollisionComponent = <span class="built_in">CreateDefaultSubobject</span>&lt;USphereComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;SphereComponent&quot;</span>));</span><br><span class="line"><span class="comment">// 设置球体的碰撞半径。</span></span><br><span class="line">CollisionComponent-&gt;<span class="built_in">InitSphereRadius</span>(<span class="number">15.0f</span>);</span><br><span class="line"><span class="comment">// 将根组件设置为碰撞组件。</span></span><br><span class="line">RootComponent = CollisionComponent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把 <code>CollisionComponent</code> 设为 <code>RootComponent</code>，接下来的操作就都是对CollisionComponent直接进行的了。</p>
<p>每一次都会生成一个新的CollisionComponent，然后根组件也随之更新到新的CollisionComponent上，这样我们每次进行的操作都是对新的CollisionComponent进行的。</p>
<h1 id="添加发射物移动组件"><a href="#添加发射物移动组件" class="headerlink" title="添加发射物移动组件"></a>添加发射物移动组件</h1><h2 id="FPSProjectile-h-1"><a href="#FPSProjectile-h-1" class="headerlink" title="FPSProjectile.h"></a>FPSProjectile.h</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GameFramework/ProjectileMovementComponent.h&quot;</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发射物移动组件。</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(VisibleAnywhere, Category = Movement)</span><br><span class="line">UProjectileMovementComponent* ProjectileMovementComponent;</span><br></pre></td></tr></table></figure>

<p>引入头文件，声明发射物移动组件并命名为ProjectileMovementCompone</p>
<h2 id="FPSProjectile-cpp-1"><a href="#FPSProjectile-cpp-1" class="headerlink" title="FPSProjectile.cpp"></a>FPSProjectile.cpp</h2><p>在FPSProjectile.cpp的构造函数中添加</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!ProjectileMovementComponent)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 使用此组件驱动发射物的移动。</span></span><br><span class="line">    ProjectileMovementComponent = <span class="built_in">CreateDefaultSubobject</span>&lt;UProjectileMovementComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;ProjectileMovementComponent&quot;</span>));</span><br><span class="line">    ProjectileMovementComponent-&gt;<span class="built_in">SetUpdatedComponent</span>(CollisionComponent);</span><br><span class="line">    ProjectileMovementComponent-&gt;InitialSpeed = <span class="number">3000.0f</span>;</span><br><span class="line">    ProjectileMovementComponent-&gt;MaxSpeed = <span class="number">3000.0f</span>;</span><br><span class="line">    ProjectileMovementComponent-&gt;bRotationFollowsVelocity = <span class="literal">true</span>;</span><br><span class="line">    ProjectileMovementComponent-&gt;bShouldBounce = <span class="literal">true</span>;</span><br><span class="line">    ProjectileMovementComponent-&gt;Bounciness = <span class="number">0.3f</span>;</span><br><span class="line">    ProjectileMovementComponent-&gt;ProjectileGravityScale = <span class="number">0.0f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>定义移动组件</p>
</li>
<li><p>将移动组件进行更新</p>
</li>
<li><p>InitialSpeed初始速度设置为3000.0f</p>
</li>
<li><p>MaxSpeed最大速度设置为3000.0f</p>
</li>
<li><p>bRotationFollowsVelocity是否沿某方向进行高速旋转</p>
</li>
<li><p>bShouldBounce能否被反弹</p>
</li>
<li><p>Bounciness受到阻碍之后的反弹力是多少</p>
</li>
<li><p>ProjectileGravityScale受到的重力大小（弹道抛物线）</p>
</li>
</ul>
<h1 id="设置发射物的方向"><a href="#设置发射物的方向" class="headerlink" title="设置发射物的方向"></a>设置发射物的方向</h1><p>在官网上此标题为“设置发射物的初始速度”</p>
<p>但是我觉得不妥，因为在上一小节中，我们已经在发射物的移动组件内设置了发射物的初始速度，在这一小节中，我们只需要定义一个函数，此函数为发射物提供一个方向，然后再根据已经初始化的速度，进行发射即可</p>
<h2 id="FPSProjectile-h-2"><a href="#FPSProjectile-h-2" class="headerlink" title="FPSProjectile.h"></a>FPSProjectile.h</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化射击方向上发射物速度的函数。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FireInDirection</span><span class="params">(<span class="type">const</span> FVector&amp; ShootDirection)</span></span>;</span><br></pre></td></tr></table></figure>

<p>声明发射物方向函数，参数为设计方向（记住这里是引用传递）</p>
<h2 id="FPSProjectile-cpp-2"><a href="#FPSProjectile-cpp-2" class="headerlink" title="FPSProjectile.cpp"></a>FPSProjectile.cpp</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化射击方向上发射物速度的函数。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSProjectile::FireInDirection</span><span class="params">(<span class="type">const</span> FVector&amp; ShootDirection)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ProjectileMovementComponent-&gt;Velocity = ShootDirection * ProjectileMovementComponent-&gt;InitialSpeed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Velocity的中文意思是沿某一方向的速度</p>
<p>所以这个值是由两个参数共同决定的-&gt;方向和速度</p>
<p>Velocity更像是一个向量，可以将其理解为一个合成力，它的两个子力为方向和速度</p>
<p>于是我们直接调用射击方向*已在移动函数中设置好的速度</p>
<h1 id="绑定发射输入操作"><a href="#绑定发射输入操作" class="headerlink" title="绑定发射输入操作"></a>绑定发射输入操作</h1><h2 id="FPSCharacter-h-4"><a href="#FPSCharacter-h-4" class="headerlink" title="FPSCharacter.h"></a>FPSCharacter.h</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理发射物射击的函数。</span></span><br><span class="line"><span class="built_in">UFUNCTION</span>()</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Fire</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>声明函数，没啥好多说的。</p>
<h2 id="FPSCharacter-cpp-4"><a href="#FPSCharacter-cpp-4" class="headerlink" title="FPSCharacter.cpp"></a>FPSCharacter.cpp</h2><p>将其下内容添加到<code>SetupPlayerInputComponent</code>中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PlayerInputComponent-&gt;<span class="built_in">BindAction</span>(<span class="string">&quot;Fire&quot;</span>, IE_Pressed, <span class="keyword">this</span>, &amp;AFPSCharacter::Fire);</span><br></pre></td></tr></table></figure>

<p>绑定操作按键，也没啥好多说的</p>
<p>先将fire()的定义添加到cpp文件中，后面咱再详细定义具体实现</p>
<h1 id="定义发射物的生成位置"><a href="#定义发射物的生成位置" class="headerlink" title="定义发射物的生成位置"></a>定义发射物的生成位置</h1><ol>
<li><p>生成 <code>FPSProjectile</code> actor并实现 <code>OnFire</code> 函数时需要考虑两点，即：</p>
<ul>
<li><p>发射物的生成位置。</p>
</li>
<li><p>发射物对应的类（让 <code>FPSCharacter</code> 及其派生蓝图知道要生成哪种发射物）。</p>
</li>
</ul>
</li>
</ol>
<p>你将使用一个摄像机空间中的偏移向量来确定发射物的生成位置。设置该参数为可编辑参数，这样你就可以在 <code>BP_FPSCharacter</code> 蓝图中对其进行设置和调整。最终，你可以基于这些数据计算发射物的初始位置。</p>
<h2 id="FPSCharacter-h-5"><a href="#FPSCharacter-h-5" class="headerlink" title="FPSCharacter.h"></a>FPSCharacter.h</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 枪口相对于摄像机位置的偏移。</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadWrite, Category = Gameplay)</span><br><span class="line">FVector MuzzleOffset;</span><br></pre></td></tr></table></figure>

<p>MuzzleOffset是一个跟随着摄像机的中间量</p>
<p>在后面我们会根据这个中间量定义枪口的世界位置</p>
<p>将以下代码添加到protected:下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 要生成的发射物类。</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditDefaultsOnly, Category = Projectile)</span><br><span class="line">TSubclassOf&lt;<span class="keyword">class</span> <span class="title class_">AFPSProjectile</span>&gt; ProjectileClass;</span><br></pre></td></tr></table></figure>

<p><code>EditDefaultsOnly</code> 意味着你只能将发射物类设置为蓝图上的默认值，而不是每个蓝图实例上的默认值。</p>
<p>在蓝图或C++层面调用SpawnActor创建一个actor对象，或者调用SpawnActorDeferred</p>
<p>延迟创建一个actor对象时，都需要一个class类型的参数。</p>
<p>如果在C++层面，对象类型是我们自己在蓝图里做的蓝图类</p>
<p>那么C++层面需要得到蓝图类型</p>
<p>做法如下：</p>
<p>建立一个成员变量并暴露给蓝图</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UPROPERTY</span>(EditDefaultsOnly, Category = XXX)</span><br><span class="line"></span><br><span class="line">TSubclassOf&lt;<span class="keyword">class</span> 蓝图类的C++父类&gt; 变量名称</span><br></pre></td></tr></table></figure>

<p>接下来就可以再蓝图里面给这个变量设置蓝图类型</p>
<p>最后调用SpawnActor或SpawnActorDeferred将上面定义的变量传入给class参数即可生成对象</p>
<p>简单来说，就是需要依托某个类（父类）生成一个Actor对象时，就可以使用TSubclassOf</p>
<h1 id="实现射击"><a href="#实现射击" class="headerlink" title="实现射击"></a>实现射击</h1><h2 id="FPSCharacter-h-6"><a href="#FPSCharacter-h-6" class="headerlink" title="FPSCharacter.h"></a>FPSCharacter.h</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;FPSProjectile.h&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>引入发射物的头文件</p>
<h2 id="FPSCharacter-cpp-5"><a href="#FPSCharacter-cpp-5" class="headerlink" title="FPSCharacter.cpp"></a>FPSCharacter.cpp</h2><p>用以下代码段定义fire()函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ProjectileClass)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 获取摄像机变换。</span></span><br><span class="line">FVector CameraLocation;</span><br><span class="line">FRotator CameraRotation;</span><br><span class="line"><span class="built_in">GetActorEyesViewPoint</span>(CameraLocation, CameraRotation);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置MuzzleOffset，在略靠近摄像机前生成发射物。</span></span><br><span class="line">MuzzleOffset.<span class="built_in">Set</span>(<span class="number">100.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将MuzzleOffset从摄像机空间变换到世界空间。</span></span><br><span class="line">FVector MuzzleLocation = CameraLocation + <span class="built_in">FTransform</span>(CameraRotation).<span class="built_in">TransformVector</span>(MuzzleOffset);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使目标方向略向上倾斜。</span></span><br><span class="line">FRotator MuzzleRotation = CameraRotation;</span><br><span class="line">MuzzleRotation.Pitch += <span class="number">10.0f</span>;</span><br><span class="line"></span><br><span class="line">UWorld* World = <span class="built_in">GetWorld</span>();</span><br><span class="line"><span class="keyword">if</span> (World)</span><br><span class="line">&#123;</span><br><span class="line">    FActorSpawnParameters SpawnParams;</span><br><span class="line">    SpawnParams.Owner = <span class="keyword">this</span>;</span><br><span class="line">    SpawnParams.Instigator = <span class="built_in">GetInstigator</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在枪口位置生成发射物。</span></span><br><span class="line">    AFPSProjectile* Projectile = World-&gt;<span class="built_in">SpawnActor</span>&lt;AFPSProjectile&gt;(ProjectileClass, MuzzleLocation, MuzzleRotation, SpawnParams);</span><br><span class="line">    <span class="keyword">if</span> (Projectile)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 设置发射物的初始轨迹。</span></span><br><span class="line">        FVector LaunchDirection = MuzzleRotation.<span class="built_in">Vector</span>();</span><br><span class="line">        Projectile-&gt;<span class="built_in">FireInDirection</span>(LaunchDirection);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="将枪口位置转换为世界坐标中的位置"><a href="#将枪口位置转换为世界坐标中的位置" class="headerlink" title="将枪口位置转换为世界坐标中的位置"></a>将枪口位置转换为世界坐标中的位置</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置MuzzleOffset，在略靠近摄像机前生成发射物。</span></span><br><span class="line">MuzzleOffset.<span class="built_in">Set</span>(<span class="number">100.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将MuzzleOffset从摄像机空间变换到世界空间。</span></span><br><span class="line">FVector MuzzleLocation = CameraLocation + <span class="built_in">FTransform</span>(CameraRotation).<span class="built_in">TransformVector</span>(MuzzleOffset);</span><br></pre></td></tr></table></figure>

<p>先设置枪口的位置，然后根据枪口位置和相机位置转换为世界坐标中的位置</p>
<p><code>CameraLocation + FTransform(CameraRotation).TransformVector(MuzzleOffset);</code></p>
<h3 id="模拟后坐力"><a href="#模拟后坐力" class="headerlink" title="模拟后坐力"></a>模拟后坐力</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使目标方向略向上倾斜。</span></span><br><span class="line">FRotator MuzzleRotation = CameraRotation;</span><br><span class="line">MuzzleRotation.Pitch += <span class="number">10.0f</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">UWorld* World = <span class="built_in">GetWorld</span>();</span><br><span class="line"><span class="keyword">if</span> (World)</span><br><span class="line"> &#123;</span><br><span class="line">FActorSpawnParameters SpawnParams;</span><br><span class="line">SpawnParams.Owner = <span class="keyword">this</span>;</span><br><span class="line">SpawnParams.Instigator = <span class="built_in">GetInstigator</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在枪口位置生成发射物。</span></span><br><span class="line">AFPSProjectile* Projectile = World-&gt;<span class="built_in">SpawnActor</span>&lt;AFPSProjectile&gt;(ProjectileClass, MuzzleLocation, MuzzleRotation, SpawnParams);</span><br><span class="line"><span class="keyword">if</span> (Projectile)&#123;<span class="comment">//如果生成成功</span></span><br><span class="line">     <span class="comment">// 设置发射物的初始轨迹。</span></span><br><span class="line">     FVector LaunchDirection = MuzzleRotation.<span class="built_in">Vector</span>();</span><br><span class="line">     Projectile-&gt;<span class="built_in">FireInDirection</span>(LaunchDirection);</span><br><span class="line">               &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="FActorSpwanParamenters"><a href="#FActorSpwanParamenters" class="headerlink" title="FActorSpwanParamenters"></a>FActorSpwanParamenters</h3><p>是一个传递给SpawnActor函数的可选参数的结构体</p>
<p>它有很多的对象</p>
<p>Name：衍生Actor的名称（不填写的话就会有一个默认值）</p>
<p>Templat：将用模板值对新生成的Actor进行初始化</p>
<p>Owner：衍生的Actor</p>
<p>Instigator：敌方</p>
<p>定义一个FPSProjectile类的对象（发射物），这个对象要在世界坐标内，所以就需要在世界坐标内生成发射物，所以此时我们需要调用world中的SpawnActor&lt;&gt;()函数</p>
<h3 id="SpawnActor"><a href="#SpawnActor" class="headerlink" title="SpawnActor"></a>SpawnActor</h3><p>SpawnActor&lt;发射物的构造函数&gt;(要生成的发射物类，发射物位置，发射物角度，FActorSpawnParameters的对象)</p>
<p>用来生成发射物</p>
<p>最后是设置发射物的初始轨迹</p>
<p>以枪口的角度定义一个FVector</p>
<p>再将该FVector作为参数填入到FireInDirection()中（此函数再前文已经讲解过）</p>
<h1 id="添加发射物网格体"><a href="#添加发射物网格体" class="headerlink" title="添加发射物网格体"></a>添加发射物网格体</h1><h2 id="FPSProjectile-h-3"><a href="#FPSProjectile-h-3" class="headerlink" title="FPSProjectile.h"></a>FPSProjectile.h</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发射物网格体</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(VisibleDefaultsOnly, Category = Projectile)</span><br><span class="line">UStaticMeshComponent* ProjectileMeshComponent;</span><br></pre></td></tr></table></figure>

<h2 id="FPSProjectile-cpp-3"><a href="#FPSProjectile-cpp-3" class="headerlink" title="FPSProjectile.cpp"></a>FPSProjectile.cpp</h2><p>构造函数中添加</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!ProjectileMeshComponent)</span><br><span class="line">&#123;</span><br><span class="line">    ProjectileMeshComponent = <span class="built_in">CreateDefaultSubobject</span>&lt;UStaticMeshComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;ProjectileMeshComponent&quot;</span>));</span><br><span class="line">    <span class="type">static</span> ConstructorHelpers::FObjectFinder&lt;UStaticMesh&gt;<span class="built_in">Mesh</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;&#x27;/Game/Sphere.Sphere&#x27;&quot;</span>));</span><br><span class="line">    <span class="keyword">if</span>(Mesh.<span class="built_in">Succeeded</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        ProjectileMeshComponent-&gt;<span class="built_in">SetStaticMesh</span>(Mesh.Object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="添加发射物材质"><a href="#添加发射物材质" class="headerlink" title="添加发射物材质"></a>添加发射物材质</h1><h2 id="FPSProjectile-h-4"><a href="#FPSProjectile-h-4" class="headerlink" title="FPSProjectile.h"></a>FPSProjectile.h</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发射物材质</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(VisibleDefaultsOnly, Category = Movement)</span><br><span class="line">UMaterialInstanceDynamic* ProjectileMaterialInstance;</span><br></pre></td></tr></table></figure>

<h2 id="FPSProjectile-cpp-4"><a href="#FPSProjectile-cpp-4" class="headerlink" title="FPSProjectile.cpp"></a>FPSProjectile.cpp</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> ConstructorHelpers::FObjectFinder&lt;UMaterial&gt;<span class="built_in">Material</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;&#x27;/Game/SphereMaterial.SphereMaterial&#x27;&quot;</span>));</span><br><span class="line"><span class="keyword">if</span> (Material.<span class="built_in">Succeeded</span>())</span><br><span class="line">&#123;</span><br><span class="line">    ProjectileMaterialInstance = UMaterialInstanceDynamic::<span class="built_in">Create</span>(Material.Object, ProjectileMeshComponent);</span><br><span class="line">&#125;</span><br><span class="line">ProjectileMeshComponent-&gt;<span class="built_in">SetMaterial</span>(<span class="number">0</span>, ProjectileMaterialInstance);</span><br><span class="line">ProjectileMeshComponent-&gt;<span class="built_in">SetRelativeScale3D</span>(<span class="built_in">FVector</span>(<span class="number">0.09f</span>, <span class="number">0.09f</span>, <span class="number">0.09f</span>));</span><br><span class="line">ProjectileMeshComponent-&gt;<span class="built_in">SetupAttachment</span>(RootComponent);</span><br></pre></td></tr></table></figure>

<p>SetMaterial()源文件</p>
<ul>
<li><p>第一个参数：必须大于等于0的，具体啥玩意，确实还没搞懂，等我以后搞懂了，再做补充说明</p>
</li>
<li><p>第二个参数：材质名称</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">SetMaterial</span>(int32 ElementIndex, UMaterialInterface* Material)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">check</span>(ElementIndex &gt;= <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (ElementIndex &gt;= BaseMaterials.<span class="built_in">Num</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        BaseMaterials.<span class="built_in">SetNum</span>(ElementIndex + <span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    BaseMaterials[ElementIndex] = Material;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他的就都没什么好讲解的了，如果看不懂的话，可以看看我之前的博客内容</p>
<h1 id="限制发射物的生命周期"><a href="#限制发射物的生命周期" class="headerlink" title="限制发射物的生命周期"></a>限制发射物的生命周期</h1><h2 id="FPSProjectile-cpp-5"><a href="#FPSProjectile-cpp-5" class="headerlink" title="FPSProjectile.cpp"></a>FPSProjectile.cpp</h2><p>添加到构造函数中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3 秒后删除发射物。</span></span><br><span class="line">InitialLifeSpan = <span class="number">3.0f</span>;</span><br></pre></td></tr></table></figure>

<p>这玩意叫初始化声明周期</p>
<h1 id="编辑发射物的碰撞设置"><a href="#编辑发射物的碰撞设置" class="headerlink" title="编辑发射物的碰撞设置"></a>编辑发射物的碰撞设置</h1><p>虚幻引擎自带了数个预设碰撞通道；不过，引擎也支持游戏项目使用自定义通道。</p>
<ol>
<li><p>要创建自定义碰撞通道，打开项目设置（Project Settings），在引擎（Engine） - 碰撞（Collision）中，展开预设（Preset）。</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/3/SettingCollisionChannels.jpg" alt="SettingCollisionChannels.png"></p>
</li>
<li><p>在对象通道（Object Channels）中，选择 <strong>新建对象通道…（New Object Channel…）</strong>，创建新碰撞通道。将新碰撞通道命名为”Projectile”，确保将默认响应（Default Response）设置为阻止（Block），然后点击接受（Accept）。</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/3/NewChannel.jpg" alt="NewChannel.png"></p>
</li>
<li><p>在预设（Preset）中选择 <strong>新建…（New…）</strong>，将新配置文件命名为”Projectile”。参考以下图片来设置你的碰撞预设。然后点击”接受（Accept）”。</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/3/NewProfile.jpg" alt="NewProfile.png"></p>
</li>
</ol>
<p>此碰撞配置文件将发射物设定为将被静态Actor、动态Actor、模拟物理Actor、载具和可破坏Actor阻挡。此外，此碰撞配置文件设定发射物与Pawn重叠。</p>
<h1 id="使用新的发射物的碰撞设置"><a href="#使用新的发射物的碰撞设置" class="headerlink" title="使用新的发射物的碰撞设置"></a>使用新的发射物的碰撞设置</h1><h2 id="FPSProjectile-cpp-6"><a href="#FPSProjectile-cpp-6" class="headerlink" title="FPSProjectile.cpp"></a>FPSProjectile.cpp</h2><p>在FPSProjectile构造函数中，将以下代码行添加到CreateDefaultSubobject下方</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将球体的碰撞配置文件名称设置为&quot;Projectile&quot;。</span></span><br><span class="line">CollisionComponent-&gt;BodyInstance.<span class="built_in">SetCollisionProfileName</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;Projectile&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>这是在修改碰撞组件的形体实例的碰撞配置文件</p>
<h1 id="使发射物对碰撞做出响应"><a href="#使发射物对碰撞做出响应" class="headerlink" title="使发射物对碰撞做出响应"></a>使发射物对碰撞做出响应</h1><h2 id="FPSProjectile-h-5"><a href="#FPSProjectile-h-5" class="headerlink" title="FPSProjectile.h"></a>FPSProjectile.h</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当发射物击中物体时会调用的函数。</span></span><br><span class="line"><span class="built_in">UFUNCTION</span>()</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OnHit</span><span class="params">(UPrimitiveComponent* HitComponent, AActor* OtherActor, UPrimitiveComponent* OtherComponent, FVector NormalImpulse, <span class="type">const</span> FHitResult&amp; Hit)</span></span>;</span><br></pre></td></tr></table></figure>

<p>声明击中物体时的函数</p>
<h2 id="FPSProjectile-cpp-7"><a href="#FPSProjectile-cpp-7" class="headerlink" title="FPSProjectile.cpp"></a>FPSProjectile.cpp</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当发射物击中物体时会调用的函数。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSProjectile::OnHit</span><span class="params">(UPrimitiveComponent* HitComponent, AActor* OtherActor, UPrimitiveComponent* OtherComponent, FVector NormalImpulse, <span class="type">const</span> FHitResult&amp; Hit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (OtherActor != <span class="keyword">this</span> &amp;&amp; OtherComponent-&gt;<span class="built_in">IsSimulatingPhysics</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        OtherComponent-&gt;<span class="built_in">AddImpulseAtLocation</span>(ProjectileMovementComponent-&gt;Velocity * <span class="number">100.0f</span>, Hit.ImpactPoint);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Destroy</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果另一个actor不是本actor，而且另一个actor的组件上使模拟物理状态的</p>
<p>那么另一个组件就调用AddImpulseAtLocation()函数来模拟被击中的反馈</p>
<p><code>AddImpulseAtLocation(ProjectileMovementComponent-&gt;Velocity * 100.0f, Hit.ImpactPoint);</code></p>
<p>第一个参数为冲击力，第二个参数为冲击点。</p>
<p>在 <code>FPSProjectile</code> 构造函数中，将以下代码行添加到 <code>BodyInstance.SetCollisionProfileName</code> 下方：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 组件击中某物时调用的事件。</span></span><br><span class="line">CollisionComponent-&gt;OnComponentHit.<span class="built_in">AddDynamic</span>(<span class="keyword">this</span>, &amp;AFPSProjectile::OnHit);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>OnComponentHit：当组件（被）碰撞时调用的函数</p>
</li>
<li><p>AddDynamic( UserObject, FuncName )：给某物添加一个力</p>
<ul>
<li><p>第一个参数：调用的对象</p>
</li>
<li><p>第二个参数：调用的函数</p>
</li>
</ul>
</li>
</ul>
<h1 id="将十字准星导入到视口"><a href="#将十字准星导入到视口" class="headerlink" title="将十字准星导入到视口"></a>将十字准星导入到视口</h1><h2 id="FPSHUD-h"><a href="#FPSHUD-h" class="headerlink" title="FPSHUD.h"></a>FPSHUD.h</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line">   <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CoreMinimal.h&quot;</span></span></span><br><span class="line">   <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GameFramework/HUD.h&quot;</span></span></span><br><span class="line">   <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Engine/Canvas.h&quot;</span></span></span><br><span class="line">   <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;FPSHUD.generated.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="built_in">UCLASS</span>()</span><br><span class="line">   <span class="keyword">class</span> <span class="title class_">FPSPROJECT_API</span> AFPSHUD : <span class="keyword">public</span> AHUD</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">       <span class="comment">// HUD绘制的主要调用。</span></span><br><span class="line">       <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">DrawHUD</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">protected</span>:</span><br><span class="line">       <span class="comment">// 将被绘制在屏幕中心。</span></span><br><span class="line">       <span class="built_in">UPROPERTY</span>(EditDefaultsOnly)</span><br><span class="line">       UTexture2D* CrosshairTexture;</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure>

<h2 id="FPSHUD-cpp"><a href="#FPSHUD-cpp" class="headerlink" title="FPSHUD.cpp"></a>FPSHUD.cpp</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;FPSHUD.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">AFPSHUD::DrawHUD</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      Super::<span class="built_in">DrawHUD</span>();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (CrosshairTexture)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="comment">// 找出我们的画布的中心点。</span></span><br><span class="line">          <span class="function">FVector2D <span class="title">Center</span><span class="params">(Canvas-&gt;ClipX * <span class="number">0.5f</span>, Canvas-&gt;ClipY * <span class="number">0.5f</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 偏移纹理大小的一半，以便纹理中心与画布中心对齐。</span></span><br><span class="line">          <span class="function">FVector2D <span class="title">CrossHairDrawPosition</span><span class="params">(Center.X - (CrosshairTexture-&gt;GetSurfaceWidth() * <span class="number">0.5f</span>), Center.Y - (CrosshairTexture-&gt;GetSurfaceHeight() * <span class="number">0.5f</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 在中心点绘制十字准星。</span></span><br><span class="line">          <span class="function">FCanvasTileItem <span class="title">TileItem</span><span class="params">(CrossHairDrawPosition, CrosshairTexture-&gt;Resource, FLinearColor::White)</span></span>;</span><br><span class="line">          TileItem.BlendMode = SE_BLEND_Translucent;</span><br><span class="line">          Canvas-&gt;<span class="built_in">DrawItem</span>(TileItem);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="FVector2D"><a href="#FVector2D" class="headerlink" title="FVector2D"></a>FVector2D</h3><p>2D类型的vector，定义方式是两条线确定的一个交点（更像是提供一个位置信息，而不是Vector2D本身）</p>
<p><code>FVector2D Center(Canvas-&gt;ClipX * 0.5f, Canvas-&gt;ClipY * 0.5f);</code></p>
<ul>
<li><p>第一个参数：第一条线（x轴）</p>
</li>
<li><p>第二个参数：第二条线（Y轴）</p>
</li>
</ul>
<h3 id="FCanvasTileItem"><a href="#FCanvasTileItem" class="headerlink" title="FCanvasTileItem"></a>FCanvasTileItem</h3><p>理解为画布基本色块，类似于，这玩意就是一个颜料，我们调用绘制函数就是画笔。</p>
<p>只不过这个颜料可以直接添加位置信息，就不用在绘制的时候额外添加位置信息。</p>
<p><code>FCanvasTileItem::FCanvasTileItem(const FVector2D&amp; InPosition, const FTexture* InTexture, const FLinearColor&amp; InColor)</code></p>
<ul>
<li><p>第一个参数：位置信息</p>
</li>
<li><p>第二个参数：资产</p>
</li>
<li><p>第三个参数：线性颜色</p>
</li>
</ul>
<h3 id="BlendMode"><a href="#BlendMode" class="headerlink" title="BlendMode"></a>BlendMode</h3><p>用来设置材质颜色如何与背景混合</p>
<p>SE_BLEND_Translucent-&gt;半透明模式</p>
<h3 id="DrawItem"><a href="#DrawItem" class="headerlink" title="DrawItem()"></a>DrawItem()</h3><p><code>DrawItem(FCanvasItem&amp; Item, float PosX, float PosY)</code></p>
<p>绘制函数（画笔），用于将第一个参数绘制进画布中</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/29/UE4-%E7%AC%AC%E4%B8%80%E4%BA%BA%E7%A7%B0FPS-%E5%AE%9E%E7%8E%B0%E8%A7%92%E8%89%B2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="williny">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Williny'home">
      <meta itemprop="description" content="孤独是人生的常态">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Williny'home">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/04/29/UE4-%E7%AC%AC%E4%B8%80%E4%BA%BA%E7%A7%B0FPS-%E5%AE%9E%E7%8E%B0%E8%A7%92%E8%89%B2/" class="post-title-link" itemprop="url">UE4-第一人称FPS-实现角色</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-04-29 14:20:16 / 修改时间：14:37:22" itemprop="dateCreated datePublished" datetime="2022-04-29T14:20:16+08:00">2022-04-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/unreal-engine/" itemprop="url" rel="index"><span itemprop="name">unreal engine</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="建立项目"><a href="#建立项目" class="headerlink" title="建立项目"></a><a target="_blank" rel="noopener" href="https://docs.unrealengine.com/4.27/zh-CN/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/1/">建立项目</a></h1><ol>
<li><p>通过Epic启动器打开 <strong>虚幻引擎</strong>，然后选择创建新项目。</p>
</li>
<li><p>点击 <strong>游戏（Games）</strong> 新项目类别，然后点击 <strong>下一步（Next）</strong>。</p>
</li>
<li><p>选择 <strong>空白模板（Blank template）</strong>，然后点击 <strong>下一步（Next）</strong>。</p>
</li>
<li><p>将项目类型更改为 **C++**（而非 <strong>蓝图（Blueprint）</strong>），确保选中 <strong>无初学者内容（No Starter Content）</strong>。</p>
</li>
<li><p>将新项目命名为”FPSProject”。</p>
</li>
<li><p>转到 <strong>内容浏览器（Content Browser）</strong>（通常在屏幕底部附近），在 <strong>内容（Content）</strong> 文件夹下创建一个 <strong>地图（Maps）</strong> 文件夹（选择内容文件夹，在其中任意位置点击右键，选择 <strong>文件夹（Folder）</strong> &gt; <strong>新建文件夹（New Folder）</strong>）。</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/1/MapsFolder.jpg" alt="MapsFolder.png"></p>
</li>
<li><p>在 <strong>文件（File）</strong> 菜单中，选择 <strong>将当前内容另存为（Save Current as…）</strong>，然后点击地图文件夹。将新地图命名为”FPSMap”，然后点击 <strong>保存（Save）</strong>。</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/1/SaveLevelAs.jpg" alt="SaveLevelAs.png"></p>
</li>
<li><p>从 <strong>编辑（Edit）</strong> 菜单中，点击 <strong>项目设置（Project Settings）</strong>。</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/1/EditProjectSettings.jpg" alt="EditProjectSettings.png"></p>
</li>
<li><p>在 <strong>项目设置（Project Settings）</strong> 选项卡左侧的 <strong>项目（Project）</strong> 标题下，点击 <strong>地图和模式（Maps &amp; Modes）</strong>。</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/1/ProjectMaps_Modes.jpg" alt="ProjectMaps_Modes.png"></p>
</li>
<li><p>展开 <strong>编辑器启动地图（Editor Startup Map）</strong> 下拉菜单，选择 <strong>FPSMap</strong>。</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/1/EditorDefaultMap.jpg" alt="EditorDefaultMap.png"></p>
<p>从现在开始，编辑器将自动加载FPSMap作为默认地图。</p>
</li>
</ol>
<h1 id="添加日志消息"><a href="#添加日志消息" class="headerlink" title="添加日志消息"></a>添加日志消息</h1><p>日志消息对于在开发期间验证和调试代码非常有用。在这一步中，你将使用日志消息来验证自己确实在使用FPSGameMode而非虚幻引擎提供的默认游戏模式。</p>
<h2 id="FPSProjectGameMode头文件"><a href="#FPSProjectGameMode头文件" class="headerlink" title="FPSProjectGameMode头文件"></a>FPSProjectGameMode头文件</h2><ol>
<li><p>在 <strong>解决方案资源管理器</strong> 中，展开 <strong>FPSProject</strong> &gt; <strong>源（Source）</strong> &gt; <strong>FPSProject</strong>。</p>
</li>
<li><p>双击 <code>FPSProjectGameModeBase.h</code> 打开 <strong>FPSGameMode</strong> 类的头文件。</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/1/InterfaceFile.jpg" alt="InterfaceFile.png"></p>
</li>
<li><p>类声明应该如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FPSPROJECT_API</span> AFPSProjectGameModeBase : <span class="keyword">public</span> AGameModeBase</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 <code>AFPSProjectGameMode</code> 构造函数声明下方添加以下函数声明：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">StartPlay</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br></pre></td></tr></table></figure>

<p>此函数声明允许你重载<a target="_blank" rel="noopener" href="https://docs.unrealengine.com/en-US/API/Runtime/Engine/GameFramework/AGameModeBase/StartPlay/index.html">StartPlay</a>，以便游戏启动时在屏幕上打印日志消息。</p>
</li>
<li><p><code>FPSProjectGameMode.h</code> 应如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Epic Games, Inc版权所有。保留所有权利。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CoreMinimal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GameFramework/GameModeBase.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;FPSProjectGameModeBase.generated.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** *  */</span></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FPSPROJECT_API</span> AFPSProjectGameModeBase : <span class="keyword">public</span> AGameModeBase</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">StartPlay</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在Visual Studio中保存你的头文件。</p>
</li>
</ol>
<h3 id="FPSProjectGameMode-CPP文件"><a href="#FPSProjectGameMode-CPP文件" class="headerlink" title="FPSProjectGameMode CPP文件"></a>FPSProjectGameMode CPP文件</h3><ol>
<li><p>在 <strong>解决方案资源管理器</strong> 中，定位到 <code>FPSProjectGameModeBase.cpp</code>（<strong>FPSProject &gt;源（Source）&gt; FPSProject</strong>）。</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/1/ImplementationFile.jpg" alt="ImplementationFile.png"></p>
</li>
<li><p>双击 <code>FPSProjectGameModeBase.cpp</code> 打开 <strong>FPSGameModeBase</strong> 类的实现文件。</p>
</li>
<li><p>现在将以下代码行添加到该文件中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSProjectGameModeBase::StartPlay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Super::<span class="built_in">StartPlay</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">check</span>(GEngine != <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 显示调试消息五秒。 </span></span><br><span class="line"> <span class="comment">// 参数中的-1&quot;键&quot;值类型参数能防止该消息被更新或刷新。</span></span><br><span class="line"> GEngine-&gt;<span class="built_in">AddOnScreenDebugMessage</span>(<span class="number">-1</span>, <span class="number">5.0f</span>, FColor::Yellow, <span class="built_in">TEXT</span>(<span class="string">&quot;Hello World, this is FPSGameMode!&quot;</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>游戏启动时，StartPlay()将在屏幕上打印一条新的调试消息（”Hello World, this is FPSGameModeBase!”），采用黄色文本，显示五秒钟。</p>
</li>
<li><p><code>FPSProjectGameModeBase.cpp</code> 应如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Epic Games, Inc版权所有。保留所有权利。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;FPSProjectGameMode.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSProjectGameModeBase::StartPlay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Super::<span class="built_in">StartPlay</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">check</span>(GEngine != <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示调试消息五秒。 </span></span><br><span class="line"><span class="comment">// -1&quot;键&quot;值参数防止该消息被更新或刷新。</span></span><br><span class="line">GEngine-&gt;<span class="built_in">AddOnScreenDebugMessage</span>(<span class="number">-1</span>, <span class="number">5.0f</span>, FColor::Yellow, <span class="built_in">TEXT</span>(<span class="string">&quot;Hello World, this is FPSGameModeBase!&quot;</span>));</span><br></pre></td></tr></table></figure>
</li>
<li><p>在Visual Studio中保存CPP文件。</p>
</li>
<li><p>在”内容”文件夹中创建一个 <strong>蓝图（Blueprints）</strong> 文件夹。</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/1/BlueprintsFolder.jpg" alt="BlueprintsFolder.png"></p>
</li>
<li><p>现在右键点击 <strong>FPSProjectGameModeBase</strong> 类（在 <strong>C++类（C++ Classes）</strong> &gt; <strong>FPSProject</strong> 中），打开 <strong>C++类操作（C++ Class Actions）</strong> 菜单。</p>
</li>
<li><p>点击 <strong>基于FPSProjectGameModeBase创建蓝图类（Create Blueprint class based on FPSProjectGameModeBase）</strong> 打开 <strong>添加蓝图类（Add Blueprint Class）</strong> 对话框菜单。</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/1/CreateDerivedBPClass.jpg" alt="CreateDerivedBPClass.png"></p>
</li>
<li><p>将你的新蓝图类命名为”BP_FPSProjectGameModeBase”，然后选择蓝图文件夹，之后点击 <strong>创建蓝图类（Create Blueprint Class）</strong> 按钮。</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/1/AddBPClass.jpg" alt="AddBPClass.png"></p>
</li>
<li><p>到目前为止，你应该有一个新创建的 <code>BP_FPSProjectGameModeBase</code> 蓝图类，位于蓝图文件夹内。</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/1/AddedBPClass.jpg" alt="AddedBPClass.png"></p>
</li>
<li><p>请确保在关闭蓝图编辑器之前保存你的 <code>BP_FPSProjectGameModeBase</code> 蓝图。</p>
</li>
<li><p>展开 <strong>编辑（Edit）</strong> 菜单，点击 <strong>项目设置（Project Settings）</strong>。</p>
</li>
<li><p>在 <strong>项目设置（Project Settings）</strong> 选项卡左侧的 <strong>项目（Project）</strong> 标题下，点击 <strong>地图和模式（Maps &amp; Modes）</strong>。</p>
</li>
<li><p>展开 <strong>默认游戏模式（Default GameMode）</strong> 下拉菜单，选择 <strong>BP_FPSGameModeBase</strong>。</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/1/SettingFPSGameMode.jpg" alt="SettingFPSGameMode.png"></p>
</li>
<li><p>关闭 <strong>项目设置（Project Settings）</strong> 菜单。</p>
</li>
<li><p>点击关卡编辑器工具栏中的 <strong>运行（Play）</strong> 按钮。”Hello World, this is FPSGameMode!”这句话应在视口左上角以黄色文本显示五秒钟。</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/1/SectionResult.jpg" alt="SectionResult.png"></p>
</li>
<li><p>按 <strong>退出键（Escape key）</strong> 或在关卡编辑器中点击 <strong>停止（Stop）</strong> 按钮，即可退出编辑器内运行（PIE）模式。</p>
</li>
</ol>
<h1 id="创建新角色"><a href="#创建新角色" class="headerlink" title="创建新角色"></a>创建新角色</h1><h2 id="添加角色类"><a href="#添加角色类" class="headerlink" title="添加角色类"></a>添加角色类</h2><p>虽然你可以手动将.h和.cpp文件添加到你的Visual Studio (VS)解决方案，但使用C++类向导将新类添加到你的项目是一种很好的做法。</p>
<p>使用C++类向导，引擎可创建头文件和源文件模板，这些模板文件将为你预先设置一些虚幻特定的宏。</p>
<ol>
<li><p>在UE中启动FPS项目（如果你尚未完成此操作）。</p>
</li>
<li><p>在文件（File）菜单中，选择 <strong>新建C++类…（New C++ Class…）</strong>，以选择新的父类。</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/SelectNewCPPClass.jpg" alt="SelectNewCPPClass.png"></p>
</li>
<li><p>以上操作将打开 <strong>选择父类（Choose Parent Class）</strong> 菜单。向下滚动，选择 <strong>角色</strong> 作为父类，然后点击 <strong>下一步（Next）</strong>。</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/ChooseCharacterClass.jpg" alt="ChooseCharacterClass.png"></p>
</li>
<li><p>将新类命名为”FPSCharacter”，然后点击 <strong>创建类（Create Class）</strong>。</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/MakeFPSCharacterClass.jpg" alt="MakeFPSCharacterClass.png"></p>
</li>
</ol>
<h2 id="确认角色类"><a href="#确认角色类" class="headerlink" title="确认角色类"></a>确认角色类</h2><ol>
<li><p>在VS的 <strong>解决方案浏览器</strong> 中，依次展开 <strong>FPSProject</strong> &gt; <strong>源（Source）</strong> &gt; <strong>FPSProject</strong>。</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/ExpandedSolutionExplorer.jpg" alt="ExpandedSolutionExplorer.png"></p>
</li>
<li><p>点击 <code>FPSCharacter.cpp</code>，打开 <strong>FPSCharacter</strong> 类的实现文件。</p>
</li>
<li><p>在 <code>BeginPlay()</code> 函数中添加以下代码行（在 <code>Super::BeginPlay();</code> 下面），以便确认正在使用 <code>FPSCharacter</code> 类：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">check</span>(GEngine != <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示调试消息五秒。 </span></span><br><span class="line"><span class="comment">// -1&quot;键&quot;值参数可以防止更新或刷新消息。</span></span><br><span class="line">GEngine-&gt;<span class="built_in">AddOnScreenDebugMessage</span>(<span class="number">-1</span>, <span class="number">5.0f</span>, FColor::Red, <span class="built_in">TEXT</span>(<span class="string">&quot;We are using FPSCharacter.&quot;</span>));</span><br></pre></td></tr></table></figure>
</li>
<li><p>现在 <code>FPSCharacter.cpp</code> 的内容应如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版权所有Epic Games, Inc。保留所有权利。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;FPSCharacter.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置默认值</span></span><br><span class="line">AFPSCharacter::<span class="built_in">AFPSCharacter</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 将此角色设置为每帧调用Tick()。  如果不需要此特性，可以关闭以提升性能。</span></span><br><span class="line">PrimaryActorTick.bCanEverTick = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当游戏开始或重生（Spawn）时被调用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::BeginPlay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Super::<span class="built_in">BeginPlay</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">check</span>(GEngine != <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示调试消息五秒。 </span></span><br><span class="line"><span class="comment">// -1&quot;键&quot;值参数可以防止更新或刷新消息。</span></span><br><span class="line">GEngine-&gt;<span class="built_in">AddOnScreenDebugMessage</span>(<span class="number">-1</span>, <span class="number">5.0f</span>, FColor::Red, <span class="built_in">TEXT</span>(<span class="string">&quot;We are using FPSCharacter.&quot;</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每一帧都被调用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::Tick</span><span class="params">(<span class="type">float</span> DeltaTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Super::<span class="built_in">Tick</span>(DeltaTime);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 被调用，将功能与输入绑定</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::SetupPlayerInputComponent</span><span class="params">(UInputComponent* PlayerInputComponent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Super::<span class="built_in">SetupPlayerInputComponent</span>(PlayerInputComponent);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在Visual Studio中保存 <code>FPSCharacter</code> CPP文件。</p>
</li>
<li><p>在 <strong>解决方案浏览器（Solution Explorer）</strong> 中找到 <strong>FPSProject</strong>。</p>
<p>到目前为止，你一直在使用编辑器的 <strong>构建(Build)</strong> 按钮编译项目。在此步骤中，你将使用Visual Studio的构建功能来编译代码。要从Visual Studio中编译代码，请右键点击 <strong>FPSProject</strong>，并选择 <strong>构建（Build）</strong> 来编译项目。</p>
</li>
<li><p>要从VS中编译代码，请右键点击 <strong>FPSProject</strong>，并选择 <strong>构建（Build）</strong> 来编译项目。</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/BuildProject.jpg" alt="BuildProject.png"></p>
<p>如果你使用的是VS的默认设置，则在界面底部附近（可能在代码编辑器的下方），你应该会看到一个对话框。当你点击构建（Build）后，在生成过程中该对话框中应该会显示一些信息，我们最希望显示的是构建成功的信息。 如果构建失败，不要紧张！回头看看你之前的操作步骤，确保你的代码与此处和第1分段中列出的内容相同。</p>
</li>
<li><p>构建完成后，打开虚幻编辑器，确认新编译的 <strong>FPSCharacter</strong> 类在 <strong>内容浏览器</strong> 中可见。</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/FPSCharacterContentBrowser.jpg" alt="FPSCharacterContentBrowser.png"></p>
</li>
</ol>
<h3 id="扩展你的C-FPS角色类到蓝图"><a href="#扩展你的C-FPS角色类到蓝图" class="headerlink" title="扩展你的C++ FPS角色类到蓝图"></a>扩展你的C++ FPS角色类到蓝图</h3><p>现在可以扩展C++ FPS角色类到蓝图了（类似之前进行的FPSProject游戏模式操作）。请随时前往我们的<a target="_blank" rel="noopener" href="https://docs.unrealengine.com/4.27/zh-CN/ProgrammingAndScripting/ClassCreation/CodeAndBlueprints">C++和蓝图</a>参考页面，以了解更多关于扩展C++类到蓝图的信息。</p>
<ol>
<li><p>右键点击FPSCharacter类，打开 <strong>C++类操作（C++ Class Actions）</strong> 菜单。</p>
</li>
<li><p>点击 <strong>基于FPSCharacter创建蓝图类（Create Blueprint class based on FPSHUD）</strong>，打开 <strong>添加蓝图类（Add Blueprint Class）</strong> 对话框菜单。</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/CreateDerivedBPClass.jpg" alt="CreateDerivedBPClass.png"></p>
</li>
<li><p>将新的蓝图类命名为 <code>BP_FPSCharacter</code>，选择蓝图（Blueprints）文件夹，然后点击 <strong>创建蓝图类（Create Blueprint Class）</strong> 按钮。</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/AddBPClass.jpg" alt="AddBPClass.png"></p>
</li>
<li><p>现在，在蓝图（Blueprints）文件夹内，你应该可以看到新创建的 <code>BP_FPSCharacter</code> 蓝图类。</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/AddedBPClass.jpg" alt="AddedBPClass.png"></p>
</li>
<li><p>请确保在关闭蓝图编辑器前保存 <code>BP_FPSCharacter</code> 蓝图。</p>
</li>
</ol>
<h2 id="设置默认的Pawn类"><a href="#设置默认的Pawn类" class="headerlink" title="设置默认的Pawn类"></a>设置默认的Pawn类</h2><p>现在你已经成功地把新修改的游戏模式扩展到了蓝图，接下来你需要在此步骤中设置项目，将 <code>BP_FPSCharacter</code> 作为默认的 <strong>Pawn</strong>。</p>
<ol>
<li><p>在 <strong>编辑（Edit）</strong> 菜单中点击 <strong>项目设置（Project Settings）</strong>。</p>
</li>
<li><p>在 <strong>项目设置（Project Settings）</strong> 选项卡左侧的 <strong>项目（Project）</strong> 标题栏下，点击 <strong>地图和模式（Maps &amp; Modes）</strong>。</p>
</li>
<li><p>展开 <strong>已选择的游戏模式（Selected GameMode）</strong> 段，并在 <strong>默认Pawn类（Default Pawn Class）</strong> 下拉菜单中选择 <strong>BP_FPSCharacter</strong>。</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/SettingFPSCharacter.jpg" alt="SettingFPSCharacter.png"></p>
</li>
<li><p>关闭 <strong>项目设置（Project Settings）</strong> 菜单。</p>
</li>
<li><p>在关卡编辑器工具栏中点击 <strong>运行（Play）</strong> 按钮。在视口左上角，红色文本”We are using FPSCharacter.”将显示在”Hello World, this is FPSGameMode!”的下方，并持续5秒钟。</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/VerifyingFPSCharacterResult.jpg" alt="VerifyingFPSCharacterResult.png"></p>
<p>如果你无法移动，说明你已经正确地将FPSCharacter用作了Pawn！你的新角色还没有任何移动功能按钮，因此你还不能在关卡中四处移动。</p>
</li>
<li><p>在进入下一步前，按退出键（Escape）或在关卡编辑器中点击 <strong>停止（Stop）</strong>，退出在编辑器中运行（Play in Editor）（PIE）模式。</p>
</li>
</ol>
<h1 id="设置轴映射"><a href="#设置轴映射" class="headerlink" title="设置轴映射"></a>设置轴映射</h1><p>通常，轴映射支持将键盘、鼠标和控制器输入映射到”友好名称”，该名称稍后可以绑定到游戏行为上（例如移动）。轴映射会不断被轮询，从而实现无缝的移动过渡和流畅的游戏行为。硬件轴（例如游戏摇杆）所提供的输入值为程度值，而不是离散的数字输入（例如，按下为1，不按下为0）。虽然游戏摇杆输入方法在提供可平滑伸缩的移动输入方面很有效，但轴映射也可以将常见的移动键（如WASD键或箭头键）映射到持续轮询的游戏行为。</p>
<p>在继续此步骤之前，如果你想要了解有关玩家输入的更多信息，请参阅<a target="_blank" rel="noopener" href="https://docs.unrealengine.com/4.27/zh-CN/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/PlayerInput">玩家输入和Pawn</a>教程。在此步骤中，你将设置W、A、S和D键的输入轴映射，从而使新角色可以在地图上四处移动。</p>
<h2 id="向前移动轴映射"><a href="#向前移动轴映射" class="headerlink" title="向前移动轴映射"></a>向前移动轴映射</h2><ol>
<li><p>在 <strong>编辑（Edit）</strong> 菜单中，点击 <strong>项目设置（Project Settings）</strong>。</p>
</li>
<li><p>在 <strong>项目设置（Project Settings）</strong> 选项卡左侧的 <strong>引擎（Engine）</strong> 标题栏下，点击 <strong>输入（Input）</strong>。</p>
</li>
<li><p>在 <strong>绑定（Bindings）</strong> 中，点击 <strong>轴映射（Axis Mappings）</strong> 旁边的+号。</p>
</li>
<li><p>点击 <strong>轴映射（Axis Mappings）</strong> 左侧的箭头。</p>
</li>
<li><p>在界面显示的文本框中输入”MoveForward”，然后点击文本框左侧的箭头，展开轴绑定选项。</p>
</li>
<li><p>在下拉菜单中，从 <strong>键盘（Keyboard）</strong> 下拉列表中选择 <strong>W</strong>。</p>
</li>
<li><p>现在输入设置界面应如下图所示：</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/MoveForwardAxisMap_W.jpg" alt="MoveForwardAxisMap_W.png"></p>
</li>
<li><p>点击 <strong>MoveForward</strong> 旁边的+号。</p>
</li>
<li><p>在第二个下拉菜单中，从 <strong>键盘（Keyboard）</strong> 下拉列表中选择 <strong>S</strong>。</p>
</li>
<li><p>在 <strong>S</strong> 旁边的 <strong>比例（Scale）</strong> 字段中输入”-1”。</p>
</li>
<li><p>现在输入设置界面应如下图所示：</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/MoveForwardAxisMap_S.jpg" alt="MoveForwardAxisMap_S.png"></p>
</li>
</ol>
<h2 id="向右移动轴映射"><a href="#向右移动轴映射" class="headerlink" title="向右移动轴映射"></a>向右移动轴映射</h2><ol>
<li><p>在 <strong>绑定（Bindings）</strong> 中，点击 <strong>轴映射（Axis Mappings）</strong> 旁边的+号。</p>
</li>
<li><p>在显示的文本字段中输入”向右移动（MoveForward）”，然后点击文本框左侧的箭头，展开轴绑定选项。</p>
</li>
<li><p>在下拉菜单中，从 <strong>键盘（Keyboard）</strong> 下拉列表中选择 <strong>D</strong>。</p>
</li>
<li><p>现在输入设置界面应如下图所示：</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/MoveRightAxisMap_D.jpg" alt="MoveRightAxisMap_D.png"></p>
</li>
<li><p>点击 <strong>向右移动（MoveRight）</strong> 旁边的+号。</p>
</li>
<li><p>在第二个下拉菜单中，从 <strong>键盘（Keyboard）</strong> 下拉列表中选择 <strong>A</strong>。</p>
</li>
<li><p>在 <strong>A</strong> 旁边的 <strong>比例（Scale）</strong> 字段中输入”-1”。</p>
</li>
<li><p>现在输入设置界面应如下图所示：</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/MoveRightAxisMap_A.jpg" alt="MoveRightAxisMap_A.png"></p>
</li>
<li><p>现在你已设置好向左移动（MoveLeft）和向右移动（MoveRight）轴映射，请关闭 <strong>项目设置（Project Settings）</strong> 菜单并继续。</p>
</li>
</ol>
<h1 id="实现角色移动函数"><a href="#实现角色移动函数" class="headerlink" title="实现角色移动函数"></a>实现角色移动函数</h1><p>在此步骤中，我们将设置玩家输入组件，并在FPSCharacter类中实现以下函数：</p>
<ul>
<li><p><code>MoveForward</code></p>
</li>
<li><p><code>MoveRight</code></p>
</li>
</ul>
<h2 id="移动函数接口"><a href="#移动函数接口" class="headerlink" title="移动函数接口"></a>移动函数接口</h2><p>你已经设置好FPSCharacter的轴映射，现在可以切换到VS中的项目界面。</p>
<ol>
<li><p>在 <code>FPSCharacter.h</code> 中，将以下函数声明添加到 <code>SetupPlayerInputComponent</code> 成员函数的下方。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理用于前后移动的输入。</span></span><br><span class="line"><span class="built_in">UFUNCTION</span>()</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MoveForward</span><span class="params">(<span class="type">float</span> Value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理用于左右移动的输入。</span></span><br><span class="line"><span class="built_in">UFUNCTION</span>()</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MoveRight</span><span class="params">(<span class="type">float</span> Value)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>UFUNCTION</code> 宏（位于每个函数上方）让引擎可以发觉这些函数，以便将它们纳入序列化和其他引擎功能中。</p>
</li>
<li><p>现在 <code>FPSCharacter.h</code> 的内容应如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版权所有Epic Games, Inc。保留所有权利。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CoreMinimal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GameFramework/Character.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;FPSCharacter.generated.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FPSPROJECT_API</span> AFPSCharacter : <span class="keyword">public</span> ACharacter</span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="comment">// 为此角色的属性设置默认值</span></span><br><span class="line">   <span class="built_in">AFPSCharacter</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">   <span class="comment">// 当游戏开始或重生（Spawn）时被调用</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BeginPlay</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="comment">// 每一帧都被调用</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Tick</span><span class="params">( <span class="type">float</span> DeltaTime )</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 被调用，将功能与输入绑定</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SetupPlayerInputComponent</span><span class="params">(<span class="keyword">class</span> UInputComponent* PlayerInputComponent)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 处理用于前后移动的输入。</span></span><br><span class="line">   <span class="built_in">UFUNCTION</span>()</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">MoveForward</span><span class="params">(<span class="type">float</span> Value)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 处理用于左右移动的输入。</span></span><br><span class="line">   <span class="built_in">UFUNCTION</span>()</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">MoveRight</span><span class="params">(<span class="type">float</span> Value)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="移动函数的实现"><a href="#移动函数的实现" class="headerlink" title="移动函数的实现"></a>移动函数的实现</h2><p>在典型的FPS控制模式中，角色的移动轴是相对于摄像机的。”向前”移动是指”摄像机指向的方向”，”向右”是指”摄像机指向方向的右侧”。你将使用 <code>PlayerController</code> 获取角色的控制旋转输入值。另外， <code>MoveForward</code> 函数将忽略控制旋转输入值的俯仰（Pitch）分量，将输入限制在XY平面上，以确保在你向上或向下看时，你的角色将沿着地面移动。</p>
<ol>
<li><p>在 <code>FPSCharacter.cpp</code> 中，将以下行添加到<code>SetupPlayerInputComponent </code>函数中的<code> Super::SetupPlayerInputComponent(PlayerInputComponent);</code> 下方 。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置&quot;移动&quot;绑定。</span></span><br><span class="line">PlayerInputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="string">&quot;MoveForward&quot;</span>, <span class="keyword">this</span>, &amp;AFPSCharacter::MoveForward);</span><br><span class="line">PlayerInputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="string">&quot;MoveRight&quot;</span>, <span class="keyword">this</span>, &amp;AFPSCharacter::MoveRight);</span><br></pre></td></tr></table></figure>

<p><code>InputComponent</code> 是定义如何处理输入数据的组件。可以将 <code>InputComponent</code> 附加到想要接收输入的actor。</p>
</li>
<li><p>在 <code>FPSCharacter.cpp</code> 中， <code>SetupPlayerInputComponent</code> 下方，添加以下 <code>MoveForward</code> 函数定义。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::MoveForward</span><span class="params">(<span class="type">float</span> Value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// 找出&quot;前进&quot;方向，并记录玩家想向该方向移动。</span></span><br><span class="line">   FVector Direction = <span class="built_in">FRotationMatrix</span>(Controller-&gt;<span class="built_in">GetControlRotation</span>()).<span class="built_in">GetScaledAxis</span>(EAxis::X);</span><br><span class="line">   <span class="built_in">AddMovementInput</span>(Direction, Value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 <code>FPSCharacter.cpp</code> 中添加以下 <code>MoveRight</code> 函数定义（<code>MoveForward</code> 下方）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::MoveRight</span><span class="params">(<span class="type">float</span> Value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// 找出&quot;右侧&quot;方向，并记录玩家想向该方向移动。</span></span><br><span class="line">   FVector Direction = <span class="built_in">FRotationMatrix</span>(Controller-&gt;<span class="built_in">GetControlRotation</span>()).<span class="built_in">GetScaledAxis</span>(EAxis::Y);</span><br><span class="line">   <span class="built_in">AddMovementInput</span>(Direction, Value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>现在 <code>FPSCharacter.cpp</code> 的内容应如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版权所有Epic Games, Inc。保留所有权利。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;FPSCharacter.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置默认值</span></span><br><span class="line">AFPSCharacter::<span class="built_in">AFPSCharacter</span>()</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 将此角色设置为每帧调用Tick()。  如果不需要此特性，可以关闭以提升性能。</span></span><br><span class="line">   PrimaryActorTick.bCanEverTick = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当游戏开始或重生（Spawn）时被调用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::BeginPlay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Super::<span class="built_in">BeginPlay</span>();</span><br><span class="line"></span><br><span class="line">   <span class="built_in">check</span>(GEngine != <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 显示调试消息五秒。 </span></span><br><span class="line">   <span class="comment">// -1&quot;键&quot;值参数可以防止更新或刷新消息。</span></span><br><span class="line">     GEngine-&gt;<span class="built_in">AddOnScreenDebugMessage</span>(<span class="number">-1</span>, <span class="number">5.0f</span>, FColor::Red, <span class="built_in">TEXT</span>(<span class="string">&quot;We are using FPSCharacter.&quot;</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每一帧都被调用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::Tick</span><span class="params">( <span class="type">float</span> DeltaTime )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Super::<span class="built_in">Tick</span>( DeltaTime );</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 被调用，将功能与输入绑定</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::SetupPlayerInputComponent</span><span class="params">(UInputComponent* PlayerInputComponent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Super::<span class="built_in">SetupPlayerInputComponent</span>(PlayerInputComponent);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 设置&quot;移动&quot;绑定。</span></span><br><span class="line">   PlayerInputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="string">&quot;MoveForward&quot;</span>, <span class="keyword">this</span>, &amp;AFPSCharacter::MoveForward);</span><br><span class="line">   PlayerInputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="string">&quot;MoveRight&quot;</span>, <span class="keyword">this</span>, &amp;AFPSCharacter::MoveRight);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::MoveForward</span><span class="params">(<span class="type">float</span> Value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// 找出&quot;前进&quot;方向，并记录玩家想向该方向移动。</span></span><br><span class="line">   FVector Direction = <span class="built_in">FRotationMatrix</span>(Controller-&gt;<span class="built_in">GetControlRotation</span>()).<span class="built_in">GetScaledAxis</span>(EAxis::X);</span><br><span class="line">   <span class="built_in">AddMovementInput</span>(Direction, Value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::MoveRight</span><span class="params">(<span class="type">float</span> Value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// 找出&quot;右侧&quot;方向，并记录玩家想向该方向移动。</span></span><br><span class="line">   FVector Direction = <span class="built_in">FRotationMatrix</span>(Controller-&gt;<span class="built_in">GetControlRotation</span>()).<span class="built_in">GetScaledAxis</span>(EAxis::Y);</span><br><span class="line">   <span class="built_in">AddMovementInput</span>(Direction, Value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="测试角色移动"><a href="#测试角色移动" class="headerlink" title="测试角色移动"></a>测试角色移动</h2><p>现在我们来编译和测试新实现的角色移动函数。</p>
<ol>
<li><p>在VS中保存 <code>FPSCharacter</code> 头文件（.h）和C++（.cpp）文件。</p>
</li>
<li><p>在 <strong>解决方案浏览器（Solution Explorer）</strong> 中找到 <strong>FPSProject</strong>。</p>
</li>
<li><p>右键点击 <strong>FPSProject</strong> 并选择 <strong>构建（Build）</strong>，编译你的项目。</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/BuildProject.jpg" alt="BuildProject.png"></p>
</li>
<li><p>构建完毕后，在虚幻引擎中打开 <strong>FPSProject</strong>。</p>
</li>
<li><p>在关卡编辑器工具栏中点击 <strong>运行（Play）</strong>。现在，你应该能够向前、向后、向左和向右移动。</p>
</li>
<li><p>按退出键（Escape）或在关卡编辑器中点击 <strong>停止（Stop）</strong>，退出PIE模式。</p>
</li>
</ol>
<h1 id="实现鼠标摄像机控制"><a href="#实现鼠标摄像机控制" class="headerlink" title="实现鼠标摄像机控制"></a>实现鼠标摄像机控制</h1><p>在此步骤中，你将为角色添加能够环顾四周并用鼠标操纵的功能。</p>
<h2 id="转向轴映射"><a href="#转向轴映射" class="headerlink" title="转向轴映射"></a>转向轴映射</h2><ol>
<li><p>在FPS项目中，展开 <strong>编辑（Edit）</strong> 菜单，并点击 <strong>项目设置（Project Settings）</strong>。</p>
</li>
<li><p>在 <strong>项目设置（Project Settings）</strong> 选项卡左侧的 <strong>引擎（Engine）</strong> 标题栏下，点击 <strong>输入（Input）</strong>。</p>
</li>
<li><p>在 <strong>绑定（Bindings）</strong> 中，点击 <strong>轴映射（Axis Mappings）</strong> 旁边的+号。</p>
</li>
<li><p>点击 <strong>轴映射（Axis Mappings）</strong> 左侧的箭头。</p>
</li>
<li><p>在显示的文本输入框中输入”Turn”，然后点击文本框左侧的箭头，以便展开轴绑定选项</p>
</li>
<li><p>在下拉菜单中，从 <strong>鼠标（Mouse）</strong> 下拉列表中选择 <strong>鼠标X（Mouse X）</strong>。</p>
</li>
<li><p>现在输入设置界面应如下图所示：</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/TurnAxisMapping_MouseX.jpg" alt="TurnAxisMapping_MouseX.png"></p>
</li>
</ol>
<h2 id="查找轴映射"><a href="#查找轴映射" class="headerlink" title="查找轴映射"></a>查找轴映射</h2><ol>
<li><p>在 <strong>绑定（Bindings）</strong> 中，点击 <strong>轴映射（Axis Mappings）</strong> 旁边的+号。</p>
</li>
<li><p>在显示的文本输入框中输入”LookUp”，然后点击文本框左侧的箭头，以便展开轴绑定选项。</p>
</li>
<li><p>在下拉菜单中，从 <strong>鼠标（Mouse）</strong> 下拉列表中选择 <strong>鼠标Y（Mouse Y）</strong>。</p>
</li>
<li><p>在 <strong>鼠标Y（Mouse Y）</strong> 旁边的 <strong>比例（Scale）</strong> 输入框中输入”-1.0”。</p>
</li>
<li><p>现在输入设置界面应如下图所示：</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/TurnAxisMapping_MouseY.jpg" alt="TurnAxisMapping_MouseY.png"></p>
</li>
<li><p>关闭 <strong>项目设置（Project Settings）</strong> 菜单。</p>
</li>
</ol>
<h2 id="实现输入处理"><a href="#实现输入处理" class="headerlink" title="实现输入处理"></a>实现输入处理</h2><p>现在可以添加代码处理鼠标输入以便进行转向和抬头看。<code>角色</code> 基类为我们定义了两个必要函数，即：</p>
<ul>
<li><p><code>AddControllerYawInput</code></p>
</li>
<li><p><code>AddControllerPitchInput</code></p>
<p>如果你想要执行更多的处理，例如增加对灵敏度或轴反转的支持，那么你可以提供自己的函数，以便在将输入值传递给函数之前对其进行调整。但是，在本示例中，你将直接将输入绑定到 <code>AddControllerYawInput</code> 和 <code>AddControllerPitchInput</code> 函数。</p>
</li>
</ul>
<ol>
<li><p>将以下代码行添加到 <code>FPSCharacter.cpp</code> 中的 <code>SetupPlayerInputComponent</code> 函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置&quot;观看&quot;绑定。</span></span><br><span class="line">PlayerInputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="string">&quot;Turn&quot;</span>, <span class="keyword">this</span>, &amp;AFPSCharacter::AddControllerYawInput);</span><br><span class="line">PlayerInputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="string">&quot;LookUp&quot;</span>, <span class="keyword">this</span>, &amp;AFPSCharacter::AddControllerPitchInput);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>SetupPlayerInputComponent</code> 函数应如下图所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 被调用，将功能与输入绑定</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::SetupPlayerInputComponent</span><span class="params">(UInputComponent* PlayerInputComponent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Super::<span class="built_in">SetupPlayerInputComponent</span>(PlayerInputComponent);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 设置&quot;移动&quot;绑定。</span></span><br><span class="line">   PlayerInputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="string">&quot;MoveForward&quot;</span>, <span class="keyword">this</span>, &amp;AFPSCharacter::MoveForward);</span><br><span class="line">   PlayerInputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="string">&quot;MoveRight&quot;</span>, <span class="keyword">this</span>, &amp;AFPSCharacter::MoveRight);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 设置&quot;观看&quot;绑定。</span></span><br><span class="line">   PlayerInputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="string">&quot;Turn&quot;</span>, <span class="keyword">this</span>, &amp;AFPSCharacter::AddControllerYawInput);</span><br><span class="line">   PlayerInputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="string">&quot;LookUp&quot;</span>, <span class="keyword">this</span>, &amp;AFPSCharacter::AddControllerPitchInput);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="测试鼠标摄像机控制"><a href="#测试鼠标摄像机控制" class="headerlink" title="测试鼠标摄像机控制"></a>测试鼠标摄像机控制</h2><ol>
<li><p>在VS中保存 <code>FPSCharacter</code> 的实现文件。</p>
</li>
<li><p>在 <strong>解决方案浏览器（Solution Explorer）</strong> 中找到 <strong>FPSProject</strong>。</p>
</li>
<li><p>右键点击 <strong>FPSProject</strong> 并选择 <strong>构建（Build）</strong>，编译你的项目。</p>
</li>
<li><p>构建完毕后，在虚幻引擎中打开 <strong>FPSProject</strong>。</p>
</li>
<li><p>在关卡编辑器工具栏中点击 <strong>运行（Play）</strong>。现在，你可以通过鼠标控制摄像机。</p>
</li>
<li><p>按 <strong>退出键（Escape key）</strong> 或在关卡编辑器中点击 <strong>停止（Stop）</strong>，退出PIE模式。</p>
</li>
</ol>
<h1 id="实现角色跳跃"><a href="#实现角色跳跃" class="headerlink" title="实现角色跳跃"></a>实现角色跳跃</h1><p>通常，操作映射处理离散事件的输入，让你可以将输入映射到”友好名称”，该名称稍后可以与事件驱动的行为绑定。最终效果是，按下和&#x2F;或释放单个键、鼠标按钮或辅助键盘按钮可以直接触发游戏行为。在此步骤中，你将为空格键设置输入操作映射，增加角色的跳跃能力。</p>
<h2 id="跳跃操作映射"><a href="#跳跃操作映射" class="headerlink" title="跳跃操作映射"></a>跳跃操作映射</h2><ol>
<li><p>在 <strong>编辑（Edit）</strong> 菜单中，点击 <strong>项目设置（Project Settings）</strong>。</p>
</li>
<li><p>在 <strong>项目设置（Project Settings）</strong> 选项卡左侧的 <strong>引擎（Engine）</strong> 标题栏下，点击 <strong>输入（Input）</strong>。</p>
</li>
<li><p>在 <strong>绑定（Bindings）</strong> 中，点击 <strong>操作映射（Action Mappings）</strong> 旁边的+号。</p>
</li>
<li><p>点击 <strong>操作映射（Action Mappings）</strong> 左侧的箭头。</p>
</li>
<li><p>在显示的文本输入框中输入”Jump”，然后点击文本框左侧的箭头，展开操作绑定选项。</p>
</li>
<li><p>在下拉菜单中，从 <strong>键盘（Keyboard）</strong> 下拉列表中选择 <strong>空格键（Space Bar）</strong>。</p>
</li>
<li><p>现在输入设置界面应如下图所示：</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/JumpActionMapping_SpaceBar.jpg" alt="JumpActionMapping_SpaceBar.png"></p>
</li>
<li><p>关闭 <strong>项目设置（Project Settings）</strong> 菜单。</p>
</li>
</ol>
<h2 id="实现输入处理-1"><a href="#实现输入处理-1" class="headerlink" title="实现输入处理"></a>实现输入处理</h2><p>如果你查看 <code>Acharacter</code> 基类的接口文件（.h）的内容，你会看到角色跳跃的内置支持。角色跳跃与 <code>bPressedJump</code> 变量绑定，因此我们需要做的就是，在跳跃操作按下时将该布尔值设置为 <code>true</code>，在跳跃操作释放时将该布尔值设置为 <code>false</code>。你需要添加以下两个函数完成此操作：</p>
<ul>
<li><p><code>StartJump</code></p>
</li>
<li><p><code>StopJump</code></p>
</li>
</ul>
<p>返回Visual Studio，将代码添加到 <code>FPSCharacter</code> 类。</p>
<ol>
<li><p>在 <code>FPSCharacter.h</code> 中，添加以下公共函数声明：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按下键时，设置跳跃标记。</span></span><br><span class="line"><span class="built_in">UFUNCTION</span>()</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StartJump</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放键时，清除跳跃标记。</span></span><br><span class="line"><span class="built_in">UFUNCTION</span>()</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StopJump</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>现在 <code>FPSCharacter.h</code> 的内容应如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版权所有Epic Games, Inc。保留所有权利。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CoreMinimal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GameFramework/Character.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;FPSCharacter.generated.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FPSPROJECT_API</span> AFPSCharacter : <span class="keyword">public</span> ACharacter</span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="comment">// 为此角色的属性设置默认值</span></span><br><span class="line">   <span class="built_in">AFPSCharacter</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">   <span class="comment">// 当游戏开始或重生（Spawn）时被调用</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BeginPlay</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="comment">// 每一帧都被调用</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Tick</span><span class="params">( <span class="type">float</span> DeltaTime )</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 被调用，将功能与输入绑定</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SetupPlayerInputComponent</span><span class="params">(<span class="keyword">class</span> UInputComponent* PlayerInputComponent)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 处理用于前后移动的输入。</span></span><br><span class="line">   <span class="built_in">UFUNCTION</span>()</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">MoveForward</span><span class="params">(<span class="type">float</span> Value)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 处理用于左右移动的输入。</span></span><br><span class="line">   <span class="built_in">UFUNCTION</span>()</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">MoveRight</span><span class="params">(<span class="type">float</span> Value)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 按下键时，设置跳跃标记。</span></span><br><span class="line">   <span class="built_in">UFUNCTION</span>()</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">StartJump</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 释放键时，清除跳跃标记。</span></span><br><span class="line">   <span class="built_in">UFUNCTION</span>()</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">StopJump</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 <code>FPSCharacter.cpp</code> 中，将以下函数定义添加到代码底部：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::StartJump</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   bPressedJump = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::StopJump</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   bPressedJump = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>现在，将以下代码添加到 <code>SetupPlayerInputComponent</code>，以便将跳跃操作与刚才编写的函数绑定：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置&quot;操作&quot;绑定。</span></span><br><span class="line">PlayerInputComponent-&gt;<span class="built_in">BindAction</span>(<span class="string">&quot;Jump&quot;</span>, IE_Pressed, <span class="keyword">this</span>, &amp;AFPSCharacter::StartJump);</span><br><span class="line">PlayerInputComponent-&gt;<span class="built_in">BindAction</span>(<span class="string">&quot;Jump&quot;</span>, IE_Released, <span class="keyword">this</span>, &amp;AFPSCharacter::StopJump);</span><br></pre></td></tr></table></figure>
</li>
<li><p>现在 <code>FPSCharacter.cpp</code> 的内容应如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版权所有Epic Games, Inc。保留所有权利。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;FPSCharacter.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置默认值</span></span><br><span class="line">AFPSCharacter::<span class="built_in">AFPSCharacter</span>()</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 将此角色设置为每帧调用Tick()。  如果不需要此特性，可以关闭以提升性能。</span></span><br><span class="line">   PrimaryActorTick.bCanEverTick = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当游戏开始或重生（Spawn）时被调用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::BeginPlay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Super::<span class="built_in">BeginPlay</span>();</span><br><span class="line"></span><br><span class="line">   <span class="built_in">check</span>(GEngine != <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 显示调试消息五秒。 </span></span><br><span class="line">   <span class="comment">// -1&quot;键&quot;值参数可以防止更新或刷新消息。</span></span><br><span class="line">     GEngine-&gt;<span class="built_in">AddOnScreenDebugMessage</span>(<span class="number">-1</span>, <span class="number">5.0f</span>, FColor::Red, <span class="built_in">TEXT</span>(<span class="string">&quot;We are using FPSCharacter.&quot;</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每一帧都被调用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::Tick</span><span class="params">( <span class="type">float</span> DeltaTime )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Super::<span class="built_in">Tick</span>( DeltaTime );</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 被调用，将功能与输入绑定</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::SetupPlayerInputComponent</span><span class="params">(UInputComponent* PlayerInputComponent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Super::<span class="built_in">SetupPlayerInputComponent</span>(PlayerInputComponent);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 设置&quot;移动&quot;绑定。</span></span><br><span class="line">   PlayerInputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="string">&quot;MoveForward&quot;</span>, <span class="keyword">this</span>, &amp;AFPSCharacter::MoveForward);</span><br><span class="line">   PlayerInputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="string">&quot;MoveRight&quot;</span>, <span class="keyword">this</span>, &amp;AFPSCharacter::MoveRight);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 设置&quot;观看&quot;绑定。</span></span><br><span class="line">   PlayerInputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="string">&quot;Turn&quot;</span>, <span class="keyword">this</span>, &amp;AFPSCharacter::AddControllerYawInput);</span><br><span class="line">   PlayerInputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="string">&quot;LookUp&quot;</span>, <span class="keyword">this</span>, &amp;AFPSCharacter::AddControllerPitchInput);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 设置&quot;操作&quot;绑定。</span></span><br><span class="line">   PlayerInputComponent-&gt;<span class="built_in">BindAction</span>(<span class="string">&quot;Jump&quot;</span>, IE_Pressed, <span class="keyword">this</span>, &amp;AFPSCharacter::StartJump);</span><br><span class="line">   PlayerInputComponent-&gt;<span class="built_in">BindAction</span>(<span class="string">&quot;Jump&quot;</span>, IE_Released, <span class="keyword">this</span>, &amp;AFPSCharacter::StopJump);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::MoveForward</span><span class="params">(<span class="type">float</span> Value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// 找出&quot;前进&quot;方向，并记录玩家想向该方向移动。</span></span><br><span class="line">   FVector Direction = <span class="built_in">FRotationMatrix</span>(Controller-&gt;<span class="built_in">GetControlRotation</span>()).<span class="built_in">GetScaledAxis</span>(EAxis::X);</span><br><span class="line">   <span class="built_in">AddMovementInput</span>(Direction, Value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::MoveRight</span><span class="params">(<span class="type">float</span> Value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// 找出&quot;右侧&quot;方向，并记录玩家想向该方向移动。</span></span><br><span class="line">   FVector Direction = <span class="built_in">FRotationMatrix</span>(Controller-&gt;<span class="built_in">GetControlRotation</span>()).<span class="built_in">GetScaledAxis</span>(EAxis::Y);</span><br><span class="line">   <span class="built_in">AddMovementInput</span>(Direction, Value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::StartJump</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   bPressedJump = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::StopJump</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   bPressedJump = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="测试角色跳跃"><a href="#测试角色跳跃" class="headerlink" title="测试角色跳跃"></a>测试角色跳跃</h2><p>现在我们来编译和测试新实现的角色移动函数。</p>
<ol>
<li><p>在VS中保存FPSCharacter 头文件（.h）和C++（.cpp）文件。</p>
</li>
<li><p>在 <strong>解决方案浏览器（Solution Explorer）</strong> 中找到 <strong>FPSProject</strong>。</p>
</li>
<li><p>右键点击 <strong>FPSProject</strong> 并选择 <strong>构建（Build）</strong>，编译你的项目。</p>
</li>
<li><p>构建完毕后，在虚幻引擎中打开 <strong>FPSProject</strong>。</p>
</li>
<li><p>在关卡编辑器工具栏中点击 <strong>运行（Play）</strong>。你应该能够在地图上跳跃。</p>
</li>
<li><p>按 <strong>退出（Escape）</strong> 键或在关卡编辑器中点击 <strong>停止（Stop）</strong>，退出PIE模式。</p>
</li>
</ol>
<p>步骤完成</p>
<h1 id="将网格体添加到角色"><a href="#将网格体添加到角色" class="headerlink" title="将网格体添加到角色"></a>将网格体添加到角色</h1><p>通过以下链接下载并提取示例网格体：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.unrealengine.com/4.27/Attachments/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/6/GenericMale.zip">示例网格体</a></li>
</ul>
<p>在此步骤中，你将为角色提供骨骼网格体。默认情况下，角色类为你创建了SkeletalMeshComponent对象，因此仅需了解使用哪个SkeletalMesh资产。</p>
<h2 id="导入骨骼网格体"><a href="#导入骨骼网格体" class="headerlink" title="导入骨骼网格体"></a>导入骨骼网格体</h2><ol>
<li><p>导航返回内容浏览器文件框内的内容（Content）文件夹。</p>
</li>
<li><p>现在，右键点击内容浏览器的文件框，打开 <strong>导入资产（Import Asset）</strong> 对话框。</p>
</li>
<li><p>点击 **‘导入&#x2F;游戏…（Import to &#x2F;Game…）’**，打开 <strong>导入（Import）</strong> 对话框。</p>
</li>
<li><p>找到并选择 <strong>GenericMale.fbx</strong> 网格体文件。</p>
</li>
<li><p>点击 <strong>打开（Open）</strong>，开始将网格体导入到你的项目中。</p>
</li>
<li><p><strong>内容浏览器（Content Browser）</strong> 中将显示 <strong>FBX导入选项（FBX Import Options）</strong> 对话框。点击 <strong>全部导入（Import All）</strong>，将你的网格体添加到项目。</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/ImportGenericMale.jpg" alt="ImportGenericMale.png"></p>
</li>
<li><p>点击 <strong>保存（Save）</strong> 按钮保存导入的网格体。</p>
</li>
</ol>
<h2 id="设置第三人称网格体"><a href="#设置第三人称网格体" class="headerlink" title="设置第三人称网格体"></a>设置第三人称网格体</h2><ol>
<li><p>在 <strong>内容（Content）</strong> &gt; <strong>蓝图（Blueprints）</strong> 中，双击 <strong>BP_FPSCharacter</strong> 蓝图类图标，在 <strong>蓝图编辑器</strong> 中打开它。</p>
<p>如果你看到有关此蓝图为仅数据蓝图的说明，请点击 <strong>打开完整蓝图编辑器（Open Full Blueprint Editor）</strong>。</p>
</li>
<li><p>在 <strong>组件（Components）</strong> 选项卡中点击 <strong>网格体（Mesh）</strong> 组件。</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/MeshComponent.jpg" alt="MeshComponent.png"></p>
</li>
<li><p>滚动到 <strong>细节（Details）</strong> 选项卡（屏幕右侧，或在 <strong>窗口（Window）</strong> &gt; <strong>细节（Details）</strong> 中）的 <strong>网格体（Mesh）</strong> 段。</p>
</li>
<li><p>点击骨骼网格体（Skeletal Mesh）行中显示为”无”的下拉列表，然后选择 <strong>GenericMale</strong> 骨骼网格体。</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/SelectSkeletalMesh.jpg" alt="SelectSkeletalMesh.png"></p>
</li>
<li><p>滚动到 <strong>细节（Details）</strong> 窗格中的 <strong>变换（Transform）</strong> 段，然后，将变换的 <strong>Z</strong> 轴向位置设置为 **”-88.0”**，使 <code>SkeletalMeshComponent</code> 与 <code>CapsuleComponent</code> 对齐。</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/NewZLoc_Mesh.jpg" alt="NewZLoc_Mesh.png"></p>
</li>
<li><p>打开视口（Viewport）预览骨骼网格体。骨骼网格体应该如下图所示：</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/SkeletalMeshLocation.jpg" alt="SkeletalMeshLocation.png"></p>
<p>确认骨骼网格体在 <code>CapsuleComponent</code> 内部，并且网格体的朝向与 <code>ArrowComponent</code> 相同。正确确定骨骼网格体组件的朝向，将确保你的角色朝正确的方向在整个世界中移动。</p>
</li>
<li><p>请确保在关闭 <strong>蓝图编辑器（Blueprint Editor）</strong> 之前 <strong>编译（Compile)</strong> 并 <strong>保存（Save）</strong> <strong>BP_FPSCharacter</strong> 蓝图。</p>
</li>
</ol>
<h2 id="确认处于PIE模式的新网格体"><a href="#确认处于PIE模式的新网格体" class="headerlink" title="确认处于PIE模式的新网格体"></a>确认处于PIE模式的新网格体</h2><p>现在可在编辑器中查看新增网格体。</p>
<ol>
<li><p>在关卡编辑器工具栏中点击 <strong>运行（Play）</strong> 按钮。在你四处移动时，你应该能看到角色的影子。</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/PawnwithShadow.jpg" alt="PawnwithShadow.png"></p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/Section0206.jpg" alt="Section0206.gif"></p>
<p>如果你要在编辑器的视口中查看角色的网格体，请按F8键，使自己从pawn中弹出来。按下F8键后，你将可以在关卡中自由移动摄像机。要移动摄像机，请在移动鼠标的同时按住鼠标左键。</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/FreelyMovingCamera.jpg" alt="FreelyMovingCamera.png"></p>
</li>
<li><p>按 <strong>退出（Escape）</strong> 键或在关卡编辑器中点击 <strong>停止（Stop）</strong> 按钮，退出在编辑器中运行（Play in Editor）（PIE）模式。</p>
</li>
</ol>
<h1 id="更改摄像机视角"><a href="#更改摄像机视角" class="headerlink" title="更改摄像机视角"></a>更改摄像机视角</h1><p>在上一步结束时，默认摄像机放置在网格体的颈部。在此步骤中，你将设置FPS摄像机，这样你可以调整摄像机的属性（例如位置和视野）。 在开始之前，你需要在 <code>FPSCharacter.h</code> 中包含更多的头文件。这将使你的代码可以访问更多与摄像机相关的函数，并最终使你能够操纵摄像机的位置。</p>
<ol>
<li><p>打开Visual Studio项目，然后导航至 <code>FPSCharacter.h</code>。</p>
</li>
<li><p>将以下头文件添加到 <code>FPSCharacter.h</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;Camera/CameraComponent.h&quot;</span><br><span class="line">#include &quot;Components/CapsuleComponent.h&quot;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="附加摄像机组件"><a href="#附加摄像机组件" class="headerlink" title="附加摄像机组件"></a>附加摄像机组件</h3><ol>
<li><p>打开 <code>FPSCharacter.h</code>，添加以下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// FPS摄像机。</span><br><span class="line">UPROPERTY(VisibleAnywhere)</span><br><span class="line">UCameraComponent* FPSCameraComponent;</span><br></pre></td></tr></table></figure>
</li>
<li><p>现在 <code>FPSCharacter.h</code> 的内容应如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">//版权所有Epic Games, Inc。保留所有权利。</span><br><span class="line"></span><br><span class="line">#pragma once</span><br><span class="line"></span><br><span class="line">#include &quot;CoreMinimal.h&quot;</span><br><span class="line">#include &quot;GameFramework/Character.h&quot;</span><br><span class="line">#include &quot;Camera/CameraComponent.h&quot;</span><br><span class="line">#include &quot;Components/CapsuleComponent.h&quot;</span><br><span class="line">#include &quot;FPSCharacter.generated.h&quot;</span><br><span class="line"></span><br><span class="line">UCLASS()</span><br><span class="line">class FPSPROJECT_API AFPSCharacter : public ACharacter</span><br><span class="line">&#123;</span><br><span class="line">GENERATED_BODY()</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">// 为此角色的属性设置默认值</span><br><span class="line">AFPSCharacter();</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line">// 当游戏开始或重生（Spawn）时被调用</span><br><span class="line">virtual void BeginPlay() override;</span><br><span class="line"></span><br><span class="line">public:     </span><br><span class="line">// 每一帧都被调用</span><br><span class="line">virtual void Tick( float DeltaTime ) override;</span><br><span class="line"></span><br><span class="line">// 被调用，将功能与输入绑定</span><br><span class="line">virtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;</span><br><span class="line"></span><br><span class="line">// 处理用于前后移动的输入。</span><br><span class="line">UFUNCTION()</span><br><span class="line">void MoveForward(float Value);</span><br><span class="line"></span><br><span class="line">// 处理用于左右移动的输入。</span><br><span class="line">UFUNCTION()</span><br><span class="line">void MoveRight(float Value);</span><br><span class="line"></span><br><span class="line">// 按下键时，设置跳跃标记。</span><br><span class="line">UFUNCTION()</span><br><span class="line">void StartJump();</span><br><span class="line"></span><br><span class="line">// 释放键时，清除跳跃标记。</span><br><span class="line">UFUNCTION()</span><br><span class="line">void StopJump();</span><br><span class="line"></span><br><span class="line">// FPS摄像机</span><br><span class="line">UPROPERTY(VisibleAnywhere)</span><br><span class="line">UCameraComponent* FPSCameraComponent;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>打开 <code>FPSCharacter.cpp</code>，将以下代码添加到构造函数中： <code>PrimaryActorTick.bCanEverTick = true:</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 创建第一人称摄像机组件。</span><br><span class="line">FPSCameraComponent = CreateDefaultSubobject&lt;UCameraComponent&gt;(TEXT(&quot;FirstPersonCamera&quot;));</span><br><span class="line">check(FPSCameraComponent != nullptr);</span><br><span class="line"></span><br><span class="line">// 将摄像机组件附加到我们的胶囊体组件。</span><br><span class="line">FPSCameraComponent-&gt;SetupAttachment(CastChecked&lt;USceneComponent, UCapsuleComponent&gt;(GetCapsuleComponent()));</span><br></pre></td></tr></table></figure>

<p>此代码创建 <code>UCameraComponent</code>，并将其附加到角色的 <code>CapsuleComponent</code>。</p>
</li>
<li><p>现在，将以下代码添加到你刚刚在构造函数中编写的代码块下面：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 将摄像机置于略高于眼睛上方的位置。</span><br><span class="line">FPSCameraComponent-&gt;SetRelativeLocation(FVector(0.0f, 0.0f, 50.0f + BaseEyeHeight));</span><br><span class="line"></span><br><span class="line">// 启用Pawn控制摄像机旋转。</span><br><span class="line">FPSCameraComponent-&gt;bUsePawnControlRotation = true;</span><br></pre></td></tr></table></figure>

<p>此代码将摄像机的位置调整为略高于角色眼睛的位置，同时允许pawn控制摄像机的旋转。</p>
<p><code>SetRelativeLocation</code> 用于设置组件的默认值。不过，上一个值仍然会在设置在编辑器中。为纠正这点，请打开蓝图编辑器。点击 <code>FPSCameraComponent</code>，然后在 <strong>细节</strong> 面板中找到 <strong>变换 -&gt; 位置（Transform -&gt; Location）</strong> 数值。点击这个值旁边的 <strong>重置为默认（Reset to Default）</strong>。</p>
</li>
<li><p>现在 <code>FPSCharacter.cpp</code> 的内容应如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">//版权所有Epic Games, Inc。保留所有权利。</span><br><span class="line"></span><br><span class="line">#include &quot;FPSCharacter.h&quot;</span><br><span class="line"></span><br><span class="line">// 设置默认值</span><br><span class="line">AFPSCharacter::AFPSCharacter()</span><br><span class="line">&#123;</span><br><span class="line">   // 将此角色设置为每帧调用Tick()。  如果不需要此特性，可以关闭以提升性能。</span><br><span class="line">   PrimaryActorTick.bCanEverTick = true;</span><br><span class="line"></span><br><span class="line">   // 创建第一人称摄像机组件。</span><br><span class="line">   FPSCameraComponent = CreateDefaultSubobject&lt;UCameraComponent&gt;(TEXT(&quot;FirstPersonCamera&quot;));</span><br><span class="line">   check(FPSCameraComponent != nullptr);</span><br><span class="line"></span><br><span class="line">   // 将摄像机组件附加到我们的胶囊体组件。</span><br><span class="line">   FPSCameraComponent-&gt;SetupAttachment(CastChecked&lt;USceneComponent, UCapsuleComponent&gt;(GetCapsuleComponent()));</span><br><span class="line"></span><br><span class="line">   // 将摄像机置于略高于眼睛上方的位置。</span><br><span class="line">   FPSCameraComponent-&gt;SetRelativeLocation(FVector(0.0f, 0.0f, 50.0f + BaseEyeHeight));</span><br><span class="line"></span><br><span class="line">   // 启用Pawn控制摄像机旋转。</span><br><span class="line">   FPSCameraComponent-&gt;bUsePawnControlRotation = true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 当游戏开始或重生（Spawn）时被调用</span><br><span class="line">void AFPSCharacter::BeginPlay()</span><br><span class="line">&#123;</span><br><span class="line">   Super::BeginPlay();</span><br><span class="line"></span><br><span class="line">   check(GEngine != nullptr)</span><br><span class="line"></span><br><span class="line">     // 显示调试消息五秒。 </span><br><span class="line">    // -1&quot;键&quot;值（第一个参数）表示我们从不需要更新或刷新此消息。</span><br><span class="line">     GEngine-&gt;AddOnScreenDebugMessage(-1, 5.0f, FColor::Red, TEXT(&quot;We are using FPSCharacter.&quot;));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 每一帧都被调用</span><br><span class="line">void AFPSCharacter::Tick( float DeltaTime )</span><br><span class="line">&#123;</span><br><span class="line">   Super::Tick( DeltaTime );</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 被调用，将功能与输入绑定</span><br><span class="line">void AFPSCharacter::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)</span><br><span class="line">&#123;</span><br><span class="line">   Super::SetupPlayerInputComponent(PlayerInputComponent);</span><br><span class="line"></span><br><span class="line">   // 设置&quot;移动&quot;绑定。</span><br><span class="line">   PlayerInputComponent-&gt;BindAxis(&quot;MoveForward&quot;, this, &amp;AFPSCharacter::MoveForward);</span><br><span class="line">   PlayerInputComponent-&gt;BindAxis(&quot;MoveRight&quot;, this, &amp;AFPSCharacter::MoveRight);</span><br><span class="line"></span><br><span class="line">   // 设置&quot;观看&quot;绑定。</span><br><span class="line">   PlayerInputComponent-&gt;BindAxis(&quot;Turn&quot;, this, &amp;AFPSCharacter::AddControllerYawInput);</span><br><span class="line">   PlayerInputComponent-&gt;BindAxis(&quot;LookUp&quot;, this, &amp;AFPSCharacter::AddControllerPitchInput);</span><br><span class="line"></span><br><span class="line">   // 设置&quot;操作&quot;绑定。</span><br><span class="line">   PlayerInputComponent-&gt;BindAction(&quot;Jump&quot;, IE_Pressed, this, &amp;AFPSCharacter::StartJump);</span><br><span class="line">   PlayerInputComponent-&gt;BindAction(&quot;Jump&quot;, IE_Released, this, &amp;AFPSCharacter::StopJump);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void AFPSCharacter::MoveForward(float Value)</span><br><span class="line">&#123;</span><br><span class="line">   // 找出&quot;前进&quot;方向，并记录玩家想向该方向移动。</span><br><span class="line">   FVector Direction = FRotationMatrix(Controller-&gt;GetControlRotation()).GetScaledAxis(EAxis::X);</span><br><span class="line">   AddMovementInput(Direction, Value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void AFPSCharacter::MoveRight(float Value)</span><br><span class="line">&#123;</span><br><span class="line">   // 找出&quot;右侧&quot;方向，并记录玩家想向该方向移动。</span><br><span class="line">   FVector Direction = FRotationMatrix(Controller-&gt;GetControlRotation()).GetScaledAxis(EAxis::Y);</span><br><span class="line">   AddMovementInput(Direction, Value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void AFPSCharacter::StartJump()</span><br><span class="line">&#123;</span><br><span class="line">   bPressedJump = true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void AFPSCharacter::StopJump()</span><br><span class="line">&#123;</span><br><span class="line">   bPressedJump = false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="测试新摄像机"><a href="#测试新摄像机" class="headerlink" title="测试新摄像机"></a>测试新摄像机</h3><p>现在我们来编译和测试新实现的摄像机代码。</p>
<ol>
<li><p>在Visual Studio中保存 <code>FPSCharacter</code> 头文件（.h）和C++（.cpp）文件。</p>
</li>
<li><p>在 <strong>解决方案浏览器（Solution Explorer）</strong> 中找到 <strong>FPSProject</strong>。</p>
</li>
<li><p>右键点击 <strong>FPSProject</strong> 并选择 <strong>构建（Build）</strong>，编译你的项目。</p>
</li>
<li><p>构建完毕后，在虚幻引擎中打开 <strong>FPSProject</strong>。</p>
</li>
<li><p>在关卡编辑器工具栏中点击 <strong>运行（Play）</strong>。</p>
</li>
</ol>
<p>现在，摄像机应该略高于角色的头部。</p>
<p>你还可以通过打开BP_FPSCharacter视口来确认新添加的摄像机组件。 <img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/NewCameraComponent.jpg" alt="NewCameraComponent.png"></p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/NewCameraPosition.jpg" alt="NewCameraPosition.png"></p>
<h1 id="将第一人称网格体添加到角色"><a href="#将第一人称网格体添加到角色" class="headerlink" title="将第一人称网格体添加到角色"></a>将第一人称网格体添加到角色</h1><p>构建FPS游戏的常见方法是使用两个分开的角色网格体，其中一个是全身网格体，另一个是”武器和手部”网格体。全身网格体用于从第三人称视角观察角色。但是，当玩家以第一人称视角进行游戏时，全身网格体是隐藏的。”武器和手部”网格体通常附着到摄像机，并且仅当玩家以第一人称视角查看地图时才对玩家可见。在此步骤中，你将向角色添加第一人称网格体。</p>
<h3 id="添加第一人称角色网格体"><a href="#添加第一人称角色网格体" class="headerlink" title="添加第一人称角色网格体"></a>添加第一人称角色网格体</h3><ol>
<li><p>切换回Visual Studio并打开 <code>FPSCharacter.h</code>，在 <strong>public:</strong> 下添加以下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 第一人称网格体（手臂），仅对所属玩家可见。</span><br><span class="line">UPROPERTY(VisibleDefaultsOnly, Category = Mesh)</span><br><span class="line">USkeletalMeshComponent* FPSMesh;</span><br></pre></td></tr></table></figure>
</li>
<li><p>现在，打开 <code>FPSCharacter.cpp</code>，找到构造函数，添加以下代码，创建和配置第一人称网格体：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 为所属玩家创建第一人称网格体组件。</span><br><span class="line">FPSMesh = CreateDefaultSubobject&lt;USkeletalMeshComponent&gt;(TEXT(&quot;FirstPersonMesh&quot;));</span><br><span class="line">check(FPSMesh != nullptr);</span><br><span class="line"></span><br><span class="line">// 仅所属玩家可以看见此网格体。</span><br><span class="line">FPSMesh-&gt;SetOnlyOwnerSee(true);</span><br><span class="line"></span><br><span class="line">// 将 FPS 网格体附加到 FPS 摄像机。</span><br><span class="line">FPSMesh-&gt;SetupAttachment(FPSCameraComponent);</span><br><span class="line"></span><br><span class="line">// 禁用某些环境阴影以便实现只有单个网格体的感觉。</span><br><span class="line">FPSMesh-&gt;bCastDynamicShadow = false;</span><br><span class="line">FPSMesh-&gt;CastShadow = false;</span><br></pre></td></tr></table></figure>

<p><code>SetOnlyOwnerSee</code> 表示此网格体仅对拥有此角色的 <code>PlayerController</code> 可见。此代码还将网格体附加到摄像机，并禁用某些环境阴影。让手臂投射阴影会破坏第一人称角色应该只有单个网格体的感觉。</p>
</li>
<li><p>最后，将以下代码添加到FPSCharacter.cpp的构造函数中，以便隐藏所属角色的现有第三人称网格体：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 所属玩家看不到常规（第三人称）全身网格体。</span><br><span class="line">GetMesh()-&gt;SetOwnerNoSee(true);</span><br></pre></td></tr></table></figure>
</li>
<li><p>在Visual Studio中保存FPSCharacter头文件（.h）和实现（.cpp）文件。</p>
</li>
<li><p>在 <strong>解决方案浏览器（Solution Explorer）</strong> 中找到 <strong>FPSProject</strong>。</p>
</li>
<li><p>右键点击 <strong>FPSProject</strong> 并选择 <strong>构建（Build）</strong>，编译你的项目。</p>
</li>
<li><p>构建完成后，打开并以PIE模式运行 <strong>FPSProject</strong>。</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/HiddenMeshInGame.jpg" alt="HiddenMeshInGame.png"></p>
</li>
</ol>
<p>此时，你的角色网格体在编辑器中应该不可见。</p>
<p>如果你仍然看到网格体及其阴影投射，请关闭并重新启动编辑器。</p>
<h3 id="构建网格体蓝图"><a href="#构建网格体蓝图" class="headerlink" title="构建网格体蓝图"></a>构建网格体蓝图</h3><p>在继续之前，请通过以下链接下载并提取示例网格体： <a target="_blank" rel="noopener" href="https://docs.unrealengine.com/4.27/Attachments/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/8/HeroFPP.zip">“第一人称骨骼网格体”</a></p>
<ol>
<li><p>右键点击内容浏览器的文件框，打开 <strong>导入资产（Import Asset）</strong> 对话框。</p>
</li>
<li><p>点击 <strong>导入&#x2F;游戏…（Import to &#x2F;Game…）</strong>，打开 <strong>导入（Import）</strong> 对话框。</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/RightClickImport.jpg" alt="RightClickImport.png"></p>
</li>
<li><p>找到并选择 <strong>HeroFPP.fbx</strong> 网格体文件。</p>
</li>
<li><p>点击 <strong>打开（Open）</strong>，开始将网格体导入到你的项目中。</p>
</li>
<li><p><strong>内容浏览器（Content Browser）</strong> 中将显示 <strong>FBX导入选项（FBX Import Options）</strong> 对话框。</p>
</li>
<li><p>请确保将 <strong>骨架（Skeleton）</strong> 设置为 <strong>无（None）</strong>，然后点击 <strong>全部导入（Import All）</strong>。</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/ClearSkeletonMesh.jpg" alt="ClearSkeletonMesh.png"></p>
</li>
<li><p>关闭以下消息日志。  </p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/FBXWarning.jpg" alt="FBXWarning.png">  </p>
<p>此网格体仍展示第一人称网格体设置，它将与你在后面分段中设置的动画一起使用。</p>
</li>
<li><p>点击 <strong>保存（Save）</strong>，保存导入的网格体。</p>
</li>
<li><p>导航返回 <strong>内容浏览器（Content Browser）</strong> 中的 <strong>蓝图（Blueprints）</strong> 文件夹。</p>
</li>
<li><p>双击 <strong>BP_FPSCharacter</strong> 图标，在 <strong>蓝图编辑器</strong> 中打开它。</p>
</li>
<li><p>在 <strong>组件（Components）</strong> 选项卡中找到新的 <strong>FPSMesh</strong> 组件。首先，你可能需要打开 <strong>完整的蓝图编辑器</strong>。</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/LocateFPSMeshComponent.jpg" alt="LocateFPSMeshComponent.png">  </p>
<p><strong>FPSMesh</strong> 组件是 <strong>FPSCameraComponent</strong> 组件的子项，这意味着它将始终附加到摄像机。</p>
</li>
<li><p>在 <strong>组件（Components）</strong> 菜单中点击 <strong>FPSMesh</strong>。</p>
</li>
<li><p>滚动到 <strong>细节（Details）</strong> 选项卡的 <strong>网格体（Mesh）</strong> 段，然后点击显示为”无（None）”的下拉菜单。现在，选择 <strong>HeroFPP</strong> 骨骼网格体，将手臂添加到 <strong>视口（Viewport）</strong>。</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/SelectHeroFPPSkeletalMesh.jpg" alt="SelectHeroFPPSkeletalMesh.png"></p>
</li>
<li><p>在 <strong>视口（Viewport）</strong> 中，新增的 <strong>HeroFPP</strong> 骨骼网格体应如下图所示。</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/HeroFPPMesh_Viewport.jpg" alt="HeroFPPMesh_Viewport.png"></p>
</li>
<li><p>将新增网格体的变换属性调整为在摄像机前面：将其 <strong>位置（Location）</strong> 设置为{220, 0, 35}，将其 <strong>旋转（Rotation）</strong> 设置为{180, 50, 180}。</p>
<p><a target="_blank" rel="noopener" href="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/AdjustingArmsTransform.png"><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/AdjustingArmsTransform.jpg" alt="AdjustingArmsTransform.png"></a></p>
<p>点击查看大图。</p>
</li>
<li><p>请确保在关闭 <strong>蓝图编辑器（Blueprint Editor）</strong> 之前 <strong>编译（Compile)</strong> 并 <strong>保存（Save）</strong> <strong>BP_FPSCharacter</strong> 蓝图。</p>
</li>
</ol>
<h3 id="在游戏中查看新网格体"><a href="#在游戏中查看新网格体" class="headerlink" title="在游戏中查看新网格体"></a>在游戏中查看新网格体</h3><ol>
<li><p>点击 <strong>关卡编辑器工具栏</strong> 中的 <strong>运行（Play）</strong> 按钮**，在游戏中查看新网格体。</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/Section0208.jpg" alt="Section0208.gif"></p>
</li>
<li><p>按 <strong>退出（Escape）</strong> 键或在关卡编辑器中点击 <strong>停止（Stop）</strong> 按钮，退出在编辑器中运行（Play in Editor）（PIE）模式。</p>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/27/UE4-API/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="williny">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Williny'home">
      <meta itemprop="description" content="孤独是人生的常态">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Williny'home">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/04/27/UE4-API/" class="post-title-link" itemprop="url">UE4-API</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-04-27 09:06:23 / 修改时间：14:34:34" itemprop="dateCreated datePublished" datetime="2022-04-27T09:06:23+08:00">2022-04-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/unreal-engine/" itemprop="url" rel="index"><span itemprop="name">unreal engine</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>在这里记录一些目前遇到的unreal engine中的API</p>
<h1 id="组件与碰撞"><a href="#组件与碰撞" class="headerlink" title="组件与碰撞"></a>组件与碰撞</h1><p>在官方案例——<a target="_blank" rel="noopener" href="https://docs.unrealengine.com/4.27/zh-CN/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/Components/">组件与碰撞</a>中的API</p>
<h2 id="CreateDefaultSubject-lt-gt"><a href="#CreateDefaultSubject-lt-gt" class="headerlink" title="CreateDefaultSubject&lt;&gt;()"></a>CreateDefaultSubject&lt;&gt;()</h2><p>创建默认子网格体&lt;&gt;中是子网格体的类型</p>
<p><code>USphereComponent* SphereComponent = CreateDefaultSubobject&lt;USphereComponent&gt;(TEXT(&quot;RootComponent&quot;))</code></p>
<h2 id="InitSphereRadius"><a href="#InitSphereRadius" class="headerlink" title="InitSphereRadius()"></a>InitSphereRadius()</h2><p>初始化球体半径</p>
<p><code>SphereComponent-&gt;InitSphereRadius(40.0f);</code></p>
<h2 id="SetCollisionProfileName"><a href="#SetCollisionProfileName" class="headerlink" title="SetCollisionProfileName()"></a>SetCollisionProfileName()</h2><p>设置碰撞预设名称</p>
<p><code>SphereComponent-&gt;SetCollisionProfileName(TEXT(&quot;Pawn&quot;));</code></p>
<h2 id="SetupAttachment"><a href="#SetupAttachment" class="headerlink" title="SetupAttachment()"></a>SetupAttachment()</h2><p>将某组件添加到括号内的组件上</p>
<p><code>SphereVisual-&gt;SetupAttachment(RootComponent);</code></p>
<h2 id="static-ConstructorHelpers-FObjectFinder-lt-gt"><a href="#static-ConstructorHelpers-FObjectFinder-lt-gt" class="headerlink" title="static ConstructorHelpers::FObjectFinder&lt;&gt;"></a>static ConstructorHelpers::FObjectFinder&lt;&gt;</h2><p>直接在代码中设置静态网格体资源</p>
<p><code>static ConstructorHelpers::FObjectFinder&lt;UStaticMesh&gt; SphereVisualAsset(TEXT(&quot;/Game/StarterContent/Shapes/Shape_Sphere.Shape_Sphere&quot;));</code></p>
<h2 id="SetStaticMesh"><a href="#SetStaticMesh" class="headerlink" title="SetStaticMesh()"></a>SetStaticMesh()</h2><p>将找到的网格体附加到括号内的组件上</p>
<p>SphereVisual-&gt;SetStaticMesh(SphereVisualAsset.Object);</p>
<h2 id="SetRelativeLocation"><a href="#SetRelativeLocation" class="headerlink" title="SetRelativeLocation()"></a>SetRelativeLocation()</h2><p>设置相对位置</p>
<p><code>SphereVisual-&gt;SetRelativeLocation(FVector(0.0f, 0.0f, -40.0f));</code></p>
<h2 id="SetWorldScale3D"><a href="#SetWorldScale3D" class="headerlink" title="SetWorldScale3D()"></a>SetWorldScale3D()</h2><p>设置缩放大小</p>
<p><code>SphereVisual-&gt;SetWorldScale3D(FVector(0.8f));</code></p>
<h2 id="bAutoActivate"><a href="#bAutoActivate" class="headerlink" title="bAutoActivate"></a>bAutoActivate</h2><p>粒子效果开关</p>
<p><code>OurParticleSystem-&gt;bAutoActivate = false;</code></p>
<h2 id="SetTemplate"><a href="#SetTemplate" class="headerlink" title="SetTemplate"></a>SetTemplate</h2><p>给粒子系统设定模板</p>
<p><code>OurParticleSystem-&gt;SetTemplate(ParticleAsset.Object);</code></p>
<h2 id="TargetArmLength"><a href="#TargetArmLength" class="headerlink" title="TargetArmLength"></a>TargetArmLength</h2><p>弹簧臂长度</p>
<p><code>SpringArm-&gt;TargetArmLength = 400.0f;</code></p>
<h2 id="bEnableCameraLag"><a href="#bEnableCameraLag" class="headerlink" title="bEnableCameraLag"></a>bEnableCameraLag</h2><p>弹簧臂平滑效果开关</p>
<p><code>SpringArm-&gt;bEnableCameraLag = true;</code></p>
<h2 id="CameraLagSpeed"><a href="#CameraLagSpeed" class="headerlink" title="CameraLagSpeed"></a>CameraLagSpeed</h2><p>平滑效果切换速度</p>
<p><code>SpringArm-&gt;CameraLagSpeed = 3.0f;</code></p>
<h2 id="SocketName"><a href="#SocketName" class="headerlink" title="SocketName"></a>SocketName</h2><p>弹簧臂插槽</p>
<p><code>Camera-&gt;SetupAttachment(SpringArm, USpringArmComponent::SocketName);</code></p>
<h2 id="AutoPossessPlayer"><a href="#AutoPossessPlayer" class="headerlink" title="AutoPossessPlayer"></a>AutoPossessPlayer</h2><p>默认控制玩家</p>
<p><code>AutoPossessPlayer = EAutoReceiveInput::Player0;</code></p>
<h2 id="UpdatedComonent"><a href="#UpdatedComonent" class="headerlink" title="UpdatedComonent"></a>UpdatedComonent</h2><p>更新某组件</p>
<p><code>OurMovementComponent-&gt;UpdatedComponent = RootComponent;</code></p>
<h2 id="BindAxtion"><a href="#BindAxtion" class="headerlink" title="BindAxtion()"></a>BindAxtion()</h2><p>绑定输入映射</p>
<p><code>InInputComponent-&gt;BindAction(&quot;ParticleToggle&quot;, IE_Pressed, this, &amp;ACollidingPawn::ParticleToggle);</code></p>
<ul>
<li><p>参数一：为 虚幻4-&gt;设置 -&gt;输入-&gt;按键绑定的名称</p>
</li>
<li><p>参数二：事件名称 IE_Pressed 按下 IE_Released松开 IE_DoubleClick双击</p>
</li>
<li><p>参数三：当前对象——this</p>
</li>
<li><p>参数四：事件方法的函数指针 例 &amp;类名::方法名的写法</p>
</li>
</ul>
<h2 id="BindAxis"><a href="#BindAxis" class="headerlink" title="BindAxis()"></a>BindAxis()</h2><p>绑定轴映射</p>
<p><code>InInputComponent-&gt;BindAxis(&quot;MoveForward&quot;, this, &amp;ACollidingPawn::MoveForward);</code></p>
<ul>
<li><p>参数一：为 虚幻4-&gt;设置 -&gt;输入-&gt;按键绑定的名称 一定要一样 重要！！！ </p>
</li>
<li><p>参数二 ：当前对象——this</p>
</li>
<li><p>参数三 事件方法的函数指针 例 &amp;类名::方法名 的写法</p>
</li>
</ul>
<h2 id="AddInputVector"><a href="#AddInputVector" class="headerlink" title="AddInputVector()"></a>AddInputVector()</h2><p>根据输入更改Vector位置</p>
<p><code>OurMovementComponent-&gt;AddInputVector(GetActorForwardVector() * AxisValue);</code></p>
<h2 id="GetActorForwardVector"><a href="#GetActorForwardVector" class="headerlink" title="GetActorForwardVector()"></a>GetActorForwardVector()</h2><p>更新Actor向前运动的vector</p>
<p><code>OurMovementComponent-&gt;AddInputVector(GetActorForwardVector() * AxisValue);</code></p>
<h2 id="GetActorRightVector"><a href="#GetActorRightVector" class="headerlink" title="GetActorRightVector()"></a>GetActorRightVector()</h2><p>更新Actor向右运动的vector</p>
<p><code>OurMovementComponent-&gt;AddInputVector(GetActorRightVector() * AxisValue);</code></p>
<h2 id="GetActorRotation"><a href="#GetActorRotation" class="headerlink" title="GetActorRotation()"></a>GetActorRotation()</h2><p>获取Actor的旋转角度</p>
<p><code>FRotator NewRotation = GetActorRotation();</code></p>
<h2 id="SetActorRotation"><a href="#SetActorRotation" class="headerlink" title="SetActorRotation();"></a>SetActorRotation();</h2><p>设置Actor的新角度</p>
<p><code>SetActorRotation(NewRotation);</code></p>
<h2 id="ToggleActive"><a href="#ToggleActive" class="headerlink" title="ToggleActive()"></a>ToggleActive()</h2><p>转换粒子效果状态（开关）</p>
<p><code>OurParticleSystem-&gt;ToggleActive();</code></p>
<p>GetClampedToMaxSize()</p>
<p>用于更新vector的位置</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FVector <span class="title">FVector::GetClampedToMaxSize</span><span class="params">(<span class="type">float</span> MaxSize)</span></span></span><br></pre></td></tr></table></figure>

<p>用于创建一个新的vector，方向与原本的方向一直，距离为MaxSize</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FVector <span class="title">FVector::GetClampedToSize</span><span class="params">(<span class="type">float</span> Min,<span class="type">float</span> Max)</span> </span></span><br></pre></td></tr></table></figure>

<p>创建一个新的Vector，方向与原方向一致</p>
<p>距离为</p>
<ol>
<li><p>若距离&lt;Min，则新的vector距离为Min</p>
</li>
<li><p>若距离&gt;Max，则新的vector距离为Max</p>
</li>
<li><p>若距离在Min和Max之间，则新的vector等于原本的vector</p>
</li>
</ol>
<h2 id="ConsumeInputVector-1-0f"><a href="#ConsumeInputVector-1-0f" class="headerlink" title="ConsumeInputVector(1.0f)"></a>ConsumeInputVector(1.0f)</h2><p>报告并清空用于存储移动输入的内置变量值。</p>
<h2 id="SafeMoveUpdatedComponent"><a href="#SafeMoveUpdatedComponent" class="headerlink" title="SafeMoveUpdatedComponent()"></a>SafeMoveUpdatedComponent()</h2><p><code>SafeMoveUpdatedComponent(const FVector&amp; Delta, const FRotator&amp; NewRotation, bool bSweep, FHitResult&amp; OutHit, ETeleportType Teleport)</code></p>
<p><code>SafeMoveUpdatedComponent(DesiredMovementThisFrame, UpdatedComponent-&gt;GetComponentRotation(), true, Hit);</code></p>
<p>利用虚幻引擎物理移动Pawn移动组件，同时考虑固体障碍。</p>
<ul>
<li><p>第一个参数：要移动的Vector</p>
</li>
<li><p>第二个参数：旋转参数</p>
</li>
<li><p>第三个参数：是否考虑物理障碍（如果为true，将在移动过程中扫描以阻止碰撞。如果为false，它将简单地传送到下一个位置并忽略碰撞。）</p>
</li>
<li><p>第四个参数：碰撞结果</p>
</li>
<li><p>第五个参数：可省略，远距离传送类型</p>
</li>
</ul>
<h2 id="SlideAlongSurface"><a href="#SlideAlongSurface" class="headerlink" title="SlideAlongSurface()"></a>SlideAlongSurface()</h2><p><code>SlideAlongSurface(const FVector&amp; Delta, float Time, const FQuat Rotation, const FVector&amp; Normal, FHitResult&amp; Hit, bool bHandleImpact)</code></p>
<ul>
<li><p>第一个参数：要移动的vector</p>
</li>
<li><p>第二个参数：运动时间</p>
</li>
<li><p>第三个参数：旋转情况（可省略）</p>
</li>
<li><p>第四个参数：vector类型？（这个不太确定）</p>
</li>
<li><p>第五个参数：碰撞结果（必须为bBlockingHit）</p>
</li>
<li><p>第六个参数：手柄反馈？（这个扎找不到源文件）</p>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/25/UE4-HowTo-Components/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="williny">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Williny'home">
      <meta itemprop="description" content="孤独是人生的常态">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Williny'home">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/04/25/UE4-HowTo-Components/" class="post-title-link" itemprop="url">UE4-HowTo_Components</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-04-25 17:08:45" itemprop="dateCreated datePublished" datetime="2022-04-25T17:08:45+08:00">2022-04-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-04-27 09:11:14" itemprop="dateModified" datetime="2022-04-27T09:11:14+08:00">2022-04-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/unreal-engine/" itemprop="url" rel="index"><span itemprop="name">unreal engine</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>官方案例——<a target="_blank" rel="noopener" href="https://docs.unrealengine.com/4.27/zh-CN/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/Components/">解组件和碰撞</a></p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li><p>明确目标：创建一个有物理性质的球体，能和其他物体碰撞，并且拥有火焰粒子效果</p>
</li>
<li><p>创建CollidingPawn</p>
</li>
<li><p>创建这个球体本身需要什么头文件</p>
</li>
<li><p>修改根组件为对物理反应的球体</p>
</li>
<li><p>创建球体并附加到根组件上</p>
</li>
<li><p>将粒子系统直接附加到球体上（不是根组件）</p>
</li>
<li><p>添加弹簧臂组件，并在其上插槽内添加摄像机组件</p>
</li>
<li><p>将此Pawn设为受默认玩家控制</p>
</li>
<li><p>配置输入：编辑-&gt;设置项目-&gt;输入-&gt;操作映射（粒子系统）-&gt;轴映射(移动和转动)</p>
</li>
<li><p>创建Pawn移动组件类（PawnMovementComponent）CollidingPawnMovementComponent</p>
</li>
<li><p>定义TickComonent函数，告知逐帧移动方式</p>
</li>
<li><p>将Pawn移动组件添加到Pawn内</p>
</li>
<li><p>创建Pawn移动组件并将其与Pawn关联，使其更新根组件</p>
</li>
<li><p>声明并定义一些函数处理Pawn会接收的输入</p>
</li>
<li><p>将函数绑定到输入事件</p>
</li>
</ol>
<h1 id="CollidingPawn-h"><a href="#CollidingPawn-h" class="headerlink" title="CollidingPawn.h"></a>CollidingPawn.h</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CoreMinimal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GameFramework/Pawn.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CollidingPawn.generated.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HOWTO_COMPONENTS_API</span> ACollidingPawn : <span class="keyword">public</span> APawn</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 设置此Pawn属性的默认值</span></span><br><span class="line">    <span class="built_in">ACollidingPawn</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// 游戏开始或生成时调用</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BeginPlay</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 逐帧调用</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Tick</span><span class="params">( <span class="type">float</span> DeltaSeconds )</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用以将功能与输入绑定（也就是将要设定的wasd和空格的输入功能）</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SetupPlayerInputComponent</span><span class="params">(<span class="keyword">class</span> UInputComponent* InInputComponent)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明粒子系统（火焰燃烧效果等）</span></span><br><span class="line">    <span class="built_in">UPROPERTY</span>()</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">UParticleSystemComponent</span>* OurParticleSystem;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明移动组件，使其可以追踪变量</span></span><br><span class="line">    <span class="built_in">UPROPERTY</span>()</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">UCollidingPawnMovementComponent</span>* OurMovementComponent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Pawn拥有名为 GetMovementComponent 的函数，用于提供引擎中其他类访问该Pawn当前所用Pawn移动组件的权限。需覆盖该函数，使其返回自定义Pawn移动组件</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> UPawnMovementComponent* <span class="title">GetMovementComponent</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建代码处理pawn接受过来的输入</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">MoveForward</span><span class="params">(<span class="type">float</span> AxisValue)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">MoveRight</span><span class="params">(<span class="type">float</span> AxisValue)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Turn</span><span class="params">(<span class="type">float</span> AxisValue)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ParticleToggle</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="CollidingPawn-cpp"><a href="#CollidingPawn-cpp" class="headerlink" title="CollidingPawn.cpp"></a>CollidingPawn.cpp</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CollidingPawn.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CollidingPawnMovementComponent.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UObject/ConstructorHelpers.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Particles/ParticleSystemComponent.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Components/SphereComponent.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Camera/CameraComponent.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GameFramework/SpringArmComponent.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置默认值</span></span><br><span class="line">ACollidingPawn::<span class="built_in">ACollidingPawn</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 设置该Pawn以逐帧调用Tick()。如无需此功能，可关闭以提高性能。</span></span><br><span class="line">    PrimaryActorTick.bCanEverTick = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根组件将成为对物理反应的球体</span></span><br><span class="line">    USphereComponent* SphereComponent = <span class="built_in">CreateDefaultSubobject</span>&lt;USphereComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;RootComponent&quot;</span>));</span><br><span class="line">    RootComponent = SphereComponent;</span><br><span class="line">    SphereComponent-&gt;<span class="built_in">InitSphereRadius</span>(<span class="number">40.0f</span>);<span class="comment">//初始化球的半径</span></span><br><span class="line">    SphereComponent-&gt;<span class="built_in">SetCollisionProfileName</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;Pawn&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建并放置网格体组件，以便查看球体位置</span></span><br><span class="line">    UStaticMeshComponent* SphereVisual = <span class="built_in">CreateDefaultSubobject</span>&lt;UStaticMeshComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;VisualRepresentation&quot;</span>));</span><br><span class="line">    SphereVisual-&gt;<span class="built_in">SetupAttachment</span>(RootComponent);</span><br><span class="line">    <span class="function"><span class="type">static</span> ConstructorHelpers::FObjectFinder&lt;UStaticMesh&gt; <span class="title">SphereVisualAsset</span><span class="params">(TEXT(<span class="string">&quot;/Game/StarterContent/Shapes/Shape_Sphere.Shape_Sphere&quot;</span>))</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (SphereVisualAsset.<span class="built_in">Succeeded</span>())<span class="comment">//如果找到了绑定的网格体</span></span><br><span class="line">    &#123;</span><br><span class="line">        SphereVisual-&gt;<span class="built_in">SetStaticMesh</span>(SphereVisualAsset.Object);<span class="comment">//则将找到的网格体附加到SphereVisual上！</span></span><br><span class="line">        SphereVisual-&gt;<span class="built_in">SetRelativeLocation</span>(<span class="built_in">FVector</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">-40.0f</span>));<span class="comment">//设置相对位置</span></span><br><span class="line">        SphereVisual-&gt;<span class="built_in">SetWorldScale3D</span>(<span class="built_in">FVector</span>(<span class="number">0.8f</span>));<span class="comment">//缩放为80%</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建可激活或停止的粒子系统</span></span><br><span class="line">    <span class="comment">// 粒子系统组件直接附加到静态网格体组件，而非附加到根。其同时略微偏离网格体底部中心，以便在运行时清晰显示。</span></span><br><span class="line">    OurParticleSystem = <span class="built_in">CreateDefaultSubobject</span>&lt;UParticleSystemComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;MovementParticles&quot;</span>));</span><br><span class="line">    OurParticleSystem-&gt;<span class="built_in">SetupAttachment</span>(SphereVisual);<span class="comment">//将粒子效果组件添加到SphereVisual上！</span></span><br><span class="line">    OurParticleSystem-&gt;bAutoActivate = <span class="literal">false</span>;<span class="comment">//关闭激活粒子效果</span></span><br><span class="line">    OurParticleSystem-&gt;<span class="built_in">SetRelativeLocation</span>(<span class="built_in">FVector</span>(<span class="number">-20.0f</span>, <span class="number">0.0f</span>, <span class="number">20.0f</span>));<span class="comment">//设定粒子效果在网格体上的相对位置</span></span><br><span class="line">    <span class="function"><span class="type">static</span> ConstructorHelpers::FObjectFinder&lt;UParticleSystem&gt; <span class="title">ParticleAsset</span><span class="params">(TEXT(<span class="string">&quot;/Game/StarterContent/Particles/P_Fire.P_Fire&quot;</span>))</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (ParticleAsset.<span class="built_in">Succeeded</span>())<span class="comment">//如果在资源中找到指定的粒子效果</span></span><br><span class="line">    &#123;</span><br><span class="line">        OurParticleSystem-&gt;<span class="built_in">SetTemplate</span>(ParticleAsset.Object);<span class="comment">//将找到的粒子效果附加到PartcleAsset上！</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用弹簧臂给予摄像机平滑自然的运动感。</span></span><br><span class="line">    USpringArmComponent* SpringArm = <span class="built_in">CreateDefaultSubobject</span>&lt;USpringArmComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;CameraAttachmentArm&quot;</span>));</span><br><span class="line">    SpringArm-&gt;<span class="built_in">SetupAttachment</span>(RootComponent);<span class="comment">//将弹簧臂附加到根组件上</span></span><br><span class="line">    SpringArm-&gt;<span class="built_in">SetRelativeRotation</span>(<span class="built_in">FRotator</span>(<span class="number">-45.f</span>, <span class="number">0.f</span>, <span class="number">0.f</span>));<span class="comment">//设定弹簧臂相对于转子的位置</span></span><br><span class="line">    SpringArm-&gt;TargetArmLength = <span class="number">400.0f</span>;<span class="comment">//弹簧臂长度</span></span><br><span class="line">    SpringArm-&gt;bEnableCameraLag = <span class="literal">true</span>;<span class="comment">//打开平滑效果</span></span><br><span class="line">    SpringArm-&gt;CameraLagSpeed = <span class="number">3.0f</span>;<span class="comment">//设置平滑效果时间</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建摄像机并附加到弹簧臂</span></span><br><span class="line">    <span class="comment">// 弹簧臂内置一个特殊的插槽，可供我们添加对象，这样就不必将对象直接添加到组件的根节点上。</span></span><br><span class="line">    UCameraComponent* Camera = <span class="built_in">CreateDefaultSubobject</span>&lt;UCameraComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;ActualCamera&quot;</span>));</span><br><span class="line">    Camera-&gt;<span class="built_in">SetupAttachment</span>(SpringArm, USpringArmComponent::SocketName);<span class="comment">//将摄像机添加到弹簧臂的插槽上！</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 控制默认玩家</span></span><br><span class="line">    AutoPossessPlayer = EAutoReceiveInput::Player0;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建移动组件的实例，并要求其更新根组件。</span></span><br><span class="line">    OurMovementComponent = <span class="built_in">CreateDefaultSubobject</span>&lt;UCollidingPawnMovementComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;CustomMovementComponent&quot;</span>));</span><br><span class="line">    OurMovementComponent-&gt;UpdatedComponent = RootComponent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 游戏开始或生成时调用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ACollidingPawn::BeginPlay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">BeginPlay</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 逐帧调用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ACollidingPawn::Tick</span><span class="params">( <span class="type">float</span> DeltaTime )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">Tick</span>( DeltaTime );</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置键盘输入将会发生的事件，其中前进左右转弯等等函数将在下文定义</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ACollidingPawn::SetupPlayerInputComponent</span><span class="params">(<span class="keyword">class</span> UInputComponent* InInputComponent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">SetupPlayerInputComponent</span>(InInputComponent);</span><br><span class="line"></span><br><span class="line">    InInputComponent-&gt;<span class="built_in">BindAction</span>(<span class="string">&quot;ParticleToggle&quot;</span>, IE_Pressed, <span class="keyword">this</span>, &amp;ACollidingPawn::ParticleToggle);</span><br><span class="line"></span><br><span class="line">    InInputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="string">&quot;MoveForward&quot;</span>, <span class="keyword">this</span>, &amp;ACollidingPawn::MoveForward);</span><br><span class="line">    InInputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="string">&quot;MoveRight&quot;</span>, <span class="keyword">this</span>, &amp;ACollidingPawn::MoveRight);</span><br><span class="line">    InInputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="string">&quot;Turn&quot;</span>, <span class="keyword">this</span>, &amp;ACollidingPawn::Turn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于提供引擎中其他类访问该Pawn当前所用Pawn移动组件的权限。</span></span><br><span class="line"><span class="function">UPawnMovementComponent* <span class="title">ACollidingPawn::GetMovementComponent</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> OurMovementComponent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义前后移动的函数代码</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ACollidingPawn::MoveForward</span><span class="params">(<span class="type">float</span> AxisValue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//保证移动组件存在并且移动组件用来更新根组件</span></span><br><span class="line">    <span class="keyword">if</span> (OurMovementComponent &amp;&amp; (OurMovementComponent-&gt;UpdatedComponent == RootComponent))</span><br><span class="line">    &#123;</span><br><span class="line">        OurMovementComponent-&gt;<span class="built_in">AddInputVector</span>(<span class="built_in">GetActorForwardVector</span>() * AxisValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义左右转动的函数代码</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ACollidingPawn::MoveRight</span><span class="params">(<span class="type">float</span> AxisValue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (OurMovementComponent &amp;&amp; (OurMovementComponent-&gt;UpdatedComponent == RootComponent))</span><br><span class="line">    &#123;</span><br><span class="line">        OurMovementComponent-&gt;<span class="built_in">AddInputVector</span>(<span class="built_in">GetActorRightVector</span>() * AxisValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义转向代码</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ACollidingPawn::Turn</span><span class="params">(<span class="type">float</span> AxisValue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FRotator NewRotation = <span class="built_in">GetActorRotation</span>();<span class="comment">//获取actor当前位置</span></span><br><span class="line">    NewRotation.Yaw += AxisValue;<span class="comment">//围绕Z轴旋转更新actor</span></span><br><span class="line">    <span class="built_in">SetActorRotation</span>(NewRotation);<span class="comment">//更新actor的旋转角度</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义粒子效果开关代码</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ACollidingPawn::ParticleToggle</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//保证粒子效果存在且已经设定好了模板</span></span><br><span class="line">    <span class="keyword">if</span> (OurParticleSystem &amp;&amp; OurParticleSystem-&gt;Template)</span><br><span class="line">    &#123;</span><br><span class="line">        OurParticleSystem-&gt;<span class="built_in">ToggleActive</span>();<span class="comment">//ToggleActor的意思是切换状态</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="有关BindAction-与BindAction"><a href="#有关BindAction-与BindAction" class="headerlink" title="有关BindAction()与BindAction()"></a>有关BindAction()与BindAction()</h2><p><code>BindAction(&quot;ZoomIn&quot;, IE_Pressed, this, &amp;APawnWithCamera::ZoomIn);</code></p>
<ul>
<li><p>参数一：为 虚幻4-&gt;设置 -&gt;输入-&gt;按键绑定的名称 </p>
</li>
<li><p>参数二：事件名称 IE_Pressed 按下 IE_Released松开 IE_DoubleClick双击 </p>
</li>
<li><p>参数三：当前对象——this</p>
</li>
<li><p>参数四：事件方法的函数指针 例 &amp;类名::方法名的写法</p>
</li>
</ul>
<p><code>BindAxis(&quot;MoveForward&quot;, this, &amp;ACollidingPawn::MoveForward);</code></p>
<p>参数一：为 虚幻4-&gt;设置 -&gt;输入-&gt;按键绑定的名称 一定要一样 重要！！！<br>参数二 ：当前对象——this<br>参数三 事件方法的函数指针 例 &amp;类名::方法名 的写法</p>
<h1 id="CollidingPawnMovementComponent-h"><a href="#CollidingPawnMovementComponent-h" class="headerlink" title="CollidingPawnMovementComponent.h"></a>CollidingPawnMovementComponent.h</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CoreMinimal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GameFramework/PawnMovementComponent.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CollidingPawnMovementComponent.generated.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HOWTO_COMPONENTS_API</span> UCollidingPawnMovementComponent : <span class="keyword">public</span> UPawnMovementComponent</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">//TickComponent函数类似于Tick，意思是逐帧刷新</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">TickComponent</span><span class="params">(<span class="type">float</span> DeltaTime, <span class="keyword">enum</span> ELevelTick TickType, FActorComponentTickFunction *ThisTickFunction)</span> <span class="keyword">override</span></span>;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="CollidingPawnMovementComponent-cpp"><a href="#CollidingPawnMovementComponent-cpp" class="headerlink" title="CollidingPawnMovementComponent.cpp"></a>CollidingPawnMovementComponent.cpp</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CollidingPawnMovementComponent.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UCollidingPawnMovementComponent::TickComponent</span><span class="params">(<span class="type">float</span> DeltaTime, <span class="keyword">enum</span> ELevelTick TickType, FActorComponentTickFunction *ThisTickFunction)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">TickComponent</span>(DeltaTime, TickType, ThisTickFunction);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确保所有事物持续有效，以便进行移动。</span></span><br><span class="line">    <span class="keyword">if</span> (!PawnOwner || !UpdatedComponent || <span class="built_in">ShouldSkipUpdate</span>(DeltaTime))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取（然后清除）ACollidingPawn::Tick中设置的移动向量</span></span><br><span class="line">    <span class="comment">// 设定一个变量来存储移动输入的变量值（ConsumeInputVector()），然后通过运行时间来设置运动速度</span></span><br><span class="line">    FVector DesiredMovementThisFrame = <span class="built_in">ConsumeInputVector</span>().<span class="built_in">GetClampedToMaxSize</span>(<span class="number">1.0f</span>) * DeltaTime * <span class="number">150.0f</span>;</span><br><span class="line">    <span class="keyword">if</span> (!DesiredMovementThisFrame.<span class="built_in">IsNearlyZero</span>())</span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="comment">//Hit变量来记录碰撞结果</span></span><br><span class="line">        FHitResult Hit;</span><br><span class="line">        <span class="comment">//用虚幻引擎物理移动pawn移动组件，同时会考虑到固体障碍物</span></span><br><span class="line">        <span class="built_in">SafeMoveUpdatedComponent</span>(DesiredMovementThisFrame, UpdatedComponent-&gt;<span class="built_in">GetComponentRotation</span>(), <span class="literal">true</span>, Hit);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若发生碰撞，尝试滑过去</span></span><br><span class="line">        <span class="keyword">if</span> (Hit.<span class="built_in">IsValidBlockingHit</span>())</span><br><span class="line">        &#123;    </span><br><span class="line">            <span class="comment">//移动导致碰撞时， SlideAlongSurface 会处理沿墙壁和斜坡等碰撞表面平滑滑动所涉及的计算和物理，而非直接停留原地，粘在墙壁或斜坡上。</span></span><br><span class="line">            <span class="built_in">SlideAlongSurface</span>(DesiredMovementThisFrame, <span class="number">1.f</span> - Hit.Time, Hit.Normal, Hit);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="GetClampedToMaxSize"><a href="#GetClampedToMaxSize" class="headerlink" title="GetClampedToMaxSize()"></a>GetClampedToMaxSize()</h2><p>用于更新vector的位置</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FVector <span class="title">FVector::GetClampedToMaxSize</span><span class="params">(<span class="type">float</span> MaxSize)</span></span></span><br></pre></td></tr></table></figure>

<p>用于创建一个新的vector，方向与原本的方向一直，距离为MaxSize</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FVector <span class="title">FVector::GetClampedToSize</span><span class="params">(<span class="type">float</span> Min,<span class="type">float</span> Max)</span> </span></span><br></pre></td></tr></table></figure>

<p>创建一个新的Vector，方向与原方向一致</p>
<p>距离为</p>
<ol>
<li><p>若距离&lt;Min，则新的vector距离为Min</p>
</li>
<li><p>若距离&gt;Max，则新的vector距离为Max</p>
</li>
<li><p>若距离在Min和Max之间，则新的vector等于原本的vector</p>
</li>
</ol>
<h2 id="ConsumeInputVector-1-0f"><a href="#ConsumeInputVector-1-0f" class="headerlink" title="ConsumeInputVector(1.0f)"></a>ConsumeInputVector(1.0f)</h2><p>报告并清空用于存储移动输入的内置变量值。</p>
<h2 id="SafeMoveUpdatedComponent"><a href="#SafeMoveUpdatedComponent" class="headerlink" title="SafeMoveUpdatedComponent()"></a>SafeMoveUpdatedComponent()</h2><p><code>SafeMoveUpdatedComponent(const FVector&amp; Delta, const FRotator&amp; NewRotation, bool bSweep, FHitResult&amp; OutHit, ETeleportType Teleport)</code></p>
<p><code>SafeMoveUpdatedComponent(DesiredMovementThisFrame, UpdatedComponent-&gt;GetComponentRotation(), true, Hit);</code></p>
<p>利用虚幻引擎物理移动Pawn移动组件，同时考虑固体障碍。</p>
<ul>
<li><p>第一个参数：要移动的Vector</p>
</li>
<li><p>第二个参数：旋转参数</p>
</li>
<li><p>第三个参数：是否考虑物理障碍（如果为true，将在移动过程中扫描以阻止碰撞。如果为false，它将简单地传送到下一个位置并忽略碰撞。）</p>
</li>
<li><p>第四个参数：碰撞结果</p>
</li>
<li><p>第五个参数：可省略，远距离传送类型</p>
</li>
</ul>
<h2 id="SlideAlongSurface"><a href="#SlideAlongSurface" class="headerlink" title="SlideAlongSurface()"></a>SlideAlongSurface()</h2><p><code>SlideAlongSurface(const FVector&amp; Delta, float Time, const FQuat Rotation, const FVector&amp; Normal, FHitResult&amp; Hit, bool bHandleImpact)</code></p>
<ul>
<li><p>第一个参数：要移动的vector</p>
</li>
<li><p>第二个参数：运动时间</p>
</li>
<li><p>第三个参数：旋转情况（可省略）</p>
</li>
<li><p>第四个参数：vector类型？（这个不太确定）</p>
</li>
<li><p>第五个参数：碰撞结果（必须为bBlockingHit）</p>
</li>
<li><p>第六个参数：手柄反馈？（这个扎找不到源文件）</p>
</li>
</ul>
<h1 id="配置项目输入设置"><a href="#配置项目输入设置" class="headerlink" title="配置项目输入设置"></a>配置项目输入设置</h1><p>这里要注意的一点是，在给动作映射和轴映射命名的时候一定要和代码中定义的函数名相同否则无效。</p>
<ol>
<li><p>回到 <strong>虚幻编辑器</strong>，开始配置项目输入设置。可在 <strong>编辑</strong> 下拉菜单中的 <strong>项目设置</strong> 下找到相关设置。</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/Components/EditProjectSettings.jpg" alt="EditProjectSettings.png"></p>
<p>进入该菜单后，可在左侧面板中的 <strong>引擎</strong> 部分中选择 <strong>输入</strong>。同时需要设置粒子系统切换的 <strong>操作映射</strong> 、移动 <strong>Pawn</strong> 的两个 <strong>轴映射</strong>，和转动 <strong>Pawn</strong> 的一个 <strong>轴映射</strong>。</p>
<table>
<thead>
<tr>
<th>操作映射</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>ParticleToggle</td>
<td>空格</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>轴映射</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>MoveForward</td>
<td>W</td>
<td>1.0</td>
</tr>
<tr>
<td></td>
<td>S</td>
<td>-1.0</td>
</tr>
<tr>
<td>MoveRight</td>
<td>A</td>
<td>-1.0</td>
</tr>
<tr>
<td></td>
<td>D</td>
<td>1.0</td>
</tr>
<tr>
<td>Turn</td>
<td>Mouse X</td>
<td>1.0</td>
</tr>
</tbody></table>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/Components/InputSettings.jpg" alt="InputSettings.png"></p>
</li>
</ol>
<p>将创建 <strong>移动组件</strong> 管理移动，而非直接在Pawn类中处理所有移动。本教程中将扩展 <strong>Pawn移动组件</strong> 类。首先在 <strong>文件</strong> 下拉菜单中选择 <strong>将代码添加到项目（Add Code to Project）</strong> 命令。</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/Components/AddCPPCode.jpg" alt="AddCPPCode.png"></p>
<p>与Pawn类不同的，Pawn移动组件类默认为不可见。要找到该组件，需选中 <strong>显示所有类（Show All Classes）</strong> 选项。</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/Components/ShowAllClasses.jpg" alt="ShowAllClasses.png"></p>
<p>在搜索栏中输入”movement”，以便快速缩小列表范围。</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/Components/ChooseParentClass2.jpg" alt="ChooseParentClass2.png"></p>
<p>Pawn移动组件拥有部分强大内置功能，以便使用常见物理功能，同时便于在大量Pawn类型间共享移动代码。使用组件分隔不同功能是上佳方法，可在项目增大、Pawn越加复杂时减少杂乱。</p>
<p>这里放一个来自于的<a target="_blank" rel="noopener" href="https://blog.csdn.net/heneyT" title="heneyT">heneyT</a>移动组件的继承树</p>
<p><img src="https://img-blog.csdn.net/20171130205337919?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjk5OTk4NQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/22/UE4-CameraDirector/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="williny">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Williny'home">
      <meta itemprop="description" content="孤独是人生的常态">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Williny'home">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/04/22/UE4-CameraDirector/" class="post-title-link" itemprop="url">UE4-CameraDirector</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-04-22 15:20:03" itemprop="dateCreated datePublished" datetime="2022-04-22T15:20:03+08:00">2022-04-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-04-24 10:48:47" itemprop="dateModified" datetime="2022-04-24T10:48:47+08:00">2022-04-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/unreal-engine/" itemprop="url" rel="index"><span itemprop="name">unreal engine</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1><p>分析官方案例<a target="_blank" rel="noopener" href="https://docs.unrealengine.com/4.27/zh-CN/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/AutoCamera/">CameraDirector</a></p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><ol>
<li><p>放两个摄像机</p>
<ul>
<li><p>所有类中直接拖入</p>
</li>
<li><p>先创建一个立方体，然后给他添加一个摄像机组件</p>
</li>
</ul>
</li>
<li><p>以Actor为父类创建C++类</p>
</li>
</ol>
<h2 id="CameraDirector-h"><a href="#CameraDirector-h" class="headerlink" title="CameraDirector.h"></a>CameraDirector.h</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line">AActor* CameraOne;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line">AActor* CameraTwo;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> TimeToNextCameraChange;</span><br></pre></td></tr></table></figure>

<h2 id="CameraDirector-cpp"><a href="#CameraDirector-cpp" class="headerlink" title="CameraDirector.cpp"></a>CameraDirector.cpp</h2><p>添加到引用位置</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Kismet/GameplayStatics.h&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>添加到<strong>ACameraDirector::Tick</strong> 的底部位置</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">float</span> TimeBetweenCameraChanges = <span class="number">2.0f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">float</span> SmoothBlendTime = <span class="number">0.75f</span>;</span><br><span class="line">TimeToNextCameraChange -= DeltaTime;</span><br><span class="line"><span class="keyword">if</span> (TimeToNextCameraChange &lt;= <span class="number">0.0f</span>)</span><br><span class="line">&#123;</span><br><span class="line">    TimeToNextCameraChange += TimeBetweenCameraChanges;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找处理本地玩家控制的actor。</span></span><br><span class="line">    APlayerController* OurPlayerController = UGameplayStatics::<span class="built_in">GetPlayerController</span>(<span class="keyword">this</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (OurPlayerController)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((OurPlayerController-&gt;<span class="built_in">GetViewTarget</span>() != CameraOne) &amp;&amp; (CameraOne != <span class="literal">nullptr</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 立即切换到摄像机1。</span></span><br><span class="line">            OurPlayerController-&gt;<span class="built_in">SetViewTarget</span>(CameraOne);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((OurPlayerController-&gt;<span class="built_in">GetViewTarget</span>() != CameraTwo) &amp;&amp; (CameraTwo != <span class="literal">nullptr</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 平滑地混合到摄像机2。</span></span><br><span class="line">            OurPlayerController-&gt;<span class="built_in">SetViewTargetWithBlend</span>(CameraTwo, SmoothBlendTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="添加C-类"><a href="#添加C-类" class="headerlink" title="添加C++类"></a>添加C++类</h2><p>在代码编译完成后，我们可以将 <strong>内容浏览器（Content Browser）</strong> 中的新类的实例拖曳到 <strong>关卡编辑器（Level Editor）</strong> 中。</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/AutoCamera/CameraDirectorInContentBrowser.jpg" alt="CameraDirectorInContentBrowser.png"></p>
<p>接下来，我们需要设置摄像机1（CameraOne）和摄像机2（CameraTwo）变量。在 <strong>World Outliner （世界大纲视图）</strong> 中找到CameraDirector，并在 <strong>详细信息面板（Details Panel）</strong> 中进行编辑。</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/AutoCamera/CameraDirectorDetails.jpg" alt="CameraDirectorDetails.png"></p>
<p>单击标记为”无（None）”的下拉框，然后将变量设置为 <strong>Cube（立方体）</strong> 和我们之前创建的 <strong>摄像机Actor （CameraActor）</strong>。</p>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>ok以上是来自官网的教程，现在我来把它掰开来理解</p>
<h2 id="CameraDirector-h-1"><a href="#CameraDirector-h-1" class="headerlink" title="CameraDirector.h"></a>CameraDirector.h</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GameFramework/Actor.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CameraDirector.generated.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HOWTO_AUTOCAMERA_API</span> ACameraDirector : <span class="keyword">public</span> AActor</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="comment">// 为此Actor的属性设置默认值</span></span><br><span class="line">    <span class="built_in">ACameraDirector</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// 当游戏开始或生成时调用</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BeginPlay</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 每一帧调用</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Tick</span><span class="params">( <span class="type">float</span> DeltaSeconds )</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line">    AActor* CameraOne;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line">    AActor* CameraTwo;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> TimeToNextCameraChange;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这一段代码，其实没啥需要讲解的，在我的前两篇博客中已经讲得很明白了。</p>
<p>在此就不多做赘述。</p>
<h2 id="CameraDirector-cpp-1"><a href="#CameraDirector-cpp-1" class="headerlink" title="CameraDirector.cpp"></a>CameraDirector.cpp</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;HowTo_AutoCamera.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CameraDirector.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Kismet/GameplayStatics.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置默认值</span></span><br><span class="line">ACameraDirector::<span class="built_in">ACameraDirector</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 将此Actor设置为每一帧调用Tick()。如果不需要，可以关闭此选项来提高性能。</span></span><br><span class="line">    PrimaryActorTick.bCanEverTick = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当游戏开始或生成时调用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ACameraDirector::BeginPlay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">BeginPlay</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每一帧调用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ACameraDirector::Tick</span><span class="params">( <span class="type">float</span> DeltaTime )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">Tick</span>( DeltaTime );</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">float</span> TimeBetweenCameraChanges = <span class="number">2.0f</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">float</span> SmoothBlendTime = <span class="number">0.75f</span>;</span><br><span class="line">    TimeToNextCameraChange -= DeltaTime;</span><br><span class="line">    <span class="keyword">if</span> (TimeToNextCameraChange &lt;= <span class="number">0.0f</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        TimeToNextCameraChange += TimeBetweenCameraChanges;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//查找处理本地玩家控制的Actor。</span></span><br><span class="line">        APlayerController* OurPlayerController = UGameplayStatics::<span class="built_in">GetPlayerController</span>(<span class="keyword">this</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (OurPlayerController)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (CameraTwo &amp;&amp; (OurPlayerController-&gt;<span class="built_in">GetViewTarget</span>() == CameraOne))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//平滑地混合到摄像机2。</span></span><br><span class="line">                OurPlayerController-&gt;<span class="built_in">SetViewTargetWithBlend</span>(CameraTwo, SmoothBlendTime);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (CameraOne)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//立即切换到摄像机1。</span></span><br><span class="line">                OurPlayerController-&gt;<span class="built_in">SetViewTarget</span>(CameraOne);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们首先解决这些代码中API的问题</p>
<h3 id="GetPlayerController-this-0"><a href="#GetPlayerController-this-0" class="headerlink" title="GetPlayerController(this,0)"></a>GetPlayerController(this,0)</h3><p>这一段可以通过查看其定义明白其含义——获取玩家控制器</p>
<p>this指当前玩家控制器，0是玩家控制器的标号，代表了本地玩家控制器</p>
<p>在定义代码中，GetPlayerController返回的返回值是APlayerController，所以在前面定义一个该类型的指针OurPlayerController</p>
<h3 id="GetViewTarget"><a href="#GetViewTarget" class="headerlink" title="GetViewTarget()"></a>GetViewTarget()</h3><p>获取玩家身上的摄像机Actor</p>
<h3 id="SetViewTargetWithBlend-CameraTwo-SmoothBlendTime"><a href="#SetViewTargetWithBlend-CameraTwo-SmoothBlendTime" class="headerlink" title="SetViewTargetWithBlend(CameraTwo,SmoothBlendTime);"></a>SetViewTargetWithBlend(CameraTwo,SmoothBlendTime);</h3><p>使摄像机平滑切换到摄像机二，前一个变量使设定切换到哪个摄像机，后一个使设定切换时间</p>
<p>理解了API的意思之后，代码逻辑我就不再讲解了，代码中的变量和常量完全可以见文知意，结构使非常基础的if判断，如果看不懂的话还是需要先好好学习数据结构与算法。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/20/UE4-FloatingActor/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="williny">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Williny'home">
      <meta itemprop="description" content="孤独是人生的常态">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Williny'home">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/04/20/UE4-FloatingActor/" class="post-title-link" itemprop="url">UE4-FloatingActor</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-04-20 13:43:20" itemprop="dateCreated datePublished" datetime="2022-04-20T13:43:20+08:00">2022-04-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-04-22 14:33:36" itemprop="dateModified" datetime="2022-04-22T14:33:36+08:00">2022-04-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/unreal-engine/" itemprop="url" rel="index"><span itemprop="name">unreal engine</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>根据虚幻引擎<a target="_blank" rel="noopener" href="https://docs.unrealengine.com/4.27/zh-CN/ProgrammingAndScripting/ProgrammingWithCPP/CPPProgrammingQuickStart/">官方文档</a>的编程快速入门章节所创建的第一个项目——FloatingActor</p>
<p>当然，官方文档中给出了详细的源码，可是他是授人以鱼，并没有授人以渔。</p>
<p>现在我就想着把这个渔给掰开揉碎了，方便自己理解，也供大家学习分享。</p>
<h1 id="创建FloatingActor"><a href="#创建FloatingActor" class="headerlink" title="创建FloatingActor"></a>创建FloatingActor</h1><p>此处不再赘述，如果像了解生成的默认代码含义，可以参考我的上一篇博客</p>
<h1 id="实现FloatingActor效果"><a href="#实现FloatingActor效果" class="headerlink" title="实现FloatingActor效果"></a>实现FloatingActor效果</h1><p>按照官方文档的操作，我们可以得到如下两端代码</p>
<h2 id="FloatingActor-h"><a href="#FloatingActor-h" class="headerlink" title="FloatingActor.h"></a>FloatingActor.h</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CoreMinimal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GameFramework/Actor.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;FloatingActor.generated.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">QUICKSTART_API</span> AFloatingActor : <span class="keyword">public</span> AActor</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="comment">// Sets default values for this actor&#x27;s properties</span></span><br><span class="line">    <span class="built_in">AFloatingActor</span>();<span class="comment">//声明FloatingActor</span></span><br><span class="line">        <span class="built_in">UPROPERTY</span>(VisibleAnywhere)<span class="comment">//这段代码的作用是让FloatActor可以在编辑器中被编辑细节面板</span></span><br><span class="line">        UStaticMeshComponent* VisualMesh;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// Called when the game starts or when spawned</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BeginPlay</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="comment">// Called every frame</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Tick</span><span class="params">(<span class="type">float</span> DeltaTime)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="AFloatingActor"><a href="#AFloatingActor" class="headerlink" title="AFloatingActor()"></a>AFloatingActor()</h3><p>声明FloatingActor</p>
<h3 id="UPROPERTY-VisibleAnywhere"><a href="#UPROPERTY-VisibleAnywhere" class="headerlink" title="UPROPERTY(VisibleAnywhere)"></a>UPROPERTY(VisibleAnywhere)</h3><p>让FloatingActor可以在虚幻编辑器被看见，如果去掉这个，那FloatingActor在虚幻引擎中就不能被看到了！（此时编辑框是灰色的，意味着<strong>只读，不可写</strong>）</p>
<h3 id="UStaticMeshComponent-VisualMesh"><a href="#UStaticMeshComponent-VisualMesh" class="headerlink" title="UStaticMeshComponent* VisualMesh;"></a>UStaticMeshComponent* VisualMesh;</h3><ul>
<li><p>staticmesh的意思是静态网格体</p>
</li>
<li><p>Component的意思是组件</p>
</li>
<li><p>整段代码合起来的意思是声明了一个类型为UStaticMeshComponent的名为VisualMesh的指针</p>
</li>
</ul>
<h2 id="FloatingActor-cpp"><a href="#FloatingActor-cpp" class="headerlink" title="FloatingActor.cpp"></a>FloatingActor.cpp</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;FloatingActor.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Sets default values</span></span><br><span class="line">AFloatingActor::<span class="built_in">AFloatingActor</span>()</span><br><span class="line">&#123;</span><br><span class="line">     <span class="comment">// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don&#x27;t need it.</span></span><br><span class="line">    PrimaryActorTick.bCanEverTick = <span class="literal">true</span>;</span><br><span class="line">    VisualMesh = <span class="built_in">CreateDefaultSubobject</span>&lt;UStaticMeshComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;Mesh&quot;</span>));</span><br><span class="line">    VisualMesh-&gt;<span class="built_in">SetupAttachment</span>(RootComponent);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> ConstructorHelpers::FObjectFinder&lt;UStaticMesh&gt; <span class="title">CubeVisualAsset</span><span class="params">(TEXT(<span class="string">&quot;/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube&quot;</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (CubeVisualAsset.<span class="built_in">Succeeded</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        VisualMesh-&gt;<span class="built_in">SetStaticMesh</span>(CubeVisualAsset.Object);</span><br><span class="line">        VisualMesh-&gt;<span class="built_in">SetRelativeLocation</span>(<span class="built_in">FVector</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Called when the game starts or when spawned</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFloatingActor::BeginPlay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">BeginPlay</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Called every frame</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFloatingActor::Tick</span><span class="params">(<span class="type">float</span> DeltaTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">Tick</span>(DeltaTime);</span><br><span class="line">    FVector NewLocation = <span class="built_in">GetActorLocation</span>();</span><br><span class="line">    FRotator NewRotation = <span class="built_in">GetActorRotation</span>();</span><br><span class="line">    <span class="type">float</span> RunningTime = <span class="built_in">GetGameTimeSinceCreation</span>();</span><br><span class="line">    <span class="type">float</span> DeltaHeight = (FMath::<span class="built_in">Sin</span>(RunningTime + DeltaTime) - FMath::<span class="built_in">Sin</span>(RunningTime));</span><br><span class="line">    NewLocation.Z += DeltaHeight * <span class="number">20.0f</span>;       <span class="comment">//Scale our height by a factor of 20</span></span><br><span class="line">    <span class="type">float</span> DeltaRotation = DeltaTime * <span class="number">20.0f</span>;    <span class="comment">//Rotate by 20 degrees per second</span></span><br><span class="line">    NewRotation.Yaw += DeltaRotation;</span><br><span class="line">    <span class="built_in">SetActorLocationAndRotation</span>(NewLocation, NewRotation);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="VisualMesh-x3D-CreateDefaultSubobject-TEXT-“Mesh”"><a href="#VisualMesh-x3D-CreateDefaultSubobject-TEXT-“Mesh”" class="headerlink" title="VisualMesh &#x3D; CreateDefaultSubobject(TEXT(“Mesh”));"></a>VisualMesh &#x3D; CreateDefaultSubobject<UStaticMeshComponent>(TEXT(“Mesh”));</h2><p>在.h文件中我们声明了VisualMesh，现在我们来给其赋值</p>
<p>CreateDefaultSubobject（是一个模板类）代表着创建一个组件，&lt;&gt;里面就是它创建组件的类型</p>
<p>因为VisualMesh的类型本身就是UStaticMeshComponent，所以就创建相同类型的组件，然后赋值给VisualMesh</p>
<h2 id="VisualMesh-gt-SetupAttachment-RootComponent"><a href="#VisualMesh-gt-SetupAttachment-RootComponent" class="headerlink" title="VisualMesh-&gt;SetupAttachment(RootComponent);"></a>VisualMesh-&gt;SetupAttachment(RootComponent);</h2><p>VisualMesh调用SetupAttachment()函数，将它本身附加到根组件下面</p>
<p><img src="D:\R_programme\Blog\source\images\Rootcomonent.png" alt="Rootcomonent.png"></p>
<h2 id="初始化组件"><a href="#初始化组件" class="headerlink" title="初始化组件"></a>初始化组件</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> ConstructorHelpers::FObjectFinder&lt;UStaticMesh&gt; <span class="title">CubeVisualAsset</span><span class="params">(TEXT(<span class="string">&quot;/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube&quot;</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (CubeVisualAsset.<span class="built_in">Succeeded</span>())</span><br><span class="line">&#123;</span><br><span class="line">    VisualMesh-&gt;<span class="built_in">SetStaticMesh</span>(CubeVisualAsset.Object);</span><br><span class="line">    VisualMesh-&gt;<span class="built_in">SetRelativeLocation</span>(<span class="built_in">FVector</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>static ConstructorHelpers::FObjectFinder&lt;UStaticMesh&gt; CubeVisualAsset(TEXT(&quot;/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube&quot;));</code></p>
<p>这么长一段，仔细看一下后面的<code>/Game/StarterContent/Shapes/Shape_Cube.Shape_Cube</code>很容易就能理解，这是在现有资产中寻找网格体。</p>
<p>下面的if语句，就是在找到的情况下，进行位置的初始化</p>
<p>从整体上理解，其实这段代码就是在构造函数中初始化FloatingActor的</p>
<p>这一段不是必须的，我们可以不要它，在创建好这个组件之后，再把它添加到其他的Actor上</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFloatingActor::Tick</span><span class="params">(<span class="type">float</span> DeltaTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">Tick</span>(DeltaTime);</span><br><span class="line">    FVector NewLocation = <span class="built_in">GetActorLocation</span>();</span><br><span class="line">    FRotator NewRotation = <span class="built_in">GetActorRotation</span>();</span><br><span class="line">    <span class="type">float</span> RunningTime = <span class="built_in">GetGameTimeSinceCreation</span>();</span><br><span class="line">    <span class="type">float</span> DeltaHeight = (FMath::<span class="built_in">Sin</span>(RunningTime + DeltaTime) - FMath::<span class="built_in">Sin</span>(RunningTime));</span><br><span class="line">    NewLocation.Z += DeltaHeight * <span class="number">20.0f</span>;       <span class="comment">//Scale our height by a factor of 20</span></span><br><span class="line">    <span class="type">float</span> DeltaRotation = DeltaTime * <span class="number">20.0f</span>;    <span class="comment">//Rotate by 20 degrees per second</span></span><br><span class="line">    NewRotation.Yaw += DeltaRotation;</span><br><span class="line">    <span class="built_in">SetActorLocationAndRotation</span>(NewLocation, NewRotation);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="FVector-NewLocation-x3D-GetActorLocation"><a href="#FVector-NewLocation-x3D-GetActorLocation" class="headerlink" title="FVector NewLocation&#x3D;GetActorLocation();"></a>FVector NewLocation&#x3D;GetActorLocation();</h3><p>我通过查看了FVetoc的声明和定义代码，大概能得出他的意思——<strong>以X,Y,Z轴来设定一个物体的新的三维坐标位置的结构体</strong></p>
<p>那剩下的这一行的意思也可以轻易得出：</p>
<p>声明一个FVector类型的变量NewLocation，初始化为GetActorLocation()</p>
<h3 id="FRotator-NewRotation-x3D-GetActorLocation"><a href="#FRotator-NewRotation-x3D-GetActorLocation" class="headerlink" title="FRotator NewRotation&#x3D;GetActorLocation();"></a>FRotator NewRotation&#x3D;GetActorLocation();</h3><p>同样的通过查看FRotator的声明和定义代码，也得出他的意思——<strong>以Pitch，Yaw，Roll轴来设定一个物体围绕某个轴来进行旋转的结构体</strong></p>
<p>注意：</p>
<ul>
<li><p>Pitch是Y轴</p>
</li>
<li><p>Yaw是Z轴</p>
</li>
<li><p>Roll是X轴</p>
</li>
</ul>
<p>同理，此行代码意思类似于上一行，此处便不多做赘述</p>
<h3 id="float-RunningTime-x3D-GetGameTimeSinceCreation"><a href="#float-RunningTime-x3D-GetGameTimeSinceCreation" class="headerlink" title="float RunningTime&#x3D;GetGameTimeSinceCreation();"></a>float RunningTime&#x3D;GetGameTimeSinceCreation();</h3><p>这一行就很好理解，就是这个函数的字面意思</p>
<p>设定一个名为RunningTime的变量，使其为游戏开始到现在的时间</p>
<h3 id="float-DeltaHeight-x3D-FMath-Sin-RunningTime-DeltaTime-FMath-Sin-RunningTime"><a href="#float-DeltaHeight-x3D-FMath-Sin-RunningTime-DeltaTime-FMath-Sin-RunningTime" class="headerlink" title="float DeltaHeight &#x3D; (FMath::Sin(RunningTime + DeltaTime) - FMath::Sin(RunningTime));"></a>float DeltaHeight &#x3D; (FMath::Sin(RunningTime + DeltaTime) - FMath::Sin(RunningTime));</h3><p>这一行就比较妙了，首先声明了一个名为DeltaHeight的变量</p>
<p>FMath是数学命名空间的意思</p>
<p>sin是正弦函数</p>
<p>这个数学式子可以保证DeltaHeight在1与-1之间变换</p>
<h3 id="NewLocation-Z-x3D-DeltaHeight-20-0f"><a href="#NewLocation-Z-x3D-DeltaHeight-20-0f" class="headerlink" title="NewLocation.Z +&#x3D; DeltaHeight * 20.0f;"></a>NewLocation.Z +&#x3D; DeltaHeight * 20.0f;</h3><p>上面已经初始化过NewLocation，现在通过这个数学式子，使其实时更新</p>
<h3 id="float-DeltaRotation-x3D-DeltaTime-20-0f"><a href="#float-DeltaRotation-x3D-DeltaTime-20-0f" class="headerlink" title="float DeltaRotation &#x3D; DeltaTime * 20.0f;"></a>float DeltaRotation &#x3D; DeltaTime * 20.0f;</h3><p>定义一个变量DeltaRotation（旋转角度），使其每秒旋转20.0个单位</p>
<h3 id="NewRotation-Yaw-x3D-DeltaRotation"><a href="#NewRotation-Yaw-x3D-DeltaRotation" class="headerlink" title="NewRotation.Yaw +&#x3D; DeltaRotation;"></a>NewRotation.Yaw +&#x3D; DeltaRotation;</h3><p>实时更新旋转状态</p>
<h3 id="SetActorLocationAndRotation-NewLocation-NewRotation"><a href="#SetActorLocationAndRotation-NewLocation-NewRotation" class="headerlink" title="SetActorLocationAndRotation(NewLocation, NewRotation);"></a>SetActorLocationAndRotation(NewLocation, NewRotation);</h3><p>这就很容易理解——设置actor的位置和角度</p>
<h1 id="提高可适配性"><a href="#提高可适配性" class="headerlink" title="提高可适配性"></a>提高可适配性</h1><p>FloatingActor.h</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadWrite, Category=<span class="string">&quot;FloatingActor&quot;</span>)</span><br><span class="line">    <span class="type">float</span> FloatSpeed = <span class="number">20.0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadWrite, Category=<span class="string">&quot;FloatingActor&quot;</span>)</span><br><span class="line">    <span class="type">float</span> RotationSpeed = <span class="number">20.0f</span>;</span><br></pre></td></tr></table></figure>

<p>FloatingActor.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NewLocation.Z += DeltaHeight * FloatSpeed;          <span class="comment">//按FloatSpeed调整高度</span></span><br><span class="line"><span class="type">float</span> DeltaRotation = DeltaTime * RotationSpeed;    <span class="comment">//每秒旋转等于RotationSpeed的角度</span></span><br></pre></td></tr></table></figure>

<p>通过在标头文件中添加这些变量，并替换在.cpp中用于缩放DeltaHeight和DeltaRotation的浮点值，可在选择Actor时在 <strong>细节（Details）</strong> 面板中编辑浮动和旋转速度。</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPProgrammingQuickStart/PRQuickStart_6-1.jpg" alt="PRQuickStart_6-1.png"></p>
<p>以上内容是官方文档的原文，现在我来尝试理解其中的意思</p>
<p>前面我们已经讲过UPROPERTY()可以使得该组件能够在虚幻编辑器中被编辑，我们现在在括号内加上其他的字符串</p>
<h2 id="EditAnywhere"><a href="#EditAnywhere" class="headerlink" title="EditAnywhere"></a>EditAnywhere</h2><p>见文知意，能在任何地方被编辑，在蓝图中<strong>可读且可写入</strong>。</p>
<h2 id="BlueprintReadWrite"><a href="#BlueprintReadWrite" class="headerlink" title="BlueprintReadWrite"></a>BlueprintReadWrite</h2><p>BlueprintReadOnly和BlueprintReadWrite是一组。明明是C++的class，和BP(Bluprint)有什么关系呢？<br>这里指的是，用BP方式创建子类，以C++代码编写父类。创建一个BPclass，从目前编写的C++ class继承，然后在子类的BP Editor里，就可以获取这个值，<strong>如果不写BlueprintReadOnly或者BlueprintReadWrite，是不能在蓝图里看到这个变量的。</strong></p>
<p>首先创建一个叫MyActor的C++类，然后创建一个叫做BPMyActor的class，以MyActor为父类。<br><img src="https://img-blog.csdnimg.cn/2020070600443981.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80OTE4MjY3Mw==,size_16,color_FFFFFF,t_70"></p>
<p>父类中定义一个变量，被BlueprintReadOnly修饰</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UPROPERTY</span>(BlueprintReadOnly, Category = <span class="string">&quot;Damage&quot;</span>)</span><br><span class="line">int32 TotalDamage</span><br></pre></td></tr></table></figure>

<p>那么在子类的蓝图编辑器主界面，点右键然后搜索，就会出现Get操作。</p>
<p><img src="https://img-blog.csdnimg.cn/20200706005200494.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80OTE4MjY3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>而如果用BlueprintReadWrite修饰变量，则既会出现Get，又会出现Set操作。</p>
<p><img src="https://img-blog.csdnimg.cn/20200706005309445.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80OTE4MjY3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>如果不提供任何一个，则父类中定义的这个变量，完全无法在BP继承出来的子类中访问到。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UPROPERTY</span>()</span><br><span class="line">int32 TotalDamage;</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20200706005500919.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80OTE4MjY3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>以上是CSDN博主「不知名图形学者」的<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_49182673/article/details/107148609">原创文章</a>中的解释</p>
<p>用我自己的话来说就是：用C++创建父类，蓝图方式创建它的子类。BlueprintReadWrite和BuleprintReadOnly能分别让他们可以在蓝图编辑器中可读写以及仅仅可读</p>
<h2 id="float-FloatSpeed-x3D-20-0f"><a href="#float-FloatSpeed-x3D-20-0f" class="headerlink" title="float FloatSpeed&#x3D;20.0f"></a>float FloatSpeed&#x3D;20.0f</h2><p>初始化浮动速度为20.0f</p>
<h2 id="float-FloatSpeed-x3D-20-0f-1"><a href="#float-FloatSpeed-x3D-20-0f-1" class="headerlink" title="float FloatSpeed&#x3D;20.0f"></a>float FloatSpeed&#x3D;20.0f</h2><p>初始化旋转速度为20.0f</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/20/%E6%9C%89%E5%85%B3%E7%AE%97%E6%B3%95%E4%B8%AD%E7%9A%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E4%B8%80%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="williny">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Williny'home">
      <meta itemprop="description" content="孤独是人生的常态">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Williny'home">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/04/20/%E6%9C%89%E5%85%B3%E7%AE%97%E6%B3%95%E4%B8%AD%E7%9A%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E4%B8%80%EF%BC%89/" class="post-title-link" itemprop="url">有关算法中的动态规划（一）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-04-20 08:20:39" itemprop="dateCreated datePublished" datetime="2022-04-20T08:20:39+08:00">2022-04-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-05-01 09:54:27" itemprop="dateModified" datetime="2022-05-01T09:54:27+08:00">2022-05-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="什么是动态规划"><a href="#什么是动态规划" class="headerlink" title="什么是动态规划"></a>什么是动态规划</h1><p>如果某问题有很多重叠子问题，使用动态规划是最有效的</p>
<p>所以动态规划中每一个状态一定是由上一个状态推导出来的，这一点就区分与贪心，贪心没有状态推导。</p>
<p>例如：有N件物品和一个最多能背重量为W 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。<strong>每件物品只能用一次</strong>，求解将哪些物品装入背包里物品价值总和最大。</p>
<ul>
<li><p>动态规划中dp[j]是由dp[j-weight[i]]推导出来的，然后取max(dp[j], dp[j - weight[i]] + value[i])。</p>
</li>
<li><p>但如果是贪心呢，每次拿物品选一个最大的或者最小的就完事了，和上一个状态没有关系。</p>
</li>
</ul>
<p>所以贪心解决不了动态规划的问题。</p>
<p><strong>其实大家也不用死扣动规和贪心的理论区别，后面做做题目自然就知道了</strong>。</p>
<p>而且很多讲解动态规划的文章都会讲最优子结构啊和重叠子问题啊这些，这些东西都是教科书的上定义，晦涩难懂而且不实用。</p>
<p>大家知道动规是由前一个状态推导出来的，而贪心是局部直接选最优的，对于刷题来说就够用了。</p>
<p>上述提到的背包问题，后序会详细讲解。</p>
<h1 id="动态规划的解题步骤"><a href="#动态规划的解题步骤" class="headerlink" title="动态规划的解题步骤"></a>动态规划的解题步骤</h1><p>做动规题目的时候，很多同学会陷入一个误区，就是以为把状态转移公式背下来，照葫芦画瓢改改，就开始写代码，甚至把题目AC之后，都不太清楚dp[i]表示的是什么。</p>
<p><strong>这就是一种朦胧的状态，然后就把题给过了，遇到稍稍难一点的，可能直接就不会了，然后看题解，然后继续照葫芦画瓢陷入这种恶性循环中</strong>。</p>
<ul>
<li>状态转移公式（递推公式）是很重要，但动规不仅仅只有递推公式。</li>
</ul>
<p><strong>对于动态规划问题，我将拆解为如下五步曲，这五步都搞清楚了，才能说把动态规划真的掌握了！</strong></p>
<ol>
<li>确定dp数组（dp table）以及下标的含义</li>
<li>确定递推公式</li>
<li>dp数组如何初始化</li>
<li>确定遍历顺序</li>
<li>举例推导dp数组</li>
</ol>
<p>一些同学可能想为什么要先确定递推公式，然后在考虑初始化呢？</p>
<p><strong>因为一些情况是递推公式决定了dp数组要如何初始化！</strong></p>
<p>后面的讲解中我都是围绕着这五点来进行讲解。</p>
<p>可能刷过动态规划题目的同学可能都知道递推公式的重要性，感觉确定了递推公式这道题目就解出来了。</p>
<p>其实 确定递推公式 仅仅是解题里的一步而已！</p>
<p>一些同学知道递推公式，但搞不清楚dp数组应该如何初始化，或者正确的遍历顺序，以至于记下来公式，但写的程序怎么改都通过不了。</p>
<p>后序的讲解的大家就会慢慢感受到这五步的重要性了。</p>
<h1 id="动态规划应该如何debug"><a href="#动态规划应该如何debug" class="headerlink" title="动态规划应该如何debug"></a>动态规划应该如何debug</h1><p>写动规题目，代码出问题很正常！</p>
<p><strong>找问题的最好方式就是把dp数组打印出来，看看究竟是不是按照自己思路推导的！</strong></p>
<p><strong>做动规的题目，写代码之前一定要把状态转移在dp数组的上具体情况模拟一遍，心中有数，确定最后推出的是想要的结果</strong>。</p>
<ul>
<li><p>然后再写代码，如果代码没通过就打印dp数组，看看是不是和自己预先推导的哪里不一样。</p>
</li>
<li><p>如果打印出来和自己预先模拟推导是一样的，那么就是自己的递归公式、初始化或者遍历顺序有问题了。</p>
</li>
<li><p>如果和自己预先模拟推导的不一样，那么就是代码实现细节有问题。</p>
</li>
</ul>
<p><strong>这样才是一个完整的思考过程，而不是一旦代码出问题，就毫无头绪的东改改西改改，最后过不了，或者说是稀里糊涂的过了</strong>。</p>
<p>这也是我为什么在动规五步曲里强调推导dp数组的重要性。</p>
<ul>
<li>这道题目我举例推导状态转移公式了么？</li>
<li>我打印dp数组的日志了么？</li>
<li>打印出来了dp数组和我想的一样么？</li>
</ul>
<p><strong>如果这灵魂三问自己都做到了，基本上这道题目也就解决了</strong>，或者更清晰的知道自己究竟是哪一点不明白，是状态转移不明白，还是实现代码不知道该怎么写，还是不理解遍历dp数组的顺序。</p>
<h1 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h1><h2 id="斐波那契数"><a href="#斐波那契数" class="headerlink" title="斐波那契数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/fibonacci-number/">斐波那契数</a></h2><p>斐波那契数，通常用 F(n) 表示，形成的序列称为斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是： F(0) &#x3D; 0，F(1) &#x3D; 1，F(n) &#x3D; F(n - 1) + F(n - 2)，其中 n &gt; 1 给你n ，请计算 F(n) 。</p>
<p>示例 1：</p>
<ul>
<li>输入：2</li>
<li>输出：1</li>
<li>解释：F(2) &#x3D; F(1) + F(0) &#x3D; 1 + 0 &#x3D; 1</li>
</ul>
<p>示例 2：</p>
<ul>
<li>输入：3</li>
<li>输出：2</li>
<li>解释：F(3) &#x3D; F(2) + F(1) &#x3D; 1 + 1 &#x3D; 2</li>
</ul>
<p>示例 3：</p>
<ul>
<li>输入：4</li>
<li>输出：3</li>
<li>解释：F(4) &#x3D; F(3) + F(2) &#x3D; 2 + 1 &#x3D; 3</li>
</ul>
<p>提示：</p>
<ul>
<li>0 &lt;&#x3D; n &lt;&#x3D; 30</li>
</ul>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>动态规划五部曲：</p>
<p>这里我们要用一个一维dp数组来保存递归的结果</p>
<ol>
<li>确定dp数组以及下标的含义</li>
</ol>
<p>dp[i]的定义为：第i个数的斐波那契数值是dp[i]</p>
<ol start="2">
<li>确定递推公式</li>
</ol>
<p>为什么这是一道非常简单的入门题目呢？</p>
<p><strong>因为题目已经把递推公式直接给我们了：状态转移方程 dp[i] &#x3D; dp[i - 1] + dp[i - 2];</strong></p>
<ol start="3">
<li>dp数组如何初始化</li>
</ol>
<p><strong>题目中把如何初始化也直接给我们了，如下：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>确定遍历顺序</li>
</ol>
<p>从递归公式dp[i] &#x3D; dp[i - 1] + dp[i - 2];中可以看出，dp[i]是依赖 dp[i - 1] 和 dp[i - 2]，那么遍历的顺序一定是从前到后遍历的</p>
<ol start="5">
<li>举例推导dp数组</li>
</ol>
<p>按照这个递推公式dp[i] &#x3D; dp[i - 1] + dp[i - 2]，我们来推导一下，当N为10的时候，dp数组应该是如下的数列：</p>
<p>0 1 1 2 3 5 8 13 21 34 55</p>
<p>如果代码写出来，发现结果不对，就把dp数组打印出来看看和我们推导的数列是不是一致的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fib</span><span class="params">(<span class="type">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (N &lt;= <span class="number">1</span>) <span class="keyword">return</span> N;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(N + <span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= N; i++) &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[N];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(n)</li>
</ul>
<p>其实我们只需要维护两个数值就可以了，不需要记录整个序列。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fib</span><span class="params">(<span class="type">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (N &lt;= <span class="number">1</span>) <span class="keyword">return</span> N;</span><br><span class="line">        <span class="type">int</span> dp[<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= N; i++) &#123;</span><br><span class="line">            <span class="type">int</span> sum = dp[<span class="number">0</span>] + dp[<span class="number">1</span>];</span><br><span class="line">            dp[<span class="number">0</span>] = dp[<span class="number">1</span>];</span><br><span class="line">            dp[<span class="number">1</span>] = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/climbing-stairs/">爬楼梯</a></h2><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p>
<p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<p>注意：给定 n 是一个正整数。</p>
<p>示例 1：</p>
<ul>
<li>输入： 2</li>
<li>输出： 2</li>
<li>解释： 有两种方法可以爬到楼顶。<ul>
<li>1 阶 + 1 阶</li>
<li>2 阶</li>
</ul>
</li>
</ul>
<p>示例 2：</p>
<ul>
<li>输入： 3</li>
<li>输出： 3</li>
<li>解释： 有三种方法可以爬到楼顶。<ul>
<li>1 阶 + 1 阶 + 1 阶</li>
<li>1 阶 + 2 阶</li>
<li>2 阶 + 1 阶</li>
</ul>
</li>
</ul>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>多举几个例子，就可以发现其规律。</p>
<p>爬到第一层楼梯有一种方法，爬到二层楼梯有两种方法。</p>
<p>那么第一层楼梯再跨两步就到第三层 ，第二层楼梯再跨一步就到第三层。</p>
<p>所以到第三层楼梯的状态可以由第二层楼梯 和 到第一层楼梯状态推导出来，那么就可以想到动态规划了。</p>
<p>我们来分析一下，动规五部曲：</p>
<p>定义一个一维数组来记录不同楼层的状态</p>
<ol>
<li>确定dp数组以及下标的含义</li>
</ol>
<p>dp[i]： 爬到第i层楼梯，有dp[i]种方法</p>
<ol start="2">
<li>确定递推公式</li>
</ol>
<p>怎样推导出dp[i]呢？</p>
<p>从dp[i]的定义可以看出，dp[i] 可以有两个方向推出来。</p>
<p>首先是dp[i - 1]，上i-1层楼梯，有dp[i - 1]种方法，那么再一步跳一个台阶不就是dp[i]了么。</p>
<p>还有就是dp[i - 2]，上i-2层楼梯，有dp[i - 2]种方法，那么再一步跳两个台阶不就是dp[i]了么。</p>
<p>那么dp[i]就是 dp[i - 1]与dp[i - 2]之和！</p>
<p>所以<strong>dp[i] &#x3D; dp[i - 1] + dp[i - 2]</strong> 。</p>
<p>在推导dp[i]的时候，一定要时刻想着dp[i]的定义，否则容易跑偏。</p>
<p>这体现出确定dp数组以及下标的含义的重要性！</p>
<ol start="3">
<li>dp数组如何初始化</li>
</ol>
<p>在回顾一下dp[i]的定义：爬到第i层楼梯，有dp[i]中方法。</p>
<p>那么i为0，dp[i]应该是多少呢，这个可以有很多解释，但都基本是直接奔着答案去解释的。</p>
<p>例如强行安慰自己爬到第0层，也有一种方法，什么都不做也就是一种方法即：dp[0] &#x3D; 1，相当于直接站在楼顶。</p>
<p>但总有点牵强的成分。</p>
<p>那还这么理解呢：我就认为跑到第0层，方法就是0啊，一步只能走一个台阶或者两个台阶，然而楼层是0，直接站楼顶上了，就是不用方法，dp[0]就应该是0.</p>
<p><strong>其实这么争论下去没有意义，大部分解释说dp[0]应该为1的理由其实是因为dp[0]&#x3D;1的话在递推的过程中i从2开始遍历本题就能过，然后就往结果上靠去解释dp[0] &#x3D; 1</strong>。</p>
<p>从dp数组定义的角度上来说，dp[0] &#x3D; 0 也能说得通。</p>
<p>需要注意的是：题目中说了n是一个正整数，题目根本就没说n有为0的情况。</p>
<p>所以本题其实就不应该讨论dp[0]的初始化！</p>
<p>我相信dp[1] &#x3D; 1，dp[2] &#x3D; 2，这个初始化大家应该都没有争议的。</p>
<p>所以我的原则是：不考虑dp[0]如果初始化，只初始化dp[1] &#x3D; 1，dp[2] &#x3D; 2，然后从i &#x3D; 3开始递推，这样才符合dp[i]的定义。</p>
<ol start="4">
<li>确定遍历顺序</li>
</ol>
<p>从递推公式dp[i] &#x3D; dp[i - 1] + dp[i - 2];中可以看出，遍历顺序一定是从前向后遍历的</p>
<ol start="5">
<li>举例推导dp数组</li>
</ol>
<p>举例当n为5的时候，dp table（dp数组）应该是这样的</p>
<p><img src="https://img-blog.csdnimg.cn/20210105202546299.png" alt="70.爬楼梯"></p>
<p>如果代码出问题了，就把dp table 打印出来，看看究竟是不是和自己推导的一样。</p>
<p><strong>此时大家应该发现了，这不就是斐波那契数列么！</strong></p>
<p>唯一的区别是，没有讨论dp[0]应该是什么，因为dp[0]在本题没有意义！</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n; <span class="comment">// 因为下面直接对dp[2]操作了，防止空指针</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123; <span class="comment">// 注意i是从3开始的</span></span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>优化一下空间复杂度</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="type">int</span> dp[<span class="number">3</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> sum = dp[<span class="number">1</span>] + dp[<span class="number">2</span>];</span><br><span class="line">            dp[<span class="number">1</span>] = dp[<span class="number">2</span>];</span><br><span class="line">            dp[<span class="number">2</span>] = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="使用最小花费爬楼梯"><a href="#使用最小花费爬楼梯" class="headerlink" title="使用最小花费爬楼梯"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/min-cost-climbing-stairs/">使用最小花费爬楼梯</a></h2><p>数组的每个下标作为一个阶梯，第 i 个阶梯对应着一个非负数的体力花费值 cost[i]（下标从 0 开始）。</p>
<p>每当你爬上一个阶梯你都要花费对应的体力值，一旦支付了相应的体力值，你就可以选择向上爬一个阶梯或者爬两个阶梯。</p>
<p>请你找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为 0 或 1 的元素作为初始阶梯。</p>
<p>示例 1：</p>
<p>输入：cost &#x3D; [10, 15, 20] 输出：15 </p>
<p>解释：最低花费是从 cost[1] 开始，然后走两步即可到阶梯顶，一共花费 15 。  示例 2：</p>
<p>输入：cost &#x3D; [1, 100, 1, 1, 1, 100, 1, 1, 100, 1] 输出：6 </p>
<p>解释：最低花费方式是从 cost[0] 开始，逐个经过那些 1 ，跳过 cost[3] ，一共花费 6 。</p>
<p>提示：</p>
<ul>
<li>cost 的长度范围是 [2, 1000]。</li>
<li>cost[i] 将会是一个整型数据，范围为 [0, 999] 。</li>
</ul>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p><strong>注意题目描述：每当你爬上一个阶梯你都要花费对应的体力值，一旦支付了相应的体力值，你就可以选择向上爬一个阶梯或者爬两个阶梯</strong></p>
<p>所以示例1中只花费一个15 就可以到阶梯顶，最后一步可以理解为 不用花费。</p>
<p>读完题大家应该知道指定需要动态规划的，贪心是不可能了。</p>
<ol>
<li>确定dp数组以及下标的含义</li>
</ol>
<p>使用动态规划，就要有一个数组来记录状态，本题只需要一个一维数组dp[i]就可以了。</p>
<p>**dp[i]的定义：到达第i个台阶所花费的最少体力为dp[i]**。（注意这里认为是第一步一定是要花费）</p>
<p><strong>对于dp数组的定义，大家一定要清晰！</strong></p>
<ol start="2">
<li>确定递推公式</li>
</ol>
<p>**可以有两个途径得到dp[i]，一个是dp[i-1] 一个是dp[i-2]**。</p>
<p>那么究竟是选dp[i-1]还是dp[i-2]呢？</p>
<p>一定是选最小的，所以dp[i] &#x3D; min(dp[i - 1], dp[i - 2]) + cost[i];</p>
<p><strong>注意这里为什么是加cost[i]，而不是cost[i-1],cost[i-2]之类的</strong></p>
<p>因为题目中说了：<strong>每当你爬上一个阶梯你都要花费对应的体力值</strong></p>
<ol start="3">
<li>dp数组如何初始化</li>
</ol>
<p>根据dp数组的定义，dp数组初始化其实是比较难的，因为不可能初始化为第i台阶所花费的最少体力。</p>
<p>那么看一下递归公式，dp[i]由dp[i-1]，dp[i-2]推出，既然初始化所有的dp[i]是不可能的，那么只初始化dp[0]和dp[1]就够了，其他的最终都是dp[0]dp[1]推出。</p>
<p>所以初始化代码为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(cost.size())</span></span>;</span><br><span class="line">dp[<span class="number">0</span>] = cost[<span class="number">0</span>];</span><br><span class="line">dp[<span class="number">1</span>] = cost[<span class="number">1</span>];</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>确定遍历顺序</li>
</ol>
<p>最后一步，递归公式有了，初始化有了，如何遍历呢？</p>
<p>本题的遍历顺序其实比较简单，简单到很多同学都忽略了思考这一步直接就把代码写出来了。</p>
<p>因为是模拟台阶，而且dp[i]又dp[i-1]dp[i-2]推出，所以是从前到后遍历cost数组就可以了。</p>
<p><strong>但是稍稍有点难度的动态规划，其遍历顺序并不容易确定下来</strong>。</p>
<p>例如：01背包，都知道两个for循环，一个for遍历物品嵌套一个for遍历背包容量，那么为什么不是一个for遍历背包容量嵌套一个for遍历物品呢？ 以及在使用一维dp数组的时候遍历背包容量为什么要倒序呢？</p>
<ol start="5">
<li>举例推导dp数组</li>
</ol>
<p>拿示例2：cost &#x3D; [1, 100, 1, 1, 1, 100, 1, 1, 100, 1] ，来模拟一下dp数组的状态变化，如下：</p>
<p><img src="https://img-blog.csdnimg.cn/2021010621363669.png" alt="746.使用最小花费爬楼梯"></p>
<p>如果代码写出来有问题，就把dp数组打印出来，看看和如上推导的是不是一样的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(cost.size())</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = cost[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = cost[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; cost.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            dp[i] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>], dp[i - <span class="number">2</span>]) + cost[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注意最后一步可以理解为不用花费，所以取倒数第一步，第二步的最少值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(dp[cost.<span class="built_in">size</span>() - <span class="number">1</span>], dp[cost.<span class="built_in">size</span>() - <span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>还可以优化空间复杂度，因为dp[i]就是由前两位推出来的，那么也不用dp数组了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> dp0 = cost[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> dp1 = cost[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; cost.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> dpi = <span class="built_in">min</span>(dp0, dp1) + cost[i];</span><br><span class="line">            dp0 = dp1; <span class="comment">// 记录一下前两位</span></span><br><span class="line">            dp1 = dpi;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(dp0, dp1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="不同路径"><a href="#不同路径" class="headerlink" title="不同路径"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/unique-paths/">不同路径</a></h2><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p>
<p>问总共有多少条不同的路径？</p>
<p>示例 1：</p>
<p><img src="https://img-blog.csdnimg.cn/20210110174033215.png"></p>
<ul>
<li>输入：m &#x3D; 3, n &#x3D; 7</li>
<li>输出：28</li>
</ul>
<p>示例 2：</p>
<ul>
<li>输入：m &#x3D; 2, n &#x3D; 3</li>
<li>输出：3</li>
</ul>
<p>解释： 从左上角开始，总共有 3 条路径可以到达右下角。</p>
<ol>
<li>向右 -&gt; 向右 -&gt; 向下</li>
<li>向右 -&gt; 向下 -&gt; 向右</li>
<li>向下 -&gt; 向右 -&gt; 向右</li>
</ol>
<p>示例 3：</p>
<ul>
<li>输入：m &#x3D; 7, n &#x3D; 3</li>
<li>输出：28</li>
</ul>
<p>示例 4：</p>
<ul>
<li>输入：m &#x3D; 3, n &#x3D; 3</li>
<li>输出：6</li>
</ul>
<p>提示：</p>
<ul>
<li>1 &lt;&#x3D; m, n &lt;&#x3D; 100</li>
<li>题目数据保证答案小于等于 2 * 10^9</li>
</ul>
<h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><h4 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h4><p>这道题目，刚一看最直观的想法就是用图论里的深搜，来枚举出来有多少种路径。</p>
<p>注意题目中说机器人每次只能向下或者向右移动一步，那么其实<strong>机器人走过的路径可以抽象为一棵二叉树，而叶子节点就是终点！</strong></p>
<p>如图举例：</p>
<p><img src="https://img-blog.csdnimg.cn/20201209113602700.png" alt="62.不同路径"></p>
<p>此时问题就可以转化为求二叉树叶子节点的个数，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; m || j &gt; n) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 越界了</span></span><br><span class="line">        <span class="keyword">if</span> (i == m &amp;&amp; j == n) <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 找到一种方法，相当于找到了叶子节点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(i + <span class="number">1</span>, j, m, n) + <span class="built_in">dfs</span>(i, j + <span class="number">1</span>, m, n);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">1</span>, m, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>大家如果提交了代码就会发现超时了！</strong></p>
<p>来分析一下时间复杂度，这个深搜的算法，其实就是要遍历整个二叉树。</p>
<p>这棵树的深度其实就是m+n-1（深度按从1开始计算）。</p>
<p>那二叉树的节点个数就是 2^(m + n - 1) - 1。可以理解深搜的算法就是遍历了整个满二叉树（其实没有遍历整个满二叉树，只是近似而已）</p>
<p>所以上面深搜代码的时间复杂度为O(2^(m + n - 1) - 1)，可以看出，这是指数级别的时间复杂度，是非常大的。</p>
<h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><p>机器人从(0 , 0) 位置出发，到(m - 1, n - 1)终点。</p>
<p>按照动规五部曲来分析：</p>
<ol>
<li>确定dp数组（dp table）以及下标的含义</li>
</ol>
<p>dp[i][j] ：表示从（0 ，0）出发，到(i, j) 有dp[i][j]条不同的路径。</p>
<ol start="2">
<li>确定递推公式</li>
</ol>
<p>想要求dp[i][j]，只能有两个方向来推导出来，即dp[i - 1][j] 和 dp[i][j - 1]。</p>
<p>此时在回顾一下 dp[i - 1][j] 表示啥，是从(0, 0)的位置到(i - 1, j)有几条路径，dp[i][j - 1]同理。</p>
<p>那么很自然，dp[i][j] &#x3D; dp[i - 1][j] + dp[i][j - 1]，因为dp[i][j]只有这两个方向过来。</p>
<ol start="3">
<li>dp数组的初始化</li>
</ol>
<p>如何初始化呢，首先dp[i][0]一定都是1，因为从(0, 0)的位置到(i, 0)的路径只有一条，那么dp[0][j]也同理。</p>
<p>所以初始化代码为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>确定遍历顺序</li>
</ol>
<p>这里要看一下递归公式dp[i][j] &#x3D; dp[i - 1][j] + dp[i][j - 1]，dp[i][j]都是从其上方和左方推导而来，那么从左到右一层一层遍历就可以了。</p>
<p>这样就可以保证推导dp[i][j]的时候，dp[i - 1][j] 和 dp[i][j - 1]一定是有数值的。</p>
<ol start="5">
<li>举例推导dp数组</li>
</ol>
<p>如图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20201209113631392.png" alt="62.不同路径1"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>));<span class="comment">//将m，n数组初始化数值全为0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="不同路径-II"><a href="#不同路径-II" class="headerlink" title="不同路径 II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/unique-paths-ii/">不同路径 II</a></h2><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p>
<p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p>
<p>网格中的障碍物和空位置分别用 1 和 0 来表示。</p>
<p>示例 1：</p>
<p><img src="https://img-blog.csdnimg.cn/20210111204939971.png"></p>
<ul>
<li>输入：obstacleGrid &#x3D; [[0,0,0],[0,1,0],[0,0,0]]</li>
<li>输出：2 解释：</li>
<li>3x3 网格的正中间有一个障碍物。</li>
<li>从左上角到右下角一共有 2 条不同的路径：<ol>
<li>向右 -&gt; 向右 -&gt; 向下 -&gt; 向下</li>
<li>向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</li>
</ol>
</li>
</ul>
<p>示例 2：</p>
<p><img src="https://img-blog.csdnimg.cn/20210111205857918.png"></p>
<ul>
<li>输入：obstacleGrid &#x3D; [[0,1],[0,0]]</li>
<li>输出：1</li>
</ul>
<p>提示：</p>
<ul>
<li>m &#x3D;&#x3D; obstacleGrid.length</li>
<li>n &#x3D;&#x3D; obstacleGrid[i].length</li>
<li>1 &lt;&#x3D; m, n &lt;&#x3D; 100</li>
<li>obstacleGrid[i][j] 为 0 或 1</li>
</ul>
<h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>这道题相对于<a target="_blank" rel="noopener" href="https://programmercarl.com/0062.%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84.html">62.不同路径</a>就是有了障碍。</p>
<p>第一次接触这种题目的同学可能会有点懵，这有障碍了，应该怎么算呢？</p>
<p>62.不同路径 中我们已经详细分析了没有障碍的情况，有障碍的话，其实就是标记对应的dp table（dp数组）保持初始值(0)就可以了。</p>
<p>动规五部曲：</p>
<ol>
<li>确定dp数组（dp table）以及下标的含义</li>
</ol>
<p>dp[i][j] ：表示从（0 ，0）出发，到(i, j) 有dp[i][j]条不同的路径。</p>
<ol start="2">
<li>确定递推公式</li>
</ol>
<p>递推公式和62.不同路径一样，dp[i][j] &#x3D; dp[i - 1][j] + dp[i][j - 1]。</p>
<p>但这里需要注意一点，因为有了障碍，(i, j)如果就是障碍的话应该就保持初始状态（初始状态为0）。</p>
<p>所以代码为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (obstacleGrid[i][j] == <span class="number">0</span>) &#123; <span class="comment">// 当(i, j)没有障碍的时候，再推导dp[i][j]</span></span><br><span class="line">    dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>dp数组如何初始化</li>
</ol>
<p>在62.不同路径 不同路径中我们给出如下的初始化：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>)); <span class="comment">// 初始值为0</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>因为从(0, 0)的位置到(i, 0)的路径只有一条，所以dp[i][0]一定为1，dp[0][j]也同理。</p>
<p>但如果(i, 0) 这条边有了障碍之后，障碍之后（包括障碍）都是走不到的位置了，所以<strong>障碍之后的dp[i][0]应该还是初始值0</strong>。</p>
<p>如图：</p>
<p><img src="https://img-blog.csdnimg.cn/20210104114513928.png" alt="63.不同路径II"></p>
<p>下标(0, j)的初始化情况同理。</p>
<p>所以本题初始化代码为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m &amp;&amp; obstacleGrid[i][<span class="number">0</span>] == <span class="number">0</span>; i++) dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n &amp;&amp; obstacleGrid[<span class="number">0</span>][j] == <span class="number">0</span>; j++) dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p><strong>注意代码里for循环的终止条件，一旦遇到obstacleGrid[i][0] &#x3D;&#x3D; 1的情况就停止dp[i][0]的赋值1的操作，dp[0][j]同理</strong></p>
<ol start="4">
<li>确定遍历顺序</li>
</ol>
<p>从递归公式dp[i][j] &#x3D; dp[i - 1][j] + dp[i][j - 1] 中可以看出，一定是从左到右一层一层遍历，这样保证推导dp[i][j]的时候，dp[i - 1][j] 和 dp[i][j - 1]一定是有数值。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obstacleGrid[i][j] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>举例推导dp数组</li>
</ol>
<p>拿示例1来举例如题：</p>
<p><img src="https://img-blog.csdnimg.cn/20210104114548983.png" alt="63.不同路径II1"></p>
<p>对应的dp table 如图：</p>
<p><img src="https://img-blog.csdnimg.cn/20210104114610256.png" alt="63.不同路径II2"></p>
<p>如果这个图看不同，建议在理解一下递归公式，然后照着文章中说的遍历顺序，自己推导一下​！​</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = obstacleGrid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = obstacleGrid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m &amp;&amp; obstacleGrid[i][<span class="number">0</span>] == <span class="number">0</span>; i++) dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n &amp;&amp; obstacleGrid[<span class="number">0</span>][j] == <span class="number">0</span>; j++) dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (obstacleGrid[i][j] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="整数拆分"><a href="#整数拆分" class="headerlink" title="整数拆分"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/integer-break/">整数拆分</a></h2><p>给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。</p>
<p>示例 1:</p>
<ul>
<li>输入: 2</li>
<li>输出: 1</li>
<li>解释: 2 &#x3D; 1 + 1, 1 × 1 &#x3D; 1。</li>
</ul>
<p>示例 2:</p>
<ul>
<li><p>输入: 10</p>
</li>
<li><p>输出: 36</p>
</li>
<li><p>解释: 10 &#x3D; 3 + 3 + 4, 3 × 3 × 4 &#x3D; 36。</p>
</li>
<li><p>说明: 你可以假设 n 不小于 2 且不大于 58。</p>
</li>
</ul>
<h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><p>动规五部曲，分析如下：</p>
<ol>
<li>确定dp数组（dp table）以及下标的含义</li>
</ol>
<p>dp[i]：分拆数字i，可以得到的最大乘积为dp[i]。</p>
<p>dp[i]的定义讲贯彻整个解题过程，下面哪一步想不懂了，就想想dp[i]究竟表示的是啥！</p>
<ol start="2">
<li>确定递推公式</li>
</ol>
<p>可以想 dp[i]最大乘积是怎么得到的呢？</p>
<p>其实可以从1遍历j，然后有两种渠道得到dp[i].</p>
<p>一个是j * (i - j) 直接相乘。</p>
<p>一个是j * dp[i - j]，相当于是拆分(i - j)，对这个拆分不理解的话，可以回想dp数组的定义。</p>
<p><strong>那有同学问了，j怎么就不拆分呢？</strong></p>
<p>j是从1开始遍历，拆分j的情况，在遍历j的过程中其实都计算过了。那么从1遍历j，比较(i - j) * j和dp[i - j] * j 取最大的。递推公式：dp[i] &#x3D; max(dp[i], max((i - j) * j, dp[i - j] * j));</p>
<p>也可以这么理解，j * (i - j) 是单纯的把整数拆分为两个数相乘，而j * dp[i - j]是拆分成两个以及两个以上的个数相乘。</p>
<p>如果定义dp[i - j] * dp[j] 也是默认将一个数强制拆成4份以及4份以上了。</p>
<p>所以递推公式：dp[i] &#x3D; max({dp[i], (i - j) * j, dp[i - j] * j});</p>
<p>那么在取最大值的时候，为什么还要比较dp[i]呢？</p>
<p>因为在递推公式推导的过程中，每次计算dp[i]，取最大的而已。</p>
<ol start="3">
<li>dp的初始化</li>
</ol>
<p>不少同学应该疑惑，dp[0] dp[1]应该初始化多少呢？</p>
<p>有的题解里会给出dp[0] &#x3D; 1，dp[1] &#x3D; 1的初始化，但解释比较牵强，主要还是因为这么初始化可以把题目过了。</p>
<p>严格从dp[i]的定义来说，dp[0] dp[1] 就不应该初始化，也就是没有意义的数值。</p>
<p>拆分0和拆分1的最大乘积是多少？</p>
<p>这是无解的。</p>
<p>这里我只初始化dp[2] &#x3D; 1，从dp[i]的定义来说，拆分数字2，得到的最大乘积是1，这个没有任何异议！</p>
<ol start="4">
<li>确定遍历顺序</li>
</ol>
<p>确定遍历顺序，先来看看递归公式：dp[i] &#x3D; max(dp[i], max((i - j) * j, dp[i - j] * j));</p>
<p>dp[i] 是依靠 dp[i - j]的状态，所以遍历i一定是从前向后遍历，先有dp[i - j]再有dp[i]。</p>
<p>枚举j的时候，是从1开始的。i是从3开始，这样dp[i - j]就是dp[2]正好可以通过我们初始化的数值求出来。</p>
<p>所以遍历顺序为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n ; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">        dp[i] = <span class="built_in">max</span>(dp[i], <span class="built_in">max</span>((i - j) * j, dp[i - j] * j));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>举例推导dp数组</li>
</ol>
<p>举例当n为10 的时候，dp数组里的数值，如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20210104173021581.png" alt="343.整数拆分"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">integerBreak</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n ; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                dp[i] = <span class="built_in">max</span>(dp[i], <span class="built_in">max</span>((i - j) * j, dp[i - j] * j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="不同的二叉搜索树"><a href="#不同的二叉搜索树" class="headerlink" title="不同的二叉搜索树"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/unique-binary-search-trees/">不同的二叉搜索树</a></h2><p>给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？</p>
<p>示例:</p>
<p><img src="https://img-blog.csdnimg.cn/20210113161941835.png"></p>
<h3 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h3><p>这道题目描述很简短，但估计大部分同学看完都是懵懵的状态，这得怎么统计呢？</p>
<p>关于什么是二叉搜索树，可以看看这篇<a target="_blank" rel="noopener" href="https://programmercarl.com/0700.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2.html">二叉树：二叉搜索树登场！</a>讲得非常棒！。</p>
<p>了解了二叉搜索树之后，我们应该先举几个例子，画画图，看看有没有什么规律，如图：</p>
<p><img src="https://img-blog.csdnimg.cn/20210107093106367.png" alt="96.不同的二叉搜索树"></p>
<p>n为1的时候有一棵树，n为2有两棵树，这个是很直观的。</p>
<p><img src="https://img-blog.csdnimg.cn/20210107093129889.png" alt="96.不同的二叉搜索树1"></p>
<p>来看看n为3的时候，有哪几种情况。</p>
<p>当1为头结点的时候，其右子树有两个节点，看这两个节点的布局，是不是和 n 为2的时候两棵树的布局是一样的啊！</p>
<p>（可能有同学问了，这布局不一样啊，节点数值都不一样。别忘了我们就是求不同树的数量，并不用把搜索树都列出来，所以不用关心其具体数值的差异）</p>
<p>当3为头结点的时候，其左子树有两个节点，看这两个节点的布局，是不是和n为2的时候两棵树的布局也是一样的啊！</p>
<p>当2为头结点的时候，其左右子树都只有一个节点，布局是不是和n为1的时候只有一棵树的布局也是一样的啊！</p>
<p>发现到这里，其实我们就找到了重叠子问题了，其实也就是发现可以通过dp[1] 和 dp[2] 来推导出来dp[3]的某种方式。</p>
<p>思考到这里，这道题目就有眉目了。</p>
<p>dp[3]，就是 元素1为头结点搜索树的数量 + 元素2为头结点搜索树的数量 + 元素3为头结点搜索树的数量</p>
<p>元素1为头结点搜索树的数量 &#x3D; 右子树有2个元素的搜索树数量 * 左子树有0个元素的搜索树数量</p>
<p>元素2为头结点搜索树的数量 &#x3D; 右子树有1个元素的搜索树数量 * 左子树有1个元素的搜索树数量</p>
<p>元素3为头结点搜索树的数量 &#x3D; 右子树有0个元素的搜索树数量 * 左子树有2个元素的搜索树数量</p>
<p>有2个元素的搜索树数量就是dp[2]。</p>
<p>有1个元素的搜索树数量就是dp[1]。</p>
<p>有0个元素的搜索树数量就是dp[0]。</p>
<p>所以dp[3] &#x3D; dp[2] * dp[0] + dp[1] * dp[1] + dp[0] * dp[2]</p>
<p>如图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20210107093226241.png" alt="96.不同的二叉搜索树2"></p>
<p>此时我们已经找到递推关系了，那么可以用动规五部曲再系统分析一遍。</p>
<ol>
<li>确定dp数组（dp table）以及下标的含义</li>
</ol>
<p>**dp[i] ： 1到i为节点组成的二叉搜索树的个数为dp[i]**。</p>
<p>也可以理解是i的不同元素节点组成的二叉搜索树的个数为dp[i] ，都是一样的。</p>
<p>以下分析如果想不清楚，就来回想一下dp[i]的定义</p>
<ol start="2">
<li>确定递推公式</li>
</ol>
<p>在上面的分析中，其实已经看出其递推关系， dp[i] +&#x3D; dp[以j为头结点左子树节点数量] * dp[以j为头结点右子树节点数量]</p>
<p>j相当于是头结点的元素，从1遍历到i为止。</p>
<p>所以递推公式：dp[i] +&#x3D; dp[j - 1] * dp[i - j]; ，j-1 为j为头结点左子树节点数量，i-j 为以j为头结点右子树节点数量</p>
<ol start="3">
<li>dp数组如何初始化</li>
</ol>
<p>初始化，只需要初始化dp[0]就可以了，推导的基础，都是dp[0]。</p>
<p>那么dp[0]应该是多少呢？</p>
<p>从定义上来讲，空节点也是一棵二叉树，也是一棵二叉搜索树，这是可以说得通的。</p>
<p>从递归公式上来讲，dp[以j为头结点左子树节点数量] * dp[以j为头结点右子树节点数量] 中以j为头结点左子树节点数量为0，也需要dp[以j为头结点左子树节点数量] &#x3D; 1， 否则乘法的结果就都变成0了。</p>
<p>所以初始化dp[0] &#x3D; 1</p>
<ol start="4">
<li>确定遍历顺序</li>
</ol>
<p>首先一定是遍历节点数，从递归公式：dp[i] +&#x3D; dp[j - 1] * dp[i - j]可以看出，节点数为i的状态是依靠 i之前节点数的状态。</p>
<p>那么遍历i里面每一个数作为头结点的状态，用j来遍历。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">        dp[i] += dp[j - <span class="number">1</span>] * dp[i - j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>举例推导dp数组</li>
</ol>
<p>n为5时候的dp数组状态如图：</p>
<p><img src="https://img-blog.csdnimg.cn/20210107093253987.png" alt="96.不同的二叉搜索树3"></p>
<p>当然如果自己画图举例的话，基本举例到n为3就可以了，n为4的时候，画图已经比较麻烦了。</p>
<p><strong>我这里列到了n为5的情况，是为了方便大家 debug代码的时候，把dp数组打出来，看看哪里有问题</strong>。</p>
<p>综上分析完毕，C++代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numTrees</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">                dp[i] += dp[j - <span class="number">1</span>] * dp[i - j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="0-1背包-一"><a href="#0-1背包-一" class="headerlink" title="0-1背包(一)"></a><a target="_blank" rel="noopener" href="https://www.programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-1.html#_01-%E8%83%8C%E5%8C%85">0-1背包(一)</a></h2><p>对于面试的话，其实掌握01背包，和完全背包，就够用了，最多可以再来一个多重背包。</p>
<p>如果这几种背包，分不清，我这里画了一个图，如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20210117171307407.png" alt="416.分割等和子集1"></p>
<p>至于背包九讲其其他背包，面试几乎不会问，都是竞赛级别的了，leetcode上连多重背包的题目都没有，所以题库也告诉我们，01背包和完全背包就够用了。</p>
<p>而完全背包又是也是01背包稍作变化而来，即：完全背包的物品数量是无限的。</p>
<p><strong>所以背包问题的理论基础重中之重是01背包，一定要理解透！</strong></p>
<p><strong>所以我先通过纯01背包问题，把01背包原理讲清楚，后续再讲解leetcode题目的时候，重点就是讲解如何转化为01背包问题了</strong>。</p>
<p>有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。<strong>每件物品只能用一次</strong>，求解将哪些物品装入背包里物品价值总和最大。</p>
<p><img src="https://img-blog.csdnimg.cn/20210117175428387.jpg" alt="动态规划-背包问题"></p>
<p>这是标准的背包问题，以至于很多同学看了这个自然就会想到背包，甚至都不知道暴力的解法应该怎么解了。</p>
<p>这样其实是没有从底向上去思考，而是习惯性想到了背包，那么暴力的解法应该是怎么样的呢？</p>
<p>每一件物品其实只有两个状态，取或者不取，所以可以使用回溯法搜索出所有的情况，那么时间复杂度就是$o(2^n)$，这里的n表示物品数量。</p>
<p><strong>所以暴力的解法是指数级别的时间复杂度。进而才需要动态规划的解法来进行优化！</strong></p>
<p>在下面的讲解中，我举一个例子：</p>
<p>背包最大重量为4。</p>
<p>物品为：</p>
<table>
<thead>
<tr>
<th></th>
<th>重量</th>
<th>价值</th>
</tr>
</thead>
<tbody><tr>
<td>物品0</td>
<td>1</td>
<td>15</td>
</tr>
<tr>
<td>物品1</td>
<td>3</td>
<td>20</td>
</tr>
<tr>
<td>物品2</td>
<td>4</td>
<td>30</td>
</tr>
</tbody></table>
<p>问背包能背的物品最大价值是多少？</p>
<p>以下讲解和图示中出现的数字都是以这个例子为例。</p>
<h3 id="二维dp数组01背包"><a href="#二维dp数组01背包" class="headerlink" title="二维dp数组01背包"></a>二维dp数组01背包</h3><p>依然动规五部曲分析一波。</p>
<ol>
<li>确定dp数组以及下标的含义</li>
</ol>
<p>对于背包问题，有一种写法， 是使用二维数组，即<strong>dp[i][j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少</strong>。</p>
<p>只看这个二维数组的定义，大家一定会有点懵，看下面这个图：</p>
<p><img src="https://img-blog.csdnimg.cn/20210110103003361.png" alt="动态规划-背包问题1"></p>
<p><strong>要时刻记着这个dp数组的含义，下面的一些步骤都围绕这dp数组的含义进行的</strong>，如果哪里看懵了，就来回顾一下i代表什么，j又代表什么。</p>
<ol start="2">
<li>确定递推公式</li>
</ol>
<p>再回顾一下dp[i][j]的含义：从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少。</p>
<p>那么可以有两个方向推出来dp[i][j]，</p>
<ul>
<li><strong>不放物品i</strong>：由dp[i - 1][j]推出，即背包容量为j，里面不放物品i的最大价值，此时dp[i][j]就是dp[i - 1][j]。(其实就是当物品i的重量大于背包j的重量时，物品i无法放进背包中，所以被背包内的价值依然和前面相同。)</li>
<li><strong>放物品i</strong>：由dp[i - 1][j - weight[i]]推出，dp[i - 1][j - weight[i]] 为背包容量为j - weight[i]的时候不放物品i的最大价值，那么dp[i - 1][j - weight[i]] + value[i] （物品i的价值），就是背包放物品i得到的最大价值</li>
</ul>
<p>所以递归公式： dp[i][j] &#x3D; max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);</p>
<ol start="3">
<li>dp数组如何初始化</li>
</ol>
<p><strong>关于初始化，一定要和dp数组的定义吻合，否则到递推公式的时候就会越来越乱</strong>。</p>
<p>首先从dp[i][j]的定义出发，如果背包容量j为0的话，即dp[i][0]，无论是选取哪些物品，背包价值总和一定为0。如图：</p>
<p><img src="https://img-blog.csdnimg.cn/2021011010304192.png" alt="动态规划-背包问题2"></p>
<p>在看其他情况。</p>
<p>状态转移方程 dp[i][j] &#x3D; max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]); 可以看出i 是由 i-1 推导出来，那么i为0的时候就一定要初始化。</p>
<p>dp[0][j]，即：i为0，存放编号0的物品的时候，各个容量的背包所能存放的最大价值。</p>
<p>那么很明显当 j &lt; weight[0]的时候，dp[0][j] 应该是 0，因为背包容量比编号0的物品重量还小。</p>
<p>当j &gt;&#x3D; weight[0]时，dp[0][j] 应该是value[0]，因为背包容量放足够放编号0物品。</p>
<p>代码初始化如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span> ; j &lt; weight[<span class="number">0</span>]; j++) &#123;  <span class="comment">// 当然这一步，如果把dp数组预先初始化为0了，这一步就可以省略，但很多同学应该没有想清楚这一点。</span></span><br><span class="line">    dp[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 正序遍历</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = weight[<span class="number">0</span>]; j &lt;= bagweight; j++) &#123;</span><br><span class="line">    dp[<span class="number">0</span>][j] = value[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时dp数组初始化情况如图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20210110103109140.png" alt="动态规划-背包问题7"></p>
<p>dp[0][j] 和 dp[i][0] 都已经初始化了，那么其他下标应该初始化多少呢？</p>
<p>其实从递归公式： dp[i][j] &#x3D; max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]); 可以看出dp[i][j] 是由左上方数值推导出来了，那么 其他下标初始为什么数值都可以，因为都会被覆盖。</p>
<p><strong>初始-1，初始-2，初始100，都可以！</strong></p>
<p>但只不过一开始就统一把dp数组统一初始为0，更方便一些。</p>
<p>如图：</p>
<p><img src="https://code-thinking.cdn.bcebos.com/pics/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%9810.jpg" alt="动态规划-背包问题10"></p>
<p>最后初始化代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化 dp</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(weight.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(bagweight + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = weight[<span class="number">0</span>]; j &lt;= bagweight; j++) &#123;</span><br><span class="line">    dp[<span class="number">0</span>][j] = value[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>费了这么大的功夫，才把如何初始化讲清楚，相信不少同学平时初始化dp数组是凭感觉来的，但有时候感觉是不靠谱的</strong>。</p>
<ol start="4">
<li>确定遍历顺序</li>
</ol>
<p>在如下图中，可以看出，有两个遍历的维度：物品与背包重量</p>
<p><img src="https://img-blog.csdnimg.cn/2021011010314055.png" alt="动态规划-背包问题3"></p>
<p>那么问题来了，<strong>先遍历 物品还是先遍历背包重量呢？</strong></p>
<p><strong>其实都可以！！ 但是先遍历物品更好理解</strong>。</p>
<p>那么我先给出先遍历物品，然后遍历背包重量的代码。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// weight数组的大小 就是物品个数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; weight.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= bagweight; j++) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">        <span class="keyword">if</span> (j &lt; weight[i]) dp[i][j] = dp[i - <span class="number">1</span>][j]; </span><br><span class="line">        <span class="keyword">else</span> dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - weight[i]] + value[i]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>先遍历背包，再遍历物品，也是可以的！（注意我这里使用的二维dp数组）</strong></p>
<p>例如这样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// weight数组的大小 就是物品个数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= bagweight; j++) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; weight.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">        <span class="keyword">if</span> (j &lt; weight[i]) dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">        <span class="keyword">else</span> dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - weight[i]] + value[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么也是可以的呢？</p>
<p><strong>要理解递归的本质和递推的方向</strong>。</p>
<p>dp[i][j] &#x3D; max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]); 递归公式中可以看出dp[i][j]是靠dp[i-1][j]和dp[i - 1][j - weight[i]]推导出来的。</p>
<p>dp[i-1][j]和dp[i - 1][j - weight[i]] 都在dp[i][j]的左上角方向（包括正上方向），那么先遍历物品，再遍历背包的过程如图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/202101101032124.png" alt="动态规划-背包问题5"></p>
<p>再来看看先遍历背包，再遍历物品呢，如图：</p>
<p><img src="https://img-blog.csdnimg.cn/20210110103244701.png" alt="动态规划-背包问题6"></p>
<p><strong>大家可以看出，虽然两个for循环遍历的次序不同，但是dp[i][j]所需要的数据就是左上角，根本不影响dp[i][j]公式的推导！</strong></p>
<p>但先遍历物品再遍历背包这个顺序更好理解。</p>
<p><strong>其实背包问题里，两个for循环的先后循序是非常有讲究的，理解遍历顺序其实比理解推导公式难多了</strong>。</p>
<ol start="5">
<li>举例推导dp数组</li>
</ol>
<p>来看一下对应的dp数组的数值，如图：</p>
<p><img src="https://img-blog.csdnimg.cn/20210118163425129.jpg" alt="动态规划-背包问题4"></p>
<p>最终结果就是dp[2][4]。</p>
<p>建议大家此时自己在纸上推导一遍，看看dp数组里每一个数值是不是这样的。</p>
<p><strong>做动态规划的题目，最好的过程就是自己在纸上举一个例子把对应的dp数组的数值推导一下，然后在动手写代码！</strong></p>
<p>很多同学做dp题目，遇到各种问题，然后凭感觉东改改西改改，怎么改都不对，或者稀里糊涂就改过了。</p>
<p>主要就是自己没有动手推导一下dp数组的演变过程，如果推导明白了，代码写出来就算有问题，只要把dp数组打印出来，对比一下和自己推导的有什么差异，很快就可以发现问题了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_2_wei_bag_problem1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; weight = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; value = &#123;<span class="number">15</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;</span><br><span class="line">    <span class="type">int</span> bagweight = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二维数组</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(weight.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(bagweight + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = weight[<span class="number">0</span>]; j &lt;= bagweight; j++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][j] = value[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// weight数组的大小 就是物品个数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; weight.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= bagweight; j++) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">            <span class="keyword">if</span> (j &lt; weight[i]) dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">else</span> dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - weight[i]] + value[i]);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; dp[weight.<span class="built_in">size</span>() - <span class="number">1</span>][bagweight] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test_2_wei_bag_problem1</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="0-1背包问题（二）"><a href="#0-1背包问题（二）" class="headerlink" title="0-1背包问题（二）"></a><a target="_blank" rel="noopener" href="https://www.programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-2.html#%E4%B8%80%E7%BB%B4dp01%E8%83%8C%E5%8C%85%E5%AE%8C%E6%95%B4c-%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81">0-1背包问题（二）</a></h2><p>今天我们就来说一说滚动数组，其实在前面的题目中我们已经用到过滚动数组了，就是把二维dp降为一维dp，一些录友当时还表示比较困惑。</p>
<p>那么我们通过01背包，来彻底讲一讲滚动数组！</p>
<p>接下来还是用如下这个例子来进行讲解</p>
<p>背包最大重量为4。</p>
<p>物品为：</p>
<table>
<thead>
<tr>
<th></th>
<th>重量</th>
<th>价值</th>
</tr>
</thead>
<tbody><tr>
<td>物品0</td>
<td>1</td>
<td>15</td>
</tr>
<tr>
<td>物品1</td>
<td>3</td>
<td>20</td>
</tr>
<tr>
<td>物品2</td>
<td>4</td>
<td>30</td>
</tr>
</tbody></table>
<p>问背包能背的物品最大价值是多少？</p>
<p>对于背包问题其实状态都是可以压缩的。</p>
<p>在使用二维数组的时候，递推公式：dp[i][j] &#x3D; max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);</p>
<p><strong>其实可以发现如果把dp[i - 1]那一层拷贝到dp[i]上，表达式完全可以是：dp[i][j] &#x3D; max(dp[i][j], dp[i][j - weight[i]] + value[i]);</strong></p>
<p><strong>与其把dp[i - 1]这一层拷贝到dp[i]上，不如只用一个一维数组了</strong>，只用dp[j]（一维数组，也可以理解是一个滚动数组）。</p>
<p>这就是滚动数组的由来，<strong>需要满足的条件是上一层可以重复利用，直接拷贝到当前层</strong>。</p>
<p>读到这里估计大家都忘了 dp[i][j]里的i和j表达的是什么了，i是物品，j是背包容量。</p>
<p><strong>dp[i][j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少</strong>。</p>
<p>一定要时刻记住这里i和j的含义，要不然很容易看懵了。</p>
<p>动规五部曲分析如下：</p>
<ol>
<li>确定dp数组的定义</li>
</ol>
<p>在一维dp数组中，dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]。</p>
<ol start="2">
<li>一维dp数组的递推公式</li>
</ol>
<p>dp[j]为 容量为j的背包所背的最大价值，那么如何推导dp[j]呢？</p>
<p>dp[j]可以通过dp[j - weight[i]]推导出来，dp[j - weight[i]]表示容量为j - weight[i]的背包所背的最大价值。</p>
<p>dp[j - weight[i]] + value[i] 表示 容量为 j - 物品i重量 的背包 加上 物品i的价值。（也就是容量为j的背包，放入物品i了之后的价值即：dp[j]）</p>
<p>此时dp[j]有两个选择，一个是取自己dp[j] 相当于 二维dp数组中的dp[i-1][j]，即不放物品i，一个是取dp[j - weight[i]] + value[i]，即放物品i，指定是取最大的，毕竟是求最大价值，</p>
<p>所以递归公式为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[j] = <span class="built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);</span><br></pre></td></tr></table></figure>

<p>可以看出相对于二维dp数组的写法，就是把dp[i][j]中i的维度去掉了。</p>
<ol start="3">
<li>一维dp数组如何初始化</li>
</ol>
<p><strong>关于初始化，一定要和dp数组的定义吻合，否则到递推公式的时候就会越来越乱</strong>。</p>
<p>dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]，那么dp[0]就应该是0，因为背包容量为0所背的物品的最大价值就是0。</p>
<p>那么dp数组除了下标0的位置，初始为0，其他下标应该初始化多少呢？</p>
<p>看一下递归公式：dp[j] &#x3D; max(dp[j], dp[j - weight[i]] + value[i]);</p>
<p>dp数组在推导的时候一定是取价值最大的数，如果题目给的价值都是正整数那么非0下标都初始化为0就可以了。</p>
<p><strong>这样才能让dp数组在递归公式的过程中取的最大的价值，而不是被初始值覆盖了</strong>。</p>
<p>那么我假设物品价值都是大于0的，所以dp数组初始化的时候，都初始为0就可以了。</p>
<ol start="4">
<li>一维dp数组遍历顺序</li>
</ol>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; weight.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = bagWeight; j &gt;= weight[i]; j--) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">        dp[j] = <span class="built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>这里大家发现和二维dp的写法中，遍历背包的顺序是不一样的！</strong></p>
<p>二维dp遍历的时候，背包容量是从小到大，而一维dp遍历的时候，背包是从大到小。</p>
<p>为什么呢？</p>
<p><strong>倒序遍历是为了保证物品i只被放入一次！</strong>。但如果一旦正序遍历了，那么物品0就会被重复加入多次！</p>
<p>举一个例子：物品0的重量weight[0] &#x3D; 1，价值value[0] &#x3D; 15</p>
<p>如果正序遍历</p>
<p>dp[1] &#x3D; dp[1 - weight[0]] + value[0] &#x3D; 15</p>
<p>dp[2] &#x3D; dp[2 - weight[0]] + value[0] &#x3D; 30</p>
<p>此时dp[2]就已经是30了，意味着物品0，被放入了两次，所以不能正序遍历。</p>
<p>为什么倒序遍历，就可以保证物品只放入一次呢？</p>
<p>倒序就是先算dp[2]</p>
<p>dp[2] &#x3D; dp[2 - weight[0]] + value[0] &#x3D; 15 （dp数组已经都初始化为0）</p>
<p>dp[1] &#x3D; dp[1 - weight[0]] + value[0] &#x3D; 15</p>
<p>所以从后往前循环，每次取得状态不会和之前取得状态重合，这样每种物品就只取一次了。</p>
<p><strong>那么问题又来了，为什么二维dp数组历的时候不用倒序呢？</strong></p>
<p>因为对于二维dp，dp[i][j]都是通过上一层即dp[i - 1][j]计算而来，本层的dp[i][j]并不会被覆盖！</p>
<p>（如何这里读不懂，大家就要动手试一试了，空想还是不靠谱的，实践出真知！）</p>
<p><strong>再来看看两个嵌套for循环的顺序，代码中是先遍历物品嵌套遍历背包容量，那可不可以先遍历背包容量嵌套遍历物品呢？</strong></p>
<p>不可以！</p>
<p>因为一维dp的写法，背包容量一定是要倒序遍历（原因上面已经讲了），如果遍历背包容量放在上一层，那么每个dp[j]就只会放入一个物品，即：背包里只放入了一个物品。</p>
<p>（这里如果读不懂，就在回想一下dp[j]的定义，或者就把两个for循环顺序颠倒一下试试！）</p>
<p><strong>所以一维dp数组的背包在遍历顺序上和二维其实是有很大差异的！</strong>，这一点大家一定要注意。</p>
<ol start="5">
<li>举例推导dp数组</li>
</ol>
<p>一维dp，分别用物品0，物品1，物品2 来遍历背包，最终得到结果如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20210110103614769.png" alt="动态规划-背包问题9"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_1_wei_bag_problem</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; weight = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; value = &#123;<span class="number">15</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;</span><br><span class="line">    <span class="type">int</span> bagWeight = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(bagWeight + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; weight.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = bagWeight; j &gt;= weight[i]; j--) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">            dp[j] = <span class="built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[bagWeight] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test_1_wei_bag_problem</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，一维dp 的01背包，要比二维简洁的多！ 初始化 和 遍历顺序相对简单了。</p>
<p><strong>所以我倾向于使用一维dp数组的写法，比较直观简洁，而且空间复杂度还降了一个数量级！</strong></p>
<h2 id="分割等和子集"><a href="#分割等和子集" class="headerlink" title="分割等和子集"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/partition-equal-subset-sum/">分割等和子集</a></h2><p>给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p>
<p>注意: 每个数组中的元素不会超过 100 数组的大小不会超过 200</p>
<p>示例 1: 输入: [1, 5, 11, 5] 输出: true 解释: 数组可以分割成 [1, 5, 5] 和 [11].</p>
<p>示例 2: 输入: [1, 2, 3, 5] 输出: false 解释: 数组不能分割成两个元素和相等的子集.</p>
<p>提示：</p>
<ul>
<li>1 &lt;&#x3D; nums.length &lt;&#x3D; 200</li>
<li>1 &lt;&#x3D; nums[i] &lt;&#x3D; 100</li>
</ul>
<h3 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h3><p>这道题目初步看，是如下两题几乎是一样的，大家可以用回溯法，解决如下两题</p>
<ul>
<li>698.划分为k个相等的子集</li>
<li>473.火柴拼正方形</li>
</ul>
<p>这道题目是要找是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p>
<p>那么只要找到集合里能够出现 sum &#x2F; 2 的子集总和，就算是可以分割成两个相同元素和子集了。</p>
<p>本题是可以用回溯暴力搜索出所有答案的，但最后超时了，也不想再优化了，放弃回溯，直接上01背包吧。</p>
<p>背包问题，大家都知道，有N件物品和一个最多能被重量为W 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品只能用一次，求解将哪些物品装入背包里物品价值总和最大。</p>
<p><strong>背包问题有多种背包方式，常见的有：01背包、完全背包、多重背包、分组背包和混合背包等等。</strong></p>
<p>要注意题目描述中商品是不是可以重复放入。</p>
<p><strong>即一个商品如果可以重复多次放入是完全背包，而只能放入一次是01背包，写法还是不一样的。</strong></p>
<p><strong>要明确本题中我们要使用的是01背包，因为元素我们只能用一次。</strong></p>
<p>回归主题：首先，本题要求集合里能否出现总和为 sum &#x2F; 2 的子集。</p>
<p>那么来一一对应一下本题，看看背包问题如果来解决。</p>
<p><strong>只有确定了如下四点，才能把01背包问题套到本题上来。</strong></p>
<ul>
<li>背包的体积为sum &#x2F; 2</li>
<li>背包要放入的商品（集合里的元素）重量为 元素的数值，价值也为元素的数值</li>
<li>背包如果正好装满，说明找到了总和为 sum &#x2F; 2 的子集。</li>
<li>背包中每一个元素是不可重复放入。</li>
</ul>
<p>以上分析完，我们就可以套用01背包，来解决这个问题了。</p>
<p>动规五部曲分析如下：</p>
<ol>
<li>确定dp数组以及下标的含义</li>
</ol>
<p>01背包中，dp[j] 表示： 容量为j的背包，所背的物品价值可以最大为dp[j]。</p>
<p>**套到本题，dp[j]表示 背包总容量是j，最大可以凑成j的子集总和为dp[j]**。</p>
<ol start="2">
<li>确定递推公式</li>
</ol>
<p>01背包的递推公式为：dp[j] &#x3D; max(dp[j], dp[j - weight[i]] + value[i]);</p>
<p>本题，相当于背包里放入数值，那么物品i的重量是nums[i]，其价值也是nums[i]。</p>
<p>所以递推公式：dp[j] &#x3D; max(dp[j], dp[j - nums[i]] + nums[i]);</p>
<ol start="3">
<li>dp数组如何初始化</li>
</ol>
<p>在01背包，一维dp如何初始化，已经讲过，</p>
<p>从dp[j]的定义来看，首先dp[0]一定是0。</p>
<p>如果如果题目给的价值都是正整数那么非0下标都初始化为0就可以了，如果题目给的价值有负数，那么非0下标就要初始化为负无穷。</p>
<p><strong>这样才能让dp数组在递归公式的过程中取的最大的价值，而不是被初始值覆盖了</strong>。</p>
<p>本题题目中 只包含正整数的非空数组，所以非0下标的元素初始化为0就可以了。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 题目中说：每个数组中的元素不会超过 100，数组的大小不会超过 200</span></span><br><span class="line"><span class="comment">// 总和不会大于20000，背包最大只需要其中一半，所以10001大小就可以了</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(<span class="number">10001</span>, <span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>确定遍历顺序</li>
</ol>
<p>在<a target="_blank" rel="noopener" href="https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-2.html">动态规划：关于01背包问题，你该了解这些！（滚动数组）</a>中就已经说明：如果使用一维dp数组，物品遍历的for循环放在外层，遍历背包的for循环放在内层，且内层for循环倒序遍历！</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开始 01背包</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = target; j &gt;= nums[i]; j--) &#123; <span class="comment">// 每一个元素一定是不可重复放入，所以从大到小遍历</span></span><br><span class="line">        dp[j] = <span class="built_in">max</span>(dp[j], dp[j - nums[i]] + nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>举例推导dp数组</li>
</ol>
<p>dp[j]的数值一定是小于等于j的。</p>
<p><strong>如果dp[j] &#x3D;&#x3D; j 说明，集合中的子集总和正好可以凑成总和j，理解这一点很重要。</strong></p>
<p>用例1，输入[1,5,11,5] 为例，如图：</p>
<p><img src="https://img-blog.csdnimg.cn/20210110104240545.png" alt="416.分割等和子集2"></p>
<p>最后dp[11] &#x3D;&#x3D; 11，说明可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canPartition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// dp[i]中的i表示背包内总和</span></span><br><span class="line">        <span class="comment">// 题目中说：每个数组中的元素不会超过 100，数组的大小不会超过 200</span></span><br><span class="line">        <span class="comment">// 总和不会大于20000，背包最大只需要其中一半，所以10001大小就可以了</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(<span class="number">10001</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum % <span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> target = sum / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始 01背包</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = target; j &gt;= nums[i]; j--) &#123; <span class="comment">// 每一个元素一定是不可重复放入，所以从大到小遍历</span></span><br><span class="line">                dp[j] = <span class="built_in">max</span>(dp[j], dp[j - nums[i]] + nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 集合中的元素正好可以凑成总和target</span></span><br><span class="line">        <span class="keyword">if</span> (dp[target] == target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="最后一块石头的重量II"><a href="#最后一块石头的重量II" class="headerlink" title="最后一块石头的重量II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/last-stone-weight-ii/">最后一块石头的重量II</a></h2><p>有一堆石头，每块石头的重量都是正整数。</p>
<p>每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x &lt;&#x3D; y。那么粉碎的可能结果如下：</p>
<p>如果 x &#x3D;&#x3D; y，那么两块石头都会被完全粉碎； 如果 x !&#x3D; y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。 最后，最多只会剩下一块石头。返回此石头最小的可能重量。如果没有石头剩下，就返回 0。</p>
<p>示例： 输入：[2,7,4,1,8,1] </p>
<p>输出：1 </p>
<p>解释： 组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]， 组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]， 组合 2 和 1，得到 1，所以数组转化为 [1,1,1]， 组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。</p>
<p>提示：</p>
<ul>
<li>1 &lt;&#x3D; stones.length &lt;&#x3D; 30</li>
<li>1 &lt;&#x3D; stones[i] &lt;&#x3D; 1000</li>
</ul>
<h3 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h3><p>本题其实就是尽量让石头分成重量相同的两堆，相撞之后剩下的石头最小，<strong>这样就化解成01背包问题了</strong>。</p>
<p>是不是感觉和<a target="_blank" rel="noopener" href="https://programmercarl.com/0416.%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86.html">416. 分割等和子集 </a>非常像了。</p>
<p>本题物品的重量为store[i]，物品的价值也为store[i]。</p>
<p>对应着01背包里的物品重量weight[i]和 物品价值value[i]。</p>
<p>接下来进行动规五步曲：</p>
<ol>
<li>确定dp数组以及下标的含义</li>
</ol>
<p><strong>dp[j]表示容量（这里说容量更形象，其实就是重量）为j的背包，最多可以背dp[j]这么重的石头</strong>。</p>
<ol start="2">
<li>确定递推公式</li>
</ol>
<p>01背包的递推公式为：dp[j] &#x3D; max(dp[j], dp[j - weight[i]] + value[i]);</p>
<p>本题则是：<strong>dp[j] &#x3D; max(dp[j], dp[j - stones[i]] + stones[i]);</strong></p>
<p>一些同学可能看到这dp[j - stones[i]] + stones[i]中 又有- stones[i] 又有+stones[i]，看着有点晕乎。</p>
<p>还是要牢记dp[j]的含义，要知道dp[j - stones[i]]为 容量为j - stones[i]的背包最大所背重量。</p>
<ol start="3">
<li>dp数组如何初始化</li>
</ol>
<p>既然 dp[j]中的j表示容量，那么最大容量（重量）是多少呢，就是所有石头的重量和。</p>
<p>因为提示中给出1 &lt;&#x3D; stones.length &lt;&#x3D; 30，1 &lt;&#x3D; stones[i] &lt;&#x3D; 1000，所以最大重量就是30 * 1000 。</p>
<p>而我们要求的target其实只是最大重量的一半，所以dp数组开到15000大小就可以了。</p>
<p>当然也可以把石头遍历一遍，计算出石头总重量 然后除2，得到dp数组的大小。</p>
<p>我这里就直接用15000了。</p>
<p>接下来就是如何初始化dp[j]呢，因为重量都不会是负数，所以dp[j]都初始化为0就可以了，这样在递归公式dp[j] &#x3D; max(dp[j], dp[j - stones[i]] + stones[i]);中dp[j]才不会初始值所覆盖。</p>
<p>代码为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(<span class="number">15001</span>, <span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>确定遍历顺序</li>
</ol>
<p>在<a target="_blank" rel="noopener" href="https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-2.html">动态规划：关于01背包问题，你该了解这些！（滚动数组）</a>中就已经说明：如果使用一维dp数组，物品遍历的for循环放在外层，遍历背包的for循环放在内层，且内层for循环倒序遍历！</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; stones.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = target; j &gt;= stones[i]; j--) &#123; <span class="comment">// 遍历背包</span></span><br><span class="line">        dp[j] = <span class="built_in">max</span>(dp[j], dp[j - stones[i]] + stones[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>举例推导dp数组</li>
</ol>
<p>举例，输入：[2,4,1,1]，此时target &#x3D; (2 + 4 + 1 + 1)&#x2F;2 &#x3D; 4 ，dp数组状态图如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20210121115805904.jpg" alt="1049.最后一块石头的重量II"></p>
<p>最后dp[target]里是容量为target的背包所能背的最大重量。</p>
<p>那么分成两堆石头，一堆石头的总重量是dp[target]，另一堆就是sum - dp[target]。</p>
<p><strong>在计算target的时候，target &#x3D; sum &#x2F; 2 因为是向下取整，所以sum - dp[target] 一定是大于等于dp[target]的</strong>。</p>
<p>那么相撞之后剩下的最小石头重量就是 (sum - dp[target]) - dp[target]。</p>
<p>以上分析完毕，C++代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lastStoneWeightII</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(<span class="number">15001</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; stones.<span class="built_in">size</span>(); i++) sum += stones[i];</span><br><span class="line">        <span class="type">int</span> target = sum / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; stones.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = target; j &gt;= stones[i]; j--) &#123; <span class="comment">// 遍历背包</span></span><br><span class="line">                dp[j] = <span class="built_in">max</span>(dp[j], dp[j - stones[i]] + stones[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum - dp[target] - dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="目标和"><a href="#目标和" class="headerlink" title="目标和"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/target-sum/">目标和</a></h3><p>给定一个非负整数数组，a1, a2, …, an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。</p>
<p>返回可以使最终数组和为目标数 S 的所有添加符号的方法数。</p>
<p>示例：</p>
<p>输入：nums: [1, 1, 1, 1, 1], S: 3<br>输出：5</p>
<p>解释：<br>-1+1+1+1+1 &#x3D; 3<br>+1-1+1+1+1 &#x3D; 3<br>+1+1-1+1+1 &#x3D; 3<br>+1+1+1-1+1 &#x3D; 3<br>+1+1+1+1-1 &#x3D; 3</p>
<p>一共有5种方法让最终目标和为3。</p>
<p>提示：</p>
<ul>
<li>数组非空，且长度不会超过 20 。</li>
<li>初始的数组的和不会超过 1000 。</li>
<li>保证返回的最终结果能被 32 位整数存下。</li>
</ul>
<h3 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h3><p>如果跟着「代码随想录」一起学过<a target="_blank" rel="noopener" href="https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E6%80%BB%E7%BB%93.html">回溯算法系列 </a>的录友，看到这道题，应该有一种直觉，就是感觉好像回溯法可以爆搜出来。</p>
<p>事实确实如此，下面我也会给出相应的代码，只不过会超时，哈哈。</p>
<p>这道题目咋眼一看和动态规划背包啥的也没啥关系。</p>
<p>本题要如何使表达式结果为target，</p>
<p>既然为target，那么就一定有 left组合 - right组合 &#x3D; target。</p>
<p>left + right等于sum，而sum是固定的。</p>
<p>公式来了， left - (sum - left) &#x3D; target -&gt; left &#x3D; (target + sum)&#x2F;2 。</p>
<p>target是固定的，sum是固定的，left就可以求出来。</p>
<p>此时问题就是在集合nums中找出和为left的组合。</p>
<h4 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h4><p>在回溯算法系列中，一起学过这道题目<a target="_blank" rel="noopener" href="https://programmercarl.com/0039.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C.html">回溯算法：39. 组合总和 </a>的录友应该感觉很熟悉，这不就是组合总和问题么？</p>
<p>此时可以套组合总和的回溯法代码，几乎不用改动。</p>
<p>当然，也可以转变成序列区间选+ 或者 -，使用回溯法，那就是另一个解法。</p>
<p>我也把代码给出来吧，大家可以了解一下，回溯的解法，以下是本题转变为组合总和问题的回溯法代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target, <span class="type">int</span> sum, <span class="type">int</span> startIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(path);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 sum + candidates[i] &gt; target 就终止遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; candidates.<span class="built_in">size</span>() &amp;&amp; sum + candidates[i] &lt;= target; i++) &#123;</span><br><span class="line">            sum += candidates[i];</span><br><span class="line">            path.<span class="built_in">push_back</span>(candidates[i]);</span><br><span class="line">            <span class="built_in">backtracking</span>(candidates, target, sum, i + <span class="number">1</span>);</span><br><span class="line">            sum -= candidates[i];</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findTargetSumWays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) sum += nums[i];</span><br><span class="line">        <span class="keyword">if</span> (S &gt; sum) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 此时没有方案</span></span><br><span class="line">        <span class="keyword">if</span> ((S + sum) % <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 此时没有方案，两个int相加的时候要各位小心数值溢出的问题</span></span><br><span class="line">        <span class="type">int</span> bagSize = (S + sum) / <span class="number">2</span>; <span class="comment">// 转变为组合总和问题，bagsize就是要求的和</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 以下为回溯法代码</span></span><br><span class="line">        result.<span class="built_in">clear</span>();</span><br><span class="line">        path.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()); <span class="comment">// 需要排序</span></span><br><span class="line">        <span class="built_in">backtracking</span>(nums, bagSize, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="动态规划-1"><a href="#动态规划-1" class="headerlink" title="动态规划"></a>动态规划</h4><p>如何转化为01背包问题呢。</p>
<p>假设加法的总和为x，那么减法对应的总和就是sum - x。</p>
<p>所以我们要求的是 x - (sum - x) &#x3D; S</p>
<p>x &#x3D; (S + sum) &#x2F; 2</p>
<p><strong>此时问题就转化为，装满容量为x背包，有几种方法</strong>。</p>
<p>大家看到(S + sum) &#x2F; 2 应该担心计算的过程中向下取整有没有影响。</p>
<p>这么担心就对了，例如sum 是5，S是2的话其实就是无解的，所以：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((S + sum) % <span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 此时没有方案</span></span><br></pre></td></tr></table></figure>

<p>同时如果 S的绝对值已经大于sum，那么也是没有方案的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">abs</span>(S) &gt; sum) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 此时没有方案</span></span><br></pre></td></tr></table></figure>

<p>再回归到01背包问题，为什么是01背包呢？</p>
<p>因为每个物品（题目中的1）只用一次！</p>
<p>这次和之前遇到的背包问题不一样了，之前都是求容量为j的背包，最多能装多少。</p>
<p>本题则是装满有几种方法。其实这就是一个组合问题了。</p>
<ol>
<li>确定dp数组以及下标的含义</li>
</ol>
<p>dp[j] 表示：填满j（包括j）这么大容积的包，有dp[j]种方法</p>
<p>其实也可以使用二维dp数组来求解本题，dp[i][j]：使用 下标为[0, i]的nums[i]能够凑满j（包括j）这么大容量的包，有dp[i][j]种方法。</p>
<p>下面我都是统一使用一维数组进行讲解， 二维降为一维（滚动数组），其实就是上一层拷贝下来，这个我在<a target="_blank" rel="noopener" href="https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-2.html">动态规划：关于01背包问题，你该了解这些！（滚动数组） </a>也有介绍。</p>
<ol start="2">
<li>确定递推公式</li>
</ol>
<p>有哪些来源可以推出dp[j]呢？</p>
<p>不考虑nums[i]的情况下，填满容量为j - nums[i]的背包，有dp[j - nums[i]]种方法。</p>
<p>那么只要搞到nums[i]的话，凑成dp[j]就有dp[j - nums[i]] 种方法。</p>
<p>例如：dp[j]，j 为5，</p>
<ul>
<li>已经有一个1（nums[i]） 的话，有 dp[4]种方法 凑成 dp[5]。</li>
<li>已经有一个2（nums[i]） 的话，有 dp[3]种方法 凑成 dp[5]。</li>
<li>已经有一个3（nums[i]） 的话，有 dp[2]中方法 凑成 dp[5]</li>
<li>已经有一个4（nums[i]） 的话，有 dp[1]中方法 凑成 dp[5]</li>
<li>已经有一个5 （nums[i]）的话，有 dp[0]中方法 凑成 dp[5]</li>
</ul>
<p>那么凑整dp[5]有多少方法呢，也就是把 所有的 dp[j - nums[i]] 累加起来。</p>
<p>所以求组合类问题的公式，都是类似这种：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[j] += dp[j - nums[i]]</span><br></pre></td></tr></table></figure>

<p><strong>这个公式在后面在讲解背包解决排列组合问题的时候还会用到！</strong></p>
<ol start="3">
<li>dp数组如何初始化</li>
</ol>
<p>从递归公式可以看出，在初始化的时候dp[0] 一定要初始化为1，因为dp[0]是在公式中一切递推结果的起源，如果dp[0]是0的话，递归结果将都是0。</p>
<p>dp[0] &#x3D; 1，理论上也很好解释，装满容量为0的背包，有1种方法，就是装0件物品。</p>
<p>dp[j]其他下标对应的数值应该初始化为0，从递归公式也可以看出，dp[j]要保证是0的初始值，才能正确的由dp[j - nums[i]]推导出来。</p>
<ol start="4">
<li>确定遍历顺序</li>
</ol>
<p>在<a target="_blank" rel="noopener" href="https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-2.html">动态规划：关于01背包问题，你该了解这些！（滚动数组）</a>中，我们讲过对于01背包问题一维dp的遍历，nums放在外循环，target在内循环，且内循环倒序。</p>
<ol start="5">
<li>举例推导dp数组</li>
</ol>
<p>输入：nums: [1, 1, 1, 1, 1], S: 3</p>
<p>bagSize &#x3D; (S + sum) &#x2F; 2 &#x3D; (3 + 5) &#x2F; 2 &#x3D; 4</p>
<p>dp数组状态变化如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20210125120743274.jpg" alt="494.目标和"></p>
<p>C++代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findTargetSumWays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) sum += nums[i];</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span>(S) &gt; sum) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 此时没有方案</span></span><br><span class="line">        <span class="keyword">if</span> ((S + sum) % <span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 此时没有方案</span></span><br><span class="line">        <span class="type">int</span> bagSize = (S + sum) / <span class="number">2</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(bagSize + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = bagSize; j &gt;= nums[i]; j--) &#123;</span><br><span class="line">                dp[j] += dp[j - nums[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[bagSize];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(n × m)，n为正数个数，m为背包容量</li>
<li>空间复杂度：O(m)，m为背包容量</li>
</ul>
<h2 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h2><p>有N件物品和一个最多能背重量为W的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。<strong>每件物品都有无限个（也就是可以放入背包多次）</strong>，求解将哪些物品装入背包里物品价值总和最大。</p>
<p><strong>完全背包和01背包问题唯一不同的地方就是，每种物品有无限件</strong>。</p>
<p>同样leetcode上没有纯完全背包问题，都是需要完全背包的各种应用，需要转化成完全背包问题，所以我这里还是以纯完全背包问题进行讲解理论和原理。</p>
<p>在下面的讲解中，我依然举这个例子：</p>
<p>背包最大重量为4。</p>
<p>物品为：</p>
<table>
<thead>
<tr>
<th></th>
<th>重量</th>
<th>价值</th>
</tr>
</thead>
<tbody><tr>
<td>物品0</td>
<td>1</td>
<td>15</td>
</tr>
<tr>
<td>物品1</td>
<td>3</td>
<td>20</td>
</tr>
<tr>
<td>物品2</td>
<td>4</td>
<td>30</td>
</tr>
</tbody></table>
<p><strong>每件商品都有无限个！</strong></p>
<p>问背包能背的物品最大价值是多少？</p>
<p>01背包和完全背包唯一不同就是体现在遍历顺序上，所以本文就不去做动规五部曲了，我们直接针对遍历顺序经行分析！</p>
<p>首先在回顾一下01背包的核心代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; weight.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = bagWeight; j &gt;= weight[i]; j--) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">        dp[j] = <span class="built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们知道01背包内嵌的循环是从大到小遍历，为了保证每个物品仅被添加一次。</p>
<p>而完全背包的物品是可以添加多次的，所以要从小到大去遍历，即：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先遍历物品，再遍历背包</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; weight.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = weight[i]; j &lt;= bagWeight ; j++) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">        dp[j] = <span class="built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>dp状态图如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20210126104510106.jpg" alt="动态规划-完全背包"></p>
<p>相信很多同学看网上的文章，关于完全背包介绍基本就到为止了。</p>
<p><strong>其实还有一个很重要的问题，为什么遍历物品在外层循环，遍历背包容量在内层循环？</strong></p>
<p>这个问题很多题解关于这里都是轻描淡写就略过了，大家都默认 遍历物品在外层，遍历背包容量在内层，好像本应该如此一样，那么为什么呢？</p>
<p>难道就不能遍历背包容量在外层，遍历物品在内层？</p>
<p>看过这两篇的话：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-1.html">动态规划：关于01背包问题，你该了解这些！</a></li>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-2.html">动态规划：关于01背包问题，你该了解这些！（滚动数组）</a></li>
</ul>
<p>就知道了，01背包中二维dp数组的两个for遍历的先后循序是可以颠倒了，一维dp数组的两个for循环先后循序一定是先遍历物品，再遍历背包容量。</p>
<p><strong>在完全背包中，对于一维dp数组来说，其实两个for循环嵌套顺序同样无所谓！</strong></p>
<p>因为dp[j] 是根据 下标j之前所对应的dp[j]计算出来的。 只要保证下标j之前的dp[j]都是经过计算的就可以了。</p>
<p>遍历物品在外层循环，遍历背包容量在内层循环，状态如图：</p>
<p><img src="https://img-blog.csdnimg.cn/20210126104529605.jpg" alt="动态规划-完全背包1"></p>
<p>遍历背包容量在外层循环，遍历物品在内层循环，状态如图：</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210729234011.png" alt="动态规划-完全背包2"></p>
<p>看了这两个图，大家就会理解，完全背包中，两个for循环的先后循序，都不影响计算dp[j]所需要的值（这个值就是下标j之前所对应的dp[j]）。</p>
<p>先遍历背包在遍历物品，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先遍历背包，再遍历物品</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= bagWeight; j++) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; weight.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">        <span class="keyword">if</span> (j - weight[i] &gt;= <span class="number">0</span>) dp[j] = <span class="built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="零钱兑换"><a href="#零钱兑换" class="headerlink" title="零钱兑换"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/coin-change-2/">零钱兑换</a></h2><p>给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。</p>
<p>示例 1:</p>
<p>输入: amount &#x3D; 5, coins &#x3D; [1, 2, 5] </p>
<p>输出: 4 </p>
<p>解释: 有四种方式可以凑成总金额: 5&#x3D;5 5&#x3D;2+2+1 5&#x3D;2+1+1+1 5&#x3D;1+1+1+1+1</p>
<p>示例 2: </p>
<p>输入: amount &#x3D; 3, coins &#x3D; [2] </p>
<p>输出: 0 </p>
<p>解释: 只用面额2的硬币不能凑成总金额3。</p>
<p>示例 3: </p>
<p>输入: amount &#x3D; 10, coins &#x3D; [10] </p>
<p>输出: 1</p>
<p>注意，你可以假设：</p>
<ul>
<li>0 &lt;&#x3D; amount (总金额) &lt;&#x3D; 5000</li>
<li>1 &lt;&#x3D; coin (硬币面额) &lt;&#x3D; 5000</li>
<li>硬币种类不超过 500 种</li>
<li>结果符合 32 位符号整数</li>
</ul>
<h3 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h3><p>这是一道典型的背包问题，一看到钱币数量不限，就知道这是一个完全背包。</p>
<p>对完全背包还不了解的同学，可以看这篇：<a target="_blank" rel="noopener" href="https://programmercarl.com/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85.html">动态规划：关于完全背包，你该了解这些！</a></p>
<p>但本题和纯完全背包不一样，<strong>纯完全背包是能否凑成总金额，而本题是要求凑成总金额的个数！</strong></p>
<p>注意题目描述中是凑成总金额的硬币组合数，为什么强调是组合数呢？</p>
<p>例如示例一：</p>
<p>5 &#x3D; 2 + 2 + 1</p>
<p>5 &#x3D; 2 + 1 + 2</p>
<p>这是一种组合，都是 2 2 1。</p>
<p>如果问的是排列数，那么上面就是两种排列了。</p>
<p><strong>组合不强调元素之间的顺序，排列强调元素之间的顺序</strong>。 其实这一点我们在讲解回溯算法专题的时候就讲过了哈。</p>
<p>那我为什么要介绍这些呢，因为这和下文讲解遍历顺序息息相关!</p>
<p>回归本题，动规五步曲来分析如下：</p>
<ol>
<li>确定dp数组以及下标的含义</li>
</ol>
<p>dp[j]：凑成总金额j的货币组合数为dp[j]</p>
<ol start="2">
<li>确定递推公式</li>
</ol>
<p>dp[j] （考虑coins[i]的组合总和） 就是所有的dp[j - coins[i]]（不考虑coins[i]）相加。</p>
<p>所以递推公式：dp[j] +&#x3D; dp[j - coins[i]];</p>
<p><strong>这个递推公式大家应该不陌生了，我在讲解01背包题目的时候在这篇<a target="_blank" rel="noopener" href="https://programmercarl.com/0494.%E7%9B%AE%E6%A0%87%E5%92%8C.html">动态规划：目标和！</a>中就讲解了，求装满背包有几种方法，一般公式都是：dp[j] +&#x3D; dp[j - nums[i]];</strong></p>
<ol start="3">
<li>dp数组如何初始化</li>
</ol>
<p>首先dp[0]一定要为1，dp[0] &#x3D; 1是 递归公式的基础。</p>
<p>从dp[i]的含义上来讲就是，凑成总金额0的货币组合数为1。</p>
<p>下标非0的dp[j]初始化为0，这样累计加dp[j - coins[i]]的时候才不会影响真正的dp[j]</p>
<ol start="4">
<li>确定遍历顺序</li>
</ol>
<p>本题中我们是外层for循环遍历物品（钱币），内层for遍历背包（金钱总额），还是外层for遍历背包（金钱总额），内层for循环遍历物品（钱币）呢？</p>
<p>我在<a target="_blank" rel="noopener" href="https://programmercarl.com/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85.html">动态规划：关于完全背包，你该了解这些！ </a>中讲解了完全背包的两个for循环的先后顺序都是可以的。</p>
<p><strong>但本题就不行了！</strong></p>
<p>因为纯完全背包求得是能否凑成总和，和凑成总和的元素有没有顺序没关系，即：有顺序也行，没有顺序也行！</p>
<p>而本题要求凑成总和的组合数，元素之间要求没有顺序。</p>
<p>所以纯完全背包是能凑成总和就行，不用管怎么凑的。</p>
<p>本题是求凑出来的方案个数，且每个方案个数是为组合数。</p>
<p>那么本题，两个for循环的先后顺序可就有说法了。</p>
<p>我们先来看 外层for循环遍历物品（钱币），内层for遍历背包（金钱总额）的情况。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; coins.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = coins[i]; j &lt;= amount; j++) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">        dp[j] += dp[j - coins[i]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设：coins[0] &#x3D; 1，coins[1] &#x3D; 5。</p>
<p>那么就是先把1加入计算，然后再把5加入计算，得到的方法数量只有{1, 5}这种情况。而不会出现{5, 1}的情况。</p>
<p><strong>所以这种遍历顺序中dp[j]里计算的是组合数！</strong></p>
<p>如果把两个for交换顺序，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= amount; j++) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; coins.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">        <span class="keyword">if</span> (j - coins[i] &gt;= <span class="number">0</span>) dp[j] += dp[j - coins[i]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>背包容量的每一个值，都是经过 1 和 5 的计算，包含了{1, 5} 和 {5, 1}两种情况。</p>
<p><strong>此时dp[j]里算出来的就是排列数！</strong></p>
<p>可能这里很多同学还不是很理解，<strong>建议动手把这两种方案的dp数组数值变化打印出来，对比看一看！（实践出真知）</strong></p>
<ol start="5">
<li>举例推导dp数组</li>
</ol>
<p>输入: amount &#x3D; 5, coins &#x3D; [1, 2, 5] ，dp状态图如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20210120181331461.jpg" alt="518.零钱兑换II"></p>
<p>最后红色框dp[amount]为最终结果。</p>
<p>以上分析完毕，C++代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">change</span><span class="params">(<span class="type">int</span> amount, vector&lt;<span class="type">int</span>&gt;&amp; coins)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(amount + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; coins.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = coins[i]; j &lt;= amount; j++) &#123; <span class="comment">// 遍历背包</span></span><br><span class="line">                dp[j] += dp[j - coins[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="组合总和-Ⅳ"><a href="#组合总和-Ⅳ" class="headerlink" title="组合总和 Ⅳ"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/combination-sum-iv/">组合总和 Ⅳ</a></h2><p>给定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。</p>
<p>示例:</p>
<p>nums &#x3D; [1, 2, 3] target &#x3D; 4</p>
<p>所有可能的组合为： (1, 1, 1, 1) (1, 1, 2) (1, 2, 1) (1, 3) (2, 1, 1) (2, 2) (3, 1)</p>
<p>请注意，顺序不同的序列被视作不同的组合。</p>
<p>因此输出为 7。</p>
<h3 id="思路-11"><a href="#思路-11" class="headerlink" title="思路"></a>思路</h3><p>本题题目描述说是求组合，但又说是可以元素相同顺序不同的组合算两个组合，<strong>其实就是求排列！</strong></p>
<p>弄清什么是组合，什么是排列很重要。</p>
<p>组合不强调顺序，(1,5)和(5,1)是同一个组合。</p>
<p>排列强调顺序，(1,5)和(5,1)是两个不同的排列。</p>
<p>大家在公众号里学习回溯算法专题的时候，一定做过这两道题目<a target="_blank" rel="noopener" href="https://programmercarl.com/0039.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C.html">回溯算法：39.组合总和 </a>和<a target="_blank" rel="noopener" href="https://programmercarl.com/0040.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CII.html">回溯算法：40.组合总和II</a>会感觉这两题和本题很像！</p>
<p>但其本质是本题求的是排列总和，而且仅仅是求排列总和的个数，并不是把所有的排列都列出来。</p>
<p><strong>如果本题要把排列都列出来的话，只能使用回溯算法爆搜</strong>。</p>
<p>动规五部曲分析如下：</p>
<ol>
<li>确定dp数组以及下标的含义</li>
</ol>
<p><strong>dp[i]: 凑成目标正整数为i的排列个数为dp[i]</strong></p>
<ol start="2">
<li>确定递推公式</li>
</ol>
<p>dp[i]（考虑nums[j]）可以由 dp[i - nums[j]]（不考虑nums[j]） 推导出来。</p>
<p>因为只要得到nums[j]，排列个数dp[i - nums[j]]，就是dp[i]的一部分。</p>
<p>在<a target="_blank" rel="noopener" href="https://programmercarl.com/0494.%E7%9B%AE%E6%A0%87%E5%92%8C.html">动态规划：494.目标和</a>和 <a target="_blank" rel="noopener" href="https://programmercarl.com/0518.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2II.html">动态规划：518.零钱兑换II</a>中我们已经讲过了，求装满背包有几种方法，递推公式一般都是dp[i] +&#x3D; dp[i - nums[j]];</p>
<p>本题也一样。</p>
<ol start="3">
<li>dp数组如何初始化</li>
</ol>
<p>因为递推公式dp[i] +&#x3D; dp[i - nums[j]]的缘故，dp[0]要初始化为1，这样递归其他dp[i]的时候才会有数值基础。</p>
<p>至于dp[0] &#x3D; 1 有没有意义呢？</p>
<p>其实没有意义，所以我也不去强行解释它的意义了，因为题目中也说了：给定目标值是正整数！ 所以dp[0] &#x3D; 1是没有意义的，仅仅是为了推导递推公式。</p>
<p>至于非0下标的dp[i]应该初始为多少呢？</p>
<p>初始化为0，这样才不会影响dp[i]累加所有的dp[i - nums[j]]。</p>
<ol start="4">
<li>确定遍历顺序</li>
</ol>
<p>个数可以不限使用，说明这是一个完全背包。</p>
<p>得到的集合是排列，说明需要考虑元素之间的顺序。</p>
<p>本题要求的是排列，那么这个for循环嵌套的顺序可以有说法了。</p>
<p>在<a target="_blank" rel="noopener" href="https://programmercarl.com/0518.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2II.html">动态规划：518.零钱兑换II</a>中就已经讲过了。</p>
<p><strong>如果求组合数就是外层for循环遍历物品，内层for遍历背包</strong>。</p>
<p><strong>如果求排列数就是外层for遍历背包，内层for循环遍历物品</strong>。</p>
<p>如果把遍历nums（物品）放在外循环，遍历target的作为内循环的话，举一个例子：计算dp[4]的时候，结果集只有 {1,3} 这样的集合，不会有{3,1}这样的集合，因为nums遍历放在外层，3只能出现在1后面！</p>
<p>所以本题遍历顺序最终遍历顺序：<strong>target（背包）放在外循环，将nums（物品）放在内循环，内循环从前到后遍历</strong>。</p>
<ol start="5">
<li>举例来推导dp数组</li>
</ol>
<p>我们再来用示例中的例子推导一下：</p>
<p><img src="https://img-blog.csdnimg.cn/20210131174250148.jpg" alt="377.组合总和Ⅳ"></p>
<p>如果代码运行处的结果不是想要的结果，就把dp[i]都打出来，看看和我们推导的一不一样。</p>
<p>以上分析完毕，C++代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">combinationSum4</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(target + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= target; i++) &#123; <span class="comment">// 遍历背包</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; nums.<span class="built_in">size</span>(); j++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">                <span class="keyword">if</span> (i - nums[j] &gt;= <span class="number">0</span> &amp;&amp; dp[i] &lt; INT_MAX - dp[i - nums[j]]) &#123;</span><br><span class="line">                    dp[i] += dp[i - nums[j]];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="爬楼梯-1"><a href="#爬楼梯-1" class="headerlink" title="爬楼梯"></a>爬楼梯</h2><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p>
<p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<p>注意：给定 n 是一个正整数。</p>
<p>示例 1： 输入： 2 输出： 2 解释： 有两种方法可以爬到楼顶。</p>
<ol>
<li>1 阶 + 1 阶</li>
<li>2 阶</li>
</ol>
<p>示例 2： 输入： 3 输出： 3 解释： 有三种方法可以爬到楼顶。</p>
<ol>
<li>1 阶 + 1 阶 + 1 阶</li>
<li>1 阶 + 2 阶</li>
<li>2 阶 + 1 阶</li>
</ol>
<h3 id="思路-12"><a href="#思路-12" class="headerlink" title="思路"></a>思路</h3><p>这道题目 我们在<a target="_blank" rel="noopener" href="https://programmercarl.com/0070.%E7%88%AC%E6%A5%BC%E6%A2%AF.html">动态规划：爬楼梯 </a>中已经讲过一次了，原题其实是一道简单动规的题目。</p>
<p>既然这么简单为什么还要讲呢，其实本题稍加改动就是一道面试好题。</p>
<p><strong>改为：一步一个台阶，两个台阶，三个台阶，…….，直到 m个台阶。问有多少种不同的方法可以爬到楼顶呢？</strong></p>
<p>1阶，2阶，…. m阶就是物品，楼顶就是背包。</p>
<p>每一阶可以重复使用，例如跳了1阶，还可以继续跳1阶。</p>
<p>问跳到楼顶有几种方法其实就是问装满背包有几种方法。</p>
<p><strong>此时大家应该发现这就是一个完全背包问题了！</strong></p>
<p>和昨天的题目<a target="_blank" rel="noopener" href="https://programmercarl.com/0377.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%E2%85%A3.html">动态规划：377. 组合总和 Ⅳ </a>基本就是一道题了。</p>
<p>动规五部曲分析如下：</p>
<ol>
<li>确定dp数组以及下标的含义</li>
</ol>
<p><strong>dp[i]：爬到有i个台阶的楼顶，有dp[i]种方法</strong>。</p>
<ol start="2">
<li>确定递推公式</li>
</ol>
<p>在<a target="_blank" rel="noopener" href="https://programmercarl.com/0494.%E7%9B%AE%E6%A0%87%E5%92%8C.html">动态规划：494.目标和</a>、 <a target="_blank" rel="noopener" href="https://programmercarl.com/0518.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2II.html">动态规划：518.零钱兑换II </a>、<a target="_blank" rel="noopener" href="https://programmercarl.com/0377.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%E2%85%A3.html">动态规划：377. 组合总和 Ⅳ </a>中我们都讲过了，求装满背包有几种方法，递推公式一般都是dp[i] +&#x3D; dp[i - nums[j]];</p>
<p>本题呢，dp[i]有几种来源，dp[i - 1]，dp[i - 2]，dp[i - 3] 等等，即：dp[i - j]</p>
<p>那么递推公式为：dp[i] +&#x3D; dp[i - j]</p>
<ol start="3">
<li>dp数组如何初始化</li>
</ol>
<p>既然递归公式是 dp[i] +&#x3D; dp[i - j]，那么dp[0] 一定为1，dp[0]是递归中一切数值的基础所在，如果dp[0]是0的话，其他数值都是0了。</p>
<p>下标非0的dp[i]初始化为0，因为dp[i]是靠dp[i-j]累计上来的，dp[i]本身为0这样才不会影响结果</p>
<ol start="4">
<li>确定遍历顺序</li>
</ol>
<p>这是背包里求排列问题，即：<strong>1、2 步 和 2、1 步都是上三个台阶，但是这两种方法不一样！</strong></p>
<p>所以需将target放在外循环，将nums放在内循环。</p>
<p>每一步可以走多次，这是完全背包，内循环需要从前向后遍历。</p>
<ol start="5">
<li>举例来推导dp数组</li>
</ol>
<p>介于本题和<a target="_blank" rel="noopener" href="https://programmercarl.com/0377.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%E2%85%A3.html">动态规划：377. 组合总和 Ⅳ </a>几乎是一样的，这里我就不再重复举例了。</p>
<p>以上分析完毕，C++代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123; <span class="comment">// 遍历背包</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">                <span class="keyword">if</span> (i - j &gt;= <span class="number">0</span>) dp[i] += dp[i - j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>代码中m表示最多可以爬m个台阶，代码中把m改成2就是本题70.爬楼梯可以AC的代码了。</p>
<p>声明：</p>
<p>本博客整理参考《代码随想录》，题目来自leecode</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/7/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/9/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">williny</span>
</div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  





</body>
</html>
