<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.1.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.0.0/css/all.min.css" integrity="sha256-jTIdiMuX/e3DGJUGwl3pKSxuc6YOuqtJYkM0bGQESA4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.10.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="孤独是人生的常态">
<meta property="og:type" content="website">
<meta property="og:title" content="Williny&#39;home">
<meta property="og:url" content="http://example.com/page/7/index.html">
<meta property="og:site_name" content="Williny&#39;home">
<meta property="og:description" content="孤独是人生的常态">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="williny">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/7/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/7/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Williny'home</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Williny'home</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="williny"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">williny</p>
  <div class="site-description" itemprop="description">孤独是人生的常态</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">94</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/suchangche" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;suchangche" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:469478061@qq.com" title="E-Mail → mailto:469478061@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/20/UE4-%E8%93%9D%E5%9B%BE-%E8%93%9D%E5%9B%BE%E6%8E%A5%E5%8F%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="williny">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Williny'home">
      <meta itemprop="description" content="孤独是人生的常态">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Williny'home">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/05/20/UE4-%E8%93%9D%E5%9B%BE-%E8%93%9D%E5%9B%BE%E6%8E%A5%E5%8F%A3/" class="post-title-link" itemprop="url">UE4-蓝图-蓝图接口</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-05-20 14:26:02 / 修改时间：14:44:52" itemprop="dateCreated datePublished" datetime="2022-05-20T14:26:02+08:00">2022-05-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/unreal-engine/" itemprop="url" rel="index"><span itemprop="name">unreal engine</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="蓝图接口是什么？"><a href="#蓝图接口是什么？" class="headerlink" title="蓝图接口是什么？"></a>蓝图接口是什么？</h1><p>一个蓝图接口是一个或多个Function的集合，可以被添加至别的蓝图中，任何添加了接口的蓝图都可以保证具有这些功能，在每个添加了蓝图接口的蓝图类中，都可以为其添加功能实现。类似编程中的接口概念。允许不同类型的对象通过一个公共接口来访问他。</p>
<h1 id="为什么要使用蓝图接口？"><a href="#为什么要使用蓝图接口？" class="headerlink" title="为什么要使用蓝图接口？"></a>为什么要使用蓝图接口？</h1><p>在使用中蓝图接口允许一种通用的方法与所有拥有蓝图接口的对象进行交互。</p>
<p>也就是说，在不同类型的对象，他们可以拥有一个相同的功能。</p>
<p>比如汽车和树木，都可以被武器射击。所以就可以创建一个蓝图接口，在武器射击汽车或者大树时调用对应的函数。</p>
<h1 id="蓝图接口的特点"><a href="#蓝图接口的特点" class="headerlink" title="蓝图接口的特点"></a>蓝图接口的特点</h1><ul>
<li><p>目的：与多个对象中的特定几个对象进行通信</p>
</li>
<li><p>方式：对检测到的对象发送消息，只有设置了对应接口的对象才会接收到消息并且相应。其他的对象就跟瞎了一样。</p>
</li>
</ul>
<h1 id="创建蓝图接口"><a href="#创建蓝图接口" class="headerlink" title="创建蓝图接口"></a>创建蓝图接口</h1><ul>
<li><p>创建一个蓝图接口</p>
</li>
<li><p>设置目标蓝图类（接收者）</p>
</li>
<li><p>在发信者蓝图类中编写逻辑</p>
</li>
<li><p>在接收者蓝图类中调用接口</p>
</li>
</ul>
<h2 id="1-新建一个Blueprint-Interface。"><a href="#1-新建一个Blueprint-Interface。" class="headerlink" title="1.新建一个Blueprint Interface。"></a>1.新建一个Blueprint Interface。</h2><img src="https://img-blog.csdnimg.cn/2021030423122868.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTM2MzE1Ng==,size_16,color_FFFFFF,t_70" title="" alt="" width="349">

<h2 id="2-在新建的BluePrint-Interface中添加一个函数，点击Add-New即可。"><a href="#2-在新建的BluePrint-Interface中添加一个函数，点击Add-New即可。" class="headerlink" title="2.在新建的BluePrint Interface中添加一个函数，点击Add New即可。"></a>2.在新建的BluePrint Interface中添加一个函数，点击Add New即可。</h2><p>其中Voice就是叫的Function，我们在这里通过声明一个Voice的函数，然后在添加过该接口的类中写实现，然后在别的地方调用这个函数。</p>
<img src="https://img-blog.csdnimg.cn/20210304231337210.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTM2MzE1Ng==,size_16,color_FFFFFF,t_70" title="" alt="" width="572">

<h2 id="3-新建两个Actor，一个是Dog，一个Cow。"><a href="#3-新建两个Actor，一个是Dog，一个Cow。" class="headerlink" title="3.新建两个Actor，一个是Dog，一个Cow。"></a>3.新建两个Actor，一个是Dog，一个Cow。</h2><p><img src="https://img-blog.csdnimg.cn/20210304231852229.png"></p>
<h2 id="4-打开新建的Dog类，在Class-Setting中添加上面创建的蓝图接口。（设置接收者）"><a href="#4-打开新建的Dog类，在Class-Setting中添加上面创建的蓝图接口。（设置接收者）" class="headerlink" title="4.打开新建的Dog类，在Class Setting中添加上面创建的蓝图接口。（设置接收者）"></a>4.打开新建的Dog类，在Class Setting中添加上面创建的蓝图接口。（设置接收者）</h2><p><img src="https://img-blog.csdnimg.cn/20210304232034505.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTM2MzE1Ng==,size_16,color_FFFFFF,t_70"></p>
<h2 id="5-完成Voice的实现。"><a href="#5-完成Voice的实现。" class="headerlink" title="5.完成Voice的实现。"></a>5.完成Voice的实现。</h2><p><img src="https://img-blog.csdnimg.cn/20210304232133311.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTM2MzE1Ng==,size_16,color_FFFFFF,t_70"></p>
<h2 id="6-将Cow类进行同样的操作，在Print-String中输出MOUMOU。"><a href="#6-将Cow类进行同样的操作，在Print-String中输出MOUMOU。" class="headerlink" title="6.将Cow类进行同样的操作，在Print String中输出MOUMOU。"></a>6.将Cow类进行同样的操作，在Print String中输出MOUMOU。</h2><p><img src="https://img-blog.csdnimg.cn/20210304232226225.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTM2MzE1Ng==,size_16,color_FFFFFF,t_70"></p>
<h2 id="7-我们在关卡蓝图中添加该接口并调用该方法。"><a href="#7-我们在关卡蓝图中添加该接口并调用该方法。" class="headerlink" title="7.我们在关卡蓝图中添加该接口并调用该方法。"></a>7.我们在关卡蓝图中添加该接口并调用该方法。</h2><p><img src="https://img-blog.csdnimg.cn/20210304232333544.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTM2MzE1Ng==,size_16,color_FFFFFF,t_70"></p>
<h2 id="8-运行，按下2，得到Dog和cow的叫声。"><a href="#8-运行，按下2，得到Dog和cow的叫声。" class="headerlink" title="8.运行，按下2，得到Dog和cow的叫声。"></a>8.运行，按下2，得到Dog和cow的叫声。</h2><p><img src="https://img-blog.csdnimg.cn/20210304232417781.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTM2MzE1Ng==,size_16,color_FFFFFF,t_70"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>蓝图接口就是先定义了一个函数接口，告诉别人存在这个函数，可以进行调用，但是每个类中可以有不同的实现</p>
<p>蓝图接口可以进行一对多甚至多对多的广播，一处调用，多出响应。</p>
<p>版权声明：本博客参考自<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_41363156/article/details/114356562">「wang161x」</a>与<a target="_blank" rel="noopener" href="https://blog.csdn.net/Motarookie/article/details/121627783">「宗浩多捞」</a>的CSDN文章</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/18/UE4-%E8%93%9D%E5%9B%BE-%E8%A7%92%E8%89%B2%E4%B8%8A%E4%B8%8B%E8%BD%A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="williny">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Williny'home">
      <meta itemprop="description" content="孤独是人生的常态">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Williny'home">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/05/18/UE4-%E8%93%9D%E5%9B%BE-%E8%A7%92%E8%89%B2%E4%B8%8A%E4%B8%8B%E8%BD%A6/" class="post-title-link" itemprop="url">UE4-蓝图-角色上下车</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-05-18 15:21:02" itemprop="dateCreated datePublished" datetime="2022-05-18T15:21:02+08:00">2022-05-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-05-20 10:27:19" itemprop="dateModified" datetime="2022-05-20T10:27:19+08:00">2022-05-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/unreal-engine/" itemprop="url" rel="index"><span itemprop="name">unreal engine</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>本博客根据<a target="_blank" rel="noopener" href="https://space.bilibili.com/31898841">谌嘉诚</a>大佬的<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV164411Y732?p=49">虚幻蓝图教程</a>进行整理</p>
<h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><p>实现角色上车和下车的切换</p>
<h1 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h1><h2 id="获取场景变换"><a href="#获取场景变换" class="headerlink" title="获取场景变换"></a>获取场景变换</h2><p>获取目标引脚在场景中的位置，旋转，缩放等信息</p>
<p><img src="C:\Users\asus\AppData\Roaming\marktext\images\2022-05-18-15-27-40-image.png"></p>
<h2 id="拆分变换"><a href="#拆分变换" class="headerlink" title="拆分变换"></a>拆分变换</h2><p>将场景变换的位置，旋转，缩放等信息分开</p>
<p><img src="C:\Users\asus\AppData\Roaming\marktext\images\2022-05-18-15-27-50-image.png"></p>
<h2 id="设置Actor变换"><a href="#设置Actor变换" class="headerlink" title="设置Actor变换"></a>设置Actor变换</h2><p>字面意思，设置Actor的位置，旋转，缩放情况</p>
<p><img src="C:\Users\asus\AppData\Roaming\marktext\images\2022-05-18-15-28-05-image.png"></p>
<h2 id="设置Actor启用碰撞"><a href="#设置Actor启用碰撞" class="headerlink" title="设置Actor启用碰撞"></a>设置Actor启用碰撞</h2><p>关闭或开启Actor的碰撞效果</p>
<p><img src="C:\Users\asus\AppData\Roaming\marktext\images\2022-05-18-15-29-03-image.png"></p>
<h2 id="附加Actor到组件"><a href="#附加Actor到组件" class="headerlink" title="附加Actor到组件"></a>附加Actor到组件</h2><p>将Actor附加到组件上，相当于把Actor黏贴到组件上</p>
<p><img src="C:\Users\asus\AppData\Roaming\marktext\images\2022-05-18-15-29-16-image.png"></p>
<h2 id="设置手动输入"><a href="#设置手动输入" class="headerlink" title="设置手动输入"></a>设置手动输入</h2><p>让载具可以或不接收键盘的输入</p>
<p><img src="C:\Users\asus\AppData\Roaming\marktext\images\2022-05-20-10-08-08-image.png"></p>
<h2 id="设置油门输入"><a href="#设置油门输入" class="headerlink" title="设置油门输入"></a>设置油门输入</h2><p>字面意思</p>
<p><img src="C:\Users\asus\AppData\Roaming\marktext\images\2022-05-20-10-09-01-image.png"></p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>大体可分为——上车，下车，下车减速三个模块。</p>
<h2 id="实现上车"><a href="#实现上车" class="headerlink" title="实现上车"></a>实现上车</h2><p>首先弄清楚，我们需要在ThirdPersonCharacter中按F键来切换到汽车上</p>
<p>所以，可以在Sedan（汽车蓝图）内添加一个名为“上车”的自定义事件</p>
<p>然后在ThirdPersonCharacter蓝图中定义按F键调用“上车事件”</p>
<h3 id="自定义上车事件"><a href="#自定义上车事件" class="headerlink" title="自定义上车事件"></a>自定义上车事件</h3><ol>
<li><p>在Sedan(汽车蓝图内)中添加自定义事件“上车”</p>
</li>
<li><p>在ThirdPersonCharacter蓝图内添加一个Sedan类型的变量“VehicleRef”</p>
</li>
<li><p>由VehicleRef引出“上车”事件</p>
</li>
<li><p>再用Is Valid节点判断VehicleRef是否有效，如果有效，则链接“上车”事件</p>
</li>
<li><p>另外，在Sedan的“上车”事件中将目标提升为变量，并且设置为小白人，类型设置为Pawn</p>
</li>
<li><p>在ThirdPersonCharacter蓝图中的上车事件的小白人引脚引出节点“self”（小白人）</p>
</li>
</ol>
<h3 id="转移控制权"><a href="#转移控制权" class="headerlink" title="转移控制权"></a>转移控制权</h3><p>在这里，我们需要将玩家的控制权从小白人身上转换到汽车上！</p>
<ol>
<li><p>首先在汽车上面添加一个碰撞盒子，用来检测小白人是否到了可以上下车的位置</p>
</li>
<li><p>添加重叠开始和结束事件，并类型转换为ThirdPersonCharacter</p>
</li>
<li><p>用Gate判断是否可以开始</p>
</li>
<li><p>获取玩家控制器，引出“控制”节点，In Pawn引脚引出“Self”节点（汽车）</p>
</li>
<li><p>“上车”和“Gate”的输出都连接到“控制”的输入</p>
</li>
</ol>
<h3 id="将小白人附加到汽车上"><a href="#将小白人附加到汽车上" class="headerlink" title="将小白人附加到汽车上"></a>将小白人附加到汽车上</h3><ol>
<li><p>“上车”事件的小白人引脚已经在前面提升成变量了，此时由此变量节点的输出引出“设置Actor变换”节点。以此达到变换小白人位置的目标</p>
</li>
<li><p>将小白人的位置与汽车重合</p>
<ol>
<li><p>添加一个名为“up”的球体碰撞组件，将其放在汽车的合适位置</p>
</li>
<li><p>在蓝图中获取“up”节点，引出“获取场景变换”节点</p>
</li>
<li><p>再引出“拆分变换节点”</p>
</li>
<li><p>将对应的位置，旋转数据连接到“设置Actor变换”节点上，同时“获取小白人变量”将其附加到“设置Actor变换”的目标上</p>
</li>
<li><p>此时我们就实现了将小白人的位置与“up”的位置保持一致</p>
</li>
</ol>
</li>
<li><p>接下来我们需要取消小白人自身的碰撞，否则会与汽车的碰撞产生冲突，最后形成奇怪的bug</p>
<ol>
<li>“设置Actor变换”输出引出“设置Actor启用碰撞”节点，目标为“小白人”，取消勾选“New Actor Enable Collision”引脚</li>
</ol>
</li>
<li><p>最后将小白人附加到up上，这样up移动的时候就会带动小白人一起移动</p>
<ol>
<li><p>由“设置Actor启用碰撞”节点引出“附加Actor到组件”节点</p>
</li>
<li><p>目标设置为“小白人”</p>
</li>
<li><p>Parent设置为“Up”</p>
</li>
<li><p>位置，旋转，缩放均改为“保持场景一致”</p>
</li>
</ol>
</li>
</ol>
<p><img src="C:\Users\asus\AppData\Roaming\marktext\images\2022-05-19-16-43-48-image.png"></p>
<p><img src="C:\Users\asus\AppData\Roaming\marktext\images\2022-05-19-16-44-42-image.png"></p>
<p><img src="C:\Users\asus\AppData\Roaming\marktext\images\2022-05-19-16-45-00-image.png"></p>
<h2 id="实现下车"><a href="#实现下车" class="headerlink" title="实现下车"></a>实现下车</h2><p>我们在车上的时候，控制权在“车”蓝图里，所以我们只需要在“车”蓝图内设置“按键 F”进行下车操作即可，然后就是和上车的步骤反过来——将小白人和车分离，设置小白人位置，启用小白人碰撞，将控制权转换回小白人身上</p>
<h3 id="分离小白人"><a href="#分离小白人" class="headerlink" title="分离小白人"></a>分离小白人</h3><ol>
<li><p>获取小白人变量，用Is Valid判断是否有效，并且接入“键盘 F”节点</p>
</li>
<li><p>由小白人变量引出“从Actor分离”节点，将各个引脚设置为“保持场景”</p>
</li>
</ol>
<h3 id="设置小白人位置"><a href="#设置小白人位置" class="headerlink" title="设置小白人位置"></a>设置小白人位置</h3><ol>
<li><p>再添加一个名为“down”的球体碰撞组件，放在车外合适的位置</p>
</li>
<li><p>获取“down”，引出“获取场景变换”节点，引出“拆分变换”节点</p>
</li>
<li><p>由小白人变量引出“设置Actor变换”节点，并与“从Actor分离”节点链接</p>
</li>
<li><p>将“设置Actor变换”节点的位置引脚，旋转引脚中的Z轴与“拆分变换”中相应的引脚链接</p>
<ol>
<li>为什么只同步旋转引脚中的Z轴？因为如果在车身是斜着的情况下下车的话，小白人也成了斜着走路的了，所以只需要同步Z轴，也就是“面向”即可</li>
</ol>
</li>
</ol>
<h3 id="启用碰撞"><a href="#启用碰撞" class="headerlink" title="启用碰撞"></a>启用碰撞</h3><ol>
<li><p>由“设置Actor变换”节点的输出引出“设置Actor启用碰撞”节点</p>
</li>
<li><p>目标为“小白人”变量</p>
</li>
<li><p>“New Actor Enable Collision”引脚取消勾选</p>
</li>
</ol>
<h3 id="转移控制权-1"><a href="#转移控制权-1" class="headerlink" title="转移控制权"></a>转移控制权</h3><ol>
<li><p>获取玩家控制器，引出“控制”节点</p>
</li>
<li><p>“In Pawn”引脚为“小白人”</p>
</li>
<li><p>但是我们为了有个过渡，所以我们还需要从“获取玩家控制器”节点引出“使用混合设置视图目标”节点</p>
</li>
<li><p>New View Target 引脚为小白人，混合时间和混合方式随便啦！</p>
</li>
<li><p>记得再引出“延迟”节点，和混合时间相同</p>
</li>
<li><p>最后先链接“使用混合设置视图目标”，再链接“控制”节点即可</p>
</li>
</ol>
<p><img src="C:\Users\asus\AppData\Roaming\marktext\images\2022-05-19-17-02-57-image.png"></p>
<p><img src="C:\Users\asus\AppData\Roaming\marktext\images\2022-05-19-17-03-10-image.png"></p>
<h2 id="实现下车减速"><a href="#实现下车减速" class="headerlink" title="实现下车减速"></a>实现下车减速</h2><p>车在告诉行驶的时候我们进行下车操作，如果不进行下车减速的话，车会一直往前跑。根本停不下来。所以我们需要下车减速功能。</p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>首先看Sedan中的事件图表中的Throttle Input注释</p>
<p>这一块实现了加油门的功能，我们要下车，就要把油门关掉</p>
<p>此模块是帧刷新的，所以我们需要用一个bool值和一个分支节点来关闭“设置油门输入”节点</p>
<h4 id="关闭油门"><a href="#关闭油门" class="headerlink" title="关闭油门"></a>关闭油门</h4><ol>
<li><p>添加一个bool变量“下车”，初始值为true（因为一开始我们不再车上）</p>
</li>
<li><p>然后在Throttle Input中获取变量，引出分支节点</p>
</li>
<li><p>当值为false时输出“设置油门节点”</p>
</li>
<li><p>在“上下车”图表中的“上车”注释内的最后“设置下车变量”为false</p>
</li>
</ol>
<h4 id="取消手动输入"><a href="#取消手动输入" class="headerlink" title="取消手动输入"></a>取消手动输入</h4><ol>
<li><p>将组件“载具移动”获取到“上下车”图表中的“下车”注释内，引出“设置手制动输入”和“设置油门输入”节点</p>
</li>
<li><p>由“使用混合设置视图目标”引出“设置下车变量”节点，将其值为true</p>
</li>
<li><p>下车变量链接“设置手动输入”再链接“设置油门输入”最后链接“延迟”</p>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/17/UE4-%E8%93%9D%E5%9B%BE-%E5%A4%9A%E4%B8%AA%E8%A7%92%E8%89%B2%E6%8E%A7%E5%88%B6%E6%9D%83%E5%88%87%E6%8D%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="williny">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Williny'home">
      <meta itemprop="description" content="孤独是人生的常态">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Williny'home">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/05/17/UE4-%E8%93%9D%E5%9B%BE-%E5%A4%9A%E4%B8%AA%E8%A7%92%E8%89%B2%E6%8E%A7%E5%88%B6%E6%9D%83%E5%88%87%E6%8D%A2/" class="post-title-link" itemprop="url">UE4-蓝图-多个角色控制权切换</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-05-17 16:01:11 / 修改时间：16:30:17" itemprop="dateCreated datePublished" datetime="2022-05-17T16:01:11+08:00">2022-05-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/unreal-engine/" itemprop="url" rel="index"><span itemprop="name">unreal engine</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>本章根据<a target="_blank" rel="noopener" href="https://space.bilibili.com/31898841">谌嘉诚</a>大佬的虚幻蓝图教学整理</p>
<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>兄弟们我话放这里了：蓝图——玩个乐子。</p>
<p>不如U++，可读性实在是太差了！连线整的乱七八糟的！</p>
<p><img src="C:\Users\asus\AppData\Roaming\marktext\images\2022-05-17-16-07-10-image.png"></p>
<p>这些线连在一起之后直接让人脑瓜疼。</p>
<h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><p>我们要在地图上放若干个角色，根据角色的possess:player 0,player 1…来实现在这几个角色之间的控制权互换。</p>
<h1 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h1><h2 id="MultiGate"><a href="#MultiGate" class="headerlink" title="MultiGate"></a>MultiGate</h2><p>这个节点就相当于是只遍历一次的for循环，如果需要多次遍历，则将其Loop引脚勾选即可</p>
<p>其他的几个引脚，就是英文翻译中文，望文生义，不做赘述。</p>
<h2 id="使用混合设置视图目标"><a href="#使用混合设置视图目标" class="headerlink" title="使用混合设置视图目标"></a>使用混合设置视图目标</h2><p>这玩意的功能就是能够平滑切换视角，相当于是过场动画吧！</p>
<p>注意：本节点由“获取玩家控制器”引出</p>
<p>引脚望文生义即可，另外：目标引脚为玩家控制器</p>
<h2 id="延迟"><a href="#延迟" class="headerlink" title="延迟"></a>延迟</h2><p>字面意思，可自定义延迟时间</p>
<h2 id="控制（possess）"><a href="#控制（possess）" class="headerlink" title="控制（possess）"></a>控制（possess）</h2><p>本节点的作用是切换控制器，从character1切换到character2。</p>
<p>该节点由“获取玩家控制器”引出，目标引脚为“获取玩家控制器”</p>
<p>In Pawn引脚链接要切换到的character</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li><p>地图上放三个角色，possess分别设置为0，1，2</p>
</li>
<li><p>打开关卡蓝图，编写切换控制器视角</p>
</li>
<li><p>键盘1来控制切换视角</p>
</li>
<li><p>定义一个bool来判断切换动画是否结束</p>
<ol>
<li><p>初始值为false</p>
</li>
<li><p>每一次切换前将值设置为true</p>
</li>
<li><p>每一次切换结束后将值设置为false</p>
</li>
</ol>
</li>
<li><p>获取玩家控制器，引出“使用混合设置视图目标”节点</p>
</li>
<li><p>引出“控制”节点</p>
</li>
<li><p>因为我们要先有过场动画，然后再切换控制权，所以“视图目标”节点在“控制”节点之前</p>
</li>
<li><p>同时，我们需要在有过场动画之后“延迟”一段时间再切换“控制“</p>
<ol>
<li>因为计算机执行速度非常快，如果不延迟，过场动画还没执行完，就切换控制权了，那么画面就会直接切换到下一个character当中。</li>
</ol>
</li>
<li><p>延迟时间和过场动画时间一定要相等</p>
</li>
<li><p>最后需要设置bool值为false</p>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/12/UE4-%E5%8F%98%E9%87%8F%EF%BC%8C%E5%AE%9A%E6%97%B6%E5%99%A8%E5%92%8C%E4%BA%8B%E4%BB%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="williny">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Williny'home">
      <meta itemprop="description" content="孤独是人生的常态">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Williny'home">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/05/12/UE4-%E5%8F%98%E9%87%8F%EF%BC%8C%E5%AE%9A%E6%97%B6%E5%99%A8%E5%92%8C%E4%BA%8B%E4%BB%B6/" class="post-title-link" itemprop="url">UE4-变量，定时器和事件</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-05-12 09:39:05 / 修改时间：11:26:39" itemprop="dateCreated datePublished" datetime="2022-05-12T09:39:05+08:00">2022-05-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/unreal-engine/" itemprop="url" rel="index"><span itemprop="name">unreal engine</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><a target="_blank" rel="noopener" href="https://docs.unrealengine.com/4.27/zh-CN/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/VariablesTimersEvents/">官方案例</a>的讲解与小结</p>
<p>内容：向编辑器公开变量和函数，使用定时器，并以蓝图覆盖C++函数</p>
<h1 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h1><p>创建一个Actor，它是一个倒计时，从X倒数到0，然后到0的时候显示的是“GO！”最后加上一个粒子特效啥的。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li><p>创建一个UTextRenderComponent类型的组件来显示倒计时，命名为CountdownText</p>
</li>
<li><p>设定一个倒计时的时长CountdownTime，并公开到编辑器</p>
</li>
<li><p>定义一个UpdateTimerDisplay()函数在游戏开始时显示CountdownText组件</p>
</li>
<li><p>定义CountdownHasFinished()函数来执行特殊操作”倒计时显示为GO！”</p>
</li>
<li><p>定义一个AdvanceTimer()更新CountdownTime，并调用UpdateTimerDisplay()在视口中显示倒计时，并在倒计时归零的时候停止运行定时器，且调用CountdownHasFinished()函数</p>
</li>
<li><p>在游戏开始时调用UpdateTimerDisplay()显示初始倒计时</p>
</li>
<li><p>通过GetWorldTimerManager().SetTimer()函数调用AdvanceTimer()函数更新倒计时</p>
</li>
</ol>
<h1 id="创建使用定时器的Actor"><a href="#创建使用定时器的Actor" class="headerlink" title="创建使用定时器的Actor"></a>创建使用定时器的Actor</h1><p>创建一个以Actor为父类，名为Countdown的C++类</p>
<h2 id="头文件！"><a href="#头文件！" class="headerlink" title="头文件！"></a>头文件！</h2><p>这个很重要，我们要使得Actor显示为一个文本，所以我们需要引入</p>
<p><code>#include &quot;Components/TextRenderComponent.h&quot;</code></p>
<h2 id="声明游戏中显示的倒数定时器"><a href="#声明游戏中显示的倒数定时器" class="headerlink" title="声明游戏中显示的倒数定时器"></a>声明游戏中显示的倒数定时器</h2><p>在Countdown.h中声明以下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int32 CountdownTime;</span><br><span class="line">UTextRenderComponent* CountdownText;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UpdateTimerDisplay</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>



<h2 id="定义倒数定时器"><a href="#定义倒数定时器" class="headerlink" title="定义倒数定时器"></a>定义倒数定时器</h2><p>Countdown.cpp-&gt;ACountdown::ACountdown</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ACountdown::<span class="built_in">ACountdown</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//将此Actor设为逐帧调用Tick()。如无需此功能，可关闭以提高性能。</span></span><br><span class="line">    PrimaryActorTick.bCanEverTick = <span class="literal">false</span>;</span><br><span class="line">    CountdownText = <span class="built_in">CreateDefaultSubobject</span>&lt;UTextRenderComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;CountdownNumber&quot;</span>));</span><br><span class="line">    CountdownText-&gt;<span class="built_in">SetHorizontalAlignment</span>(EHTA_Center);<span class="comment">//设置水平对其方式为居中对其</span></span><br><span class="line">    CountdownText-&gt;<span class="built_in">SetWorldSize</span>(<span class="number">150.0f</span>);</span><br><span class="line">    RootComponent = CountdownText;</span><br><span class="line">    CountdownTime = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="定义UpdateTimerDisplay-来更新文本显示"><a href="#定义UpdateTimerDisplay-来更新文本显示" class="headerlink" title="定义UpdateTimerDisplay()来更新文本显示"></a>定义UpdateTimerDisplay()来更新文本显示</h2><p>此代码应在游戏中首次生成 <code>ACountdown</code> 时运行，在 <code>CountdownTime</code> 变量为零前每秒运行一次。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ACountdown::UpdateTimerDisplay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CountdownText-&gt;<span class="built_in">SetText</span>(FString::<span class="built_in">FromInt</span>(FMath::<span class="built_in">Max</span>(CountdownTime, <span class="number">0</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CountdownText-&gt;<span class="built_in">SetText</span>(FString::<span class="built_in">FromInt</span>(FMath::<span class="built_in">Max</span>(CountdownTime, <span class="number">0</span>)));</span><br></pre></td></tr></table></figure>

<ul>
<li><p>SetText()参数必须是一个FString类型的变量</p>
</li>
<li><p>但是我们需要显示的数字是Int类型的</p>
</li>
<li><p>所以我们需要用FString::FromInt来对其转换类型为FString</p>
</li>
<li><p>Max这个函数，在算法中很常见，就跟那一样的意思</p>
</li>
</ul>
<h2 id="声明计时器函数，调用UpdateTimerDisplay"><a href="#声明计时器函数，调用UpdateTimerDisplay" class="headerlink" title="声明计时器函数，调用UpdateTimerDisplay()"></a>声明计时器函数，调用UpdateTimerDisplay()</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AdvanceTimer</span><span class="params">()</span></span>;<span class="comment">//计时器，每秒调用一次UpdateTimerDisplay();</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CountdownHasFinished</span><span class="params">()</span></span>;<span class="comment">//特殊输出</span></span><br><span class="line"></span><br><span class="line">FTimerHandle CountdownTimerHandle;<span class="comment">//定时器句柄</span></span><br></pre></td></tr></table></figure>

<p>每次指定 <strong>定时器</strong> 运行函数时，都会得到 <strong>定时器句柄</strong>。利用此句柄，就可以在倒数结束时关闭定时器。</p>
<ul>
<li>句柄：用于识别的唯一ID，不能是常量。</li>
</ul>
<h2 id="定义计时器函数"><a href="#定义计时器函数" class="headerlink" title="定义计时器函数"></a>定义计时器函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ACountdown::AdvanceTimer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    --CountdownTime;</span><br><span class="line">    <span class="built_in">UpdateTimerDisplay</span>();</span><br><span class="line">    <span class="keyword">if</span> (CountdownTime &lt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//倒数完成，停止运行定时器。</span></span><br><span class="line">        <span class="built_in">GetWorldTimerManager</span>().<span class="built_in">ClearTimer</span>(CountdownTimerHandle);</span><br><span class="line">        <span class="built_in">CountdownHasFinished</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ACountdown::CountdownHasFinished</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//改为特殊读出</span></span><br><span class="line">    CountdownText-&gt;<span class="built_in">SetText</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;GO!&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="初始化ACountdown-BeginPlay中的显示文本"><a href="#初始化ACountdown-BeginPlay中的显示文本" class="headerlink" title="初始化ACountdown::BeginPlay中的显示文本"></a>初始化ACountdown::BeginPlay中的显示文本</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UpdateTimerDisplay</span>();</span><br><span class="line"><span class="built_in">GetWorldTimerManager</span>().<span class="built_in">SetTimer</span>(CountdownTimerHandle, <span class="keyword">this</span>, &amp;ACountdown::AdvanceTimer, <span class="number">1.0f</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">SetTimer</span>(FTimerHandle&amp; InOutHandle, UserClass* InObj, <span class="keyword">typename</span> FTimerDelegate::TUObjectMethodDelegate&lt; UserClass &gt;::FMethodPtr InTimerMethod, <span class="type">float</span> InRate, <span class="type">bool</span> InbLoop = <span class="literal">false</span>, <span class="type">float</span> InFirstDelay = <span class="number">-1.f</span>)</span><br></pre></td></tr></table></figure>

<p>这几个参数的意义如下</p>
<ul>
<li><p>FTimerHandle &amp; InOutHandle : 计时器的句柄</p>
</li>
<li><p>UserClass* InObj : 执行此方法的类，一般为this</p>
</li>
<li><p>FTimerDelegate::TUObjectMethodDelegate&lt; UserClass &gt;::FMethodPtr InTimerMethod : 计数器每次结束后要执行的代理函数</p>
</li>
<li><p>float InRate : 每次计时器的时间长度</p>
</li>
<li><p>bool InbLoop : 是否循环</p>
</li>
<li><p>float InFirstDelay : 循环计时器第一次迭代的时间， 若小于0.f则使用inRate</p>
</li>
</ul>
<h1 id="向编辑器公开变量和函数"><a href="#向编辑器公开变量和函数" class="headerlink" title="向编辑器公开变量和函数"></a>向编辑器公开变量和函数</h1><p>将.h文件中的</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int32 CountdownTime;</span><br></pre></td></tr></table></figure>

<p>修改为</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//倒数的运行时长（以秒计）</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line">int32 CountdownTime;;</span><br></pre></td></tr></table></figure>

<p>将</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CountdownHasFinished</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>修改为</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UFUNCTION</span>(BlueprintNativeEvent)</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CountdownHasFinished</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">CountdownHasFinished_Implementation</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>和 <code>UPROPERTY</code> 宏相同，需提供使用其进行操作的相关信息，以便非程序员开发者可使用更多功能和访问权。有三种选择可使用：</p>
<ol>
<li><p><code>BlueprintCallable</code> 函数以C++编写，可从 <strong>蓝图图表</strong> 中调用，但只能通过编辑C++代码进行修改或重写。以此类方式标记的函数通常具备供非程序员使用而编写的功能，但是不应对其进行修改，否则修改将毫无意义。数学函数便是此类函数的经典范例。</p>
</li>
<li><p>在C++ header (.h)文件中设置 <code>BlueprintImplementableEvent</code> 函数，但是函数的主体则在蓝图图表中完成编写，而非C++中。创建此类通常是为了使非程序员能够对无预期默认动作或标准行为的特殊情况创建自定义反应。在宇宙飞船游戏中，玩家飞船接触到能量升级时发生的事件便是这方面的范例。</p>
</li>
<li><p><code>BlueprintNativeEvent</code> 函数与 <code>BlueprintCallable</code> 和 <code>BlueprintImplementableEvent</code> 函数的组合类似。其具备用C++中编程的默认行为，但此类行为可通过在蓝图图表中覆盖进行补充或替换。对此类代码编程时，<strong>C++代码固定使用命名末尾添加了_Implementation的虚拟函数</strong></p>
</li>
</ol>
<p>然后，在Countdown.cpp中，需对以下行进行修改：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ACountdown::CountdownHasFinished</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<p>改为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ACountdown::CountdownHasFinished_Implementation</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>



<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>使用<code>BlueprintNativeEvent</code>类型公开函数后</p>
<ol>
<li><p>函数必须设为虚函数</p>
</li>
<li><p>函数命名需在末尾添加_Implementation</p>
</li>
</ol>
<h1 id="用蓝图扩展和覆盖C"><a href="#用蓝图扩展和覆盖C" class="headerlink" title="用蓝图扩展和覆盖C++"></a>用蓝图扩展和覆盖C++</h1><p>以下内容和官网一致</p>
<ol>
<li><p>要在编辑器中改变名为Countdown1的ACountdown实例的行为，须首先创建其可编辑的蓝图版本。为此，可在 <strong>世界大纲视图（World Outliner）</strong> 中将其选中，然后点击 <strong>细节面板</strong> 中的 <strong>蓝图&#x2F;添加脚本（Blueprint&#x2F;Add Script）</strong> 按钮。</p>
</li>
<li><p>在 <strong>事件图表</strong> 选项卡中找到函数和事件，先将其选中。</p>
</li>
<li><p><strong>右键点击</strong> <strong>事件图表</strong> 窗口中的任意位置，便可添加 <strong>CountdownHasFinished</strong> 函数，将其作为事件节点以定义其行为。</p>
</li>
<li><p>通过点击左键并连出新节点右侧的白色（执行）引脚，添加需要的附加功能。释放鼠标左键时，系统将询问需要执行的功能或事件。本教程中将在倒数结束时生成 <strong>粒子系统</strong>。由于需要 <strong>Spawn Emitter At Location</strong>（在位置处生成发射器） 节点，因此在列表中选中。在搜索栏中输入如spawn loc的部分短语，即可节省时间。然后点击左键并拖动黄色的”Location”引脚，并将其附加到 <strong>Get Actor Location</strong> 函数上。</p>
</li>
<li><p>选择想要的效果。通过点击发射器模板下的”选择资源”，即可获得合适的效果资源列表。</p>
</li>
<li><p>但本教程中，倒数被设为结束时显示GO！，而非0。由于已使用 <strong>蓝图</strong> 可视化脚本完全取代了C++功能，因此不会发生此情况。此结果并非理想结果，因此需添加对该函数C++版本的调用，此操作可通过右键点击 <strong>Countdown Has Finished</strong> 节点，并在快捷菜单中选择 <strong>添加对父函数的调用（Add call to parent function）</strong> 来完成。</p>
</li>
<li><p>完成该步骤后，将创建一个名为 <strong>Parent: Countdown Has Finished</strong> 的节点</p>
</li>
</ol>
<p>注意：</p>
<ul>
<li><p>粒子生成节点：在位置处生成发射器</p>
</li>
<li><p>调用父类：右键节点“将调用添加到父类函数”</p>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/11/UE4-%E5%AE%9E%E7%8E%B0%E7%89%A9%E4%BD%93%E8%87%AA%E8%BD%AC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="williny">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Williny'home">
      <meta itemprop="description" content="孤独是人生的常态">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Williny'home">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/05/11/UE4-%E5%AE%9E%E7%8E%B0%E7%89%A9%E4%BD%93%E8%87%AA%E8%BD%AC/" class="post-title-link" itemprop="url">UE4-实现物体自转</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-05-11 15:23:37 / 修改时间：15:47:51" itemprop="dateCreated datePublished" datetime="2022-05-11T15:23:37+08:00">2022-05-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/unreal-engine/" itemprop="url" rel="index"><span itemprop="name">unreal engine</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>这一节是根据<a target="_blank" rel="noopener" href="https://space.bilibili.com/31898841">谌嘉诚</a>大佬的<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV164411Y732?p=41">蓝图教程</a>进行的小结</p>
<p>主要知识点有：对象引用，变量有效性，自定义事件</p>
<h1 id="对象引用"><a href="#对象引用" class="headerlink" title="对象引用"></a>对象引用</h1><p>可以看作是C++中的引用传递</p>
<h1 id="变量有效性（Is-Valid）"><a href="#变量有效性（Is-Valid）" class="headerlink" title="变量有效性（Is Valid）"></a>变量有效性（Is Valid）</h1><p>保证某变量不为空</p>
<h1 id="自定义事件-添加自定义事件"><a href="#自定义事件-添加自定义事件" class="headerlink" title="自定义事件(添加自定义事件)"></a>自定义事件(添加自定义事件)</h1><p>就可以看作是自定义函数</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>我们要实现按键盘1，就能让一个Actor自转</p>
<h2 id="实现自转功能"><a href="#实现自转功能" class="headerlink" title="实现自转功能"></a>实现自转功能</h2><ol>
<li><p>创建一个Actor蓝图类</p>
</li>
<li><p>创建一个bool值“能否旋转”，用“分支”节点使其值为true时连接到“添加本地旋转”节点上</p>
</li>
<li><p>为了能让Actor一直旋转，需要将“事件Tick”来实现帧更新</p>
</li>
<li><p>最后不要忘记将Actor本身添加到“添加本地旋转”节点的目标上！</p>
</li>
</ol>
<h2 id="控制旋转事件"><a href="#控制旋转事件" class="headerlink" title="控制旋转事件"></a>控制旋转事件</h2><ol>
<li><p>默认生成的“能否旋转”为false，现在我们创建一个自定义事件来使其能在true和false之间转换</p>
</li>
<li><p>创建“分支”节点-&gt;可以看作为if(能否旋转&#x3D;false){能否旋转&#x3D;true;}</p>
</li>
</ol>
<h1 id="控制物体自转"><a href="#控制物体自转" class="headerlink" title="控制物体自转"></a>控制物体自转</h1><p>我们要明白，控制物体旋转，时根据小白人的操作来进行控制的，主要控制权还是在小白人身上，所以我们需要在小白人蓝图中添加一个新的图表（姑且看作时一个Class吧）来调用“控制旋转”这个自定义事件</p>
<p>将小白人看作主函数，“控制旋转”时自定义函数，我们需要在主函数中调用“控制旋转”！</p>
<ol>
<li><p>创建新的图标，创建一个新的变量“自我旋转对象”</p>
</li>
<li><p>变量类型为我们之前创建的那个蓝图类（自我旋转的Actor）</p>
</li>
<li><p>将变量设置为公有，使其可在此蓝图的每个实例上进行编辑（变量右边的眼睛图标）</p>
</li>
<li><p>将变量拖入蓝图中，用”Is Valid”判断是否为空</p>
</li>
<li><p>从变量拖出引线，调用“控制旋转”事件</p>
</li>
<li><p>最后，返回虚幻编辑器，小白人的细节面板，找到“自我旋转对象”，点击吸管工具，在视口中选择要旋转的对象！</p>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/11/%E6%9C%89%E5%85%B3%E7%AE%97%E6%B3%95%E4%B8%AD%E7%9A%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E4%B8%89%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="williny">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Williny'home">
      <meta itemprop="description" content="孤独是人生的常态">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Williny'home">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/05/11/%E6%9C%89%E5%85%B3%E7%AE%97%E6%B3%95%E4%B8%AD%E7%9A%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E4%B8%89%EF%BC%89/" class="post-title-link" itemprop="url">有关算法中的动态规划（三）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-05-11 08:38:33" itemprop="dateCreated datePublished" datetime="2022-05-11T08:38:33+08:00">2022-05-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-05-22 10:15:17" itemprop="dateModified" datetime="2022-05-22T10:15:17+08:00">2022-05-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-increasing-subsequence/">最长递增子序列</a></h1><p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p>
<p>子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p>
<p>示例 1： </p>
<p>输入：nums &#x3D; [10,9,2,5,3,7,101,18] </p>
<p>输出：4 </p>
<p>解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。</p>
<p>示例 2： </p>
<p>输入：nums &#x3D; [0,1,0,3,2,3] </p>
<p>输出：4</p>
<p>示例 3： </p>
<p>输入：nums &#x3D; [7,7,7,7,7,7,7] </p>
<p>输出：1</p>
<p>提示：</p>
<ul>
<li>1 &lt;&#x3D; nums.length &lt;&#x3D; 2500</li>
<li>-10^4 &lt;&#x3D; nums[i] &lt;&#x3D; 104</li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>最长上升子序列是动规的经典题目，这里dp[i]是可以根据dp[j] （j &lt; i）推导出来的，那么依然用动规五部曲来分析详细一波：</p>
<ol>
<li>dp[i]的定义</li>
</ol>
<p><strong>dp[i]表示i之前包括i的以nums[i]结尾最长上升子序列的长度</strong></p>
<ol start="2">
<li>状态转移方程</li>
</ol>
<p>位置i的最长升序子序列等于j从0到i-1各个位置的最长升序子序列 + 1 的最大值。</p>
<p>所以：if (nums[i] &gt; nums[j]) dp[i] &#x3D; max(dp[i], dp[j] + 1);</p>
<p><strong>注意这里不是要dp[i] 与 dp[j] + 1进行比较，而是我们要取dp[j] + 1的最大值</strong>。</p>
<ol start="3">
<li>dp[i]的初始化</li>
</ol>
<p>每一个i，对应的dp[i]（即最长上升子序列）起始大小至少都是1。</p>
<ol start="4">
<li>确定遍历顺序</li>
</ol>
<p>dp[i] 是有0到i-1各个位置的最长升序子序列 推导而来，那么遍历i一定是从前向后遍历。</p>
<p>j其实就是0到i-1，遍历i的循环在外层，遍历j则在内层，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; nums[j]) dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dp[i] &gt; result) result = dp[i]; <span class="comment">// 取长的子序列</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>举例推导dp数组</li>
</ol>
<p>输入：[0,1,0,3,2]，dp数组的变化如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20210110170945618.jpg" alt="300.最长上升子序列"></p>
<p>如果代码写出来，但一直AC不了，那么就把dp数组打印出来，看看对不对！</p>
<p>以上五部分析完毕，C++代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() &lt;= <span class="number">1</span>) <span class="keyword">return</span> nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size(), <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &gt; nums[j]) dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (dp[i] &gt; result) result = dp[i]; <span class="comment">// 取长的子序列</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="最长连续递增序列"><a href="#最长连续递增序列" class="headerlink" title="最长连续递增序列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-continuous-increasing-subsequence/">最长连续递增序列</a></h1><p>给定一个未经排序的整数数组，找到最长且 连续递增的子序列，并返回该序列的长度。</p>
<p>连续递增的子序列 可以由两个下标 l 和 r（l &lt; r）确定，如果对于每个 l &lt;&#x3D; i &lt; r，都有 nums[i] &lt; nums[i + 1] ，那么子序列 [nums[l], nums[l + 1], …, nums[r - 1], nums[r]] 就是连续递增子序列。</p>
<p>示例 1： </p>
<p>输入：nums &#x3D; [1,3,5,4,7] </p>
<p>输出：3 </p>
<p>解释：最长连续递增序列是 [1,3,5], 长度为3。 尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。</p>
<p>示例 2： </p>
<p>输入：nums &#x3D; [2,2,2,2,2] </p>
<p>输出：1 </p>
<p>解释：最长连续递增序列是 [2], 长度为1。</p>
<p>提示：</p>
<ul>
<li>0 &lt;&#x3D; nums.length &lt;&#x3D; 10^4</li>
<li>-10^9 &lt;&#x3D; nums[i] &lt;&#x3D; 10^9</li>
</ul>
<h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>动规五部曲分析如下：</p>
<ol>
<li>确定dp数组（dp table）以及下标的含义</li>
</ol>
<p>**dp[i]：以下标i为结尾的数组的连续递增的子序列长度为dp[i]**。</p>
<p>注意这里的定义，一定是以下标i为结尾，并不是说一定以下标0为起始位置。</p>
<ol start="2">
<li>确定递推公式</li>
</ol>
<p>如果 nums[i + 1] &gt; nums[i]，那么以 i+1 为结尾的数组的连续递增的子序列长度 一定等于 以i为结尾的数组的连续递增的子序列长度 + 1 。</p>
<p>即：dp[i + 1] &#x3D; dp[i] + 1;</p>
<p><strong>注意这里就体现出和<a target="_blank" rel="noopener" href="https://programmercarl.com/0300.%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97.html">动态规划：300.最长递增子序列</a>的区别！</strong></p>
<p>因为本题要求连续递增子序列，所以就必要比较nums[i + 1]与nums[i]，而不用去比较nums[j]与nums[i] （j是在0到i之间遍历）。</p>
<p>既然不用j了，那么也不用两层for循环，本题一层for循环就行，比较nums[i + 1] 和 nums[i]。</p>
<p>这里大家要好好体会一下！</p>
<ol start="3">
<li>dp数组如何初始化</li>
</ol>
<p>以下标i为结尾的数组的连续递增的子序列长度最少也应该是1，即就是nums[i]这一个元素。</p>
<p>所以dp[i]应该初始1;</p>
<ol start="4">
<li>确定遍历顺序</li>
</ol>
<p>从递推公式上可以看出， dp[i + 1]依赖dp[i]，所以一定是从前向后遍历。</p>
<p>本文在确定递推公式的时候也说明了为什么本题只需要一层for循环，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[i + <span class="number">1</span>] &gt; nums[i]) &#123; <span class="comment">// 连续记录</span></span><br><span class="line">        dp[i + <span class="number">1</span>] = dp[i] + <span class="number">1</span>; <span class="comment">// 递推公式</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>举例推导dp数组</li>
</ol>
<p>已输入nums &#x3D; [1,3,5,4,7]为例，dp数组状态如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20210204103529742.jpg" alt="674.最长连续递增序列"></p>
<p><strong>注意这里要取dp[i]里的最大值，所以dp[2]才是结果！</strong></p>
<p>以上分析完毕，C++代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findLengthOfLCIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">1</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size() ,<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i + <span class="number">1</span>] &gt; nums[i]) &#123; <span class="comment">// 连续记录</span></span><br><span class="line">                dp[i + <span class="number">1</span>] = dp[i] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (dp[i + <span class="number">1</span>] &gt; result) result = dp[i + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="最长重复子数组"><a href="#最长重复子数组" class="headerlink" title="最长重复子数组"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-length-of-repeated-subarray/">最长重复子数组</a></h1><p>给两个整数数组 A 和 B ，返回两个数组中公共的、长度最长的子数组的长度。</p>
<p>示例：</p>
<p>输入： A: [1,2,3,2,1] B: [3,2,1,4,7] 输出：3 解释： 长度最长的公共子数组是 [3, 2, 1] 。</p>
<p>提示：</p>
<ul>
<li>1 &lt;&#x3D; len(A), len(B) &lt;&#x3D; 1000</li>
<li>0 &lt;&#x3D; A[i], B[i] &lt; 100</li>
</ul>
<h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>注意题目中说的子数组，其实就是连续子序列。</p>
<p>这种问题动规最拿手，动规五部曲分析如下：</p>
<ol>
<li>确定dp数组（dp table）以及下标的含义</li>
</ol>
<p>dp[i][j] ：以下标i - 1为结尾的A，和以下标j - 1为结尾的B，最长重复子数组长度为dp[i][j]。</p>
<p>此时细心的同学应该发现，那dp[0][0]是什么含义呢？总不能是以下标-1为结尾的A数组吧。</p>
<p>其实dp[i][j]的定义也就决定着，我们在遍历dp[i][j]的时候i 和 j都要从1开始。</p>
<p>那有同学问了，我就定义dp[i][j]为 以下标i为结尾的A，和以下标j 为结尾的B，最长重复子数组长度。不行么？</p>
<p>行倒是行！ 但实现起来就麻烦一点，大家看下面的dp数组状态图就明白了。</p>
<ol start="2">
<li>确定递推公式</li>
</ol>
<p>根据dp[i][j]的定义，dp[i][j]的状态只能由dp[i - 1][j - 1]推导出来。</p>
<p>即当A[i - 1] 和B[j - 1]相等的时候，dp[i][j] &#x3D; dp[i - 1][j - 1] + 1;</p>
<p>根据递推公式可以看出，遍历i 和 j 要从1开始！</p>
<ol start="3">
<li>dp数组如何初始化</li>
</ol>
<p>根据dp[i][j]的定义，dp[i][0] 和dp[0][j]其实都是没有意义的！</p>
<p>但dp[i][0] 和dp[0][j]要初始值，因为 为了方便递归公式dp[i][j] &#x3D; dp[i - 1][j - 1] + 1;</p>
<p>所以dp[i][0] 和dp[0][j]初始化为0。</p>
<p>举个例子A[0]如果和B[0]相同的话，dp[1][1] &#x3D; dp[0][0] + 1，只有dp[0][0]初始为0，正好符合递推公式逐步累加起来。</p>
<ol start="4">
<li>确定遍历顺序</li>
</ol>
<p>外层for循环遍历A，内层for循环遍历B。</p>
<p>那又有同学问了，外层for循环遍历B，内层for循环遍历A。不行么？</p>
<p>也行，一样的，我这里就用外层for循环遍历A，内层for循环遍历B了。</p>
<p>同时题目要求长度最长的子数组的长度。所以在遍历的时候顺便把dp[i][j]的最大值记录下来。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= A.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= B.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[i - <span class="number">1</span>] == B[j - <span class="number">1</span>]) &#123;</span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dp[i][j] &gt; result) result = dp[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>举例推导dp数组</li>
</ol>
<p>拿示例1中，A: [1,2,3,2,1]，B: [3,2,1,4,7]为例，画一个dp数组的状态变化，如下：</p>
<p><img src="https://img-blog.csdnimg.cn/2021011215282060.jpg" alt="718.最长重复子数组"></p>
<p>以上五部曲分析完毕，C++代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A, vector&lt;<span class="type">int</span>&gt;&amp; B)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span> (A.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(B.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= A.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= B.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (A[i - <span class="number">1</span>] == B[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (dp[i][j] &gt; result) result = dp[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-common-subsequence/">最长公共子序列</a></h1><p>给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。</p>
<p>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p>
<p>例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。</p>
<p>若这两个字符串没有公共子序列，则返回 0。</p>
<p>示例 1:</p>
<p>输入：text1 &#x3D; “abcde”, text2 &#x3D; “ace”<br>输出：3<br>解释：最长公共子序列是 “ace”，它的长度为 3。</p>
<p>示例 2:<br>输入：text1 &#x3D; “abc”, text2 &#x3D; “abc”<br>输出：3<br>解释：最长公共子序列是 “abc”，它的长度为 3。</p>
<p>示例 3:<br>输入：text1 &#x3D; “abc”, text2 &#x3D; “def”<br>输出：0<br>解释：两个字符串没有公共子序列，返回 0。</p>
<p>提示:</p>
<ul>
<li>1 &lt;&#x3D; text1.length &lt;&#x3D; 1000</li>
<li>1 &lt;&#x3D; text2.length &lt;&#x3D; 1000 输入的字符串只含有小写英文字符。</li>
</ul>
<h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>本题和<a target="_blank" rel="noopener" href="https://programmercarl.com/0718.%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E6%95%B0%E7%BB%84.html">动态规划：718. 最长重复子数组 </a>区别在于这里不要求是连续的了，但要有相对顺序，即：”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。</p>
<p>继续动规五部曲分析如下：</p>
<ol>
<li>确定dp数组（dp table）以及下标的含义</li>
</ol>
<p>dp[i][j]：长度为[0, i - 1]的字符串text1 与长度为[0, j - 1]的字符串text2的最长公共子序列为dp[i][j]</p>
<p>有同学会问：为什么要定义长度为[0, i - 1]的字符串text1，定义为长度为[0, i]的字符串text1不香么？</p>
<p>这样定义是为了后面代码实现方便，如果非要定义为为长度为[0, i]的字符串text1也可以，大家可以试一试！</p>
<ol start="2">
<li>确定递推公式</li>
</ol>
<p>主要就是两大情况： text1[i - 1] 与 text2[j - 1]相同，text1[i - 1] 与 text2[j - 1]不相同</p>
<p>如果text1[i - 1] 与 text2[j - 1]相同，那么找到了一个公共元素，所以dp[i][j] &#x3D; dp[i - 1][j - 1] + 1;</p>
<p>如果text1[i - 1] 与 text2[j - 1]不相同，那就看看text1[0, i - 2]与text2[0, j - 1]的最长公共子序列 和 text1[0, i - 1]与text2[0, j - 2]的最长公共子序列，取最大的。</p>
<p>即：dp[i][j] &#x3D; max(dp[i - 1][j], dp[i][j - 1]);</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (text1[i - <span class="number">1</span>] == text2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>dp数组如何初始化</li>
</ol>
<p>先看看dp[i][0]应该是多少呢？</p>
<p>test1[0, i-1]和空串的最长公共子序列自然是0，所以dp[i][0] &#x3D; 0;</p>
<p>同理dp[0][j]也是0。</p>
<p>其他下标都是随着递推公式逐步覆盖，初始为多少都可以，那么就统一初始为0。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(text1.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(text2.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="number">0</span>));</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>确定遍历顺序</li>
</ol>
<p>从递推公式，可以看出，有三个方向可以推出dp[i][j]，如图：</p>
<p><img src="https://img-blog.csdnimg.cn/20210204115139616.jpg" alt="1143.最长公共子序列"></p>
<p>那么为了在递推的过程中，这三个方向都是经过计算的数值，所以要从前向后，从上到下来遍历这个矩阵。</p>
<ol start="5">
<li>举例推导dp数组</li>
</ol>
<p>以输入：text1 &#x3D; “abcde”, text2 &#x3D; “ace” 为例，dp状态如图：</p>
<p><img src="https://img-blog.csdnimg.cn/20210210150215918.jpg" alt="1143.最长公共子序列1"></p>
<p>最后红框dp[text1.size()][text2.size()]为最终结果</p>
<p>以上分析完毕，C++代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(string text1, string text2)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(text1.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(text2.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= text1.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= text2.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (text1[i - <span class="number">1</span>] == text2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[text1.<span class="built_in">size</span>()][text2.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="不相交的线"><a href="#不相交的线" class="headerlink" title="不相交的线"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/uncrossed-lines/">不相交的线</a></h1><p>我们在两条独立的水平线上按给定的顺序写下 A 和 B 中的整数。</p>
<p>现在，我们可以绘制一些连接两个数字 A[i] 和 B[j] 的直线，只要 A[i] &#x3D;&#x3D; B[j]，且我们绘制的直线不与任何其他连线（非水平线）相交。</p>
<p>以这种方法绘制线条，并返回我们可以绘制的最大连线数。</p>
<p><img src="https://img-blog.csdnimg.cn/2021032116363533.png" alt="1035.不相交的线"></p>
<h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>绘制一些连接两个数字 A[i] 和 B[j] 的直线，只要 A[i] &#x3D;&#x3D; B[j]，且直线不能相交！</p>
<p>直线不能相交，这就是说明在字符串A中 找到一个与字符串B相同的子序列，且这个子序列不能改变相对顺序，只要相对顺序不改变，链接相同数字的直线就不会相交。</p>
<p>拿示例一A &#x3D; [1,4,2], B &#x3D; [1,2,4]为例，相交情况如图：</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210914145158.png"></p>
<p>其实也就是说A和B的最长公共子序列是[1,4]，长度为2。 这个公共子序列指的是相对顺序不变（即数字4在字符串A中数字1的后面，那么数字4也应该在字符串B数字1的后面）</p>
<p>这么分析完之后，大家可以发现：<strong>本题说是求绘制的最大连线数，其实就是求两个字符串的最长公共子序列的长度！</strong></p>
<p>那么本题就和我们刚刚讲过的这道题目<a target="_blank" rel="noopener" href="https://programmercarl.com/1143.%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97.html">动态规划：1143.最长公共子序列 </a>就是一样一样的了。</p>
<p>一样到什么程度呢？ 把字符串名字改一下，其他代码都不用改，直接copy过来就行了。</p>
<p>其实本题就是求最长公共子序列的长度，介于我们刚刚讲过<a target="_blank" rel="noopener" href="https://programmercarl.com/1143.%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97.html">动态规划：1143.最长公共子序列 </a>，所以本题我就不再做动规五部曲分析了。</p>
<p>如果大家有点遗忘了最长公共子序列，就再看一下这篇：<a target="_blank" rel="noopener" href="https://programmercarl.com/1143.%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97.html">动态规划：1143.最长公共子序列</a></p>
<p>本题代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxUncrossedLines</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A, vector&lt;<span class="type">int</span>&gt;&amp; B)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(A.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(B.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= A.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= B.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (A[i - <span class="number">1</span>] == B[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[A.<span class="built_in">size</span>()][B.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="最大子序和"><a href="#最大子序和" class="headerlink" title="最大子序和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-subarray/">最大子序和</a></h1><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p>示例: 输入: [-2,1,-3,4,-1,2,1,-5,4] 输出: 6 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</p>
<h2 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h2><p>这道题之前我们在讲解贪心专题的时候用贪心算法解决过一次，<a target="_blank" rel="noopener" href="https://programmercarl.com/0053.%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C.html">贪心算法：最大子序和 </a>。</p>
<p>这次我们用动态规划的思路再来分析一次。</p>
<p>动规五部曲如下：</p>
<ol>
<li>确定dp数组（dp table）以及下标的含义</li>
</ol>
<p>**dp[i]：包括下标i之前的最大连续子序列和为dp[i]**。</p>
<ol start="2">
<li>确定递推公式</li>
</ol>
<p>dp[i]只有两个方向可以推出来：</p>
<ul>
<li>dp[i - 1] + nums[i]，即：nums[i]加入当前连续子序列和</li>
<li>nums[i]，即：从头开始计算当前连续子序列和</li>
</ul>
<p>一定是取最大的，所以dp[i] &#x3D; max(dp[i - 1] + nums[i], nums[i]);</p>
<ol start="3">
<li>dp数组如何初始化</li>
</ol>
<p>从递推公式可以看出来dp[i]是依赖于dp[i - 1]的状态，dp[0]就是递推公式的基础。</p>
<p>dp[0]应该是多少呢?</p>
<p>根据dp[i]的定义，很明显dp[0]应为nums[0]即dp[0] &#x3D; nums[0]。</p>
<ol start="4">
<li>确定遍历顺序</li>
</ol>
<p>递推公式中dp[i]依赖于dp[i - 1]的状态，需要从前向后遍历。</p>
<ol start="5">
<li>举例推导dp数组</li>
</ol>
<p>以示例一为例，输入：nums &#x3D; [-2,1,-3,4,-1,2,1,-5,4]，对应的dp状态如下： <img src="https://img-blog.csdnimg.cn/20210303104129101.png" alt="53.最大子序和（动态规划）"></p>
<p><strong>注意最后的结果可不是dp[nums.size() - 1]！</strong> ，而是dp[6]。</p>
<p>在回顾一下dp[i]的定义：包括下标i之前的最大连续子序列和为dp[i]。</p>
<p>那么我们要找最大的连续子序列，就应该找每一个i为终点的连续最大子序列。</p>
<p>所以在递推公式的时候，可以直接选出最大的dp[i]。</p>
<p>以上动规五部曲分析完毕，完整代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> result = dp[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>] + nums[i], nums[i]); <span class="comment">// 状态转移公式</span></span><br><span class="line">            <span class="keyword">if</span> (dp[i] &gt; result) result = dp[i]; <span class="comment">// result 保存dp[i]的最大值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="判断子序列"><a href="#判断子序列" class="headerlink" title="判断子序列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/is-subsequence/">判断子序列</a></h1><p>给定字符串 s 和 t ，判断 s 是否为 t 的子序列。</p>
<p>字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，”ace”是”abcde”的一个子序列，而”aec”不是）。</p>
<p>示例 1： 输入：s &#x3D; “abc”, t &#x3D; “ahbgdc” 输出：true</p>
<p>示例 2： 输入：s &#x3D; “axc”, t &#x3D; “ahbgdc” 输出：false</p>
<p>提示：</p>
<ul>
<li>0 &lt;&#x3D; s.length &lt;&#x3D; 100</li>
<li>0 &lt;&#x3D; t.length &lt;&#x3D; 10^4</li>
</ul>
<p>两个字符串都只由小写字符组成。</p>
<h2 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h2><p>（这道题可以用双指针的思路来实现，时间复杂度就是$O(n)$）</p>
<p>这道题应该算是编辑距离的入门题目，因为从题意中我们也可以发现，只需要计算删除的情况，不用考虑增加和替换的情况。</p>
<p><strong>所以掌握本题也是对后面要讲解的编辑距离的题目打下基础</strong>。</p>
<p>动态规划五部曲分析如下：</p>
<ol>
<li>确定dp数组（dp table）以及下标的含义</li>
</ol>
<p>**dp[i][j] 表示以下标i-1为结尾的字符串s，和以下标j-1为结尾的字符串t，相同子序列的长度为dp[i][j]**。</p>
<p>注意这里是判断s是否为t的子序列。即t的长度是大于等于s的。</p>
<p>有同学问了，为啥要表示下标i-1为结尾的字符串呢，为啥不表示下标i为结尾的字符串呢？</p>
<p>用i来表示也可以！</p>
<p>但我统一以下标i-1为结尾的字符串来计算，这样在下面的递归公式中会容易理解一些，如果还有疑惑，可以继续往下看。</p>
<ol start="2">
<li>确定递推公式</li>
</ol>
<p>在确定递推公式的时候，首先要考虑如下两种操作，整理如下：</p>
<ul>
<li>if (s[i - 1] &#x3D;&#x3D; t[j - 1])<ul>
<li>t中找到了一个字符在s中也出现了</li>
</ul>
</li>
<li>if (s[i - 1] !&#x3D; t[j - 1])<ul>
<li>相当于<strong>t要删除元素，继续匹配</strong></li>
</ul>
</li>
</ul>
<p>if (s[i - 1] &#x3D;&#x3D; t[j - 1])，那么dp[i][j] &#x3D; dp[i - 1][j - 1] + 1;，因为找到了一个相同的字符，相同子序列长度自然要在dp[i-1][j-1]的基础上加1（<strong>如果不理解，在回看一下dp[i][j]的定义</strong>）</p>
<p>if (s[i - 1] !&#x3D; t[j - 1])，此时相当于t要删除元素，t如果把当前元素t[j - 1]删除，那么dp[i][j] 的数值就是 看s[i - 1]与 t[j - 2]的比较结果了，即：dp[i][j] &#x3D; dp[i][j - 1];</p>
<ol start="3">
<li>dp数组如何初始化</li>
</ol>
<p>从递推公式可以看出dp[i][j]都是依赖于dp[i - 1][j - 1] 和 dp[i][j - 1]，所以dp[0][0]和dp[i][0]是一定要初始化的。</p>
<p>这里大家已经可以发现，在定义dp[i][j]含义的时候为什么要**表示以下标i-1为结尾的字符串s，和以下标j-1为结尾的字符串t，相同子序列的长度为dp[i][j]**。</p>
<p>因为这样的定义在dp二维矩阵中可以留出初始化的区间，如图：</p>
<p><img src="https://img-blog.csdnimg.cn/20210303173115966.png" alt="392.判断子序列"></p>
<p>如果要是定义的dp[i][j]是以下标i为结尾的字符串s和以下标j为结尾的字符串t，初始化就比较麻烦了。</p>
<p>dp[i][0] 表示以下标i-1为结尾的字符串，与空字符串的相同子序列长度，所以为0. dp[0][j]同理。</p>
<p><strong>其实这里只初始化dp[i][0]就够了，但一起初始化也方便，所以就一起操作了</strong>，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(s.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(t.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="number">0</span>));</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>确定遍历顺序</li>
</ol>
<p>同理从递推公式可以看出dp[i][j]都是依赖于dp[i - 1][j - 1] 和 dp[i][j - 1]，那么遍历顺序也应该是从上到下，从左到右</p>
<p>如图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20210303172354155.jpg" alt="392.判断子序列1"></p>
<ol start="5">
<li>举例推导dp数组</li>
</ol>
<p>以示例一为例，输入：s &#x3D; “abc”, t &#x3D; “ahbgdc”，dp状态转移图如下：</p>
<p><img src="https://img-blog.csdnimg.cn/2021030317364166.jpg" alt="392.判断子序列2"></p>
<p>dp[i][j]表示以下标i-1为结尾的字符串s和以下标j-1为结尾的字符串t 相同子序列的长度，所以如果dp[s.size()][t.size()] 与 字符串s的长度相同说明：s与t的最长相同子序列就是s，那么s 就是 t 的子序列。</p>
<p>图中dp[s.size()][t.size()] &#x3D; 3， 而s.size() 也为3。所以s是t 的子序列，返回true。</p>
<p>动规五部曲分析完毕，C++代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSubsequence</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(s.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(t.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= t.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i - <span class="number">1</span>] == t[j - <span class="number">1</span>]) dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = dp[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dp[s.<span class="built_in">size</span>()][t.<span class="built_in">size</span>()] == s.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="不同的子序列"><a href="#不同的子序列" class="headerlink" title="不同的子序列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/distinct-subsequences/">不同的子序列</a></h1><p>给定一个字符串 s 和一个字符串 t ，计算在 s 的子序列中 t 出现的个数。</p>
<p>字符串的一个 子序列 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，”ACE” 是 “ABCDE” 的一个子序列，而 “AEC” 不是）</p>
<p>题目数据保证答案符合 32 位带符号整数范围。</p>
<p><img src="https://code-thinking.cdn.bcebos.com/pics/115.%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97%E7%A4%BA%E4%BE%8B.jpg" alt="115.不同的子序列示例"></p>
<p>提示：</p>
<p>0 &lt;&#x3D; s.length, t.length &lt;&#x3D; 1000 s 和 t 由英文字母组成</p>
<h2 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h2><p>这道题目如果不是子序列，而是要求连续序列的，那就可以考虑用KMP。</p>
<p>这道题目相对于72. 编辑距离，简单了不少，因为本题相当于只有删除操作，不用考虑替换增加之类的。</p>
<p>但相对于刚讲过的<a target="_blank" rel="noopener" href="https://programmercarl.com/0392.%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97.html">动态规划：392.判断子序列</a>就有难度了，这道题目双指针法可就做不了了，来看看动规五部曲分析如下：</p>
<ol>
<li>确定dp数组（dp table）以及下标的含义</li>
</ol>
<p>dp[i][j]：以i-1为结尾的s子序列中出现以j-1为结尾的t的个数为dp[i][j]。</p>
<ol start="2">
<li>确定递推公式</li>
</ol>
<p>这一类问题，基本是要分析两种情况</p>
<ul>
<li>s[i - 1] 与 t[j - 1]相等</li>
<li>s[i - 1] 与 t[j - 1] 不相等</li>
</ul>
<p>当s[i - 1] 与 t[j - 1]相等时，dp[i][j]可以有两部分组成。</p>
<p>一部分是用s[i - 1]来匹配，那么个数为dp[i - 1][j - 1]。</p>
<p>一部分是不用s[i - 1]来匹配，个数为dp[i - 1][j]。</p>
<p>这里可能有同学不明白了，为什么还要考虑 不用s[i - 1]来匹配，都相同了指定要匹配啊。</p>
<p>例如： s：bagg 和 t：bag ，s[3] 和 t[2]是相同的，但是字符串s也可以不用s[3]来匹配，即用s[0]s[1]s[2]组成的bag。</p>
<p>当然也可以用s[3]来匹配，即：s[0]s[1]s[3]组成的bag。</p>
<p>所以当s[i - 1] 与 t[j - 1]相等时，<strong>dp[i][j] &#x3D; dp[i - 1][j - 1] + dp[i - 1][j];</strong></p>
<p>当s[i - 1] 与 t[j - 1]不相等时，dp[i][j]只有一部分组成，不用s[i - 1]来匹配，即：dp[i - 1][j]</p>
<p>所以递推公式为：<strong>dp[i][j] &#x3D; dp[i - 1][j];</strong></p>
<ol start="3">
<li>dp数组如何初始化</li>
</ol>
<p>从递推公式dp[i][j] &#x3D; dp[i - 1][j - 1] + dp[i - 1][j]; 和 dp[i][j] &#x3D; dp[i - 1][j]; 中可以看出dp[i][0] 和dp[0][j]是一定要初始化的。</p>
<p>每次当初始化的时候，都要回顾一下dp[i][j]的定义，不要凭感觉初始化。</p>
<p>dp[i][0]表示什么呢？</p>
<p>dp[i][0] 表示：以i-1为结尾的s可以随便删除元素，出现空字符串的个数。</p>
<p>那么dp[i][0]一定都是1，因为也就是把以i-1为结尾的s，删除所有元素，出现空字符串的个数就是1。</p>
<p>再来看dp[0][j]，dp[0][j]：空字符串s可以随便删除元素，出现以j-1为结尾的字符串t的个数。</p>
<p>那么dp[0][j]一定都是0，s如论如何也变成不了t。</p>
<p>最后就要看一个特殊位置了，即：dp[0][0] 应该是多少。</p>
<p>dp[0][0]应该是1，空字符串s，可以删除0个元素，变成空字符串t。</p>
<p>初始化分析完毕，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;&gt; <span class="built_in">dp</span>(s.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">long</span> <span class="type">long</span>&gt;(t.<span class="built_in">size</span>() + <span class="number">1</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= s.<span class="built_in">size</span>(); i++) dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= t.<span class="built_in">size</span>(); j++) dp[<span class="number">0</span>][j] = <span class="number">0</span>; <span class="comment">// 其实这行代码可以和dp数组初始化的时候放在一起，但我为了凸显初始化的逻辑，所以还是加上了。</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>确定遍历顺序</li>
</ol>
<p>从递推公式dp[i][j] &#x3D; dp[i - 1][j - 1] + dp[i - 1][j]; 和 dp[i][j] &#x3D; dp[i - 1][j]; 中可以看出dp[i][j]都是根据左上方和正上方推出来的。</p>
<p>所以遍历的时候一定是从上到下，从左到右，这样保证dp[i][j]可以根据之前计算出来的数值进行计算。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= t.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i - <span class="number">1</span>] == t[j - <span class="number">1</span>]) &#123;</span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + dp[i - <span class="number">1</span>][j];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>举例推导dp数组</li>
</ol>
<p>以s：”baegg”，t：”bag”为例，推导dp数组状态如下：</p>
<p><img src="https://code-thinking.cdn.bcebos.com/pics/115.%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97.jpg" alt="115.不同的子序列"></p>
<p>如果写出来的代码怎么改都通过不了，不妨把dp数组打印出来，看一看，是不是这样的。</p>
<p>动规五部曲分析完毕，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numDistinct</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">uint64_t</span>&gt;&gt; <span class="built_in">dp</span>(s.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">uint64_t</span>&gt;(t.<span class="built_in">size</span>() + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; t.<span class="built_in">size</span>(); j++) dp[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= t.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i - <span class="number">1</span>] == t[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + dp[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.<span class="built_in">size</span>()][t.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="两个字符串的删除操作"><a href="#两个字符串的删除操作" class="headerlink" title="两个字符串的删除操作"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/delete-operation-for-two-strings/">两个字符串的删除操作</a></h1><p>给定两个单词 word1 和 word2，找到使得 word1 和 word2 相同所需的最小步数，每步可以删除任意一个字符串中的一个字符。</p>
<p>示例：</p>
<p>输入: “sea”, “eat”<br>输出: 2 解释: 第一步将”sea”变为”ea”，第二步将”eat”变为”ea”</p>
<h2 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h2><h3 id="动态规划一"><a href="#动态规划一" class="headerlink" title="动态规划一"></a>动态规划一</h3><p>本题和<a target="_blank" rel="noopener" href="https://programmercarl.com/0115.%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97.html">动态规划：115.不同的子序列</a>相比，其实就是两个字符串都可以删除了，情况虽说复杂一些，但整体思路是不变的。</p>
<p>这次是两个字符串可以相互删了，这种题目也知道用动态规划的思路来解，动规五部曲，分析如下：</p>
<ol>
<li>确定dp数组（dp table）以及下标的含义</li>
</ol>
<p>dp[i][j]：以i-1为结尾的字符串word1，和以j-1位结尾的字符串word2，想要达到相等，所需要删除元素的最少次数。</p>
<p>这里dp数组的定义有点点绕，大家要撸清思路。</p>
<ol start="2">
<li>确定递推公式</li>
</ol>
<ul>
<li>当word1[i - 1] 与 word2[j - 1]相同的时候</li>
<li>当word1[i - 1] 与 word2[j - 1]不相同的时候</li>
</ul>
<p>当word1[i - 1] 与 word2[j - 1]相同的时候，dp[i][j] &#x3D; dp[i - 1][j - 1];</p>
<p>当word1[i - 1] 与 word2[j - 1]不相同的时候，有三种情况：</p>
<p>情况一：删word1[i - 1]，最少操作次数为dp[i - 1][j] + 1</p>
<p>情况二：删word2[j - 1]，最少操作次数为dp[i][j - 1] + 1</p>
<p>情况三：同时删word1[i - 1]和word2[j - 1]，操作的最少次数为dp[i - 1][j - 1] + 2</p>
<p>那最后当然是取最小值，所以当word1[i - 1] 与 word2[j - 1]不相同的时候，递推公式：<strong>dp[i][j] &#x3D; min({dp[i - 1][j - 1] + 2, dp[i - 1][j] + 1, dp[i][j - 1] + 1});</strong></p>
<ol start="3">
<li>dp数组如何初始化</li>
</ol>
<p>从递推公式中，可以看出来，dp[i][0] 和 dp[0][j]是一定要初始化的。</p>
<p>dp[i][0]：word2为空字符串，以i-1为结尾的字符串word1要删除多少个元素，才能和word2相同呢，很明显dp[i][0] &#x3D; i。</p>
<p>dp[0][j]的话同理，所以代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(word1.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(word2.<span class="built_in">size</span>() + <span class="number">1</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= word1.<span class="built_in">size</span>(); i++) dp[i][<span class="number">0</span>] = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= word2.<span class="built_in">size</span>(); j++) dp[<span class="number">0</span>][j] = j;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>确定遍历顺序</li>
</ol>
<p>从递推公式 dp[i][j] &#x3D; min(dp[i - 1][j - 1] + 2, min(dp[i - 1][j], dp[i][j - 1]) + 1); 和dp[i][j] &#x3D; dp[i - 1][j - 1]可以看出dp[i][j]都是根据左上方、正上方、正左方推出来的。</p>
<p>所以遍历的时候一定是从上到下，从左到右，这样保证dp[i][j]可以根据之前计算出来的数值进行计算。</p>
<ol start="5">
<li>举例推导dp数组</li>
</ol>
<p>以word1:”sea”，word2:”eat”为例，推导dp数组状态图如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20210714101750205.png" alt="583.两个字符串的删除操作1"></p>
<p>以上分析完毕，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDistance</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(word1.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(word2.<span class="built_in">size</span>() + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= word1.<span class="built_in">size</span>(); i++) dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= word2.<span class="built_in">size</span>(); j++) dp[<span class="number">0</span>][j] = j;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= word1.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= word2.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(&#123;dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>, dp[i - <span class="number">1</span>][j] + <span class="number">1</span>, dp[i][j - <span class="number">1</span>] + <span class="number">1</span>&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[word1.<span class="built_in">size</span>()][word2.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="动态规划二"><a href="#动态规划二" class="headerlink" title="动态规划二"></a>动态规划二</h3><p>本题和<a target="_blank" rel="noopener" href="https://programmercarl.com/1143.%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97.html">动态规划：1143.最长公共子序列</a>基本相同，只要求出两个字符串的最长公共子序列长度即可，那么除了最长公共子序列之外的字符都是必须删除的，最后用两个字符串的总长度减去两个最长公共子序列的长度就是删除的最少步数。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDistance</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(word1.<span class="built_in">size</span>()+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(word2.<span class="built_in">size</span>()+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=word1.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>; j&lt;=word2.<span class="built_in">size</span>(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (word1[i<span class="number">-1</span>] == word2[j<span class="number">-1</span>]) dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> word1.<span class="built_in">size</span>()+word2.<span class="built_in">size</span>()-dp[word1.<span class="built_in">size</span>()][word2.<span class="built_in">size</span>()]*<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a>编辑距离</h1><p>给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。</p>
<p>你可以对一个单词进行如下三种操作：</p>
<ul>
<li>插入一个字符</li>
<li>删除一个字符</li>
<li>替换一个字符</li>
</ul>
<p>示例 1： 输入：word1 &#x3D; “horse”, word2 &#x3D; “ros” 输出：3 解释： horse -&gt; rorse (将 ‘h’ 替换为 ‘r’) rorse -&gt; rose (删除 ‘r’) rose -&gt; ros (删除 ‘e’)</p>
<p>示例 2： 输入：word1 &#x3D; “intention”, word2 &#x3D; “execution” 输出：5 解释： intention -&gt; inention (删除 ‘t’) inention -&gt; enention (将 ‘i’ 替换为 ‘e’) enention -&gt; exention (将 ‘n’ 替换为 ‘x’) exention -&gt; exection (将 ‘n’ 替换为 ‘c’) exection -&gt; execution (插入 ‘u’)</p>
<p>提示：</p>
<ul>
<li>0 &lt;&#x3D; word1.length, word2.length &lt;&#x3D; 500</li>
<li>word1 和 word2 由小写英文字母组成</li>
</ul>
<h2 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h2><p>编辑距离终于来了，这道题目如果大家没有了解动态规划的话，会感觉超级复杂。</p>
<p>编辑距离是用动规来解决的经典题目，这道题目看上去好像很复杂，但用动规可以很巧妙的算出最少编辑距离。</p>
<p>接下来我依然使用动规五部曲，对本题做一个详细的分析：</p>
<h3 id="1-确定dp数组（dp-table）以及下标的含义"><a href="#1-确定dp数组（dp-table）以及下标的含义" class="headerlink" title="1. 确定dp数组（dp table）以及下标的含义"></a>1. 确定dp数组（dp table）以及下标的含义</h3><p>**dp[i][j] 表示以下标i-1为结尾的字符串word1，和以下标j-1为结尾的字符串word2，最近编辑距离为dp[i][j]**。</p>
<p>这里在强调一下：为啥要表示下标i-1为结尾的字符串呢，为啥不表示下标i为结尾的字符串呢？</p>
<p>用i来表示也可以！ 但我统一以下标i-1为结尾的字符串，在下面的递归公式中会容易理解一点。</p>
<h3 id="2-确定递推公式"><a href="#2-确定递推公式" class="headerlink" title="2. 确定递推公式"></a>2. 确定递推公式</h3><p>在确定递推公式的时候，首先要考虑清楚编辑的几种操作，整理如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>])</span><br><span class="line">    不操作</span><br><span class="line"><span class="keyword">if</span> (word1[i - <span class="number">1</span>] != word2[j - <span class="number">1</span>])</span><br><span class="line">    增</span><br><span class="line">    删</span><br><span class="line">    换</span><br></pre></td></tr></table></figure>

<p>也就是如上4种情况。</p>
<p><code>if (word1[i - 1] == word2[j - 1])</code> 那么说明不用任何编辑，<code>dp[i][j]</code> 就应该是 <code>dp[i - 1][j - 1]</code>，即<code>dp[i][j] = dp[i - 1][j - 1];</code></p>
<p>此时可能有同学有点不明白，为啥要即<code>dp[i][j] = dp[i - 1][j - 1]</code>呢？</p>
<p>那么就在回顾上面讲过的<code>dp[i][j]</code>的定义，<code>word1[i - 1]</code> 与 <code>word2[j - 1]</code>相等了，那么就不用编辑了，以下标i-2为结尾的字符串word1和以下标j-2为结尾的字符串<code>word2</code>的最近编辑距离<code>dp[i - 1][j - 1]</code>就是 <code>dp[i][j]</code>了。</p>
<p>在下面的讲解中，如果哪里看不懂，就回想一下<code>dp[i][j]</code>的定义，就明白了。</p>
<p><strong>在整个动规的过程中，最为关键就是正确理解<code>dp[i][j]</code>的定义！</strong></p>
<p><code>if (word1[i - 1] != word2[j - 1])</code>，此时就需要编辑了，如何编辑呢？</p>
<ul>
<li>操作一：word1删除一个元素，那么就是以下标i - 2为结尾的word1 与 j-1为结尾的word2的最近编辑距离 再加上一个操作。</li>
</ul>
<p>即 <code>dp[i][j] = dp[i - 1][j] + 1;</code></p>
<ul>
<li>操作二：word2删除一个元素，那么就是以下标i - 1为结尾的word1 与 j-2为结尾的word2的最近编辑距离 再加上一个操作。</li>
</ul>
<p>即 <code>dp[i][j] = dp[i][j - 1] + 1;</code></p>
<p>这里有同学发现了，怎么都是删除元素，添加元素去哪了。</p>
<p><strong>word2添加一个元素，相当于word1删除一个元素</strong>，例如 <code>word1 = &quot;ad&quot; ，word2 = &quot;a&quot;</code>，<code>word1</code>删除元素<code>&#39;d&#39;</code> 和 <code>word2</code>添加一个元素<code>&#39;d&#39;</code>，变成<code>word1=&quot;a&quot;, word2=&quot;ad&quot;</code>， 最终的操作数是一样！ dp数组如下图所示意的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">           a                         a     d</span><br><span class="line">  +-----+-----+             +-----+-----+-----+</span><br><span class="line">  |  0  |  1  |             |  0  |  1  |  2  |</span><br><span class="line">  +-----+-----+   ===&gt;      +-----+-----+-----+</span><br><span class="line">a |  1  |  0  |           a |  1  |  0  |  1  |</span><br><span class="line">  +-----+-----+             +-----+-----+-----+</span><br><span class="line">d |  2  |  1  |</span><br><span class="line">  +-----+-----+</span><br></pre></td></tr></table></figure>

<p>操作三：替换元素，<code>word1</code>替换<code>word1[i - 1]</code>，使其与<code>word2[j - 1]</code>相同，此时不用增加元素，那么以下标<code>i-2</code>为结尾的<code>word1</code> 与 <code>j-2</code>为结尾的<code>word2</code>的最近编辑距离 加上一个替换元素的操作。</p>
<p>即 <code>dp[i][j] = dp[i - 1][j - 1] + 1;</code></p>
<p>综上，当 <code>if (word1[i - 1] != word2[j - 1])</code> 时取最小的，即：<code>dp[i][j] = min(&#123;dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]&#125;) + 1;</code></p>
<p>递归公式代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    dp[i][j] = <span class="built_in">min</span>(&#123;dp[i - <span class="number">1</span>][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]&#125;) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-dp数组如何初始化"><a href="#3-dp数组如何初始化" class="headerlink" title="3. dp数组如何初始化"></a>3. dp数组如何初始化</h3><p>再回顾一下dp[i][j]的定义：</p>
<p>**dp[i][j] 表示以下标i-1为结尾的字符串word1，和以下标j-1为结尾的字符串word2，最近编辑距离为dp[i][j]**。</p>
<p>那么dp[i][0] 和 dp[0][j] 表示什么呢？</p>
<p>dp[i][0] ：以下标i-1为结尾的字符串word1，和空字符串word2，最近编辑距离为dp[i][0]。</p>
<p>那么dp[i][0]就应该是i，对word1里的元素全部做删除操作，即：dp[i][0] &#x3D; i;</p>
<p>同理dp[0][j] &#x3D; j;</p>
<p>所以C++代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= word1.<span class="built_in">size</span>(); i++) dp[i][<span class="number">0</span>] = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= word2.<span class="built_in">size</span>(); j++) dp[<span class="number">0</span>][j] = j;</span><br></pre></td></tr></table></figure>

<h3 id="4-确定遍历顺序"><a href="#4-确定遍历顺序" class="headerlink" title="4. 确定遍历顺序"></a>4. 确定遍历顺序</h3><p>从如下四个递推公式：</p>
<ul>
<li><code>dp[i][j] = dp[i - 1][j - 1]</code></li>
<li><code>dp[i][j] = dp[i - 1][j - 1] + 1</code></li>
<li><code>dp[i][j] = dp[i][j - 1] + 1</code></li>
<li><code>dp[i][j] = dp[i - 1][j] + 1</code></li>
</ul>
<p>可以看出dp[i][j]是依赖左方，上方和左上方元素的，如图：</p>
<p><img src="https://img-blog.csdnimg.cn/20210114162113131.jpg" alt="72.编辑距离"></p>
<p>所以在dp矩阵中一定是从左到右从上到下去遍历。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= word1.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= word2.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            dp[i][j] = <span class="built_in">min</span>(&#123;dp[i - <span class="number">1</span>][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]&#125;) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-举例推导dp数组"><a href="#5-举例推导dp数组" class="headerlink" title="5. 举例推导dp数组"></a>5. 举例推导dp数组</h3><p>以示例1为例，输入：<code>word1 = &quot;horse&quot;, word2 = &quot;ros&quot;</code>为例，dp矩阵状态图如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20210114162132300.jpg" alt="72.编辑距离1"></p>
<p>以上动规五部分析完毕，C++代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDistance</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(word1.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(word2.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= word1.<span class="built_in">size</span>(); i++) dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= word2.<span class="built_in">size</span>(); j++) dp[<span class="number">0</span>][j] = j;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= word1.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= word2.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(&#123;dp[i - <span class="number">1</span>][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]&#125;) + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[word1.<span class="built_in">size</span>()][word2.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="回文子串"><a href="#回文子串" class="headerlink" title="回文子串"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/palindromic-substrings/">回文子串</a></h1><p>给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。</p>
<p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p>
<p>示例 1：</p>
<p>输入：”abc” </p>
<p>输出：3 </p>
<p>解释：三个回文子串: “a”, “b”, “c”</p>
<p>示例 2：</p>
<p>输入：”aaa” </p>
<p>输出：6 </p>
<p>解释：6个回文子串: “a”, “a”, “a”, “aa”, “aa”, “aaa”</p>
<p>提示：</p>
<p>输入的字符串长度不会超过 1000 。</p>
<h2 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h2><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>动规五部曲：</p>
<ol>
<li>确定dp数组（dp table）以及下标的含义</li>
</ol>
<p>布尔类型的dp[i][j]：表示区间范围[i,j] （注意是左闭右闭）的子串是否是回文子串，如果是dp[i][j]为true，否则为false。</p>
<ol start="2">
<li>确定递推公式</li>
</ol>
<p>在确定递推公式时，就要分析如下几种情况。</p>
<p>整体上是两种，就是s[i]与s[j]相等，s[i]与s[j]不相等这两种。</p>
<p>当s[i]与s[j]不相等，那没啥好说的了，dp[i][j]一定是false。</p>
<p>当s[i]与s[j]相等时，这就复杂一些了，有如下三种情况</p>
<ul>
<li>情况一：下标i 与 j相同，同一个字符例如a，当然是回文子串</li>
<li>情况二：下标i 与 j相差为1，例如aa，也是回文子串</li>
<li>情况三：下标：i 与 j相差大于1的时候，例如cabac，此时s[i]与s[j]已经相同了，我们看i到j区间是不是回文子串就看aba是不是回文就可以了，那么aba的区间就是 i+1 与 j-1区间，这个区间是不是回文就看dp[i + 1][j - 1]是否为true。</li>
</ul>
<p>以上三种情况分析完了，那么递归公式如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (j - i &lt;= <span class="number">1</span>) &#123; <span class="comment">// 情况一 和 情况二</span></span><br><span class="line">        result++;</span><br><span class="line">        dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dp[i + <span class="number">1</span>][j - <span class="number">1</span>]) &#123; <span class="comment">// 情况三</span></span><br><span class="line">        result++;</span><br><span class="line">        dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>result就是统计回文子串的数量。</p>
<p>注意这里我没有列出当s[i]与s[j]不相等的时候，因为在下面dp[i][j]初始化的时候，就初始为false。</p>
<ol start="3">
<li>dp数组如何初始化</li>
</ol>
<p>dp[i][j]可以初始化为true么？ 当然不行，怎能刚开始就全都匹配上了。</p>
<p>所以dp[i][j]初始化为false。</p>
<ol start="4">
<li>确定遍历顺序</li>
</ol>
<p>遍历顺序可有有点讲究了。</p>
<p>首先从递推公式中可以看出，情况三是根据dp[i + 1][j - 1]是否为true，在对dp[i][j]进行赋值true的。</p>
<p>dp[i + 1][j - 1] 在 dp[i][j]的左下角，如图：</p>
<p><img src="https://img-blog.csdnimg.cn/20210121171032473.jpg" alt="647.回文子串"></p>
<p>如果这矩阵是从上到下，从左到右遍历，那么会用到没有计算过的dp[i + 1][j - 1]，也就是根据不确定是不是回文的区间[i+1,j-1]，来判断了[i,j]是不是回文，那结果一定是不对的。</p>
<p><strong>所以一定要从下到上，从左到右遍历，这样保证dp[i + 1][j - 1]都是经过计算的</strong>。</p>
<p>有的代码实现是优先遍历列，然后遍历行，其实也是一个道理，都是为了保证dp[i + 1][j - 1]都是经过计算的。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = s.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;  <span class="comment">// 注意遍历顺序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; s.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j - i &lt;= <span class="number">1</span>) &#123; <span class="comment">// 情况一 和 情况二</span></span><br><span class="line">                result++;</span><br><span class="line">                dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dp[i + <span class="number">1</span>][j - <span class="number">1</span>]) &#123; <span class="comment">// 情况三</span></span><br><span class="line">                result++;</span><br><span class="line">                dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol start="5">
<li>举例推导dp数组</li>
</ol>
<p>举例，输入：”aaa”，dp[i][j]状态如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20210121171059951.jpg" alt="647.回文子串1"></p>
<p>图中有6个true，所以就是有6个回文子串。</p>
<p><strong>注意因为dp[i][j]的定义，所以j一定是大于等于i的，那么在填充dp[i][j]的时候一定是只填充右上半部分</strong>。</p>
<p>以上分析完毕，C++代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countSubstrings</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">dp</span>(s.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(s.<span class="built_in">size</span>(), <span class="literal">false</span>));</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = s.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;  <span class="comment">// 注意遍历顺序</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; s.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (j - i &lt;= <span class="number">1</span>) &#123; <span class="comment">// 情况一 和 情况二</span></span><br><span class="line">                        result++;</span><br><span class="line">                        dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dp[i + <span class="number">1</span>][j - <span class="number">1</span>]) &#123; <span class="comment">// 情况三</span></span><br><span class="line">                        result++;</span><br><span class="line">                        dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h2><p>动态规划的空间复杂度是偏高的，我们再看一下双指针法。</p>
<p>首先确定回文串，就是找中心然后向两边扩散看是不是对称的就可以了。</p>
<p><strong>在遍历中心点的时候，要注意中心点有两种情况</strong>。</p>
<p>一个元素可以作为中心点，两个元素也可以作为中心点。</p>
<p>那么有人同学问了，三个元素还可以做中心点呢。其实三个元素就可以由一个元素左右添加元素得到，四个元素则可以由两个元素左右添加元素得到。</p>
<p>所以我们在计算的时候，要注意一个元素为中心点和两个元素为中心点的情况。</p>
<p><strong>这两种情况可以放在一起计算，但分别计算思路更清晰，我倾向于分别计算</strong>，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countSubstrings</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            result += <span class="built_in">extend</span>(s, i, i, s.<span class="built_in">size</span>()); <span class="comment">// 以i为中心</span></span><br><span class="line">            result += <span class="built_in">extend</span>(s, i, i + <span class="number">1</span>, s.<span class="built_in">size</span>()); <span class="comment">// 以i和i+1为中心</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">extend</span><span class="params">(<span class="type">const</span> string&amp; s, <span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n &amp;&amp; s[i] == s[j]) &#123;</span><br><span class="line">            i--;</span><br><span class="line">            j++;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="最长回文子序列"><a href="#最长回文子序列" class="headerlink" title="最长回文子序列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-palindromic-subsequence/">最长回文子序列</a></h1><p>给定一个字符串 s ，找到其中最长的回文子序列，并返回该序列的长度。可以假设 s 的最大长度为 1000 。</p>
<p>示例 1: 输入: “bbbab” </p>
<p>输出: 4 </p>
<p>一个可能的最长回文子序列为 “bbbb”。</p>
<p>示例 2: </p>
<p>输入:”cbbd” </p>
<p>输出: 2 </p>
<p>一个可能的最长回文子序列为 “bb”。</p>
<p>提示：</p>
<ul>
<li>1 &lt;&#x3D; s.length &lt;&#x3D; 1000</li>
<li>s 只包含小写英文字母</li>
</ul>
<h2 id="思路-11"><a href="#思路-11" class="headerlink" title="思路"></a>思路</h2><p>我们刚刚做过了 <a target="_blank" rel="noopener" href="https://programmercarl.com/0647.%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2.html">动态规划：回文子串 </a>，求的是回文子串，而本题要求的是回文子序列， 要搞清楚这两者之间的区别。</p>
<p><strong>回文子串是要连续的，回文子序列可不是连续的！</strong> 回文子串，回文子序列都是动态规划经典题目。</p>
<p>回文子串，可以做这两题：</p>
<ul>
<li>647.回文子串</li>
<li>5.最长回文子串</li>
</ul>
<p>思路其实是差不多的，但本题要比求回文子串简单一点，因为情况少了一点。</p>
<p>动规五部曲分析如下：</p>
<ol>
<li>确定dp数组（dp table）以及下标的含义</li>
</ol>
<p>**dp[i][j]：字符串s在[i, j]范围内最长的回文子序列的长度为dp[i][j]**。</p>
<ol start="2">
<li>确定递推公式</li>
</ol>
<p>在判断回文子串的题目中，关键逻辑就是看s[i]与s[j]是否相同。</p>
<p>如果s[i]与s[j]相同，那么dp[i][j] &#x3D; dp[i + 1][j - 1] + 2;</p>
<p>如图： <img src="https://img-blog.csdnimg.cn/20210127151350563.jpg" alt="516.最长回文子序列"></p>
<p>（如果这里看不懂，回忆一下dp[i][j]的定义）</p>
<p>如果s[i]与s[j]不相同，说明s[i]和s[j]的同时加入 并不能增加[i,j]区间回文子串的长度，那么分别加入s[i]、s[j]看看哪一个可以组成最长的回文子序列。</p>
<p>加入s[j]的回文子序列长度为dp[i + 1][j]。</p>
<p>加入s[i]的回文子序列长度为dp[i][j - 1]。</p>
<p>那么dp[i][j]一定是取最大的，即：dp[i][j] &#x3D; max(dp[i + 1][j], dp[i][j - 1]);</p>
<p><img src="https://img-blog.csdnimg.cn/20210127151420476.jpg" alt="516.最长回文子序列1"></p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">    dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    dp[i][j] = <span class="built_in">max</span>(dp[i + <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol start="3">
<li>dp数组如何初始化</li>
</ol>
<p>首先要考虑当i 和j 相同的情况，从递推公式：dp[i][j] &#x3D; dp[i + 1][j - 1] + 2; 可以看出 递推公式是计算不到 i 和j相同时候的情况。</p>
<p>所以需要手动初始化一下，当i与j相同，那么dp[i][j]一定是等于1的，即：一个字符的回文子序列长度就是1。</p>
<p>其他情况dp[i][j]初始为0就行，这样递推公式：dp[i][j] &#x3D; max(dp[i + 1][j], dp[i][j - 1]); 中dp[i][j]才不会被初始值覆盖。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(s.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(s.<span class="built_in">size</span>(), <span class="number">0</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) dp[i][i] = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>



<ol start="4">
<li>确定遍历顺序</li>
</ol>
<p>从递推公式dp[i][j] &#x3D; dp[i + 1][j - 1] + 2 和 dp[i][j] &#x3D; max(dp[i + 1][j], dp[i][j - 1]) 可以看出，dp[i][j]是依赖于dp[i + 1][j - 1] 和 dp[i + 1][j]，</p>
<p>也就是从矩阵的角度来说，dp[i][j] 下一行的数据。 <strong>所以遍历i的时候一定要从下到上遍历，这样才能保证，下一行的数据是经过计算的</strong>。</p>
<p>递推公式：dp[i][j] &#x3D; dp[i + 1][j - 1] + 2，dp[i][j] &#x3D; max(dp[i + 1][j], dp[i][j - 1]) 分别对应着下图中的红色箭头方向，如图：</p>
<p><img src="https://img-blog.csdnimg.cn/20210127151452993.jpg" alt="516.最长回文子序列2"></p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = s.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; s.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">            dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dp[i][j] = <span class="built_in">max</span>(dp[i + <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol start="5">
<li>举例推导dp数组</li>
</ol>
<p>输入s:”cbbd” 为例，dp数组状态如图：</p>
<p><img src="https://img-blog.csdnimg.cn/20210127151521432.jpg" alt="516.最长回文子序列3"></p>
<p>红色框即：dp[0][s.size() - 1]; 为最终结果。</p>
<p>以上分析完毕，C++代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(s.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(s.<span class="built_in">size</span>(), <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) dp[i][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = s.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; s.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i + <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][s.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>声明</p>
<p>本博客整理依据《代码随想录》，题目来自leetcode</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/10/UE4-%E4%BD%BF%E7%94%A8UMG%E7%9A%84%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="williny">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Williny'home">
      <meta itemprop="description" content="孤独是人生的常态">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Williny'home">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/05/10/UE4-%E4%BD%BF%E7%94%A8UMG%E7%9A%84%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2/" class="post-title-link" itemprop="url">UE4-使用UMG的用户界面</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-05-10 08:58:00 / 修改时间：20:48:28" itemprop="dateCreated datePublished" datetime="2022-05-10T08:58:00+08:00">2022-05-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/unreal-engine/" itemprop="url" rel="index"><span itemprop="name">unreal engine</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="这是啥？"><a href="#这是啥？" class="headerlink" title="这是啥？"></a>这是啥？</h1><p>这就是UI界面，也就是登录界面，属性面板等等界面</p>
<h1 id="设置UMG的模块依赖性"><a href="#设置UMG的模块依赖性" class="headerlink" title="设置UMG的模块依赖性"></a>设置UMG的模块依赖性</h1><p>将.build.cs文件修改为以下样子</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnrealBuildTool;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HowTo_UMG</span> : ModuleRules</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HowTo_UMG</span><span class="params">(ReadOnlyTargetRules Target)</span> : base(Target)</span></span><br><span class="line"><span class="function">    &#123;</span></span><br><span class="line">        PublicDependencyModuleNames.<span class="built_in">AddRange</span>(<span class="keyword">new</span> string[] &#123; <span class="string">&quot;Core&quot;</span>, <span class="string">&quot;CoreUObject&quot;</span>, <span class="string">&quot;Engine&quot;</span>, <span class="string">&quot;InputCore&quot;</span>, <span class="string">&quot;UMG&quot;</span> &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//PrivateDependencyModuleNames.AddRange(new string[] &#123;  &#125;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如使用Slate UI，则取消注释</span></span><br><span class="line">        PrivateDependencyModuleNames.<span class="built_in">AddRange</span>(<span class="keyword">new</span> string[] &#123; <span class="string">&quot;Slate&quot;</span>, <span class="string">&quot;SlateCore&quot;</span> &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如使用在线功能，则取消注释</span></span><br><span class="line">        <span class="comment">// PrivateDependencyModuleNames.Add(&quot;OnlineSubsystem&quot;);</span></span><br><span class="line">        <span class="comment">// if ((Target.Platform == UnrealTargetPlatform.Win32) || (Target.Platform == UnrealTargetPlatform.Win64))</span></span><br><span class="line">        <span class="comment">// &#123;</span></span><br><span class="line">        <span class="comment">//      if (UEBuildConfiguration.bCompileSteamOSS == true)</span></span><br><span class="line">        <span class="comment">//      &#123;</span></span><br><span class="line">        <span class="comment">//          DynamicallyLoadedModuleNames.Add(&quot;OnlineSubsystemSteam&quot;);</span></span><br><span class="line">        <span class="comment">//      &#125;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="扩展游戏模式"><a href="#扩展游戏模式" class="headerlink" title="扩展游戏模式"></a>扩展游戏模式</h1><h2 id="HowTo-UMGGameModeBase-h"><a href="#HowTo-UMGGameModeBase-h" class="headerlink" title="HowTo_UMGGameModeBase.h"></a>HowTo_UMGGameModeBase.h</h2><p>声明默认游戏菜单，变换游戏菜单两个函数，以及一个用作菜单的控件实例</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CoreMinimal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GameFramework/GameModeBase.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Blueprint/UserWidget.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;HowTo_UMGGameModeBase.generated.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HOWTO_UMG_API</span> AHowTo_UMGGameMode : <span class="keyword">public</span> AGameModeBase</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** 移除当前菜单控件，并在指定类（如有）中新建控件。*/</span></span><br><span class="line">    <span class="built_in">UFUNCTION</span>(BlueprintCallable, Category = <span class="string">&quot;UMG Game&quot;</span>)</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">ChangeMenuWidget</span><span class="params">(TSubclassOf&lt;UUserWidget&gt; NewWidgetClass)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">/** 游戏开始时调用。*/</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BeginPlay</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 游戏开始时，用作菜单的控件类。*/</span></span><br><span class="line">    <span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadOnly, Category = <span class="string">&quot;UMG Game&quot;</span>)</span><br><span class="line">        TSubclassOf&lt;UUserWidget&gt; StartingWidgetClass;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 用作菜单的控件实例。*/</span></span><br><span class="line">    <span class="built_in">UPROPERTY</span>()</span><br><span class="line">        UUserWidget* CurrentWidget;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>TSubclassOf&lt;&gt;()</p>
<p>以&lt;&gt;内的参数为父类，创建一个对象</p>
<h2 id="HowTo-UMGGameModeBase-cpp"><a href="#HowTo-UMGGameModeBase-cpp" class="headerlink" title="HowTo_UMGGameModeBase.cpp"></a>HowTo_UMGGameModeBase.cpp</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;HowTo_UMG.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;HowTo_UMGGameModeBase.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AHowTo_UMGGameMode::BeginPlay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">BeginPlay</span>();</span><br><span class="line">    <span class="built_in">ChangeMenuWidget</span>(StartingWidgetClass);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AHowTo_UMGGameMode::ChangeMenuWidget</span><span class="params">(TSubclassOf&lt;UUserWidget&gt; NewWidgetClass)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (CurrentWidget != <span class="literal">nullptr</span>)<span class="comment">//如果存在当前菜单</span></span><br><span class="line">    &#123;</span><br><span class="line">        CurrentWidget-&gt;<span class="built_in">RemoveFromViewport</span>();<span class="comment">//将当前菜单从当前视口移除</span></span><br><span class="line">        CurrentWidget = <span class="literal">nullptr</span>;<span class="comment">//将当前菜单赋值为空</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (NewWidgetClass != <span class="literal">nullptr</span>)<span class="comment">//如果要转变的菜单不为空</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//将根据要转变的菜单创建一个菜单，并赋值给当前菜单</span></span><br><span class="line">        CurrentWidget = <span class="built_in">CreateWidget</span>&lt;UUserWidget&gt;(<span class="built_in">GetWorld</span>(), NewWidgetClass);</span><br><span class="line">        <span class="keyword">if</span> (CurrentWidget != <span class="literal">nullptr</span>)<span class="comment">//赋值成功</span></span><br><span class="line">        &#123;</span><br><span class="line">            CurrentWidget-&gt;<span class="built_in">AddToViewport</span>();<span class="comment">//将当前菜单添加到视口中</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ChangeMenuWidget()函数思路</p>
<ol>
<li><p>先搞清楚CurrentWidget是否为空，不为空，则代表视口内有菜单</p>
</li>
<li><p>将视口内的菜单移除</p>
</li>
<li><p>根据NewWidgetClass创建新的菜单，赋值给CurrentWidget</p>
</li>
<li><p>将CurrentWidget添加到视口内</p>
</li>
</ol>
<h2 id="HowTo-UMGPlayerController-h"><a href="#HowTo-UMGPlayerController-h" class="headerlink" title="HowTo_UMGPlayerController.h"></a>HowTo_UMGPlayerController.h</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GameFramework/PlayerController.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;HowTo_UMGPlayerController.generated.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HOWTO_UMG_API</span> AHowTo_UMGPlayerController : <span class="keyword">public</span> APlayerController</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BeginPlay</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>声明，以便重载BeginPlay()函数</p>
<h2 id="HowTo-UMGPlayerController-cpp"><a href="#HowTo-UMGPlayerController-cpp" class="headerlink" title="HowTo_UMGPlayerController.cpp"></a>HowTo_UMGPlayerController.cpp</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;HowTo_UMG.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;HowTo_UMGPlayerController.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AHowTo_UMGPlayerController::BeginPlay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">BeginPlay</span>();</span><br><span class="line">    <span class="built_in">SetInputMode</span>(<span class="built_in">FInputModeGameAndUI</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置输入模式为FInputModeGameAndUI()</p>
<h1 id="创建菜单控件蓝图"><a href="#创建菜单控件蓝图" class="headerlink" title="创建菜单控件蓝图"></a>创建菜单控件蓝图</h1><p>这个就相对简单了</p>
<p>首先右键内容浏览器-&gt;用户界面-&gt;空间蓝图 创建MainMenu和NewGameMenu两个菜单界面</p>
<p>分别表示主菜单和新游戏菜单</p>
<p>用Button和Text进行合理布局</p>
<p>为Button添加点击事件</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/UMG/OnClicked_NewGame.jpg" alt="OnClicked_NewGame.png"></p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/UMG/OnClicked_Quit.jpg" alt="OnClicked_Quit.png"></p>
<p>这就涉及到蓝图的类型转换和Actor通信问题了</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul>
<li><p>将点击事件的类型转换为HowTo_UMGGameMode</p>
</li>
<li><p>如果转换成功，则访问Change Menu Widget函数</p>
</li>
<li><p>将New Widget Class设定为New Game Menu</p>
</li>
</ul>
<h1 id="配置游戏模式"><a href="#配置游戏模式" class="headerlink" title="配置游戏模式"></a>配置游戏模式</h1><p>基于项目的 <strong>GameMode</strong>，在 <strong>内容浏览器</strong> 中添加 <strong>蓝图类</strong>.利用此操作，可将这两个类上的公开变量设为需要的值。为此，需：</p>
<ul>
<li>在 <strong>内容浏览器</strong> 中点击的 <strong>添加</strong> 按钮。</li>
</ul>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/UMG/AddNewBPClass.jpg" alt="AddNewBPClass.png"></p>
<ul>
<li>选择 <strong>HowTo_UMGGameMode</strong> 作为父类。其将被列入 <strong>所有类（All Classes）</strong> 部分。</li>
</ul>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/UMG/PickParentClassForGameModeBP.jpg" alt="PickParentClassForGameModeBP.png"></p>
<ol>
<li><p>将得到的蓝图资源命名为MenuGameMode。</p>
</li>
<li><p>为使游戏光标出现在游戏中，需进行GameMode中的相同操作，创建 <strong>PlayerController</strong> 的蓝图。</p>
<ul>
<li><p>在 <strong>内容浏览器</strong> 中再次点击 <strong>添加</strong> 按钮。</p>
</li>
<li><p>在 <strong>常用类（Common Classes）</strong> 部分选择 <strong>玩家控制器</strong>。</p>
</li>
<li><p>将该蓝图命名为MenuPlayerController。</p>
</li>
</ul>
</li>
<li><p>编辑MenuPlayerController。</p>
<ul>
<li>勾选 <strong>显示鼠标光标（Show Mouse Cursor）</strong> 复选框。</li>
</ul>
</li>
</ol>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/UMG/GamePlayerController.jpg" alt="GamePlayerController.png"></p>
<p>编辑MenuGameMode。</p>
<ul>
<li><p>须将 <strong>启动控件类（Starting Widget Class）</strong> 设为MainMenu资源，以便在游戏开始时打开菜单。</p>
</li>
<li><p>应将 <strong>默认Pawn类（Default Pawn Class）</strong> 设为 <strong>Pawn</strong> 而非 <strong>DefaultPawn</strong>，玩家便不会在菜单中乱飞。</p>
</li>
<li><p>应将 <strong>玩家控制器类</strong> 设为创建的MenuPlayerController资源，以便在游戏中显示鼠标光标。</p>
</li>
</ul>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/UMG/ConfigureGameMode.jpg" alt="ConfigureGameMode.png"></p>
<p>为使用蓝图，必返回 <strong>关卡编辑器</strong> 窗口，并通过 <strong>设置</strong> 按钮修改当前 <strong>关卡</strong> 的 <strong>场景设置</strong>。</p>
<ol>
<li><strong>地图和模式</strong> 部分的 <strong>项目设置</strong></li>
</ol>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/UMG/WorldSettings.webp" alt="WorldSettings.png"></p>
<p>将打开 <strong>场景设置面板</strong>。其将默认与 <strong>细节面板</strong> 停靠，但也可将其移动到其他位置。需将 <strong>游戏模式覆盖（Game Mode Override）</strong> 字段设为MenuGameMode资源。</p>
<p>自定义GameMode资源现已在关卡上生效，并被配置以加载主菜单，同时使用显示鼠标光标的玩家控制器。如现在运行游戏，退出按钮将预期生效，使用新游戏按钮将进入空白菜单。将在下一步中设置新游戏菜单。</p>
<h1 id="构建二级菜单"><a href="#构建二级菜单" class="headerlink" title="构建二级菜单"></a>构建二级菜单</h1><p>在NewGameMenu中合理设置按钮和文本布局</p>
<p>为确保仅在文本框非空白时启用按钮，可将文本框中的文本转换为字符串，然后检查其长度是否大于零。以下为此逻辑的显示方式：</p>
<ul>
<li>注意：哪个粉色的节点名称为”为文本”</li>
</ul>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/UMG/PlayGameButtonEnableFunction.jpg" alt="PlayGameButtonEnableFunction.png"></p>
<p>再次添加 <strong>OnClicked</strong> 事件，向新按钮添加脚本。主菜单按钮将简单重加载主菜单控件，在 <strong>ChangeMenuWidget</strong> 函数的调用中不提供新控件，开始游戏按钮将停止菜单。显示短语 <strong>选择类</strong> 而非实际类或资产的命名，可对此进行显示。</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/UMG/NewGameButtonBPs.jpg" alt="NewGameButtonBPs.png"></p>
<p>这个就根前文解释过的逻辑相同，此处不再赘述</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/09/UE4-HowTo-PlayerInput/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="williny">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Williny'home">
      <meta itemprop="description" content="孤独是人生的常态">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Williny'home">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/05/09/UE4-HowTo-PlayerInput/" class="post-title-link" itemprop="url">UE4-HowTo_PlayerInput</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-05-09 16:35:26 / 修改时间：17:23:28" itemprop="dateCreated datePublished" datetime="2022-05-09T16:35:26+08:00">2022-05-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/unreal-engine/" itemprop="url" rel="index"><span itemprop="name">unreal engine</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Fu-k-you-unreal-engine-filer"><a href="#Fu-k-you-unreal-engine-filer" class="headerlink" title="Fu*k you unreal engine filer!!!"></a>Fu*k you unreal engine filer!!!</h1><p>气死了兄弟们，官方案例《玩家输入和Pawn》里面的第一段——自定义Pawn</p>
<p>我真的是服了，上一章节是头文件名写错了，这一节干脆不写头文件名了，无语。</p>
<p>报错还奇奇怪怪的，虽然也猜到了是头文件的问题，我一开始还以为又是头文件名写错了，结果排查了半天，发现是这家伙根本没写，也是我学艺不精，竟然没有第一时间找到问题所在，总之是花费了大量时间在这个无聊的问题上！中途UE4还崩了一次！可恶啊！</p>
<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>首先这个功能其实并不难，在之前的第一人称FPS中我们已经实现了移动等功能，在此处新增的放大缩小功能，类比跳跃功能也非常好理解！</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>创建一个Actor为父类的C++类</p>
<ol>
<li><p>我们要控制这个Actor，所以我们需要将玩家默认控制设置一下</p>
</li>
<li><p>我们创建一个根组件，用来更新</p>
</li>
<li><p>然后需要创建一个可见的对象和一个摄像机</p>
</li>
<li><p>摄像机和可见组件都附加到根组件上</p>
</li>
<li><p>配置游戏输入</p>
</li>
<li><p>声明和定义游戏操作</p>
</li>
</ol>
<p>看起来一点也不难，如果理解了前面章节的内容的话，实际上也是如此。</p>
<h1 id="自定义Actor"><a href="#自定义Actor" class="headerlink" title="自定义Actor"></a>自定义Actor</h1><p>首先，最重要的是，我们在创建一个组件之前，一定要考虑清楚，需不需要额外引入头文件！比如说Camera组件！</p>
<p>官方代码运行不起来，不用管。在这里我就直接放修改好的代码了！</p>
<h2 id="MyPawn-h"><a href="#MyPawn-h" class="headerlink" title="MyPawn.h"></a>MyPawn.h</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CoreMinimal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GameFramework/Pawn.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Camera/CameraComponent.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyPawn.generated.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HOWTO_PLAYERINPUT_API</span> AMyPawn : <span class="keyword">public</span> APawn</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// Sets default values for this pawn&#x27;s properties</span></span><br><span class="line">	<span class="built_in">AMyPawn</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="comment">// Called when the game starts or when spawned</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BeginPlay</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:	</span><br><span class="line">	<span class="comment">// Called every frame</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Tick</span><span class="params">(<span class="type">float</span> DeltaTime)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Called to bind functionality to input</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SetupPlayerInputComponent</span><span class="params">(<span class="keyword">class</span> UInputComponent* PlayerInputComponent)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line">		USceneComponent* OurVisibleComponent;</span><br><span class="line">	<span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line">		UCameraComponent* OurCamera;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>.h部分主要注意的是头文件的引用</p>
<p>还有就是，声明部分一定要放在.h文件中，别学官方案例放在.cpp里面，到时候纠错都不好找地儿！</p>
<h2 id="MyPawn-cpp"><a href="#MyPawn-cpp" class="headerlink" title="MyPawn.cpp"></a>MyPawn.cpp</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyPawn.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Sets default values</span></span><br><span class="line">AMyPawn::<span class="built_in">AMyPawn</span>()</span><br><span class="line">&#123;</span><br><span class="line"> 	<span class="comment">// Set this pawn to call Tick() every frame.  You can turn this off to improve performance if you don&#x27;t need it.</span></span><br><span class="line">	PrimaryActorTick.bCanEverTick = <span class="literal">true</span>;</span><br><span class="line">	<span class="comment">// 将该Pawn设为由最小编号玩家控制</span></span><br><span class="line">	AutoPossessPlayer = EAutoReceiveInput::Player0;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 创建可附加内容的虚拟根组件。</span></span><br><span class="line">	RootComponent = <span class="built_in">CreateDefaultSubobject</span>&lt;USceneComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;RootComponent&quot;</span>));</span><br><span class="line">	<span class="comment">// 创建相机和可见对象</span></span><br><span class="line">	OurCamera = <span class="built_in">CreateDefaultSubobject</span>&lt;UCameraComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;OurCamera&quot;</span>));</span><br><span class="line">	OurVisibleComponent = <span class="built_in">CreateDefaultSubobject</span>&lt;UStaticMeshComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;OurVisibleComponent&quot;</span>));</span><br><span class="line">	<span class="comment">// 将相机和可见对象附加到根组件。偏移并旋转相机。</span></span><br><span class="line">	OurCamera-&gt;<span class="built_in">SetupAttachment</span>(RootComponent);</span><br><span class="line">	OurCamera-&gt;<span class="built_in">SetRelativeLocation</span>(<span class="built_in">FVector</span>(<span class="number">-250.0f</span>, <span class="number">0.0f</span>, <span class="number">250.0f</span>));</span><br><span class="line">	OurCamera-&gt;<span class="built_in">SetRelativeRotation</span>(<span class="built_in">FRotator</span>(<span class="number">-45.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>));</span><br><span class="line">	OurVisibleComponent-&gt;<span class="built_in">SetupAttachment</span>(RootComponent);</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Called when the game starts or when spawned</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMyPawn::BeginPlay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Super::<span class="built_in">BeginPlay</span>();</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Called every frame</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMyPawn::Tick</span><span class="params">(<span class="type">float</span> DeltaTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Super::<span class="built_in">Tick</span>(DeltaTime);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Called to bind functionality to input</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMyPawn::SetupPlayerInputComponent</span><span class="params">(UInputComponent* PlayerInputComponent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Super::<span class="built_in">SetupPlayerInputComponent</span>(PlayerInputComponent);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里很简单，和前面章节的操作基本一致，根官方案例对比起来。</p>
<p>其实就是我把OurCamera的声明放进.h文件中去了，结构看起来更清晰。</p>
<h1 id="配置游戏输入"><a href="#配置游戏输入" class="headerlink" title="配置游戏输入"></a>配置游戏输入</h1><p>这个就按照官网的来吧，没啥太多需要注意的</p>
<p>唯一注意的是，映射名称一定要能望文生义，与后面声明定义的移动，放大函数名相同。</p>
<h1 id="编写和绑定游戏操作"><a href="#编写和绑定游戏操作" class="headerlink" title="编写和绑定游戏操作"></a>编写和绑定游戏操作</h1><p>这个步骤无非就是，先声明及定义函数，然后再将函数在<code>AMyPawn::SetupPlayerInputComponent</code>中用<code>BindAction</code>和<code>BindAxis</code>进行绑定</p>
<p>最后在<code>AMyPawn::Tick</code>实时更新放大缩小的效果以及移动</p>
<h2 id="编写函数"><a href="#编写函数" class="headerlink" title="编写函数"></a>编写函数</h2><p>首先在.h文件中声明函数和变量</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输入函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Move_XAxis</span><span class="params">(<span class="type">float</span> AxisValue)</span></span>;<span class="comment">//前进后退</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Move_YAxis</span><span class="params">(<span class="type">float</span> AxisValue)</span></span>;<span class="comment">//左右移动</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">StartGrowing</span><span class="params">()</span></span>;<span class="comment">//开始变大</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">StopGrowing</span><span class="params">()</span></span>;<span class="comment">//停止变大</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//输入变量</span></span><br><span class="line">    FVector CurrentVelocity;<span class="comment">//当前速度</span></span><br><span class="line">    <span class="type">bool</span> bGrowing;<span class="comment">//是否变大</span></span><br></pre></td></tr></table></figure>



<p>然后在.cpp文件中定义函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMyPawn::Move_XAxis</span><span class="params">(<span class="type">float</span> AxisValue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 以100单位/秒的速度向前或向后移动</span></span><br><span class="line">    CurrentVelocity.X = FMath::<span class="built_in">Clamp</span>(AxisValue, <span class="number">-1.0f</span>, <span class="number">1.0f</span>) * <span class="number">100.0f</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMyPawn::Move_YAxis</span><span class="params">(<span class="type">float</span> AxisValue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 以100单位/秒的速度向右或向左移动</span></span><br><span class="line">    CurrentVelocity.Y = FMath::<span class="built_in">Clamp</span>(AxisValue, <span class="number">-1.0f</span>, <span class="number">1.0f</span>) * <span class="number">100.0f</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMyPawn::StartGrowing</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bGrowing = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMyPawn::StopGrowing</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bGrowing = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里实现Actor移动的方式还挺别致的，是创建一个FVector来实现移动的，同时我们也可以采取另一种思路来实现移动</p>
<p>以下是第一人称FPS案例中实现移动的方法：</p>
<ul>
<li><p>首先获取玩家方向</p>
</li>
<li><p>然后调用AddMovementInput来进行移动</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::MoveForward</span><span class="params">(<span class="type">float</span> Value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 找出&quot;前进&quot;方向，并记录玩家想向该方向移动。</span></span><br><span class="line">    FVector Direction = <span class="built_in">FRotationMatrix</span>(Controller-&gt;<span class="built_in">GetControlRotation</span>()).<span class="built_in">GetScaledAxis</span>(EAxis::X);</span><br><span class="line">    <span class="built_in">AddMovementInput</span>(Direction, Value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::MoveRight</span><span class="params">(<span class="type">float</span> Value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 找出&quot;右侧&quot;方向，并记录玩家想向该方向移动。</span></span><br><span class="line">    FVector Direction = <span class="built_in">FRotationMatrix</span>(Controller-&gt;<span class="built_in">GetControlRotation</span>()).<span class="built_in">GetScaledAxis</span>(EAxis::Y);</span><br><span class="line">    <span class="built_in">AddMovementInput</span>(Direction, Value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>接下来在<strong>AMyPawn::SetupPlayerInputComponent</strong> 中绑定映射</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在按下或松开&quot;Grow&quot;键时做出响应。</span></span><br><span class="line">InputComponent-&gt;<span class="built_in">BindAction</span>(<span class="string">&quot;Grow&quot;</span>, IE_Pressed, <span class="keyword">this</span>, &amp;AMyPawn::StartGrowing);</span><br><span class="line">InputComponent-&gt;<span class="built_in">BindAction</span>(<span class="string">&quot;Grow&quot;</span>, IE_Released, <span class="keyword">this</span>, &amp;AMyPawn::StopGrowing);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对两个移动轴&quot;MoveX&quot;和&quot;MoveY&quot;的值逐帧反应。</span></span><br><span class="line">InputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="string">&quot;MoveX&quot;</span>, <span class="keyword">this</span>, &amp;AMyPawn::Move_XAxis);</span><br><span class="line">InputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="string">&quot;MoveY&quot;</span>, <span class="keyword">this</span>, &amp;AMyPawn::Move_YAxis);</span><br></pre></td></tr></table></figure>

<p>最后在<strong>AMyPawn::Tick</strong>中实时更新Actor的大小和移动</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据&quot;Grow&quot;操作处理增长和缩减</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> CurrentScale = OurVisibleComponent-&gt;<span class="built_in">GetComponentScale</span>().X;</span><br><span class="line">    <span class="keyword">if</span> (bGrowing)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 一秒内增长到两倍大小</span></span><br><span class="line">        CurrentScale += DeltaTime;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 以增长速度缩减一半</span></span><br><span class="line">        CurrentScale -= (DeltaTime * <span class="number">0.5f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 确保不会降至初始大小以下，或者增至两倍大小以上。</span></span><br><span class="line">    CurrentScale = FMath::<span class="built_in">Clamp</span>(CurrentScale, <span class="number">1.0f</span>, <span class="number">2.0f</span>);</span><br><span class="line">    OurVisibleComponent-&gt;<span class="built_in">SetWorldScale3D</span>(<span class="built_in">FVector</span>(CurrentScale));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据&quot;MoveX&quot;和&quot;MoveY&quot;轴处理移动</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!CurrentVelocity.<span class="built_in">IsZero</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        FVector NewLocation = <span class="built_in">GetActorLocation</span>() + (CurrentVelocity * DeltaTime);</span><br><span class="line">        <span class="built_in">SetActorLocation</span>(NewLocation);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/06/UE4-%E8%93%9D%E5%9B%BE-%E9%92%A5%E5%8C%99%E5%BC%80%E9%97%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="williny">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Williny'home">
      <meta itemprop="description" content="孤独是人生的常态">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Williny'home">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/05/06/UE4-%E8%93%9D%E5%9B%BE-%E9%92%A5%E5%8C%99%E5%BC%80%E9%97%A8/" class="post-title-link" itemprop="url">UE4-蓝图-钥匙开门</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-05-06 14:20:27 / 修改时间：15:16:59" itemprop="dateCreated datePublished" datetime="2022-05-06T14:20:27+08:00">2022-05-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/unreal-engine/" itemprop="url" rel="index"><span itemprop="name">unreal engine</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>这一节是根据<a target="_blank" rel="noopener" href="https://space.bilibili.com/31898841">谌嘉诚</a>的蓝图教程进行整理的！</p>
<p>在前面我们制作了自动门，按键开门这两种门，其实还有升降电梯等案例，但是其实与开门的蓝图类差不太多，顶多就是修改一下更新的不是按轴旋转，而是直接更改相对位置了。</p>
<p>接下来的是拾取钥匙开门，这涉及到了蓝图Actor之间的通信</p>
<h1 id="门蓝图"><a href="#门蓝图" class="headerlink" title="门蓝图"></a>门蓝图</h1><p>主体蓝图部分和开门没有区别，唯一需要修改的地方是</p>
<ul>
<li><p>创建一个bool类型变量，命名为IsKey，默认设置为false</p>
</li>
<li><p>沿着IsKey拖出一条引线，创建一个名为”分支”的结点</p>
</li>
<li><p>将键盘E拖出一个结点，连接上分支结点</p>
</li>
<li><p>True输出链接Gate的Open</p>
</li>
<li><p>False输出链接一个“打印字符串”节点</p>
</li>
</ul>
<h1 id="钥匙蓝图"><a href="#钥匙蓝图" class="headerlink" title="钥匙蓝图"></a>钥匙蓝图</h1><p>前部分的蓝图与普通门蓝图一致，需要注意的是Gate之后的节点</p>
<ul>
<li><p>Gate输出创建一个“获取类的所有Actor”节点，顾名思义，可以选择一个类，获取其下所有的actor</p>
</li>
<li><p>在Actor Class选项中选择BP_KeyDoor（门的类名）</p>
</li>
<li><p>Out Actor输出创建一个Get（复制）节点【获取数组中下标为i的元素】</p>
</li>
<li><p>接着从Get节点输出一个Set IsKey节点，在这个节点内就可改变IsKey的值</p>
</li>
<li><p>将获取类的所有actor输出与set节点的输入连接上</p>
</li>
<li><p>最后我们需要销毁钥匙，于是在set输出链接一个“销毁Actor”节点</p>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/06/UE4-Player-Controlled-Cameras/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="williny">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Williny'home">
      <meta itemprop="description" content="孤独是人生的常态">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Williny'home">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/05/06/UE4-Player-Controlled-Cameras/" class="post-title-link" itemprop="url">UE4-Player-Controlled Cameras</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-05-06 09:31:10 / 修改时间：11:13:24" itemprop="dateCreated datePublished" datetime="2022-05-06T09:31:10+08:00">2022-05-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/unreal-engine/" itemprop="url" rel="index"><span itemprop="name">unreal engine</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>今天是官方案例<a href="(https://docs.unrealengine.com/4.27/zh-CN/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/PlayerCamera/">Player-Controlled Cameras</a></p>
<h1 id="给我整无语了"><a href="#给我整无语了" class="headerlink" title="给我整无语了"></a>给我整无语了</h1><p>我现在使用的是4.27的版本文档，我是真的服了官方写这个文档的家伙了，咱作为萌新吧，看这玩意，学习顺序安排得不合理就算了，很多项目拿着官方给出的代码都运行不出来，真的是太无语了。</p>
<p>这一节最明显的一个错误——<code># include &quot;Camera/Component.h&quot;</code>根本没这个头文件啊！兄弟！真的无语了，头文件都打错了，原本的头文件名为<code># include &quot;Camera/CameraComponent.h&quot;</code>!</p>
<p>可恶！负责官方文档编写的人得扣工资，你说这种问题，是一个正常程序员能犯得错误嘛？</p>
<p>tnnd，跟我玩阴的是吧？你爹我是来学习的还是来给你纠错的？f**k u！</p>
<p>除了以上错误，还有别的我没发现的，我估摸着可能是头文件的问题，但是也懒得找了。</p>
<p>我就单分析代码实现当中的API和一些实现逻辑好了。</p>
<h1 id="摄像机连接到Pawn"><a href="#摄像机连接到Pawn" class="headerlink" title="摄像机连接到Pawn"></a>摄像机连接到Pawn</h1><p>直接上代码</p>
<h2 id="PawnWithCamera-h"><a href="#PawnWithCamera-h" class="headerlink" title="PawnWithCamera.h"></a>PawnWithCamera.h</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CoreMinimal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GameFramework/Pawn.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;PawnWithCamera.generated.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HOWTO_PLAYERCAMERA_API</span> APawnWithCamera : <span class="keyword">public</span> APawn</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 为Pawn的属性设置默认值</span></span><br><span class="line">    <span class="built_in">APawnWithCamera</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// 游戏开始时或对象生成时调用</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BeginPlay</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 每帧调用</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Tick</span><span class="params">( <span class="type">float</span> DeltaSeconds )</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于绑定功能和输入</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SetupPlayerInputComponent</span><span class="params">(<span class="keyword">class</span> UInputComponent* InputComponent)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">USpringArmComponent</span>* SpringArmComp;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">UCameraComponent</span>* CameraComp;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line">    UStaticMeshComponent* StaticMeshComp;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>头文件的变化仅在于声明了弹簧臂组件类和摄像机组件类以及一个静态网格体组件</p>
<h2 id="PawnWithCamera-cpp"><a href="#PawnWithCamera-cpp" class="headerlink" title="PawnWithCamera.cpp"></a>PawnWithCamera.cpp</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;HowTo_PlayerCamera.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;PawnWithCamera.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GameFramework/SpringArmComponent.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Camera/CameraComponent.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置默认值</span></span><br><span class="line">APawnWithCamera::<span class="built_in">APawnWithCamera</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 让这个Pawn每帧调用Tick()。如不需要，你可以关闭这个函数以便提升性能。</span></span><br><span class="line">    PrimaryActorTick.bCanEverTick = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建组件</span></span><br><span class="line">    RootComponent = <span class="built_in">CreateDefaultSubobject</span>&lt;USceneComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;RootSceneComponent&quot;</span>));</span><br><span class="line">    StaticMeshComp = CreateDefaultSubobject &lt;UStaticMeshComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;StaticMeshComponent&quot;</span>));</span><br><span class="line">    SpringArmComp = <span class="built_in">CreateDefaultSubobject</span>&lt;USpringArmComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;SpringArmComponent&quot;</span>));</span><br><span class="line">    CameraComp = <span class="built_in">CreateDefaultSubobject</span>&lt;UCameraComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;CameraComponent&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定组件</span></span><br><span class="line">    StaticMeshComp-&gt;<span class="built_in">SetupAttachment</span>(RootComponent);</span><br><span class="line">    SpringArmComp-&gt;<span class="built_in">SetupAttachment</span>(StaticMeshComp);</span><br><span class="line">    CameraComp-&gt;<span class="built_in">SetupAttachment</span>(SpringArmComp,USpringArmComponent::SocketName);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为SpringArm类的变量赋值</span></span><br><span class="line">    SpringArmComp-&gt;<span class="built_in">SetRelativeLocationAndRotation</span>(<span class="built_in">FVector</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">50.0f</span>), <span class="built_in">FRotator</span>(<span class="number">-60.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>));</span><br><span class="line">    SpringArmComp-&gt;TargetArmLength = <span class="number">400.f</span>;</span><br><span class="line">    SpringArmComp-&gt;bEnableCameraLag = <span class="literal">true</span>;</span><br><span class="line">    SpringArmComp-&gt;CameraLagSpeed = <span class="number">3.0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 控制默认玩家</span></span><br><span class="line">    AutoPossessPlayer = EAutoReceiveInput::Player0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 游戏开始时或对象生成时调用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">APawnWithCamera::BeginPlay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">BeginPlay</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每帧调用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">APawnWithCamera::Tick</span><span class="params">( <span class="type">float</span> DeltaTime )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">Tick</span>( DeltaTime );</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于绑定功能和输入</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">APawnWithCamera::SetupPlayerInputComponent</span><span class="params">(<span class="keyword">class</span> UInputComponent* InputComponent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">SetupPlayerInputComponent</span>(InputComponent);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="首先创建组件"><a href="#首先创建组件" class="headerlink" title="首先创建组件"></a>首先创建组件</h3><ul>
<li>根组件，静态网格体组件，弹簧臂组件，摄像机组件</li>
</ul>
<h3 id="然后绑定组件"><a href="#然后绑定组件" class="headerlink" title="然后绑定组件"></a>然后绑定组件</h3><ul>
<li><p>将静态网格体组件绑定在根组件之下，保证更新的是静态网格体</p>
</li>
<li><p>将弹簧臂组件绑定在静态网格体之下</p>
</li>
<li><p>再将摄像机插入弹簧臂的插槽上</p>
</li>
</ul>
<h3 id="接下来设置弹簧臂类的变量值"><a href="#接下来设置弹簧臂类的变量值" class="headerlink" title="接下来设置弹簧臂类的变量值"></a>接下来设置弹簧臂类的变量值</h3><ul>
<li><p>首先设置相对位置和角度</p>
</li>
<li><p>弹簧臂长度</p>
</li>
<li><p>启用弹簧臂平滑切换</p>
</li>
<li><p>设置平滑切换时间</p>
</li>
</ul>
<h3 id="最后是将默认玩家设置一下"><a href="#最后是将默认玩家设置一下" class="headerlink" title="最后是将默认玩家设置一下"></a>最后是将默认玩家设置一下</h3><p>单人的话，默认玩家编号为Player0</p>
<h1 id="定义输入函数和绑定操作"><a href="#定义输入函数和绑定操作" class="headerlink" title="定义输入函数和绑定操作"></a>定义输入函数和绑定操作</h1><p>前面的配置输入我就不讲了，之前的博客里面讲的很详细，或者去官网看看也可以，基本上没啥错误。这里直接过一下绑定输入操作。</p>
<h2 id="声明成员变量和成员函数"><a href="#声明成员变量和成员函数" class="headerlink" title="声明成员变量和成员函数"></a>声明成员变量和成员函数</h2><p>首先我们需要定义一些成员变量来存储接收到的输入数据</p>
<ul>
<li><p>在帧更新的时候，我们需要获取移动数据和鼠标轴的移动方向数据，这都是二维向量类型的数值</p>
</li>
<li><p>还有摄像机画面是要放大还是缩小，以及摄像机当前状态距离到达这两种状态还有多少距离</p>
</li>
</ul>
<p>所以我们在.h文件的protected:下定义以下代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输入变量</span></span><br><span class="line">FVector2D MovementInput;<span class="comment">//移动数据</span></span><br><span class="line">FVector2D CameraInput;<span class="comment">//鼠标轴的移动方向数据</span></span><br><span class="line"><span class="type">float</span> ZoomFactor;<span class="comment">//距离放大缩小还有多远</span></span><br><span class="line"><span class="type">bool</span> bZoomingIn;<span class="comment">//放大还是缩小</span></span><br></pre></td></tr></table></figure>



<p>还需要创建函数来跟踪输入，所以我们在.h中声明以下函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输入函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MoveForward</span><span class="params">(<span class="type">float</span> AxisValue)</span></span>;<span class="comment">//前后移动</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MoveRight</span><span class="params">(<span class="type">float</span> AxisValue)</span></span>;<span class="comment">//左右移动</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PitchCamera</span><span class="params">(<span class="type">float</span> AxisValue)</span></span>;<span class="comment">//绕Y轴旋转（上下颠簸）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">YawCamera</span><span class="params">(<span class="type">float</span> AxisValue)</span></span>;<span class="comment">//绕Z轴旋转（左右拐弯）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ZoomIn</span><span class="params">()</span></span>;<span class="comment">//放大</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ZoomOut</span><span class="params">()</span></span>;<span class="comment">//缩小</span></span><br></pre></td></tr></table></figure>



<p>1 Roll 是自身旋转<br>2 Yaw 是左右拐弯<br>3 pitch 是上下颠动</p>
<h2 id="定义成员函数"><a href="#定义成员函数" class="headerlink" title="定义成员函数"></a>定义成员函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输入函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">APawnWithCamera::MoveForward</span><span class="params">(<span class="type">float</span> AxisValue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MovementInput.X = FMath::<span class="built_in">Clamp</span>&lt;<span class="type">float</span>&gt;(AxisValue, <span class="number">-1.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">APawnWithCamera::MoveRight</span><span class="params">(<span class="type">float</span> AxisValue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MovementInput.Y = FMath::<span class="built_in">Clamp</span>&lt;<span class="type">float</span>&gt;(AxisValue, <span class="number">-1.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">APawnWithCamera::PitchCamera</span><span class="params">(<span class="type">float</span> AxisValue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CameraInput.Y = AxisValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">APawnWithCamera::YawCamera</span><span class="params">(<span class="type">float</span> AxisValue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CameraInput.X = AxisValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">APawnWithCamera::ZoomIn</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bZoomingIn = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">APawnWithCamera::ZoomOut</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bZoomingIn = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>值得一提的是<code>Clamp&lt;float&gt;(AxisValue, -1.0f, 1.0f);</code>在前面的章节中我讲得不清楚，现在终于弄明白了！</p>
<p>&lt;&gt;内是参数类型，</p>
<p><code>Clamp(const FVector4 &amp; VectorToClamp, float Min, float Max)</code>是其函数原型</p>
<ul>
<li><p>这个Clamp其实看作是一种运算，可以把它看成一个一元一次方程</p>
</li>
<li><p>VectorToClamp就是这个方程的X，最后得出的Y</p>
</li>
<li><p>MIN 和MAX是设定的最大值和最小值</p>
</li>
<li><p>Y一定在MIN和MAX之间</p>
</li>
</ul>
<h2 id="绑定轴映射事件和按键映射事件"><a href="#绑定轴映射事件和按键映射事件" class="headerlink" title="绑定轴映射事件和按键映射事件"></a>绑定轴映射事件和按键映射事件</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 绑定&quot;ZoomIn&quot;的事件</span></span><br><span class="line">InputComponent-&gt;<span class="built_in">BindAction</span>(<span class="string">&quot;ZoomIn&quot;</span>, IE_Pressed, <span class="keyword">this</span>, &amp;APawnWithCamera::ZoomIn);</span><br><span class="line">InputComponent-&gt;<span class="built_in">BindAction</span>(<span class="string">&quot;ZoomIn&quot;</span>, IE_Released, <span class="keyword">this</span>, &amp;APawnWithCamera::ZoomOut);</span><br><span class="line"></span><br><span class="line"><span class="comment">//为四条轴绑定事件（每帧调用）</span></span><br><span class="line">InputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="string">&quot;MoveForward&quot;</span>, <span class="keyword">this</span>, &amp;APawnWithCamera::MoveForward);</span><br><span class="line">InputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="string">&quot;MoveRight&quot;</span>, <span class="keyword">this</span>, &amp;APawnWithCamera::MoveRight);</span><br><span class="line">InputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="string">&quot;CameraPitch&quot;</span>, <span class="keyword">this</span>, &amp;APawnWithCamera::PitchCamera);</span><br><span class="line">InputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="string">&quot;CameraYaw&quot;</span>, <span class="keyword">this</span>, &amp;APawnWithCamera::YawCamera);</span><br></pre></td></tr></table></figure>

<p>这个在之前博客里已经讲得很详细了，就不再赘述。</p>
<h2 id="在Tick事件内绑定放大缩小"><a href="#在Tick事件内绑定放大缩小" class="headerlink" title="在Tick事件内绑定放大缩小"></a>在Tick事件内绑定放大缩小</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">APawnWithCamera::Tick</span><span class="params">( <span class="type">float</span> DeltaTime )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">Tick</span>(DeltaTime);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按下ZoomIn按钮时进行放大，否则恢复正常</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (bZoomingIn)<span class="comment">//按下按钮事件</span></span><br><span class="line">        &#123;</span><br><span class="line">            ZoomFactor += DeltaTime / <span class="number">0.5f</span>;<span class="comment">//放大0.5秒以上</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//松开按钮事件</span></span><br><span class="line">        &#123;</span><br><span class="line">            ZoomFactor -= DeltaTime / <span class="number">0.25f</span>;<span class="comment">//缩小0.25秒以上</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        ZoomFactor = FMath::<span class="built_in">Clamp</span>&lt;<span class="type">float</span>&gt;(ZoomFactor, <span class="number">0.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">        <span class="comment">// 基于ZoomFactor设置摄像机的视野（范围）和SpringArm的长度 （范围）</span></span><br><span class="line">        CameraComp-&gt;FieldOfView = FMath::<span class="built_in">Lerp</span>&lt;<span class="type">float</span>&gt;(<span class="number">90.0f</span>, <span class="number">60.0f</span>, ZoomFactor);</span><br><span class="line">        SpringArmComp-&gt;TargetArmLength = FMath::<span class="built_in">Lerp</span>&lt;<span class="type">float</span>&gt;(<span class="number">400.0f</span>, <span class="number">300.0f</span>, ZoomFactor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 旋转Actor的偏转角度，由于摄像机与Actor相互绑定，因此摄像机也会偏转</span></span><br><span class="line">    &#123;</span><br><span class="line">        FRotator NewRotation = <span class="built_in">GetActorRotation</span>();</span><br><span class="line">        NewRotation.Yaw += CameraInput.X;</span><br><span class="line">        <span class="built_in">SetActorRotation</span>(NewRotation);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 旋转摄像机的俯仰角度，但对其进行限制，确保我们始终朝下看</span></span><br><span class="line">    &#123;</span><br><span class="line">        FRotator NewRotation = SpringArmComp-&gt;<span class="built_in">GetComponentRotation</span>();</span><br><span class="line">        NewRotation.Pitch = FMath::<span class="built_in">Clamp</span>(NewRotation.Pitch + CameraInput.Y, <span class="number">-80.0f</span>, <span class="number">-15.0f</span>);</span><br><span class="line">        SpringArmComp-&gt;<span class="built_in">SetWorldRotation</span>(NewRotation);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据&quot;MoveX&quot;和&quot;MoveY&quot;的处理移动</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!MovementInput.<span class="built_in">IsZero</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//把移动轴的输入数值放大100倍</span></span><br><span class="line">            MovementInput = MovementInput.<span class="built_in">SafeNormal</span>() * <span class="number">100.0f</span>;</span><br><span class="line">            FVector NewLocation = <span class="built_in">GetActorLocation</span>();</span><br><span class="line">            NewLocation += <span class="built_in">GetActorForwardVector</span>() * MovementInput.X * DeltaTime;</span><br><span class="line">            NewLocation += <span class="built_in">GetActorRightVector</span>() * MovementInput.Y * DeltaTime;</span><br><span class="line">            <span class="built_in">SetActorLocation</span>(NewLocation);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Lerp<float>(MAX,MIN,float Alpha)</p>
<p>Alpha在通过Lerp运算后，得到的结果在MAX和MIN之间</p>
<h3 id="代码逻辑"><a href="#代码逻辑" class="headerlink" title="代码逻辑"></a>代码逻辑</h3><ul>
<li><p>首先我们根据按钮的按下或者松开来对ZoomFactor这个变量进行增加或者减小</p>
</li>
<li><p>然后根据ZoomFactor带入到Clamp来保证其值大于0，小于1</p>
</li>
<li><p>接下来将ZoomFactor带入到Lerp中设置摄像机的视野和弹簧臂的长度（均设置范围）</p>
</li>
<li><p>直接设置Actor的旋转角度，因为摄像机与其绑定，所以会连带着摄像机一同旋转</p>
</li>
<li><p>限定弹簧臂的俯仰角度，确保我们对其一直是俯视状态</p>
<ul>
<li>注意：设置弹簧臂的旋转角度的时候一定要是世界坐标内的旋转角度</li>
</ul>
</li>
<li><p>再就是设置X与Y轴的移动变化</p>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/6/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/8/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">williny</span>
</div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  





</body>
</html>
