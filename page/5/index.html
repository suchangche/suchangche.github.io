<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.1.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.0.0/css/all.min.css" integrity="sha256-jTIdiMuX/e3DGJUGwl3pKSxuc6YOuqtJYkM0bGQESA4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.10.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="孤独是人生的常态">
<meta property="og:type" content="website">
<meta property="og:title" content="Williny&#39;home">
<meta property="og:url" content="http://example.com/page/5/index.html">
<meta property="og:site_name" content="Williny&#39;home">
<meta property="og:description" content="孤独是人生的常态">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="williny">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/5/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/5/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Williny'home</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Williny'home</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="williny"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">williny</p>
  <div class="site-description" itemprop="description">孤独是人生的常态</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">172</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/suchangche" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;suchangche" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:469478061@qq.com" title="E-Mail → mailto:469478061@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/06/UE4-C-%E6%A1%86%E6%9E%B6%E6%A2%B3%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="williny">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Williny'home">
      <meta itemprop="description" content="孤独是人生的常态">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Williny'home">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/10/06/UE4-C-%E6%A1%86%E6%9E%B6%E6%A2%B3%E7%90%86/" class="post-title-link" itemprop="url">UE4-C++-框架梳理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-10-06 14:30:44 / 修改时间：14:41:59" itemprop="dateCreated datePublished" datetime="2022-10-06T14:30:44+08:00">2022-10-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/unreal-engine/" itemprop="url" rel="index"><span itemprop="name">unreal engine</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>UE 网络同步和框架</p>
<p>为一个UE引擎的初学者基于现有知识储备和见识的限制下，对UE网络和游戏框架的粗鄙之见，文中多有错误敬请指出以较后文。</p>
<h3 id="1-网络复制"><a href="#1-网络复制" class="headerlink" title="1.网络复制"></a>1.网络复制</h3><p>​ <strong>不论是服务端还是客户端，代码都是一样的，客户端和服务端拥有相同的变量和函数，只是有的函数可能只在服务端执行，有的变量可能只在某个客户端发生变化。</strong></p>
<p>​ 在多人网络游戏中，可以看到来自不同的玩家在同一个场UE 网络同步和框架</p>
<p>为一个UE引擎的初学者基于现有知识储备和见识的限制下，对UE网络和游戏框架的粗鄙之见，文中多有错误敬请指出以较后文。</p>
<h3 id="1-网络复制-1"><a href="#1-网络复制-1" class="headerlink" title="1.网络复制"></a>1.网络复制</h3><p>​ <strong>不论是服务端还是客户端，代码都是一样的，客户端和服务端拥有相同的变量和函数，只是有的函数可能只在服务端执行，有的变量可能只在某个客户端发生变化。</strong></p>
<p>​ 在多人网络游戏中，可以看到来自不同的玩家在同一个场景中，操作各自的武器或者道具，在游戏场景中进行各种交互。那么这里产生了一个问题，举例即，玩家A对玩家B使用了一个增益道具，玩家B是怎么知道自己获得了增益，并且让所有的玩家都知道自己获得了增益效果。这个问题的答案即在UE中非常重要的概念，网络复制。</p>
<h4 id="1-Replication（复制）"><a href="#1-Replication（复制）" class="headerlink" title="1.Replication（复制）"></a>1.Replication（复制）</h4><p>笼统的说，表示信息从服务端同步到客户端(单向),<strong>Actor及其派生类才有Replication的能力。</strong>一般分三种</p>
<h5 id="1-Actor-Replication-Actor复制"><a href="#1-Actor-Replication-Actor复制" class="headerlink" title="1.Actor Replication(Actor复制)"></a>1.Actor Replication(Actor复制)</h5><p>服务端生成，客户端也会跟着生成（在服务端生成一个Replicate对象）</p>
<p><strong>是当前Actor的所有属性复制，组件复制,RPC的总开关</strong></p>
<p>举上面的例子来说，如果在服务端生成了一个道具，但是这个道具并未开启或标记为Replication，那么这个道具只会出现在服务端的游戏场景里，而不会在客户端的游戏场景里生成，</p>
<p>具体用法：</p>
<p>蓝图：Actor细节面板中寻找复制相关的选项并勾选<strong>复制</strong>(Replicate)这一个选项即可，其他选项按需勾选</p>
<p><img src="/UE4-C-%E6%A1%86%E6%9E%B6%E6%A2%B3%E7%90%86%5Cimage-20221004175454361.png" alt="image20221004175454361"></p>
<p>C++：在类的<strong>构造函数</strong>中添加</p>
<p><code>bReplicates = true;//开启网络复制</code></p>
<p>注意编译后若<strong>没有达到预期效果可以回到蓝图检查</strong>一下，C++中的设置仅相当于设置了默认项，有时候蓝图不一定使用C++中的默认值，需要查看并手动设置</p>
<p>需要<strong>注意</strong>的是：</p>
<p>若一个Actor没开启网络复制，那么物体只会在服务端生成，不会在客户端生成，此时客户端的角色或其他物体，如果企图穿越该Actor的位置(尽管在客户端上看不到也真的压根不存在这个东西)，则会发现移动被阻挡并发生鬼畜效果。这是因为在联机游戏中，物体的<strong>移动是在服务端上计算的</strong>，这是为了防止客户端作弊。试想，若是客户端有权限决定游戏的每一个属性值，那么只需要一个简单的CE修改器就能修改游戏内存，并称霸整个游戏服务器。因此，需要一个权威服务器(Authority)进行所有敏感信息的计算和验证,此时客户端上不存在该物体，而服务端上认为有，因此客户端上的角色在穿越该区域的时候，服务端认为客户端正在穿越一个被阻挡的区域，从而不断发出信息纠正客户端角色的位置，这时客户端上的角色，就会发现自己前进一小段距离后，立马瞬移一小段距离回去，一直按前进键就会导致鬼畜，这是被服务端的纠错影响的结果。</p>
<p>参考视频：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Up4y1x7KU">https://www.bilibili.com/video/BV1Up4y1x7KU</a></p>
<h5 id="2-Property-Replication-属性复制"><a href="#2-Property-Replication-属性复制" class="headerlink" title="2.Property Replication(属性复制)"></a>2.Property Replication(属性复制)</h5><p>某个具体属性的网络复制，比如玩家的血量，某个道具的数量等。举一个例子，服务端和客户端A上的玩家初始生命值都是100，这时服务端玩家拾取到了一个群体增益效果所有人加生命值100，若此时未开启生命值的属性复制，产生的结果是，仅服务端玩家的生命值增加了100，而客户端玩家的生命值未发生变化，这是因为服务端没能向客户端同步这个属性的信息。</p>
<p>这里产生一个问题，前面提到过可以将类作为一个整体进行网络复制，为什么还要单独设置属性赋值呢，直接将整个类复制岂不是更方便。这是因为在多人游戏中，<strong>网络传输信息会产生延迟</strong>，大量的信息传输容易更导致网络拥堵，同时在虚幻中<strong>网络信息传输拥有优先级</strong>，像被标记为<strong>Reliable的函数</strong>传输的优先级就会比被标记为<strong>Unreliable的函数</strong>更高(后面会说)，在网络状况不好的情况下，服务端会确保更重要的信息率先发出，不那么重要的信息丢了就丢了，比如子弹的命中通知就比特效的播放通知更重要优先级更高。因此属性复制时经常使用并且重要的。</p>
<p>具体用法：</p>
<p>蓝图：</p>
<p>在蓝图中选择一个属性变量并寻找replication并选择为Replicated</p>
<p><img src="/UE4-C-%E6%A1%86%E6%9E%B6%E6%A2%B3%E7%90%86%5Cimage-20221004210425968.png" alt="image20221004210425968"></p>
<p>C++：</p>
<p>记得先在类的构造里面把bReplicate&#x3D;true这个总开关开了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UPROPERTY</span>(Replicated)<span class="comment">//使用属性网络复制，需要使用GetLifetimeReplicatedProps进行注册</span></span><br><span class="line"><span class="type">bool</span> bAiming;<span class="comment">//武器是否要瞄准</span></span><br></pre></td></tr></table></figure>

<p>首先在头文件中声明要使用网络复制的变量，比如这里设置一个武器是否瞄准的变量，并在上面添加UPROPERTY(Replicated)宏。随后在cpp文件中重写GetLifetimeReplicatedProps函数进行属性注册，函数格式如下。</p>
<p>.h文件中</p>
<p><code>virtual void GetLifetimeReplicatedProps(TArray&lt;FLifetimeProperty&gt;&amp; OutLifetimeProps) const override;</code></p>
<p><code>//使用属性网络复制，需要使用此函数进行注册</code></p>
<p>.cpp文件中需要添加头文件#include”Net&#x2F;UnrealNetwork.h”</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UCombatComponent::GetLifetimeReplicatedProps</span><span class="params">(TArray&lt;FLifetimeProperty&gt;&amp; OutLifetimeProps)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    Super::<span class="built_in">GetLifetimeReplicatedProps</span>(OutLifetimeProps);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">DOREPLIFETIME</span>(UCombatComponent, bAiming);<span class="comment">//注册CombatComponent类中声明的bool类型的bAiming变量，即类名称和变量名</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样来设置属性复制</p>
<p>参考视频：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1tf4y1k7xc/">https://www.bilibili.com/video/BV1tf4y1k7xc/</a></p>
<h5 id="3-RepNotify-复制通知"><a href="#3-RepNotify-复制通知" class="headerlink" title="3.RepNotify(复制通知)"></a>3.RepNotify(复制通知)</h5><p>如果一个变量被设置为Rep_Notify，当改变量发生改变时自动响应，这时服务端和收到该值的客户端都可以自动触发一个自定义的函数，用于通知某个事件的发生。C++的版本略有区别，仅在客户端调用函数，服务端的通知需要手动写一个函数来通知。</p>
<p>蓝图不会没用过</p>
<p>C++：</p>
<p>记得先在类的构造里面把bReplicate&#x3D;true这个总开关开了</p>
<p>.h中声明</p>
<p><code>UPROPERTY(Replicated, ReplicatedUsing = OnRep_EquippedWeapon)//使用属性网络复制，需要使用GetLifetimeReplicatedProps进行注册</code></p>
<p>ReplicatedUsing后面跟要调用的自定义函数，一般用OnRep_作为格式的开头，而后书写自定义函数的声明</p>
<p><code>UFUNCTION() void OnRep_EquippedWeapon();//装备武器的Rep_Notify</code></p>
<p>同时.cpp中也要加入GetLifetimeReplicatedProps()</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void UCombatComponent::GetLifetimeReplicatedProps(TArray&lt;FLifetimeProperty&gt;&amp; OutLifetimeProps) const</span><br><span class="line">&#123;</span><br><span class="line">Super::GetLifetimeReplicatedProps(OutLifetimeProps);</span><br><span class="line">DOREPLIFETIME(UCombatComponent, EquippedWeapon);//注册</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>视频参考：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1ht4y1z79w">https://www.bilibili.com/video/BV1ht4y1z79w</a></p>
<h4 id="2-OnwerShip-所有权"><a href="#2-OnwerShip-所有权" class="headerlink" title="2.OnwerShip(所有权)"></a>2.OnwerShip(所有权)</h4><p>理论概念，就是说很多类或者Actor在游戏中会伴随拥有者的改变而改变自己的所有权，比如在地上的枪，纵使被设置为Replicate，无人拾取的话，那么其所有权属于世界，而不是玩家，因此这把武器的信息不会被同步到任何一个玩家身上，但是当一名玩家拾取这把武器的时候，所有权被更改到这个玩家身上，这时这把枪的信息被添加到了玩家身上，玩家多出了一把武器，这把属于这名玩家的武器在击杀敌人后，因为枪的所有权是属于玩家的，所以分数算在了玩家身上。我的枪杀了你，不是我杀了你。</p>
<p>因此玩家死亡后，武器掉落，这把武器的所有权重新回归世界，而不是任一一名玩家，直到下一个玩家的到来。</p>
<p>视频：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1T44y1k72n">https://www.bilibili.com/video/BV1T44y1k72n</a></p>
<h4 id="3-Actor-Role"><a href="#3-Actor-Role" class="headerlink" title="3.Actor Role"></a>3.Actor Role</h4><p><img src="/UE4-C-%E6%A1%86%E6%9E%B6%E6%A2%B3%E7%90%86%5C%E8%87%AA%E4%B8%BB%E6%9D%83%E5%A8%81%E6%A8%A1%E6%8B%9F.png" alt="自主权威模拟"></p>
<p>服务端拥有所有玩家的权威实例，所有的信息必须经过服务器的确认才能生效。称为Authority；</p>
<p>客户端拥有自己的自主代理和所有其他玩家的模拟代理，自主代理就是本机控制的玩家，模拟代理就是画面上其他的玩家。区别如下：</p>
<p>Autonomous Proxy自主代理拥有此玩家的控制权，键盘键盘输入的信息直接操作自主代理，之所以称作代理，是因为虽然能控制你的角色，但实际上你角色的所有信息和操作必须经过服务端的计算和确认，才能真正的生效。此处产生一个问题，经过服务端的计算和确认再生效的话，来回会使得延迟很高，为了解决这个问题，自主代理会直接根据你的输入在本地进行计算并输调用事件和产生对应的画面，而信息则发到服务端进行确认，若是结果不一致，则服务端发回信息进行纠正，若一致，自主代理这边已经执行好了，最大幅度提升了玩家的体验感。这涉及到复杂的确认关系，不在讨论范围内。<strong>客户端内除了自己剩下所有玩家的Character都是模拟代理的，所以网络不好的时候，会发现自己经常瞬移。你按下前进键的时候，服务端发送回来的位置信息没有被接收到，你向前位移了一点，这是本地自主代理做出的，但是很快本地意识到，没有接收到服务端发送回来的确认位置的信息，于是本地判断你还在原地，因此你的画面卡在了原地。注意此时服务端已经因为你之前按下的前进键而更新了你的位置信息，此时若网络恢复正常，服务端再次发送回的位置信息就和本地的不一致，因为服务端的信息具有权威性，本地的角色信息被强制更新改变，然后就发生了瞬移，不过更多的情况是闪现移坟(在你掉线的时候你已经被其他玩家杀了)，换了个躺尸体的地方而已。</strong></p>
<p>Simulated Proxy模拟代理是客户端根据服务端发送来的信息，在客户端上模拟出来的除自己外的所有玩家，你所有对其他玩家的操作，都是在对从服务端发来的信息进行的操作。即，服务器认为其他的玩家在哪在干什么，你的客户端上模拟出来的玩家就在哪在干什么。客户端内除了自己剩下所有玩家的Character都是模拟代理的。</p>
<p>Authority权威，在监听服务器模式下，服务端就是权威，服务端拥有所有玩家的权威信息，包括自己，其他客户端上所有的信息都是从权威服务端复制出去的，<strong>权威服务端上拥有所有真正的玩家实例，因此在服务端上的操作拥有最低的延迟</strong>，因为不需要找服务端确认计算是否正确是否被篡改了，所有信息以服务端为准。</p>
<h4 id="4-RPC远程过程调用-Remote-Progress-Call"><a href="#4-RPC远程过程调用-Remote-Progress-Call" class="headerlink" title="4.RPC远程过程调用(Remote Progress Call)"></a>4.RPC远程过程调用(Remote Progress Call)</h4><p>可以实现客户端调用服务端执行，也可以实现服务端调用客户端执行。因为异步，所以不可以有返回值，默认是不可靠的，若要设置为可靠，UPROPERTY里设置为Reliable，RPC一共有四种状态，<strong>未复制、NetMultiCast、Server、Client</strong></p>
<p>参考图：</p>
<p><img src="/UE4-C-%E6%A1%86%E6%9E%B6%E6%A2%B3%E7%90%86%5Cimage-20221005133737857.png" alt="image20221005133737857"></p>
<p><strong>图片解释：</strong></p>
<p>如果是从服务端调用了RPC，<strong>一般情况下</strong>，对于UPRPERTY标记为NetMulticast的，即网络多播，这个函数会在<strong>服务端和所有的客户端上都执行一次</strong>。标记为Server的，那么这个函数<strong>仅在服务端上执行</strong>。标记为Client的，则<strong>在所有的客户端上执行，但是服务端不执行</strong>。<strong>特殊情况是Actor的所有权不属于客户端，而属于服务端或者谁也不属于</strong>，这种情况结果参照上图。</p>
<p>如果是从客户端调用了RPC，<strong>所有情况下</strong>，对UPRPERTY标记为NetMulticast的，仅在本地执行。标记为Server的，会在服务器上运行，这也是唯一一种客户端调用服务端的函数的方式。标记为Client的，仅在本地执行。<strong>特殊情况是若函数要操作的Actor所有权不属于本地客户端，此时函数UPROPERTY若被标记为Server，即请求服务端执行函数调用，那么服务端会丢弃这样的请求不做处理</strong>，可参照上图。</p>
<p>实现方式：</p>
<p>蓝图：</p>
<p>CustomEvent事件的Replicates选项设置有Run On Server，Run On Owing Client，Net MultiCast中的一个。</p>
<p>C++：</p>
<p>在函数生命中添加Server、Client、Net MultiCast关键字添加到UFUNCTION声明中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">UFUNCTION(Server, Reliable)                                                                                                     void ServerFire();//仅在服务器开火 </span><br><span class="line"></span><br><span class="line">UFUNCTION(NetMulticast,  Reliable)</span><br><span class="line">void MultiCastFire();//从服务器发起的通知所有客户端开火</span><br><span class="line"></span><br><span class="line">UFUNCTION(Client,  Reliable)</span><br><span class="line">void ClientFire();//服务器发起的向客户端的多播开火</span><br></pre></td></tr></table></figure>

<p>视频：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1R34y1Q7b6">https://www.bilibili.com/video/BV1R34y1Q7b6</a></p>
<h3 id="2-监听服务器模式下的状态关系"><a href="#2-监听服务器模式下的状态关系" class="headerlink" title="2.监听服务器模式下的状态关系"></a>2.监听服务器模式下的状态关系</h3><h4 id="1-各个大类的功用介绍"><a href="#1-各个大类的功用介绍" class="headerlink" title="1.各个大类的功用介绍"></a>1.各个大类的功用介绍</h4><p>至于这些状态的功能有个举例图：</p>
<p><img src="/UE4-C-%E6%A1%86%E6%9E%B6%E6%A2%B3%E7%90%86%5C%E6%B8%B8%E6%88%8F%E6%A8%A1%E5%BC%8F%E6%B8%B8%E6%88%8F%E7%8A%B6%E6%80%81%E7%8E%A9%E5%AE%B6%E7%8A%B6%E6%80%81.png" alt="游戏模式游戏状态玩家状态"></p>
<p>还有个玩家控制器就不单独放图了。玩家控制器可以设置用户控件，比如播放比赛的消息，更新玩家血量条，更新分数，更新击杀死亡数量信息，以及更新弹药。</p>
<p>看出游戏模式类中包括了玩家控制器和用户界面类，以及游戏的具体规则和匹配状态。</p>
<h5 id="1-GameMode"><a href="#1-GameMode" class="headerlink" title="1.GameMode"></a>1.GameMode</h5><p>两个主要类负责处理进行中游戏的相关信息：<strong>Game Mode</strong> 和 <strong>Game State</strong>。游戏模式是针对当前关卡的设定，里面<strong>存储了当前关卡的规则和玩法</strong>，即使最开放的游戏也拥有基础规则，而这些规则构成了 <strong>Game Mode</strong>。比如得分达到一定数目后某方获胜，然后播放什么样的动画，调用什么样的函数进行结算，再跳转到什么地图。诸如此类。在游戏模式中设置pawn类，HUD类，玩家控制器，游戏状态和玩家状态。</p>
<h5 id="2-GameState"><a href="#2-GameState" class="headerlink" title="2.GameState"></a>2.GameState</h5><p>游戏状态类主要是<strong>当前对局的具体信息</strong>，基于规则的事件在游戏中发生，需要进行追踪并和所有玩家共享时，信息将通过 <strong>Game State</strong> 进行存储和同步。例如</p>
<ul>
<li><p>游戏已运行的时间（包括本地玩家加入前的运行时间）。</p>
</li>
<li><p>每个个体玩家加入游戏的时间和玩家的当前状态，MVP玩家的信息等</p>
</li>
<li><p>当前 Game Mode 的基类。</p>
</li>
<li><p>游戏是否已开始，正在匹配中，游戏正在结算，游戏正在热身时间等</p>
</li>
<li><p>分数领先的队伍信息，队伍的分数信息以及玩家所属的队伍信息。</p>
</li>
</ul>
<h5 id="3-PlayerController"><a href="#3-PlayerController" class="headerlink" title="3.PlayerController"></a>3.PlayerController</h5><p>玩家控制器是Actor的一种子类型，其负责控制玩家所使用的的Pawn&#x2F;Character。<strong>控制器（Controller）</strong> 是一种可以控制Pawn（或Pawn的派生类，例如角色（Character）），从而控制其动作的非实体Actor。人类玩家使用PlayerController控制Pawn，而AIController则对它们控制的Pawn实加人工智能效果。控制器用Possess函数控制Pawn，用Unpossess函数放弃控制Pawn。</p>
<p><strong>控制器会接收其控制的Pawn所发生诸多事件的通知。因此控制器可借机实现 响应此事件的行为，拦截事件并接替Pawn的默认行为。 可以让控制器在给定的Pawn之前运行， 从而从而最大限度减少输入处理与Pawn移动之间的延迟。比如把响应事件写在按键的响应上而不是用具体Pawn类去响应事件。</strong></p>
<p>默认情况下，控制器与Pawn之间存在一对一的关系；也就是说，每个控制器在任何给定的时间只控制一个Pawn。这对于大多数 类型的游戏都是可以接受的，但对于某些类型的游戏可能需要进行调整，因为实时策略可能需要能够同时控制多个实体。</p>
<h5 id="4-AIController"><a href="#4-AIController" class="headerlink" title="4.AIController"></a>4.AIController</h5><p><strong>玩家控制器（PlayerController）</strong> 主要依靠人类玩家来制定决策，而 <strong>AI控制器（AIController）</strong> 则侧重通过场景中的信息来做出响应。AI控制器的任务<strong>是观察周遭的世界，相应作出决策，无需人类玩家的控制。</strong></p>
<h5 id="5-Actor"><a href="#5-Actor" class="headerlink" title="5.Actor"></a>5.Actor</h5><p>Actor是一种可以在世界中放置的的对象，可静态可动态，比如到处走动的玩家，巡逻的敌人，可拾取的道具和金币，可移动的场景电梯、轮船，<strong>一切实物都是Actor。</strong></p>
<h5 id="5-ActorComponent"><a href="#5-ActorComponent" class="headerlink" title="5.ActorComponent"></a>5.ActorComponent</h5><p>ActorComponent是一种可复用的组件，能被附加到任意的Actor上，Actor可以将组件作为子对象附加到自身。组件适用于共享相同的行为，例如显示视觉表现、播放声音。它们还可以表示项目特有的概念，例如载具解译输入和改变其速度与方向的方式。<strong>举例而言，某个项目拥有用户可控制车辆、飞机和船只。可以通过更改载具Actor所使用的组件，来实现载具控制和移动的差异。</strong></p>
<h5 id="6-PlayerState"><a href="#6-PlayerState" class="headerlink" title="6.PlayerState"></a>6.PlayerState</h5><p>玩家状态类则是包含了<strong>具体玩家的各种信息</strong>，不仅限于分数，击杀数，弹药量和所属队伍，也可以包括技能冷却信息，天赋激活信息和道具使用信息。</p>
<h5 id="7-GameInstance"><a href="#7-GameInstance" class="headerlink" title="7.GameInstance"></a>7.GameInstance</h5><p><strong>游戏实例中存储了当前对局中的所有变量，游戏实例随游戏的打开而创建，随游戏的关闭而销毁，</strong>例如游戏中切换了地图，那么游戏实例之前保存的是上一张地图的信息，现在则变成成了最新的地图信息，起到一个临时的保存和效果。</p>
<h5 id="8-Pawn-x2F-Character"><a href="#8-Pawn-x2F-Character" class="headerlink" title="8.Pawn&#x2F;Character"></a>8.Pawn&#x2F;Character</h5><p>Character角色类一般用于<strong>人形目标</strong>的实现，比如玩家类，人形的敌人类，人形NPC或者BOSS此种，类中<strong>内设了Character Movement角色移动类组件</strong>，可以让用户快速的设置人形目标的各种移动效果，诸如下蹲移动速度，奔跑速度，奔跑最大速度，奔跑加速度甚至游泳状态，反正就是一切人形目标的移动属性都几乎内设在这个类中供用户设置。需要注意的是，Character是Pawn的一种类型，即<strong>是Pawn的一种继承</strong>，增加了可四处走动的功能。</p>
<p>Pawn和Character类很像，区别在于<strong>Pawn类一般用于非人形目标</strong>，比如你操控的是一台机关，放置在墙壁上或者高台上，这个机关不具有人形，但是却有和Character类差不多的操作和功能，比如射击，使用道具和获取奖励等，那么这个时候一般选用Pawn类，比如你操控的是一台靠轮子走的坦克，汽车，甚至飞机，机甲，哥斯拉和恐龙，这些单位从功能上来说和Character角色类很像，但是可能有不一样的移动方式，比如飞行或者爬墙，这个时候其<strong>移动组件通常需要玩家自己编写</strong>，当然如果是放置类的单位就不需要，比如一个具有加工功能的桌子，放那能用能加工不就行了，谁写移动功能啊，觉得碍眼的时候销毁一下就行；那么这些情况下我们通常使用Pawn类作为基类进行编写。</p>
<p>放一张小关系图</p>
<p><img src="/UE4-C-%E6%A1%86%E6%9E%B6%E6%A2%B3%E7%90%86%5Cimage-20221004141737070.png" alt="image20221004141737070"></p>
<p>2.GameMode实现(<strong>重要</strong>)</p>
<p>进行游戏所需要的玩家数量，或玩家加入游戏的方法，在多种类型的游戏中具有共通性。无论规则如何，Game Modes 的任务都是定义和实现规则。Game Modes 当前常用的基类有两个。</p>
<p>4.14 版本中加入了 <code>AGameModeBase</code>，这是所有 Game Mode 的基类，是经典的 <code>AGameMode</code> 简化版本。<code>AGameMode</code> 是 4.14 版本之前的基类，仍然保留，功能 如旧，但现在是 <code>AGameModeBase</code> 的子类。由于其比赛状态概念的实现，**<code>AGameMode</code> 更适用于标准游戏类型（如多人射击游戏）**。<code>AGameModeBase</code> 简洁高效，是新代码项目中包含的全新默认游戏模式。</p>
<h6 id="1-AGameModeBase"><a href="#1-AGameModeBase" class="headerlink" title="1.AGameModeBase"></a>1.AGameModeBase</h6><p>所有 Game Mode 均为 <code>AGameModeBase</code> 的子类。而 <code>AGameModeBase</code> 包含大量可覆盖的基础功能。部分常见函数包括：</p>
<table>
<thead>
<tr>
<th>函数&#x2F;事件</th>
<th>目的</th>
</tr>
</thead>
<tbody><tr>
<td><code>InitGame</code>初始化游戏</td>
<td><code>InitGame</code> 事件在其他脚本之前调用（包括 <code>PreInitializeComponents</code>），<code>AGameModeBase::PreInitializeComponents</code>预初始化控件</td>
</tr>
<tr>
<td><code>PreLogin</code>准备加入</td>
<td>接受或拒绝尝试加入服务器的玩家。如它将 <code>ErrorMessage</code> 设为一个非空字符串，会导致 <code>Login</code> 函数失败。<code>PreLogin</code> 在 <code>Login</code> 前调用，Login 调用前可能需要大量时间，加入的玩家需要下载游戏内容时尤其如此。</td>
</tr>
<tr>
<td><code>PostLogin</code>请求加入</td>
<td>成功登录后调用。在 <code>PlayerController</code> 上调用可网络复制函数是安全的。<code>OnPostLogin</code> 可在蓝图中实现，以添加额外的逻辑。</td>
</tr>
<tr>
<td><code>HandleStartingNewPlayer</code>新玩家生成</td>
<td>在 <code>PostLogin</code> 后或无缝游历后调用，可在蓝图中覆盖，修改新玩家身上发生的事件。它将默认创建一个玩家 pawn。</td>
</tr>
<tr>
<td><code>RestartPlayer</code>重启&#x2F;复活玩家</td>
<td>调用开始生成一个玩家 pawn。如需要指定 Pawn 生成的地点，还可使用 <code>RestartPlayerAtPlayerStart</code> 和 <code>RestartPlayerAtTransform</code> 函数。<code>OnRestartPlayer</code> 可在蓝图中实现，在此函数完成后添加逻辑。</td>
</tr>
<tr>
<td><code>SpawnDefaultPawnAtTransform</code>在指定位置生成Pawn</td>
<td>这实际生成玩家 Pawn，可在蓝图中覆盖。</td>
</tr>
<tr>
<td><code>Logout</code>退出游戏</td>
<td>玩家离开游戏或被摧毁时调用。可实现 <code>OnLogout</code> 执行蓝图逻辑。</td>
</tr>
</tbody></table>
<p>可针对游戏提供的每个比赛格式、任务类型或特殊区域创建 <code>AGameModeBase</code> 的子类。一款游戏可拥有任意数量的 Game Mode，因此也可拥有任意数量的 <code>AGameModeBase</code> 类子类；然而，给定时间上只能使用一个 Game Mode。每次关卡进行游戏实例化时 Game Mode Actor 将通过 <code>UGameEngine::LoadMap()</code> 函数进行实例化。</p>
<p>Game Mode 不会复制到加入多人游戏的远程客户端；它只存在于服务器上，因此本地客户端可看到之前使用过的留存 Game Mode 类（或蓝图）；但无法访问实际的实例并检查其变量，确定游戏进程中已发生哪些变化。如玩家确实需要更新与当前 Game Mode 相关的信息，可将信息保存在一个 <code>AGameStateBase</code> Actor 上，轻松保持同步。<code>AGameStateBase</code> Actor 随 Game Mode 而创建，之后被复制到所有远程客户端。注意，<strong>GameStateBase由GameModeBase生成。</strong></p>
<h6 id="2-AGameMode"><a href="#2-AGameMode" class="headerlink" title="2.AGameMode"></a>2.AGameMode</h6><p><code>AGameMode</code> 是 <code>AGameModeBase</code> 的子类，拥有一些额外的功能支持多人游戏和旧行为。所有新建项目默认使用 <code>AGameModeBase</code>。如果需要此额外行为，可切换到从 <code>AGameMode</code> 进行继承。如从 <code>AGameMode</code> 进行继承，也可从 <code>AGameState</code> 继承游戏状态（其支持比赛状态机）。</p>
<p><code>AGameMode</code> 包含一个跟踪比赛状态或整体游戏流程的状态机。可使用 <code>GetMatchState</code> 或 <code>HasMatchStarted</code>、<code>IsMatchInProgress</code> 和 <code>HasMatchEnded</code> 之类的封装器查询当前的状态。以下是可能的比赛状态：</p>
<ul>
<li><code>EnteringMap</code> 是<strong>初始状态</strong>。Actor 尚未进行 tick，世界场景尚未完整初始化。内容完整加载后将过渡到下个状态。</li>
<li><code>WaitingToStart</code> 是下个状态，进入时将调用 <code>HandleMatchIsWaitingToStart</code>。Actor 正在进行 tick，但玩家尚未生成。如 <code>ReadyToStartMatch</code> 返回 <em>true</em> 或 <code>StartMatch</code> 被调用，它将过渡到下个状态。</li>
<li><code>InProgress</code> 是游戏主体所发生的状态。进入此状态时将调用 <code>HandleMatchHasStarted</code>，然后在所有 Actor 上调用 <code>BeginPlay</code>。此时，正常游戏进程已在进行中。<code>ReadyToEndMatch</code> 返回 <em>true</em> 或调用 <code>EndMatch</code> 时比赛将过渡到下个状态。</li>
<li><code>WaitingPostMatch</code> 是倒数第二个状态，进入时将调用 <code>HandleMatchHasEnded</code>。Actor 仍在 tick，但新玩家无法加入。地图转换开始时它将过渡到下个状态。</li>
<li><code>LeavingMap</code> 是正常流程中的最后一个状态，进入时将调用 <code>HandleLeavingMap</code>。转换到新地图时比赛将保持在此状态中，进入新地图时将过渡回到 <code>EnteringMap</code>。</li>
<li><code>Aborted</code> 是失败状态，调用 <code>AbortMatch</code> 可开始此状态。出现无法恢复的错误时将进行此设置。</li>
</ul>
<p>游戏状态将固定为 <code>InProgress</code>，因为这是调用 <code>BeginPlay</code>、actor 开始 tick 的状态。然而，<strong>个体游戏可能覆盖这些状态</strong>的行为，用更复杂的规则构建一个多人游戏，如在一款多人射击游戏中等待其他玩家加入时允许玩家在关卡中自由飞行。</p>
<h6 id="3-Game-State"><a href="#3-Game-State" class="headerlink" title="3.Game State"></a>3.Game State</h6><p><strong>Game State</strong> 负责启用客户端监控游戏状态。从概念上而言，Game State 应该管理所有已连接客户端已知的信息（特定于 Game Mode 但不特定于任何个体玩家）。它能够追踪游戏层面的属性，如已连接玩家的列表、夺旗游戏中的团队得分、开放世界游戏中已完成的任务，等等。</p>
<p>Game State 并非追踪玩家特有内容（如夺旗比赛中特定玩家为团队获得的分数）的最佳之处，因为它们由 <strong>Player State</strong> 更清晰地处理。整体而言，GameState 应该追踪游戏进程中变化的属性。这些属性与所有人皆相关，且所有人可见。Game mode 只存在于服务器上，而 Game State 存在于服务器上且会被复制到所有客户端，保持所有已连接机器的游戏进程更新。</p>
<p><code>AGameStateBase</code> 是基础实现，其部分默认功能包括：</p>
<table>
<thead>
<tr>
<th>函数或变量</th>
<th>使用</th>
</tr>
</thead>
<tbody><tr>
<td><code>GetServerWorldTimeSeconds</code></td>
<td>这是 <code>UWorld</code> 函数 <code>GetTimeSeconds</code> 的服务器版本，将在客户端和服务器上同步，因此该时间可用于复制，十分可靠。</td>
</tr>
<tr>
<td><code>PlayerArray</code></td>
<td>这是所有 <code>APlayerState</code> 对象的阵列，对游戏中所有玩家执行操作时十分实用。</td>
</tr>
<tr>
<td><code>HasBegunPlay</code></td>
<td>如 <code>BeginPlay</code> 函数在游戏中的 actor 上调用，则返回 true。</td>
</tr>
</tbody></table>
<p>下面是部分GameMode基类的函数，更多属性和函数请参考GameMode.h文件</p>
<p><img src="/UE4-C-%E6%A1%86%E6%9E%B6%E6%A2%B3%E7%90%86%5CGameMode%E9%83%A8%E5%88%86%E6%BA%90%E7%A0%81.png" alt="GameMode部分源码"></p>
<p>3.各个类的生成数量</p>
<p>关于游戏模式、玩家控制器、Pawn、角色、游戏实例、游戏状态、玩家状态GameMode&#x2F;PlayerController&#x2F;Pawn&#x2F;Character&#x2F;GameInstance&#x2F;GameState&#x2F;PlayerState 6个类的生成情况和生成个数。</p>
<p>首先，PlayerController、GameMode、PlayerState、都需要在关卡的WorldSetting中的GameMode栏设置，因为这几个类的生命周期仅存在于关卡中，GameInstance类需要在Edit-&gt;project setting-&gt;Map&amp;Modes中最下面的GameInstance中设定。</p>
<table>
<thead>
<tr>
<th></th>
<th>生命周期</th>
<th>存在于</th>
<th>是否网络复制</th>
<th>进程内个数</th>
</tr>
</thead>
<tbody><tr>
<td>GameInstance</td>
<td>进程</td>
<td>服务器和客户端</td>
<td>否</td>
<td>1</td>
</tr>
<tr>
<td>GameMode</td>
<td>关卡</td>
<td>服务器</td>
<td>不适用</td>
<td>1</td>
</tr>
<tr>
<td>GameState</td>
<td>关卡</td>
<td>服务器和客户端</td>
<td>是</td>
<td>1</td>
</tr>
<tr>
<td>PlayerController</td>
<td>关卡</td>
<td>服务器和客户端</td>
<td>是</td>
<td>服务器上为玩家群体的总数量，客户端上只有一个</td>
</tr>
<tr>
<td>PlayerState</td>
<td>关卡</td>
<td>服务器和客户端</td>
<td>是</td>
<td>同玩家个数</td>
</tr>
<tr>
<td>Pawn&#x2F;Character</td>
<td>逻辑控制</td>
<td>服务器和客户端</td>
<td>是</td>
<td>同玩家个数</td>
</tr>
</tbody></table>
<p>此处的是否可复制表示服务器端的变化<strong>是否会复制到所有客户端</strong>，生命周期指的是不同生命周期类可以不一样，对于生命周期为关卡的类制定在每个关卡WorldSetting中的GameMode设置。</p>
<p>举例：</p>
<p>如果此时房间里有3个玩家，即两个客户端一个服务端，那么对应其生成情况如下：</p>
<table>
<thead>
<tr>
<th>Player&#x2F;Character</th>
<th>在服务器上生成3个，两个客户端上各自生成3个</th>
</tr>
</thead>
<tbody><tr>
<td>PlayerState</td>
<td>在服务器上生成3个，两个客户端上分别生成3个(世界场景中总共9个)</td>
</tr>
<tr>
<td>PlayerController</td>
<td>服务器上生成3个，两个客户端上分别生成1个(世界场景中总共5个)</td>
</tr>
<tr>
<td>GameMode</td>
<td>只在服务器上生成1个。客户端上不生产，只允许服务端拥有。</td>
</tr>
<tr>
<td>GameState</td>
<td>服务器上生成1个，两个客户端上分别生成1个。(世界场景中总共3个)</td>
</tr>
<tr>
<td>GameInstance</td>
<td>服务器上生成1个，两个客户端上各自生成1个。(整个世界场景中共生成3个)</td>
</tr>
<tr>
<td>关卡蓝图</td>
<td>服务器上生成1个，两个客户端上各自生成1个。(整个世界场景中共生成3个)</td>
</tr>
</tbody></table>
<p>这里有两张图便于数量和关系的理解</p>
<p><img src="/UE4-C-%E6%A1%86%E6%9E%B6%E6%A2%B3%E7%90%86%5C%E6%95%B0%E9%87%8F%E7%90%86%E8%A7%A3.png" alt="数量理解"></p>
<p><strong>Game State</strong> 并非追踪玩家特有内容（如夺旗比赛中特定玩家为团队获得的分数）的最佳之处，因为它们由 <strong>Player State</strong> 更清晰地处理。整体而言，GameState 应该追踪游戏进程中变化的属性。这些属性与所有人皆相关，且所有人可见。<strong>Game mode 只存在于服务器上</strong>，而 Game State 存在于服务器上且<strong>会被复制到所有客户端</strong>，保持所有已连接机器的游戏进程更新。</p>
<p><img src="/UE4-C-%E6%A1%86%E6%9E%B6%E6%A2%B3%E7%90%86%5C%E7%B1%BB%E5%9C%A8%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF.png" alt="类在服务端和客户端"></p>
<p>3.参考资料</p>
<ol>
<li><p><a target="_blank" rel="noopener" href="https://space.bilibili.com/12825137/channel/seriesdetail?sid=317657">安宁Ken的个人空间_哔哩哔哩_Bilibili</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://docs.unrealengine.com/5.0/zh-CN/game-mode-and-game-state-in-unreal-engine/">虚幻引擎中的 Game Mode 和 Game State | 虚幻引擎5.0文档</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.udemy.com/course/unreal-engine-5-cpp-multiplayer-shooter/UE">https://www.udemy.com/course/unreal-engine-5-cpp-multiplayer-shooter/UE</a> 网络同步和框架</p>
</li>
<li><p>转载自我的好兄弟：<a href="mailto:&#x32;&#x36;&#53;&#55;&#x33;&#52;&#x38;&#x36;&#x37;&#57;&#64;&#x71;&#x71;&#x2e;&#x63;&#111;&#109;">&#x32;&#x36;&#53;&#55;&#x33;&#52;&#x38;&#x36;&#x37;&#57;&#64;&#x71;&#x71;&#x2e;&#x63;&#111;&#109;</a></p>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/06/UDP%E7%AE%80%E8%BF%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="williny">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Williny'home">
      <meta itemprop="description" content="孤独是人生的常态">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Williny'home">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/10/06/UDP%E7%AE%80%E8%BF%B0/" class="post-title-link" itemprop="url">UDP简述</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-10-06 09:45:00 / 修改时间：10:48:18" itemprop="dateCreated datePublished" datetime="2022-10-06T09:45:00+08:00">2022-10-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>UDP协议全称是用户数据报协议，在网络中它与TCP协议一样用于处理数据包，是一种无连接的协议。在OSI模型中，在第四层——传输层，处于IP协议的上一层。UDP有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的。</p>
<h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><h2 id="面向无连接"><a href="#面向无连接" class="headerlink" title="面向无连接"></a>面向无连接</h2><p>首先 UDP 是不需要和 TCP一样在发送数据前进行三次握手建立连接的，想发数据就可以开始发送了。并且也只是数据报文的搬运工，不会对数据报文进行任何拆分和拼接操作。</p>
<p>具体来说就是：</p>
<p>在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作</p>
<h2 id="有单播，多播，广播的功能"><a href="#有单播，多播，广播的功能" class="headerlink" title="有单播，多播，广播的功能"></a>有单播，多播，广播的功能</h2><p>UDP 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 UDP 提供了单播，多播，广播的功能。</p>
<h2 id="UDP是面向报文的"><a href="#UDP是面向报文的" class="headerlink" title="UDP是面向报文的"></a>UDP是面向报文的</h2><p>发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。因此，应用程序必须选择合适大小的报文</p>
<h2 id="不可靠性"><a href="#不可靠性" class="headerlink" title="不可靠性"></a>不可靠性</h2><p>首先不可靠性体现在无连接上，通信都不需要建立连接，想发就发，这样的情况肯定不可靠。</p>
<p>并且收到什么数据就传递什么数据，并且也不会备份数据，发送数据也不会关心对方是否已经正确接收到数据了。</p>
<p>再者网络环境时好时坏，但是 UDP 因为没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP。</p>
<h2 id="头部开销小，传输数据报文时是很高效的。"><a href="#头部开销小，传输数据报文时是很高效的。" class="headerlink" title="头部开销小，传输数据报文时是很高效的。"></a>头部开销小，传输数据报文时是很高效的。</h2>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/06/TCP-IP%E7%AE%80%E8%BF%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="williny">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Williny'home">
      <meta itemprop="description" content="孤独是人生的常态">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Williny'home">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/10/06/TCP-IP%E7%AE%80%E8%BF%B0/" class="post-title-link" itemprop="url">TCP/IP简述</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-10-06 09:32:36 / 修改时间：09:48:35" itemprop="dateCreated datePublished" datetime="2022-10-06T09:32:36+08:00">2022-10-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="TCP-x2F-IP-三次握手"><a href="#TCP-x2F-IP-三次握手" class="headerlink" title="TCP&#x2F;IP 三次握手"></a>TCP&#x2F;IP 三次握手</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>指在发送数据的准备阶段，需要先建立连接，（三次握手来建立连接）</p>
<h2 id="三次握手举例"><a href="#三次握手举例" class="headerlink" title="三次握手举例"></a>三次握手举例</h2><ol>
<li><p>就是A给B发送消息1 （A只知道自己刚刚发送了消息，但是发没发送成功，B有没有收到？A是不知道的，万一网络不好消息丢了呢或者B的协议不对，不能收到A的消息呢）</p>
</li>
<li><p>B给A发送消息2，告诉A,B刚刚收到了消息1，（此时，A给B发送消息，确认B是可以收到的A的消息，但是A有没有收到B的消息2，我们是不知道的，我们只是发出了消息，不确定收到消息没，万一消息2发丢了呢）</p>
</li>
<li><p>所以第三次，就是A再给B发送消息，告诉B,A可以收到B的消息。</p>
</li>
</ol>
<p>三次握手完成，双方确认了都可以收到对方消息，这就建立连接成功了</p>
<p><img src="https://img-blog.csdnimg.cn/d2415ebccb164e5294abc5b07bebeb22.png"></p>
<p>同步序号：SYN   确认字段：ACK  随机数据：seq</p>
<p>规定：</p>
<p>当SYN&#x3D;1,ACK&#x3D;0表示连接请求</p>
<p>当SYN&#x3D;1,ACK&#x3D;1表示同意建立连接</p>
<p>如上图，纵向的轴，是一个时间轴。</p>
<ol>
<li><p>第一次握手：时间点1，客户端向服务端发送连接请求报文段。ACK&#x3D;0,SYN&#x3D;1,seq&#x3D;x。将SYN位置为1，Sequence Number为x;然后，客户端进入SYN_SEND状态，等待服务器的确认;</p>
</li>
<li><p>第二次握手：服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1);同时，自己自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y;服务器端将上述所有信息放到一个报文段(即SYN+ACK报文段)中，一并发送给客户端，此时服务器进入SYN_RECV状态;</p>
</li>
<li><p>第三次握手：客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。</p>
</li>
</ol>
<p>完成了三次握手，客户端和服务器端就可以开始传送数据。</p>
<h2 id="为什么是三次握手？而不是两次握手"><a href="#为什么是三次握手？而不是两次握手" class="headerlink" title="为什么是三次握手？而不是两次握手"></a>为什么是三次握手？而不是两次握手</h2><h3 id="原因1：-两次握手只能保证单向连接是畅通的。因为TCP是一个双向传输协议，只有经过第三次握手，才能确保双向都可以接收到对方的发送的数据。"><a href="#原因1：-两次握手只能保证单向连接是畅通的。因为TCP是一个双向传输协议，只有经过第三次握手，才能确保双向都可以接收到对方的发送的数据。" class="headerlink" title="原因1： 两次握手只能保证单向连接是畅通的。因为TCP是一个双向传输协议，只有经过第三次握手，才能确保双向都可以接收到对方的发送的数据。"></a>原因1： 两次握手只能保证单向连接是畅通的。因为TCP是一个双向传输协议，只有经过第三次握手，才能确保双向都可以接收到对方的发送的数据。</h3><p>接着上面的那个打电话的日常场景，如果是2次握手话，场景就是这样的。</p>
<p>你：你能听到我说话吗？</p>
<p>你朋友：我能听到你说话，你能听到我说话吗？</p>
<p>你：我能听到你说话</p>
<p>只是确认了对方能听到你说话，但是不能确认你能听到你朋友的说话。</p>
<p>如果两次握手，就正式谈话，如果你听不到你朋友的声音，这些你朋友给你说的话不就丢失了么。</p>
<p><img src="https://img-blog.csdnimg.cn/3fe9474a4dff416ebc9c7e7f42fd9daa.png"></p>
<h3 id="原因2：主要是为了防止已经失效的连接请求报文突然又传送到了服务器，从而导致不必要的错误和资源的浪费。"><a href="#原因2：主要是为了防止已经失效的连接请求报文突然又传送到了服务器，从而导致不必要的错误和资源的浪费。" class="headerlink" title="原因2：主要是为了防止已经失效的连接请求报文突然又传送到了服务器，从而导致不必要的错误和资源的浪费。"></a>原因2：主要是为了防止已经失效的连接请求报文突然又传送到了服务器，从而导致不必要的错误和资源的浪费。</h3><p>如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送的第一个请求连接并且没有丢失，只是因为在网络中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时之前滞留的那一次请求连接，因为网络通畅了, 到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。</p>
<p>如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。<br><img src="https://img-blog.csdnimg.cn/d8d66b8e47e74089b94dfcb034ed9897.png"></p>
<h2 id="TCP建立连接为什么是三次握手，而不是四次？"><a href="#TCP建立连接为什么是三次握手，而不是四次？" class="headerlink" title="TCP建立连接为什么是三次握手，而不是四次？"></a>TCP建立连接为什么是三次握手，而不是四次？</h2><p>三次握手已经能说明握手时的通信是正常的，四次握手就显得浪费了。</p>
<h1 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h1><p>TCP 的连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)，客户端或服务器均可主动发起挥手动作。</p>
<p>TCP连接是双向的，在四次挥手中，前两次挥手用于断开一个方向的连接，后两次挥手用于断开另一方向的连接。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/d33d52354d13a78d5f56e388033372a5.png"></p>
<p>1、第一次挥手</p>
<p> 客户端发送一个 FIN 报文（请求连接终止：FIN &#x3D; 1），报文中会指定一个序列号 seq &#x3D; u。并停止再发送数据，主动关闭 TCP 连接。此时客户端进入 FIN_WAIT_1 状态，等待服务端的确认。</p>
<p> FIN-WAIT-1 ：等待远程TCP的连接中断请求，或先前的连接中断请求的确认</p>
<p> FIN&#x3D;1表示该报文段是一个连接释放请求</p>
<p> seq&#x3D;u，u-1是客户端向服务端发送的最后一个字节的序号</p>
<p>2、第二次挥手</p>
<p>服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端进入 CLOSE_WAIT状态。</p>
<p> CLOSE_WAIT ：等待从本地用户发来的连接中断请求</p>
<p> ACK&#x3D;1：除TCP连接请求报文段以外，TCP通信过程中所有数据报的ACK都为1，表示应答</p>
<p> seq&#x3D;v，v是服务端释放应答报文段第一个字节序号</p>
<p> ack&#x3D;u+1表示希望收到从第u+1个字节开始的报文段，并且已经成功接收了前u个字节</p>
<p>第二次挥手完成后，客户端到服务端方向的连接已经释放，服务端不会再接收客户端的数据，客户端也没有数据要发送了。但服务端到客户端方向的连接仍然存在，服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。</p>
<p>3、第三次挥手</p>
<p>服务端将最后的数据发送完毕后，就向客户端发送连接释放报文，其报文头包含：FIN&#x3D;1，ack&#x3D;u+1，由于在CLOS-WAIT状态，服务端很可能又发送了一些数据，假定此时的序列号为seq&#x3D;w，此时，服务器进入LAST-ACK状态。</p>
<p>LAST_ACK : 等待原来发向远程TCP的连接中断请求的确认</p>
<p>4、第四次挥手</p>
<p>客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答（ack &#x3D; w+1），且把服务端的序列值 +1 作为自己 ACK 报文的序号值（seq&#x3D;u+1），此时客户端进入TIME_WAIT状态。</p>
<p> TIME_WAIT：等待足够的时间以确保远程TCP接收到连接中断请求的确认</p>
<p>该状态会持续2MSL（最长报文段寿命）时间，这个期间TCP连接还未释放，若该时间段内没有服务端的重发请求的话，客户端就进入CLOSED状态，撤销TCB。</p>
<p>服务端只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。</p>
<h2 id="TCP关闭连接时为什么是四次挥手？"><a href="#TCP关闭连接时为什么是四次挥手？" class="headerlink" title="TCP关闭连接时为什么是四次挥手？"></a>TCP关闭连接时为什么是四次挥手？</h2><p>由于 TCP 的半关闭（half-close）特性，TCP 提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。</p>
<p> 任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。</p>
<h2 id="为什么TIME-WAIT状态需要经过2MSL才能返回到CLOSE状态？"><a href="#为什么TIME-WAIT状态需要经过2MSL才能返回到CLOSE状态？" class="headerlink" title="为什么TIME_WAIT状态需要经过2MSL才能返回到CLOSE状态？"></a>为什么TIME_WAIT状态需要经过2MSL才能返回到CLOSE状态？</h2><h3 id="1-为了保证服务端能收到客户端的确认应答。"><a href="#1-为了保证服务端能收到客户端的确认应答。" class="headerlink" title="1.为了保证服务端能收到客户端的确认应答。"></a>1.为了保证服务端能收到客户端的确认应答。</h3><p>若客户端发完确认应答后直接进入CLOSED状态，那么如果该应答丢失，服务端等待超时后就会重新发送连接释放请求，但此时客户端已经关闭了，不会作出任何响应，因此服务端就无法正常关闭。</p>
<h3 id="2-防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。"><a href="#2-防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。" class="headerlink" title="2.防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。"></a>2.防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。</h3><p> 客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。</p>
<h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><h2 id="面向连接"><a href="#面向连接" class="headerlink" title="面向连接"></a>面向连接</h2><p>面向连接，是指发送数据之前必须在两端建立连接。建立连接的方法是“三次握手”，这样能建立可靠的连接。建立连接，是为数据的可靠传输打下了基础。</p>
<h2 id="仅支持单播传输"><a href="#仅支持单播传输" class="headerlink" title="仅支持单播传输"></a>仅支持单播传输</h2><p>每条TCP传输连接只能有两个端点，只能进行点对点的数据传输，不支持多播和广播传输方式。</p>
<h2 id="面向字节流"><a href="#面向字节流" class="headerlink" title="面向字节流"></a>面向字节流</h2><p>TCP不像UDP一样那样一个个报文独立地传输，而是在不保留报文边界的情况下以字节流方式进行传输。</p>
<h2 id="可靠传输"><a href="#可靠传输" class="headerlink" title="可靠传输"></a>可靠传输</h2><p>对于可靠传输，判断丢包，误码靠的是TCP的段编号以及确认号。TCP为了保证报文传输的可靠，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的字节发回一个相应的确认(ACK)；如果发送端实体在合理的往返时延(RTT)内未收到确认，那么对应的数据（假设丢失了）将会被重传。</p>
<h2 id="提供拥塞控制"><a href="#提供拥塞控制" class="headerlink" title="提供拥塞控制"></a>提供拥塞控制</h2><p>当网络出现拥塞的时候，TCP能够减小向网络注入数据的速率和数量，缓解拥塞</p>
<h2 id="TCP提供全双工通信"><a href="#TCP提供全双工通信" class="headerlink" title="TCP提供全双工通信"></a>TCP提供全双工通信</h2><p>TCP允许通信双方的应用程序在任何时候都能发送数据，因为TCP连接的两端都设有缓存，用来临时存放双向通信的数据。当然，TCP可以立即发送一个数据段，也可以缓存一段时间以便一次发送更多的数据段（最大的数据段大小取决于MSS）</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/04/C-Set%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="williny">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Williny'home">
      <meta itemprop="description" content="孤独是人生的常态">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Williny'home">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/10/04/C-Set%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">C++-Set底层实现机制</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-10-04 09:32:33 / 修改时间：10:16:26" itemprop="dateCreated datePublished" datetime="2022-10-04T09:32:33+08:00">2022-10-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Set概念"><a href="#Set概念" class="headerlink" title="Set概念"></a>Set概念</h1><ol>
<li><p>使用 set 容器存储的各个键值对，要求键 key 和值 value 必须相等。</p>
</li>
<li><p>会自行根据键的大小对存储的键值对进行排序、</p>
</li>
<li><p>在正常情况下，用户是无法做到修改 set 容器中元素的值的</p>
</li>
<li><p>最正确的修改 set 容器中元素值的做法是：先删除该元素，然后再添加一个修改后的元素。</p>
</li>
<li><p>multiset 容器和 set 容器唯一的差别在于，multiset 容器允许存储多个值相同的元素，而 set 容器中只能存储互不相同的元素。</p>
</li>
<li><p>unordered_set 容器具有以下几个特性：</p>
<ul>
<li><p>不再以键值对的形式存储数据，而是直接存储数据的值；</p>
</li>
<li><p>容器内部存储的各个元素的值都互不相等，且不能被修改。</p>
</li>
<li><p>不会对内部存储的数据进行排序（这和该容器底层采用哈希表结构存储数据有关</p>
</li>
</ul>
</li>
</ol>
<h1 id="Set底层"><a href="#Set底层" class="headerlink" title="Set底层"></a>Set底层</h1><ol>
<li><p>set底层同Map（红黑树）</p>
</li>
<li><p>unordered_set底层同unordered_map（Hash）</p>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/04/C-Map%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="williny">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Williny'home">
      <meta itemprop="description" content="孤独是人生的常态">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Williny'home">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/10/04/C-Map%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">C++-Map底层实现机制</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-10-04 09:32:02 / 修改时间：09:59:45" itemprop="dateCreated datePublished" datetime="2022-10-04T09:32:02+08:00">2022-10-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="各Map容器的概念"><a href="#各Map容器的概念" class="headerlink" title="各Map容器的概念"></a>各Map容器的概念</h1><ol>
<li><p>map 容器存储的都是 pair 对象，也就是用 pair 类模板创建的键值对。其中，各个键值对的键和值可以是任意数据类型，包括C++基本数据类型（int、double 等）、使用结构体或类自定义的类型。</p>
</li>
<li><p>会自动根据各键值对的键的大小，按照既定的规则进行排序。默认情况下，map 容器选用<code>std::less&lt;T&gt;</code>排序规则（其中 T 表示键的数据类型），其会根据键的大小对所有键值对做升序排序。</p>
</li>
<li><p>使用 map 容器存储的各个键值对，键的值既不能重复也不能被修改。</p>
</li>
<li><p><code>multimap </code>容器中可以同时存储多（≥2）个键相同的键值对。</p>
</li>
<li><p><code>unordered_map </code>容器中是无序的。</p>
</li>
</ol>
<h1 id="Map底层"><a href="#Map底层" class="headerlink" title="Map底层"></a>Map底层</h1><p>map的实现原理就是红黑树 每个节点到叶子节点最大树高不超过1 是平衡二叉树。查找的时间复杂度是O(lgn),但是插入和删除要维持红黑树的自平衡，所以效率较低。但是有序。</p>
<h1 id="unordered-Map底层"><a href="#unordered-Map底层" class="headerlink" title="unordered_Map底层"></a>unordered_Map底层</h1><p>不仅是 unordered_map 容器，所有无序容器的底层实现都采用的是哈希表存储结构。</p>
<p>更准确地说，是用“链地址法”（又称“开链法”）解决数据存储位置发生冲突的哈希表。</p>
<p><img src="http://c.biancheng.net/uploads/allimg/200221/1-200221131A4220.gif" alt="C++ STL 无序容器存储状态示意图"></p>
<p>Pi 表示存储的各个键值对。</p>
<p>在 C++ STL 标准库中，将图 1 中的各个链表称为<code>桶（bucket）</code>，每个桶都有自己的编号（从 0 开始）。</p>
<p>当有新键值对存储到无序容器中时，整个存储过程分为如下几步：</p>
<ol>
<li><p>将该键值对中键的值带入设计好的哈希函数，会得到一个哈希值（一个整数，用 H 表示）；</p>
</li>
<li><p>将 H 和无序容器拥有桶的数量 n 做整除运算（即 H % n），该结果即表示应将此键值对存储到的桶的编号；</p>
</li>
<li><p>建立一个新节点存储此键值对，同时将该节点链接到相应编号的桶上。</p>
</li>
</ol>
<p>另外值得一提的是，哈希表存储结构还有一个重要的属性，称为<code>负载因子（load factor）</code></p>
<p>该属性同样适用于无序容器，用于衡量容器存储键值对的空&#x2F;满程序，即<code>负载因子越大，意味着容器越满，即各链表中挂载着越多的键值对</code>，这无疑会降低容器查找目标键值对的效率；反之，<code>负载因子越小，容器肯定越空，但并不一定各个链表中挂载的键值对就越少</code>。  </p>
<p>举个例子，如果设计的哈希函数不合理，使得各个键值对的键带入该函数得到的哈希值始终相同（所有键值对始终存储在同一链表上）。这种情况下，即便增加桶数是的负载因子减小，该容器的查找效率依旧很差。  </p>
<p>无序容器中，负载因子的计算方法为：</p>
<p><code>负载因子 = 容器存储的总键值对 / 桶数</code></p>
<p>默认情况下，无序容器的最大负载因子为 1.0。如果操作无序容器过程中，使得最大复杂因子超过了默认值，则容器会自动增加桶数，并重新进行哈希，以此来减小负载因子的值。需要注意的是，此过程会导致容器迭代器失效，但指向单个键值对的引用或者指针仍然有效。  </p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/02/C-List%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="williny">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Williny'home">
      <meta itemprop="description" content="孤独是人生的常态">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Williny'home">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/10/02/C-List%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">C++-List底层实现机制</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-10-02 11:29:27 / 修改时间：11:51:30" itemprop="dateCreated datePublished" datetime="2022-10-02T11:29:27+08:00">2022-10-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>List 容器，又称双向链表容器，在堆上分配空间，即该容器的底层是以双向链表的形式实现的。这意味着，list 容器中的元素可以分散存储在内存空间里，而不是必须存储在一整块连续的内存空间中。</p>
<h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p>List适用场景：经常插入删除大量数据</p>
<h1 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h1><p>List容器的底层是用双向链表实现的，甚至一些 STL 版本中（比如 SGI STL），list 容器的底层实现使用的是双向循环链表。</p>
<p><img src="http://c.biancheng.net/uploads/allimg/191218/2-19121Q62J3329.gif"></p>
<h1 id="List访问元素"><a href="#List访问元素" class="headerlink" title="List访问元素"></a>List访问元素</h1><p>通过 front() 和 back() 成员函数，可以分别获得 list 容器中第一个元素和最后一个元素的引用形式</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::list&lt;<span class="type">int</span>&gt; mylist&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> &#125;;</span><br><span class="line">    <span class="type">int</span> &amp;first = mylist.<span class="built_in">front</span>();</span><br><span class="line">    <span class="type">int</span> &amp;last = mylist.<span class="built_in">back</span>();</span><br><span class="line">    cout &lt;&lt; first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; last &lt;&lt; endl;</span><br><span class="line">    first = <span class="number">10</span>;</span><br><span class="line">    last = <span class="number">20</span>;</span><br><span class="line">    cout &lt;&lt; mylist.<span class="built_in">front</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; mylist.<span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问 list 容存储的其他元素，就只能使用 list 容器的迭代器。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> std::list&lt;<span class="type">int</span>&gt; mylist&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> it = mylist.<span class="built_in">begin</span>();</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    ++it;</span><br><span class="line">    <span class="keyword">while</span> (it!=mylist.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        ++it;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="List插入元素"><a href="#List插入元素" class="headerlink" title="List插入元素"></a>List插入元素</h1><p>list 模板类中，与“添加或插入新元素”相关的成员方法有如下几个：  </p>
<ul>
<li>push_front()：向 list 容器首个元素前添加新元素；</li>
<li>push_back()：向 list 容器最后一个元素后添加新元素；</li>
<li>emplace_front()：在容器首个元素前直接生成新的元素；</li>
<li>emplace_back()：在容器最后一个元素后直接生成新的元素；</li>
<li>emplace()：在容器的指定位置直接生成新的元素；</li>
<li>insert()：在指定位置插入新元素；</li>
<li>splice()：将其他 list 容器存储的多个元素添加到当前 list 容器的指定位置处。</li>
</ul>
<h2 id="常规插入"><a href="#常规插入" class="headerlink" title="常规插入"></a>常规插入</h2><p>除了 insert() 和 splice() 方法有多种语法格式外，其它成员方法都仅有 1 种语法格式。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::list&lt;<span class="type">int</span>&gt; values&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    values.<span class="built_in">push_front</span>(<span class="number">0</span>);<span class="comment">//&#123;0,1,2,3&#125;</span></span><br><span class="line">    values.<span class="built_in">push_back</span>(<span class="number">4</span>); <span class="comment">//&#123;0,1,2,3,4&#125;</span></span><br><span class="line">    values.<span class="built_in">emplace_front</span>(<span class="number">-1</span>);<span class="comment">//&#123;-1,0,1,2,3,4&#125;</span></span><br><span class="line">    values.<span class="built_in">emplace_back</span>(<span class="number">5</span>);  <span class="comment">//&#123;-1,0,1,2,3,4,5&#125;</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">//emplace(pos,value),其中 pos 表示指明位置的迭代器，value为要插入的元素值</span></span><br><span class="line">    values.<span class="built_in">emplace</span>(values.<span class="built_in">end</span>(), <span class="number">6</span>);<span class="comment">//&#123;-1,0,1,2,3,4,5,6&#125;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> p = values.<span class="built_in">begin</span>(); p != values.<span class="built_in">end</span>(); ++p) &#123;</span><br><span class="line">        cout &lt;&lt; *p &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="insert-成员方法"><a href="#insert-成员方法" class="headerlink" title="insert()成员方法"></a>insert()成员方法</h2><table>
<thead>
<tr>
<th>语法格式</th>
<th>用法说明</th>
</tr>
</thead>
<tbody><tr>
<td>iterator insert(pos,elem)</td>
<td>在迭代器 pos 指定的位置之前插入一个新元素 elem，并返回表示新插入元素位置的迭代器。</td>
</tr>
<tr>
<td>iterator insert(pos,n,elem)</td>
<td>在迭代器 pos 指定的位置之前插入 n 个元素 elem，并返回表示第一个新插入元素位置的迭代器。</td>
</tr>
<tr>
<td>iterator insert(pos,first,last)</td>
<td>在迭代器 pos 指定的位置之前，插入其他容器（例如 array、vector、deque 等）中位于 [first,last) 区域的所有元素，并返回表示第一个新插入元素位置的迭代器。</td>
</tr>
<tr>
<td>iterator insert(pos,initlist)</td>
<td>在迭代器 pos 指定的位置之前，插入初始化列表（用大括号 { } 括起来的多个元素，中间有逗号隔开）中所有的元素，并返回表示第一个新插入元素位置的迭代器。</td>
</tr>
</tbody></table>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::list&lt;<span class="type">int</span>&gt; values&#123; <span class="number">1</span>,<span class="number">2</span> &#125;;</span><br><span class="line">    <span class="comment">//第一种格式用法</span></span><br><span class="line">    values.<span class="built_in">insert</span>(values.<span class="built_in">begin</span>() , <span class="number">3</span>);<span class="comment">//&#123;3,1,2&#125;</span></span><br><span class="line">    <span class="comment">//第二种格式用法</span></span><br><span class="line">    values.<span class="built_in">insert</span>(values.<span class="built_in">end</span>(), <span class="number">2</span>, <span class="number">5</span>);<span class="comment">//&#123;3,1,2,5,5&#125;</span></span><br><span class="line">    <span class="comment">//第三种格式用法</span></span><br><span class="line">    std::array&lt;<span class="type">int</span>, 3&gt;test&#123; <span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span> &#125;;</span><br><span class="line">    values.<span class="built_in">insert</span>(values.<span class="built_in">end</span>(), test.<span class="built_in">begin</span>(), test.<span class="built_in">end</span>());<span class="comment">//&#123;3,1,2,5,5,7,8,9&#125;</span></span><br><span class="line">    <span class="comment">//第四种格式用法</span></span><br><span class="line">    values.<span class="built_in">insert</span>(values.<span class="built_in">end</span>(), &#123; <span class="number">10</span>,<span class="number">11</span> &#125;);<span class="comment">//&#123;3,1,2,5,5,7,8,9,10,11&#125;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> p = values.<span class="built_in">begin</span>(); p != values.<span class="built_in">end</span>(); ++p)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *p &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="list-splice-成员方法"><a href="#list-splice-成员方法" class="headerlink" title="list splice()成员方法"></a>list splice()成员方法</h2><table>
<thead>
<tr>
<th>语法格式</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>void splice (iterator position, list&amp; x);</td>
<td>position 为迭代器，用于指明插入位置；x 为另一个 list 容器。<br>此格式的 splice() 方法的功能是，将 x 容器中存储的所有元素全部移动当前 list 容器中 position 指明的位置处。</td>
</tr>
<tr>
<td>void splice (iterator position, list&amp; x, iterator i);</td>
<td>position 为迭代器，用于指明插入位置；x 为另一个 list 容器；i 也是一个迭代器，用于指向 x 容器中某个元素。<br>此格式的 splice() 方法的功能是将 x 容器中 i 指向的元素移动到当前容器中 position 指明的位置处。</td>
</tr>
<tr>
<td>void splice (iterator position, list&amp; x, iterator first, iterator last);</td>
<td>position 为迭代器，用于指明插入位置；x 为另一个 list 容器；first 和 last 都是迭代器，[fist,last) 用于指定 x 容器中的某个区域。<br>此格式的 splice() 方法的功能是将 x 容器 [first, last) 范围内所有的元素移动到当前容器 position 指明的位置处。</td>
</tr>
</tbody></table>
<h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建并初始化 2 个 list 容器</span></span><br><span class="line">    list&lt;<span class="type">int</span>&gt; mylist1&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> &#125;, mylist2&#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>&#125;;</span><br><span class="line">    list&lt;<span class="type">int</span>&gt;::iterator it = ++mylist1.<span class="built_in">begin</span>(); <span class="comment">//指向 mylist1 容器中的元素 2</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">//调用第一种语法格式</span></span><br><span class="line">    mylist1.<span class="built_in">splice</span>(it, mylist2); <span class="comment">// mylist1: 1 10 20 30 2 3 4</span></span><br><span class="line">                                 <span class="comment">// mylist2:</span></span><br><span class="line">                                 <span class="comment">// it 迭代器仍然指向元素 2，只不过容器变为了 mylist1</span></span><br><span class="line">    <span class="comment">//调用第二种语法格式，将 it 指向的元素 2 移动到 mylist2.begin() 位置处</span></span><br><span class="line">    mylist2.<span class="built_in">splice</span>(mylist2.<span class="built_in">begin</span>(), mylist1, it);   <span class="comment">// mylist1: 1 10 20 30 3 4</span></span><br><span class="line">                                                    <span class="comment">// mylist2: 2</span></span><br><span class="line">                                                    <span class="comment">// it 仍然指向元素 2</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">//调用第三种语法格式，将 [mylist1.begin(),mylist1.end())范围内的元素移动到 mylist.begin() 位置处                  </span></span><br><span class="line">    mylist2.<span class="built_in">splice</span>(mylist2.<span class="built_in">begin</span>(), mylist1, mylist1.<span class="built_in">begin</span>(), mylist1.<span class="built_in">end</span>());<span class="comment">//mylist1:</span></span><br><span class="line">                                                                             <span class="comment">//mylist2:1 10 20 30 3 4 2</span></span><br><span class="line">   </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;mylist1 包含 &quot;</span> &lt;&lt; mylist1.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot;个元素&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;mylist2 包含 &quot;</span> &lt;&lt; mylist2.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot;个元素&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//输出 mylist2 容器中存储的数据</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;mylist2:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = mylist2.<span class="built_in">begin</span>(); iter != mylist2.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">        cout &lt;&lt; *iter &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="List与Vector的区别"><a href="#List与Vector的区别" class="headerlink" title="List与Vector的区别"></a>List与Vector的区别</h1><p>1）vector底层实现是数组；list是双向 链表。<br>2）vector支持随机访问，list不支持。<br>3）vector是顺序内存，list不是(list只能快速访问头尾节点)。<br>4）vector在中间节点进行插入删除会导致内存拷贝，list不会。<br>5）vector一次性分配好内存，不够时才进行2倍扩容；list每次插入新节点都会进行内存申请<br>6）vector随机访问性能好，插入删除性能差；list随机访问性能差，插入删除性能好。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/02/C-Vector%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="williny">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Williny'home">
      <meta itemprop="description" content="孤独是人生的常态">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Williny'home">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/10/02/C-Vector%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">C++-Vector底层实现机制</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-10-02 11:05:57 / 修改时间：11:32:55" itemprop="dateCreated datePublished" datetime="2022-10-02T11:05:57+08:00">2022-10-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p><code>vector</code> 实现的是一个动态数组，即可以进行元素的插入和删除，在此过程中，vector 会动态调整所占用的内存空间，整个过程无需人工干预。</p>
<p>vector 常被称为向量容器，因为该容器擅长在尾部插入或删除元素，在常量时间内就可以完成</p>
<h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p>Vector应用场景：经常随机访问，且不经常对非尾节点进行插入删除的应用场景</p>
<h1 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h1><p>底层所采用的数据结构非常简单，就只是一段连续的线性内存空间加上使用 3 个迭代器（可以理解成指针）来表示的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//_Alloc 表示内存分配器，此参数几乎不需要我们关心</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ty</span>, <span class="keyword">class</span> <span class="title class_">_Alloc</span> = allocator&lt;_Ty&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> vector&#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    pointer _Myfirst;</span><br><span class="line">    pointer _Mylast;</span><br><span class="line">    pointer _Myend;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中，_Myfirst 指向的是 vector 容器对象的起始字节位置；_Mylast 指向当前最后一个元素的末尾字节；_myend 指向整个 vector 容器所占用内存空间的末尾字节。</p>
<p><img src="http://c.biancheng.net/uploads/allimg/191212/2-191212123P2Q5.gif"></p>
<p>将 3 个迭代器两两结合，还可以表达不同的含义，例如：</p>
<ul>
<li>_Myfirst 和 _Mylast 可以用来表示 vector 容器中目前已被使用的内存空间；</li>
<li>_Mylast 和 _Myend 可以用来表示 vector 容器目前空闲的内存空间；</li>
<li>_Myfirst 和 _Myend 可以用表示 vector 容器的容量。</li>
</ul>
<h1 id="vector扩容"><a href="#vector扩容" class="headerlink" title="vector扩容"></a>vector扩容</h1><p>当 vector 的大小和容量相等（size&#x3D;&#x3D;capacity）也就是满载时，如果再向其添加元素，那么 vector 就需要扩容。vector 容器扩容的过程需要经历以下 3 步：</p>
<ol>
<li>完全弃用现有的内存空间，重新申请更大的内存空间（一般是两倍原空间大小）；</li>
<li>将旧内存空间中的数据，按原有顺序移动到新的内存空间中；</li>
<li>析构掉旧存储空间中存储的所有元素；</li>
<li>最后将旧的内存空间释放。</li>
<li>以上三步扩容步骤会直接导致原本的迭代器，引用，指针会失效</li>
</ol>
<h2 id="如何避免Vector的不必要扩容"><a href="#如何避免Vector的不必要扩容" class="headerlink" title="如何避免Vector的不必要扩容"></a>如何避免Vector的不必要扩容</h2><p>可以借助 vector 模板类中提供的 <code>reserve() </code>成员方法。</p>
<table>
<thead>
<tr>
<th>成员方法</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>size()</td>
<td>告诉我们当前 vector 容器中已经存有多少个元素，但仅通过此方法，无法得知 vector 容器有多少存储空间。</td>
</tr>
<tr>
<td>capacity()</td>
<td>告诉我们当前 vector 容器总共可以容纳多少个元素。如果想知道当前 vector 容器有多少未被使用的存储空间，可以通过 capacity()-size() 得知。注意，如果 size() 和 capacity() 返回的值相同，则表明当前 vector 容器中没有可用存储空间了，这意味着，下一次向 vector 容器中添加新元素，将导致 vector 容器扩容。</td>
</tr>
<tr>
<td>resize(n)</td>
<td>强制 vector 容器必须存储 n 个元素，注意，如果 n 比 size() 的返回值小，则容器尾部多出的元素将会被析构（删除）；如果 n 比 size() 大，则 vector 会借助默认构造函数创建出更多的默认值元素，并将它们存储到容器末尾；如果 n 比 capacity() 的返回值还要大，则 vector 会先扩增，在添加一些默认值元素。</td>
</tr>
<tr>
<td>reserve(n)</td>
<td>强制 vector 容器的容量至少为 n。注意，如果 n 比当前 vector 容器的容量小，则该方法什么也不会做；反之如果 n 比当前 vector 容器的容量大，则 vector 容器就会扩容。</td>
</tr>
</tbody></table>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol>
<li><p>只要有新元素要添加到 vector 容器中并且此时 vector 容器的容量不足时，该容器就会自动扩容。</p>
</li>
<li><p>所以只要在Vector声明之后就通过<code>reserve()</code>将其容量设置为足够大，就可以减少自动扩容次数</p>
</li>
</ol>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;myvector;</span><br><span class="line">myvector.<span class="built_in">reserve</span>(<span class="number">1000</span>);</span><br><span class="line">cout &lt;&lt; myvector.<span class="built_in">capacity</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">1000</span>; i++) &#123;</span><br><span class="line">    myvector.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/02/C-%E6%8C%87%E9%92%88%E4%B8%8E%E5%BC%95%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="williny">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Williny'home">
      <meta itemprop="description" content="孤独是人生的常态">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Williny'home">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/10/02/C-%E6%8C%87%E9%92%88%E4%B8%8E%E5%BC%95%E7%94%A8/" class="post-title-link" itemprop="url">C++-指针与引用</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-10-02 09:34:12 / 修改时间：10:50:15" itemprop="dateCreated datePublished" datetime="2022-10-02T09:34:12+08:00">2022-10-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><code>指针</code>是指向某种数据类型对象的复合数据类型，提供了对所指向对象的间接访问，其保存的是另一个对象的地址。</p>
<p>如果一个指针指向的是另外一个指针，我们就称它为<code>二级指针</code>，或者指向指针的指针。</p>
<p><code>解引用 &quot;*&quot;</code>的作用是引用指针指向的变量值，引用其实就是引用该变量的地址，”解”就是把该地址对应的东西解开，解出来，就像打开一个包裹一样，那就是该变量的值了，所以称为”解引用”。</p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p= &amp;a;       <span class="comment">//定义一个整型指针p并且p指向了a的地址（&amp;取地址）</span></span><br><span class="line">*p=<span class="number">10</span>;            <span class="comment">//解引用，即给a赋值10；</span></span><br><span class="line">p=&amp;b;             <span class="comment">// p指向了 b的地址</span></span><br><span class="line">*p=<span class="number">200</span>;           <span class="comment">//解引用，即给b赋值200；</span></span><br><span class="line">p=&amp;a;             <span class="comment">// p指向了a的地址</span></span><br><span class="line"><span class="type">int</span> **pp=&amp;p;      <span class="comment">// 定义一个整型的指针pp并且pp指向了p的地址</span></span><br><span class="line">*pp=&amp;a;           <span class="comment">// pp指向了p的地址  p指向了a的地址即pp指向了a的地址</span></span><br><span class="line">**pp=<span class="number">1000</span>;        <span class="comment">//解引用，即给a赋值1000；</span></span><br><span class="line">*pp=&amp;b;           <span class="comment">//pp指向了p的地址  p指向了b的地址即pp指向了b的地址</span></span><br></pre></td></tr></table></figure>

<h2 id="指针函数"><a href="#指针函数" class="headerlink" title="指针函数"></a>指针函数</h2><p>简单理解就是一个返回指针的函数，其本质是一个函数，而该函数的返回值是一个指针。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> *<span class="title">myfun</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ol>
<li><p>在函数名前面多了一个*号，而这个函数就是一个指针函数。其返回值是一个 int 类型的指针。</p>
</li>
<li><p>在调用指针函数时，需要一个同类型的指针来接收其函数的返回值。也可以将其返回值定义为 <code>void*</code>类型，调用时强制转换返回值为想要的类型。</p>
</li>
<li><p>函数运行结束后会销毁在它内部定义的所有局部数据，包括局部变量、局部数组和形式参数，函数返回的指针请尽量不要指向这些数据（函数运行结束后会销毁所有的局部数据）</p>
</li>
</ol>
<h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>其本质是一个指针变量，该指针指向这个函数。函数指针就是指向函数的指针。</p>
<p>函数指针的定义形式为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">returnType</span> (*pointerName)(param list);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>returnType 为函数返回值类型</p>
</li>
<li><p>pointerName 为指针名称</p>
</li>
<li><p>param list 为函数参数列表</p>
</li>
<li><p>参数列表中可以同时给出参数的类型和名称，也可以只给出参数的类型，省略参数的名称，这一点和函数原型非常类似。</p>
</li>
</ul>
<h3 id="【实例】用指针来实现对函数的调用"><a href="#【实例】用指针来实现对函数的调用" class="headerlink" title="【实例】用指针来实现对函数的调用"></a>【实例】用指针来实现对函数的调用</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//返回两个数中较大的一个</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x, y, maxval;</span><br><span class="line">    <span class="comment">//定义函数指针</span></span><br><span class="line">    <span class="built_in">int</span> (*pmax)(<span class="type">int</span>, <span class="type">int</span>) = max;  <span class="comment">//也可以写作int (*pmax)(int a, int b)</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Input two numbers:&quot;</span>&lt;&lt;endl;</span><br><span class="line">    cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">    <span class="comment">//调用</span></span><br><span class="line">    maxval = (*pmax)(x, y);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Max value: %d\n&quot;</span>&lt;&lt;maxval&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><p><code>引用</code>可以看做是数据的一个别名，通过这个别名和原来的名字都能够找到这份数据</p>
<p>类似于 Windows 中的快捷方式，一个可执行程序可以有多个快捷方式，通过这些快捷方式和可执行程序本身都能够运行程序；</p>
<h2 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h2><ol>
<li><p>引用必须在定义的同时初始化，并且以后也要从一而终，不能再引用其它数据，这有点类似于常量（const 变量）。</p>
</li>
<li><p>引用在定义时需要添加<code>&amp;</code>，在使用时不能添加<code>&amp;</code>，使用时添加<code>&amp;</code>表示取地址。</p>
</li>
<li><p>其实引用只是对指针进行了简单的封装，它的底层依然是通过指针实现的，引用占用的内存和指针占用的内存长度一样，在 32 位环境下是 4 个字节，在 64 位环境下是 8 个字节，之所以不能获取引用的地址，是因为编译器进行了内部转换。</p>
</li>
</ol>
<h1 id="引用与指针的区别"><a href="#引用与指针的区别" class="headerlink" title="引用与指针的区别"></a>引用与指针的区别</h1><ol>
<li><p> 引用必须在定义时初始化，并且以后也要从一而终，不能再指向其他数据；而指针没有这个限制，指针在定义时不必赋值，以后也能指向任意数据。</p>
</li>
<li><p>可以有 const 指针，但是没有 const 引用。</p>
</li>
<li><p>指针可以有多级，但是引用只能有一级，例如，<code>int **p</code>是合法的，而<code>int &amp;&amp;r</code>是不合法的。</p>
</li>
<li><p>指针和引用的自增（++）自减（–）运算意义不一样。对指针使用 ++ 表示指向下一份数据，对引用使用 ++ 表示它所指代的数据本身加 1；自减（–）也是类似的道理。</p>
</li>
<li><p>“<strong>sizeof 引用</strong>”得到的是所指向的变量(对象)的大小，而“<strong>sizeof 指针</strong>”得到的是指针本身的大小；</p>
</li>
<li><p>引用使用时无需解引用（*），指针需要解引用；</p>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/09/30/C-%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E6%9E%84%E9%80%A0%E4%B8%8E%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="williny">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Williny'home">
      <meta itemprop="description" content="孤独是人生的常态">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Williny'home">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/09/30/C-%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E6%9E%84%E9%80%A0%E4%B8%8E%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/" class="post-title-link" itemprop="url">C++-继承中的构造与析构函数调用</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-09-30 11:17:26 / 修改时间：11:32:25" itemprop="dateCreated datePublished" datetime="2022-09-30T11:17:26+08:00">2022-09-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="继承中的构造函数"><a href="#继承中的构造函数" class="headerlink" title="继承中的构造函数"></a>继承中的构造函数</h1><ol>
<li><p>基类的成员函数可以被继承，可以通过派生类的对象访问</p>
</li>
<li><p>但这仅仅指的是普通的成员函数，类的构造函数不能被继承</p>
</li>
<li><p>构造函数不能被继承是有道理的，因为即使继承了，它的名字和派生类的名字也不一样，不能成为派生类的构造函数，当然更不能成为普通的成员函数</p>
</li>
</ol>
<h2 id="问题所在"><a href="#问题所在" class="headerlink" title="问题所在"></a>问题所在</h2><p>设计派生类时，对继承过来的成员变量的初始化工作也要由派生类的构造函数完成，但是大部分基类都有 private 属性的成员变量，它们在派生类中无法访问，更不能使用派生类的构造函数来初始化。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>在派生类的构造函数中调用基类的构造函数。</p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//基类People</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">char</span> *m_name;</span><br><span class="line">    <span class="type">int</span> m_age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">People</span>(<span class="type">char</span>*, <span class="type">int</span>);</span><br><span class="line">&#125;;</span><br><span class="line">People::<span class="built_in">People</span>(<span class="type">char</span> *name, <span class="type">int</span> age): <span class="built_in">m_name</span>(name), <span class="built_in">m_age</span>(age)&#123;&#125;</span><br><span class="line"><span class="comment">//派生类Student</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>: <span class="keyword">public</span> People&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">float</span> m_score;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Student</span>(<span class="type">char</span> *name, <span class="type">int</span> age, <span class="type">float</span> score);</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//People(name, age)就是调用基类的构造函数</span></span><br><span class="line">Student::<span class="built_in">Student</span>(<span class="type">char</span> *name, <span class="type">int</span> age, <span class="type">float</span> score): <span class="built_in">People</span>(name, age), <span class="built_in">m_score</span>(score)&#123; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Student::display</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;m_name&lt;&lt;<span class="string">&quot;的年龄是&quot;</span>&lt;&lt;m_age&lt;&lt;<span class="string">&quot;，成绩是&quot;</span>&lt;&lt;m_score&lt;&lt;<span class="string">&quot;。&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Student <span class="title">stu</span><span class="params">(<span class="string">&quot;小明&quot;</span>, <span class="number">16</span>, <span class="number">90.5</span>)</span></span>;</span><br><span class="line">    stu.<span class="built_in">display</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小明的年龄是<span class="number">16</span>，成绩是<span class="number">90.5</span>。</span><br></pre></td></tr></table></figure>



<h2 id="调用顺序（面试常考）"><a href="#调用顺序（面试常考）" class="headerlink" title="调用顺序（面试常考）"></a>调用顺序（面试常考）</h2><p>基类构造函数总是被优先调用，这说明创建派生类对象时，会先调用基类构造函数，再调用派生类构造函数，如果继承关系有好几层的话，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A --&gt; B --&gt; C</span><br></pre></td></tr></table></figure>

<p>那么创建 C 类对象时构造函数的执行顺序为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A类构造函数 --&gt; B类构造函数 --&gt; C类构造函数</span><br></pre></td></tr></table></figure>

<p>构造函数的调用顺序是按照继承的层次自顶向下、从基类再到派生类的。</p>
<p><code>如果从下到上，则会出现一个变量被初始化很多次的情况</code></p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>派生类构造函数中只能调用直接基类的构造函数，<code>不能调用间接基类</code>的。以上面的 A、B、C 类为例，C 是最终的派生类，B 就是 C 的直接基类，A 就是 C 的间接基类。  </p>
<p>C++ 这样规定是有道理的，因为我们在 C 中调用了 B 的构造函数，B 又调用了 A 的构造函数，相当于 C 间接地（或者说隐式地）调用了 A 的构造函数，如果再在 C 中显式地调用 A 的构造函数，那么 A 的构造函数就被调用了两次，相应地，初始化工作也做了两次，这不仅是多余的，还会浪费CPU时间以及内存，毫无益处，所以 C++ 禁止在 C 中显式地调用 A 的构造函数。</p>
<h1 id="继承中的构造函数-1"><a href="#继承中的构造函数-1" class="headerlink" title="继承中的构造函数"></a>继承中的构造函数</h1><p>和构造函数类似，析构函数也不能被继承。</p>
<p>与构造函数不同的是，在派生类的析构函数中不用显式地调用基类的析构函数，因为每个类只有一个析构函数，编译器知道如何选择，无需程序员干涉。</p>
<h2 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h2><p>虚函数中需要声明析构函数为虚函数，以免出现基类指针调用子类对象，销毁时只调用基类析构函数，导致子类中部分成员变量没有被销毁。导致内存泄漏。</p>
<h2 id="析构函数的执行顺序"><a href="#析构函数的执行顺序" class="headerlink" title="析构函数的执行顺序"></a>析构函数的执行顺序</h2><p>析构函数的执行顺序和构造函数的执行顺序也刚好相反：</p>
<ul>
<li>创建派生类对象时，构造函数的执行顺序和继承顺序相同，即先执行基类构造函数，再执行派生类构造函数。</li>
<li>而销毁派生类对象时，析构函数的执行顺序和继承顺序相反，即先执行派生类析构函数，再执行基类析构函数。</li>
</ul>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>()&#123;cout&lt;&lt;<span class="string">&quot;A constructor&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">    ~<span class="built_in">A</span>()&#123;cout&lt;&lt;<span class="string">&quot;A destructor&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>: <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>()&#123;cout&lt;&lt;<span class="string">&quot;B constructor&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">    ~<span class="built_in">B</span>()&#123;cout&lt;&lt;<span class="string">&quot;B destructor&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>: <span class="keyword">public</span> B&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">C</span>()&#123;cout&lt;&lt;<span class="string">&quot;C constructor&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">    ~<span class="built_in">C</span>()&#123;cout&lt;&lt;<span class="string">&quot;C destructor&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    C test;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">A constructor</span><br><span class="line">B constructor</span><br><span class="line">C constructor</span><br><span class="line">C destructor</span><br><span class="line">B destructor</span><br><span class="line">A destructor</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/09/30/C-%E8%99%9A%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="williny">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Williny'home">
      <meta itemprop="description" content="孤独是人生的常态">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Williny'home">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/09/30/C-%E8%99%9A%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">C++-虚函数</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-09-30 09:39:13" itemprop="dateCreated datePublished" datetime="2022-09-30T09:39:13+08:00">2022-09-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-10-02 10:56:24" itemprop="dateModified" datetime="2022-10-02T10:56:24+08:00">2022-10-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>虚函数的本质是体现了C++的多态性。</p>
<p>所谓多态性是什么呢？</p>
<p>用<strong>基类</strong>的指针指向其<strong>派生类</strong>的实例，然后通过<strong>基类</strong>的指针调用实际<strong>派生类</strong>的成员函数</p>
<p>虚函数就是实现这个效果的一种函数</p>
<p>如果没有虚函数，那么在基类中的指针只能调用子类中的成员变量而不能调用其成员函数。</p>
<h1 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h1><h2 id="virtual"><a href="#virtual" class="headerlink" title="virtual"></a>virtual</h2><p>虚函数的使用非常简单，只需要在函数声明前加上<code>virtual</code>关键字即可</p>
<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ol>
<li><p>只需要在虚函数的声明处加上 virtual 关键字，函数定义处可以加也可以不加。</p>
</li>
<li><p>当在基类中定义了虚函数时，如果派生类没有定义新的函数来遮蔽此函数，那么将使用基类的虚函数。</p>
</li>
<li><p>析构函数可以声明为虚函数，而且有时候必须要声明为虚函数</p>
</li>
<li><p>通过基类的指针只能访问从基类继承过去的成员，不能访问派生类新增的成员。</p>
</li>
<li><p>构造函数不能是虚函数。对于基类的构造函数，它仅仅是在派生类构造函数中被调用，这种机制不同于继承。也就是说，派生类不继承基类的构造函数，将构造函数声明为虚函数没有什么意义。</p>
</li>
<li><p>只有派生类的虚函数覆盖基类的虚函数（函数原型相同）才能构成多态（通过基类指针访问派生类函数）。例如基类虚函数的原型为<code>virtual void func();</code>，派生类虚函数的原型为<code>virtual void func(int);</code>，那么当基类指针 p 指向派生类对象时，语句<code>p -&gt; func(100);</code>将会出错，而语句<code>p -&gt; func();</code>将调用基类的函数。</p>
</li>
</ol>
<h3 id="继承关系中虚函数"><a href="#继承关系中虚函数" class="headerlink" title="继承关系中虚函数"></a>继承关系中虚函数</h3><p>此时只需要在父类中的虚函数前面加上<code>virtual</code>即可</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>()&#123;&#125;;</span><br><span class="line">    ~<span class="built_in">A</span>()&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;I am A!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:<span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>()&#123;&#125;;</span><br><span class="line">    ~<span class="built_in">B</span>()&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;I am B!&quot;</span>&lt;&lt;endl;    </span><br><span class="line">    &#125;        </span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;hello world&quot;</span>&lt;&lt;endl;</span><br><span class="line">    A atr, *ptr;</span><br><span class="line">    B btr;</span><br><span class="line">    <span class="comment">//指向基类A</span></span><br><span class="line">    ptr = &amp;atr;</span><br><span class="line">    ptr-&gt;<span class="built_in">show</span>();</span><br><span class="line">    <span class="comment">//指向派生类B</span></span><br><span class="line">    ptr = &amp;btr;</span><br><span class="line">    ptr-&gt;<span class="built_in">show</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&gt;nul&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">I am A！</span><br><span class="line">I am B！</span><br></pre></td></tr></table></figure>

<h3 id="非继承关系中虚函数"><a href="#非继承关系中虚函数" class="headerlink" title="非继承关系中虚函数"></a>非继承关系中虚函数</h3><ul>
<li><p>如果要不通过继承关系也实现出运行时多态的效果，则需要将两个不同类的同名函数<code>都加上virtual关键字</code></p>
</li>
<li><p>同时，需要将定义的指针指向其他对象时，要进行<code>强制类型转换</code>。（因为两个类已经没有继承关系了，不能通过赋值兼容规则进行自动转换，所以要强制转化。）</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//A类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>()&#123;&#125;;</span><br><span class="line">    ~<span class="built_in">A</span>()&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;I am A!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//B类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>()&#123;&#125;;</span><br><span class="line">    ~<span class="built_in">B</span>()&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;I am B!&quot;</span>&lt;&lt;endl;    </span><br><span class="line">    &#125;        </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;hello world&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//A类对象和A类指针</span></span><br><span class="line">    A atr, *ptr;</span><br><span class="line">    <span class="comment">//B类对象</span></span><br><span class="line">    B btr;</span><br><span class="line">    <span class="comment">//指针指向A类对象</span></span><br><span class="line">    ptr = &amp;atr;</span><br><span class="line">    ptr-&gt;<span class="built_in">show</span>();</span><br><span class="line">    <span class="comment">//指针指向B类对象时需要强制类型转换</span></span><br><span class="line">    ptr = (A*)&amp;btr;</span><br><span class="line">    ptr-&gt;<span class="built_in">show</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&gt;nul&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">I am A！</span><br><span class="line">I am B！</span><br></pre></td></tr></table></figure>

<h2 id="为什么调用普通函数比调用虚函数的效率高？"><a href="#为什么调用普通函数比调用虚函数的效率高？" class="headerlink" title="为什么调用普通函数比调用虚函数的效率高？"></a>为什么调用普通函数比调用虚函数的效率高？</h2><p>因为普通函数是静态联编的，而调用虚函数是动态联编的。</p>
<ul>
<li><p>联编的作用：程序调用函数，编译器决定使用哪个可执行代码块。（所谓<code>联编</code>就是将函数名和函数体的程序连接到一起的过程）</p>
</li>
<li><p>静态联编 ：<code>在编译的时候就确定了函数的地址</code>，然后call就调用了。</p>
</li>
<li><p>（静态联编本质是系统用实参与形参进行匹配，对于重名的重载函数根据参数上的差异进行区分，然后进行联编，从而实现编译时的多态。函数的选择基于指向对象的指针类型或者引用类型。）</p>
</li>
<li><p>动态联编 ： <code>首先需要取到对象的首地址，然后再解引用取到虚函数表的首地址后，再加上偏移量才能找到要调的虚函数</code>，然后call调用。</p>
</li>
<li><p>（动态联编本质上是运行阶段执行的联编，当程序调用某一个函数时，系统会根据当前的对象类型去寻找和连接其程序的代码。函数的选择基于对象的类型。）</p>
</li>
</ul>
<h1 id="虚函数表"><a href="#虚函数表" class="headerlink" title="虚函数表"></a>虚函数表</h1><p>如果一个类包含了虚函数，那么在创建该类的对象时就会额外地增加一个数组，数组中的每一个元素都是虚函数的入口地址。</p>
<p>不过数组和对象是分开存储的，为了将对象和数组关联起来，编译器还要在对象中安插一个指针，指向数组的起始位置。这里的数组就是虚函数表（Virtual function table），简写为<code>vtable</code></p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//People类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">People</span>(string name, <span class="type">int</span> age);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">eating</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    string m_name;</span><br><span class="line">    <span class="type">int</span> m_age;</span><br><span class="line">&#125;;</span><br><span class="line">People::<span class="built_in">People</span>(string name, <span class="type">int</span> age): <span class="built_in">m_name</span>(name), <span class="built_in">m_age</span>(age)&#123; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">People::display</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Class People：&quot;</span>&lt;&lt;m_name&lt;&lt;<span class="string">&quot;今年&quot;</span>&lt;&lt;m_age&lt;&lt;<span class="string">&quot;岁了。&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">People::eating</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Class People：我正在吃饭，请不要跟我说话...&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Student类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>: <span class="keyword">public</span> People&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Student</span>(string name, <span class="type">int</span> age, <span class="type">float</span> score);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">examing</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">float</span> m_score;</span><br><span class="line">&#125;;</span><br><span class="line">Student::<span class="built_in">Student</span>(string name, <span class="type">int</span> age, <span class="type">float</span> score):</span><br><span class="line">    <span class="built_in">People</span>(name, age), <span class="built_in">m_score</span>(score)&#123; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Student::display</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Class Student：&quot;</span>&lt;&lt;m_name&lt;&lt;<span class="string">&quot;今年&quot;</span>&lt;&lt;m_age&lt;&lt;<span class="string">&quot;岁了，考了&quot;</span>&lt;&lt;m_score&lt;&lt;<span class="string">&quot;分。&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Student::examing</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Class Student：&quot;</span>&lt;&lt;m_name&lt;&lt;<span class="string">&quot;正在考试，请不要打扰T啊！&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Senior类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Senior</span>: <span class="keyword">public</span> Student&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Senior</span>(string name, <span class="type">int</span> age, <span class="type">float</span> score, <span class="type">bool</span> hasJob);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">partying</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">bool</span> m_hasJob;</span><br><span class="line">&#125;;</span><br><span class="line">Senior::<span class="built_in">Senior</span>(string name, <span class="type">int</span> age, <span class="type">float</span> score, <span class="type">bool</span> hasJob):</span><br><span class="line">    <span class="built_in">Student</span>(name, age, score), <span class="built_in">m_hasJob</span>(hasJob)&#123; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Senior::display</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_hasJob)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Class Senior：&quot;</span>&lt;&lt;m_name&lt;&lt;<span class="string">&quot;以&quot;</span>&lt;&lt;m_score&lt;&lt;<span class="string">&quot;的成绩从大学毕业了，并且顺利找到了工作，Ta今年&quot;</span>&lt;&lt;m_age&lt;&lt;<span class="string">&quot;岁。&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Class Senior：&quot;</span>&lt;&lt;m_name&lt;&lt;<span class="string">&quot;以&quot;</span>&lt;&lt;m_score&lt;&lt;<span class="string">&quot;的成绩从大学毕业了，不过找工作不顺利，Ta今年&quot;</span>&lt;&lt;m_age&lt;&lt;<span class="string">&quot;岁。&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Senior::partying</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Class Senior：快毕业了，大家都在吃散伙饭...&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    People *p = <span class="keyword">new</span> <span class="built_in">People</span>(<span class="string">&quot;赵红&quot;</span>, <span class="number">29</span>);</span><br><span class="line">    p -&gt; <span class="built_in">display</span>();</span><br><span class="line">    p = <span class="keyword">new</span> <span class="built_in">Student</span>(<span class="string">&quot;王刚&quot;</span>, <span class="number">16</span>, <span class="number">84.5</span>);</span><br><span class="line">    p -&gt; <span class="built_in">display</span>();</span><br><span class="line">    p = <span class="keyword">new</span> <span class="built_in">Senior</span>(<span class="string">&quot;李智&quot;</span>, <span class="number">22</span>, <span class="number">92.0</span>, <span class="literal">true</span>);</span><br><span class="line">    p -&gt; <span class="built_in">display</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class People：赵红今年<span class="number">29</span>岁了。</span><br><span class="line">Class Student：王刚今年<span class="number">16</span>岁了，考了<span class="number">84.5</span>分。</span><br><span class="line">Class Senior：李智以<span class="number">92</span>的成绩从大学毕业了，并且顺利找到了工作，Ta今年<span class="number">22</span>岁。</span><br></pre></td></tr></table></figure>

<h2 id="各个类的对象内存模型"><a href="#各个类的对象内存模型" class="headerlink" title="各个类的对象内存模型"></a>各个类的对象内存模型</h2><p><img src="http://c.biancheng.net/uploads/allimg/190215/14431Q529-0.jpg"></p>
<p>图中左半部分是对象占用的内存，右半部分是虚函数表 vtable。在对象的开头位置有一个指针 vfptr，指向虚函数表，并且这个指针始终位于对象的开头位置。</p>
<h2 id="为什么要用虚函数表（存函数指针的数组）？"><a href="#为什么要用虚函数表（存函数指针的数组）？" class="headerlink" title="为什么要用虚函数表（存函数指针的数组）？"></a>为什么要用虚函数表（存函数指针的数组）？</h2><ul>
<li><p>同一个类的多个对象的虚函数表是同一个，所以这样就可以节省空间</p>
</li>
<li><p>一个类自己的虚函数和继承的虚函数还有重写父类的虚函数都会存在自己的虚函数表</p>
</li>
<li><p>虚函数表本质是一个地图导航，可以清楚告诉一个想要操作子类的父类指针到底该使用哪个函数</p>
</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>虚函数表是一个单独存储的数组，数组中的每个元素都是虚函数的入口地址。</p>
<p>对象表中的第一个元素位置会生成一个指针，指向虚函数表的第一个位置。</p>
<h1 id="虚析构函数的必要性与虚构造函数"><a href="#虚析构函数的必要性与虚构造函数" class="headerlink" title="虚析构函数的必要性与虚构造函数"></a>虚析构函数的必要性与虚构造函数</h1><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><ol>
<li><p>构造函数不能是虚函数</p>
<ul>
<li><p>因为派生类不能继承基类的构造函数，将构造函数声明为虚函数没有意义</p>
</li>
<li><p>构造函数用于在创建对象时进行初始化工作，在执行构造函数之前对象尚未创建完成，虚函数表尚不存在，也没有指向虚函数表的指针，所以此时无法查询虚函数表，也就不知道要调用哪一个构造函数。</p>
</li>
</ul>
</li>
<li><p>析构函数用于在销毁对象时进行清理工作，可以声明为虚函数，而且有时候必须要声明为虚函数</p>
<ul>
<li><p>基类的指针只会调用基类的析构函数，不会调用子类的析构函数，这样就会导致子类中的内存空间得不到释放</p>
</li>
<li><p>在实际开发中，一旦我们自己定义了析构函数，就是希望在对象销毁时用它来进行清理工作，比如释放内存、关闭文件等，如果这个类又是一个基类，那么我们就必须将该析构函数声明为虚函数，否则就有内存泄露的风险。也就是说，大部分情况下都应该将基类的析构函数声明为虚函数。</p>
</li>
</ul>
</li>
</ol>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>();</span><br><span class="line">    ~<span class="built_in">Base</span>();</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">char</span> *str;</span><br><span class="line">&#125;;</span><br><span class="line">Base::<span class="built_in">Base</span>()&#123;</span><br><span class="line">    str = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">100</span>];</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Base constructor&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">Base::~<span class="built_in">Base</span>()&#123;</span><br><span class="line">    <span class="keyword">delete</span>[] str;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Base destructor&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//派生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>();</span><br><span class="line">    ~<span class="built_in">Derived</span>();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">&#125;;</span><br><span class="line">Derived::<span class="built_in">Derived</span>()&#123;</span><br><span class="line">    name = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">100</span>];</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Derived constructor&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">Derived::~<span class="built_in">Derived</span>()&#123;</span><br><span class="line">    <span class="keyword">delete</span>[] name;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Derived destructor&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   Base *pb = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">   <span class="keyword">delete</span> pb;</span><br><span class="line">   cout&lt;&lt;<span class="string">&quot;-------------------&quot;</span>&lt;&lt;endl;</span><br><span class="line">   Derived *pd = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">   <span class="keyword">delete</span> pd;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Base constructor</span><br><span class="line">Derived constructor</span><br><span class="line">Base destructor</span><br><span class="line">-------------------</span><br><span class="line">Base constructor</span><br><span class="line">Derived constructor</span><br><span class="line">Derived destructor</span><br><span class="line">Base destructor</span><br></pre></td></tr></table></figure>

<p>语句<code>delete pb;</code>只调用了基类的析构函数，没有调用派生类的析构函数；而语句<code>delete pd;</code>同时调用了派生类和基类的析构函数。</p>
<p>在本例中，不调用派生类的析构函数会导致 name 指向的 100 个 char 类型的内存空间得不到释放；除非程序运行结束由操作系统回收，否则就再也没有机会释放这些内存。这是典型的内存泄露。</p>
<h1 id="纯虚函数和抽象类"><a href="#纯虚函数和抽象类" class="headerlink" title="纯虚函数和抽象类"></a>纯虚函数和抽象类</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>可以将虚函数声明为<code>纯虚函数</code>，语法格式为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">virtual</span> 返回值类型 函数名 (函数参数) = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>纯虚函数没有函数体，只有函数声明，在虚函数声明的结尾加上<code>=0</code>，表明此函数为纯虚函数。</p>
<p>包含纯虚函数的类称为<code>抽象类（Abstract Class）</code>。之所以说它抽象，是因为它无法实例化，也就是无法创建对象。原因很明显，纯虚函数没有函数体，不是完整的函数，无法调用，也无法为其分配内存空间。</p>
<p>抽象类通常是作为基类，让派生类去实现纯虚函数。派生类必须实现纯虚函数才能被实例化</p>
<p>在实际开发中，你可以定义一个抽象基类，只完成部分功能，未完成的功能交给派生类去实现（谁派生谁实现）。这部分未完成的功能，往往是基类不需要的，或者在基类中无法实现的。虽然抽象基类没有完成，但是却强制要求派生类完成，这就是抽象基类的“霸王条款”。</p>
<h2 id="关于纯虚函数的几点说明"><a href="#关于纯虚函数的几点说明" class="headerlink" title="关于纯虚函数的几点说明"></a>关于纯虚函数的几点说明</h2><ol>
<li>一个纯虚函数就可以使类成为抽象基类，但是抽象基类中除了包含纯虚函数外，还可以包含其它的成员函数（虚函数或普通函数）和成员变量。  </li>
<li><code>只有类中的虚函数才能被声明为纯虚函数</code>，普通成员函数和顶层函数均不能声明为纯虚函数。如下例所示：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//顶层函数不能被声明为纯虚函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span> </span>= <span class="number">0</span>;   <span class="comment">//compile error</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">base</span>&#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    <span class="comment">//普通成员函数不能被声明为纯虚函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>= <span class="number">0</span>;  <span class="comment">//compile error</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/18/">18</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">williny</span>
</div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  





</body>
</html>
