<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.1.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.0.0/css/all.min.css" integrity="sha256-jTIdiMuX/e3DGJUGwl3pKSxuc6YOuqtJYkM0bGQESA4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.10.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="孤独是人生的常态">
<meta property="og:type" content="website">
<meta property="og:title" content="Williny&#39;home">
<meta property="og:url" content="http://example.com/page/13/index.html">
<meta property="og:site_name" content="Williny&#39;home">
<meta property="og:description" content="孤独是人生的常态">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="williny">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/13/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/13/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Williny'home</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Williny'home</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="williny"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">williny</p>
  <div class="site-description" itemprop="description">孤独是人生的常态</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">145</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/suchangche" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;suchangche" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:469478061@qq.com" title="E-Mail → mailto:469478061@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/06/UE4-Player-Controlled-Cameras/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="williny">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Williny'home">
      <meta itemprop="description" content="孤独是人生的常态">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Williny'home">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/05/06/UE4-Player-Controlled-Cameras/" class="post-title-link" itemprop="url">UE4-Player-Controlled Cameras</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-05-06 09:31:10 / 修改时间：11:13:24" itemprop="dateCreated datePublished" datetime="2022-05-06T09:31:10+08:00">2022-05-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/unreal-engine/" itemprop="url" rel="index"><span itemprop="name">unreal engine</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>今天是官方案例<a href="(https://docs.unrealengine.com/4.27/zh-CN/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/PlayerCamera/">Player-Controlled Cameras</a></p>
<h1 id="给我整无语了"><a href="#给我整无语了" class="headerlink" title="给我整无语了"></a>给我整无语了</h1><p>我现在使用的是4.27的版本文档，我是真的服了官方写这个文档的家伙了，咱作为萌新吧，看这玩意，学习顺序安排得不合理就算了，很多项目拿着官方给出的代码都运行不出来，真的是太无语了。</p>
<p>这一节最明显的一个错误——<code># include &quot;Camera/Component.h&quot;</code>根本没这个头文件啊！兄弟！真的无语了，头文件都打错了，原本的头文件名为<code># include &quot;Camera/CameraComponent.h&quot;</code>!</p>
<p>可恶！负责官方文档编写的人得扣工资，你说这种问题，是一个正常程序员能犯得错误嘛？</p>
<p>tnnd，跟我玩阴的是吧？你爹我是来学习的还是来给你纠错的？f**k u！</p>
<p>除了以上错误，还有别的我没发现的，我估摸着可能是头文件的问题，但是也懒得找了。</p>
<p>我就单分析代码实现当中的API和一些实现逻辑好了。</p>
<h1 id="摄像机连接到Pawn"><a href="#摄像机连接到Pawn" class="headerlink" title="摄像机连接到Pawn"></a>摄像机连接到Pawn</h1><p>直接上代码</p>
<h2 id="PawnWithCamera-h"><a href="#PawnWithCamera-h" class="headerlink" title="PawnWithCamera.h"></a>PawnWithCamera.h</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CoreMinimal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GameFramework/Pawn.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;PawnWithCamera.generated.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HOWTO_PLAYERCAMERA_API</span> APawnWithCamera : <span class="keyword">public</span> APawn</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 为Pawn的属性设置默认值</span></span><br><span class="line">    <span class="built_in">APawnWithCamera</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// 游戏开始时或对象生成时调用</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BeginPlay</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 每帧调用</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Tick</span><span class="params">( <span class="type">float</span> DeltaSeconds )</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于绑定功能和输入</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SetupPlayerInputComponent</span><span class="params">(<span class="keyword">class</span> UInputComponent* InputComponent)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">USpringArmComponent</span>* SpringArmComp;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">UCameraComponent</span>* CameraComp;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UPROPERTY</span>(EditAnywhere)</span><br><span class="line">    UStaticMeshComponent* StaticMeshComp;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>头文件的变化仅在于声明了弹簧臂组件类和摄像机组件类以及一个静态网格体组件</p>
<h2 id="PawnWithCamera-cpp"><a href="#PawnWithCamera-cpp" class="headerlink" title="PawnWithCamera.cpp"></a>PawnWithCamera.cpp</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;HowTo_PlayerCamera.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;PawnWithCamera.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GameFramework/SpringArmComponent.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Camera/CameraComponent.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置默认值</span></span><br><span class="line">APawnWithCamera::<span class="built_in">APawnWithCamera</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 让这个Pawn每帧调用Tick()。如不需要，你可以关闭这个函数以便提升性能。</span></span><br><span class="line">    PrimaryActorTick.bCanEverTick = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建组件</span></span><br><span class="line">    RootComponent = <span class="built_in">CreateDefaultSubobject</span>&lt;USceneComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;RootSceneComponent&quot;</span>));</span><br><span class="line">    StaticMeshComp = CreateDefaultSubobject &lt;UStaticMeshComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;StaticMeshComponent&quot;</span>));</span><br><span class="line">    SpringArmComp = <span class="built_in">CreateDefaultSubobject</span>&lt;USpringArmComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;SpringArmComponent&quot;</span>));</span><br><span class="line">    CameraComp = <span class="built_in">CreateDefaultSubobject</span>&lt;UCameraComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;CameraComponent&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定组件</span></span><br><span class="line">    StaticMeshComp-&gt;<span class="built_in">SetupAttachment</span>(RootComponent);</span><br><span class="line">    SpringArmComp-&gt;<span class="built_in">SetupAttachment</span>(StaticMeshComp);</span><br><span class="line">    CameraComp-&gt;<span class="built_in">SetupAttachment</span>(SpringArmComp,USpringArmComponent::SocketName);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为SpringArm类的变量赋值</span></span><br><span class="line">    SpringArmComp-&gt;<span class="built_in">SetRelativeLocationAndRotation</span>(<span class="built_in">FVector</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">50.0f</span>), <span class="built_in">FRotator</span>(<span class="number">-60.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>));</span><br><span class="line">    SpringArmComp-&gt;TargetArmLength = <span class="number">400.f</span>;</span><br><span class="line">    SpringArmComp-&gt;bEnableCameraLag = <span class="literal">true</span>;</span><br><span class="line">    SpringArmComp-&gt;CameraLagSpeed = <span class="number">3.0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 控制默认玩家</span></span><br><span class="line">    AutoPossessPlayer = EAutoReceiveInput::Player0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 游戏开始时或对象生成时调用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">APawnWithCamera::BeginPlay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">BeginPlay</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每帧调用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">APawnWithCamera::Tick</span><span class="params">( <span class="type">float</span> DeltaTime )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">Tick</span>( DeltaTime );</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于绑定功能和输入</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">APawnWithCamera::SetupPlayerInputComponent</span><span class="params">(<span class="keyword">class</span> UInputComponent* InputComponent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">SetupPlayerInputComponent</span>(InputComponent);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="首先创建组件"><a href="#首先创建组件" class="headerlink" title="首先创建组件"></a>首先创建组件</h3><ul>
<li>根组件，静态网格体组件，弹簧臂组件，摄像机组件</li>
</ul>
<h3 id="然后绑定组件"><a href="#然后绑定组件" class="headerlink" title="然后绑定组件"></a>然后绑定组件</h3><ul>
<li><p>将静态网格体组件绑定在根组件之下，保证更新的是静态网格体</p>
</li>
<li><p>将弹簧臂组件绑定在静态网格体之下</p>
</li>
<li><p>再将摄像机插入弹簧臂的插槽上</p>
</li>
</ul>
<h3 id="接下来设置弹簧臂类的变量值"><a href="#接下来设置弹簧臂类的变量值" class="headerlink" title="接下来设置弹簧臂类的变量值"></a>接下来设置弹簧臂类的变量值</h3><ul>
<li><p>首先设置相对位置和角度</p>
</li>
<li><p>弹簧臂长度</p>
</li>
<li><p>启用弹簧臂平滑切换</p>
</li>
<li><p>设置平滑切换时间</p>
</li>
</ul>
<h3 id="最后是将默认玩家设置一下"><a href="#最后是将默认玩家设置一下" class="headerlink" title="最后是将默认玩家设置一下"></a>最后是将默认玩家设置一下</h3><p>单人的话，默认玩家编号为Player0</p>
<h1 id="定义输入函数和绑定操作"><a href="#定义输入函数和绑定操作" class="headerlink" title="定义输入函数和绑定操作"></a>定义输入函数和绑定操作</h1><p>前面的配置输入我就不讲了，之前的博客里面讲的很详细，或者去官网看看也可以，基本上没啥错误。这里直接过一下绑定输入操作。</p>
<h2 id="声明成员变量和成员函数"><a href="#声明成员变量和成员函数" class="headerlink" title="声明成员变量和成员函数"></a>声明成员变量和成员函数</h2><p>首先我们需要定义一些成员变量来存储接收到的输入数据</p>
<ul>
<li><p>在帧更新的时候，我们需要获取移动数据和鼠标轴的移动方向数据，这都是二维向量类型的数值</p>
</li>
<li><p>还有摄像机画面是要放大还是缩小，以及摄像机当前状态距离到达这两种状态还有多少距离</p>
</li>
</ul>
<p>所以我们在.h文件的protected:下定义以下代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输入变量</span></span><br><span class="line">FVector2D MovementInput;<span class="comment">//移动数据</span></span><br><span class="line">FVector2D CameraInput;<span class="comment">//鼠标轴的移动方向数据</span></span><br><span class="line"><span class="type">float</span> ZoomFactor;<span class="comment">//距离放大缩小还有多远</span></span><br><span class="line"><span class="type">bool</span> bZoomingIn;<span class="comment">//放大还是缩小</span></span><br></pre></td></tr></table></figure>



<p>还需要创建函数来跟踪输入，所以我们在.h中声明以下函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输入函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MoveForward</span><span class="params">(<span class="type">float</span> AxisValue)</span></span>;<span class="comment">//前后移动</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MoveRight</span><span class="params">(<span class="type">float</span> AxisValue)</span></span>;<span class="comment">//左右移动</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PitchCamera</span><span class="params">(<span class="type">float</span> AxisValue)</span></span>;<span class="comment">//绕Y轴旋转（上下颠簸）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">YawCamera</span><span class="params">(<span class="type">float</span> AxisValue)</span></span>;<span class="comment">//绕Z轴旋转（左右拐弯）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ZoomIn</span><span class="params">()</span></span>;<span class="comment">//放大</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ZoomOut</span><span class="params">()</span></span>;<span class="comment">//缩小</span></span><br></pre></td></tr></table></figure>



<p>1 Roll 是自身旋转<br>2 Yaw 是左右拐弯<br>3 pitch 是上下颠动</p>
<h2 id="定义成员函数"><a href="#定义成员函数" class="headerlink" title="定义成员函数"></a>定义成员函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输入函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">APawnWithCamera::MoveForward</span><span class="params">(<span class="type">float</span> AxisValue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MovementInput.X = FMath::<span class="built_in">Clamp</span>&lt;<span class="type">float</span>&gt;(AxisValue, <span class="number">-1.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">APawnWithCamera::MoveRight</span><span class="params">(<span class="type">float</span> AxisValue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MovementInput.Y = FMath::<span class="built_in">Clamp</span>&lt;<span class="type">float</span>&gt;(AxisValue, <span class="number">-1.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">APawnWithCamera::PitchCamera</span><span class="params">(<span class="type">float</span> AxisValue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CameraInput.Y = AxisValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">APawnWithCamera::YawCamera</span><span class="params">(<span class="type">float</span> AxisValue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CameraInput.X = AxisValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">APawnWithCamera::ZoomIn</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bZoomingIn = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">APawnWithCamera::ZoomOut</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bZoomingIn = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>值得一提的是<code>Clamp&lt;float&gt;(AxisValue, -1.0f, 1.0f);</code>在前面的章节中我讲得不清楚，现在终于弄明白了！</p>
<p>&lt;&gt;内是参数类型，</p>
<p><code>Clamp(const FVector4 &amp; VectorToClamp, float Min, float Max)</code>是其函数原型</p>
<ul>
<li><p>这个Clamp其实看作是一种运算，可以把它看成一个一元一次方程</p>
</li>
<li><p>VectorToClamp就是这个方程的X，最后得出的Y</p>
</li>
<li><p>MIN 和MAX是设定的最大值和最小值</p>
</li>
<li><p>Y一定在MIN和MAX之间</p>
</li>
</ul>
<h2 id="绑定轴映射事件和按键映射事件"><a href="#绑定轴映射事件和按键映射事件" class="headerlink" title="绑定轴映射事件和按键映射事件"></a>绑定轴映射事件和按键映射事件</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 绑定&quot;ZoomIn&quot;的事件</span></span><br><span class="line">InputComponent-&gt;<span class="built_in">BindAction</span>(<span class="string">&quot;ZoomIn&quot;</span>, IE_Pressed, <span class="keyword">this</span>, &amp;APawnWithCamera::ZoomIn);</span><br><span class="line">InputComponent-&gt;<span class="built_in">BindAction</span>(<span class="string">&quot;ZoomIn&quot;</span>, IE_Released, <span class="keyword">this</span>, &amp;APawnWithCamera::ZoomOut);</span><br><span class="line"></span><br><span class="line"><span class="comment">//为四条轴绑定事件（每帧调用）</span></span><br><span class="line">InputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="string">&quot;MoveForward&quot;</span>, <span class="keyword">this</span>, &amp;APawnWithCamera::MoveForward);</span><br><span class="line">InputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="string">&quot;MoveRight&quot;</span>, <span class="keyword">this</span>, &amp;APawnWithCamera::MoveRight);</span><br><span class="line">InputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="string">&quot;CameraPitch&quot;</span>, <span class="keyword">this</span>, &amp;APawnWithCamera::PitchCamera);</span><br><span class="line">InputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="string">&quot;CameraYaw&quot;</span>, <span class="keyword">this</span>, &amp;APawnWithCamera::YawCamera);</span><br></pre></td></tr></table></figure>

<p>这个在之前博客里已经讲得很详细了，就不再赘述。</p>
<h2 id="在Tick事件内绑定放大缩小"><a href="#在Tick事件内绑定放大缩小" class="headerlink" title="在Tick事件内绑定放大缩小"></a>在Tick事件内绑定放大缩小</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">APawnWithCamera::Tick</span><span class="params">( <span class="type">float</span> DeltaTime )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">Tick</span>(DeltaTime);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按下ZoomIn按钮时进行放大，否则恢复正常</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (bZoomingIn)<span class="comment">//按下按钮事件</span></span><br><span class="line">        &#123;</span><br><span class="line">            ZoomFactor += DeltaTime / <span class="number">0.5f</span>;<span class="comment">//放大0.5秒以上</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//松开按钮事件</span></span><br><span class="line">        &#123;</span><br><span class="line">            ZoomFactor -= DeltaTime / <span class="number">0.25f</span>;<span class="comment">//缩小0.25秒以上</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        ZoomFactor = FMath::<span class="built_in">Clamp</span>&lt;<span class="type">float</span>&gt;(ZoomFactor, <span class="number">0.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">        <span class="comment">// 基于ZoomFactor设置摄像机的视野（范围）和SpringArm的长度 （范围）</span></span><br><span class="line">        CameraComp-&gt;FieldOfView = FMath::<span class="built_in">Lerp</span>&lt;<span class="type">float</span>&gt;(<span class="number">90.0f</span>, <span class="number">60.0f</span>, ZoomFactor);</span><br><span class="line">        SpringArmComp-&gt;TargetArmLength = FMath::<span class="built_in">Lerp</span>&lt;<span class="type">float</span>&gt;(<span class="number">400.0f</span>, <span class="number">300.0f</span>, ZoomFactor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 旋转Actor的偏转角度，由于摄像机与Actor相互绑定，因此摄像机也会偏转</span></span><br><span class="line">    &#123;</span><br><span class="line">        FRotator NewRotation = <span class="built_in">GetActorRotation</span>();</span><br><span class="line">        NewRotation.Yaw += CameraInput.X;</span><br><span class="line">        <span class="built_in">SetActorRotation</span>(NewRotation);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 旋转摄像机的俯仰角度，但对其进行限制，确保我们始终朝下看</span></span><br><span class="line">    &#123;</span><br><span class="line">        FRotator NewRotation = SpringArmComp-&gt;<span class="built_in">GetComponentRotation</span>();</span><br><span class="line">        NewRotation.Pitch = FMath::<span class="built_in">Clamp</span>(NewRotation.Pitch + CameraInput.Y, <span class="number">-80.0f</span>, <span class="number">-15.0f</span>);</span><br><span class="line">        SpringArmComp-&gt;<span class="built_in">SetWorldRotation</span>(NewRotation);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据&quot;MoveX&quot;和&quot;MoveY&quot;的处理移动</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!MovementInput.<span class="built_in">IsZero</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//把移动轴的输入数值放大100倍</span></span><br><span class="line">            MovementInput = MovementInput.<span class="built_in">SafeNormal</span>() * <span class="number">100.0f</span>;</span><br><span class="line">            FVector NewLocation = <span class="built_in">GetActorLocation</span>();</span><br><span class="line">            NewLocation += <span class="built_in">GetActorForwardVector</span>() * MovementInput.X * DeltaTime;</span><br><span class="line">            NewLocation += <span class="built_in">GetActorRightVector</span>() * MovementInput.Y * DeltaTime;</span><br><span class="line">            <span class="built_in">SetActorLocation</span>(NewLocation);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Lerp<float>(MAX,MIN,float Alpha)</p>
<p>Alpha在通过Lerp运算后，得到的结果在MAX和MIN之间</p>
<h3 id="代码逻辑"><a href="#代码逻辑" class="headerlink" title="代码逻辑"></a>代码逻辑</h3><ul>
<li><p>首先我们根据按钮的按下或者松开来对ZoomFactor这个变量进行增加或者减小</p>
</li>
<li><p>然后根据ZoomFactor带入到Clamp来保证其值大于0，小于1</p>
</li>
<li><p>接下来将ZoomFactor带入到Lerp中设置摄像机的视野和弹簧臂的长度（均设置范围）</p>
</li>
<li><p>直接设置Actor的旋转角度，因为摄像机与其绑定，所以会连带着摄像机一同旋转</p>
</li>
<li><p>限定弹簧臂的俯仰角度，确保我们对其一直是俯视状态</p>
<ul>
<li>注意：设置弹簧臂的旋转角度的时候一定要是世界坐标内的旋转角度</li>
</ul>
</li>
<li><p>再就是设置X与Y轴的移动变化</p>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/05/%E4%B8%80%E4%BA%9B%E9%B8%A1%E6%B1%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="williny">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Williny'home">
      <meta itemprop="description" content="孤独是人生的常态">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Williny'home">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/05/05/%E4%B8%80%E4%BA%9B%E9%B8%A1%E6%B1%A4/" class="post-title-link" itemprop="url">一些鸡汤</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-05-05 20:35:08" itemprop="dateCreated datePublished" datetime="2022-05-05T20:35:08+08:00">2022-05-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-05-11 08:36:09" itemprop="dateModified" datetime="2022-05-11T08:36:09+08:00">2022-05-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%A2%A6%E6%B8%B8%E7%AC%94%E8%B0%88/" itemprop="url" rel="index"><span itemprop="name">梦游笔谈</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>这是一篇写给自己看的流水账。</p>
<p>距离上一次靠文字排解自己的心情，已经过了一个月。</p>
<p>在这一个月的时间里面，我过得真的挺充实的，算法的学习完成了一个小的阶段，同时也开始了unreal engine 的学习，上午算法，下午unreal engine，晚上健身和娱乐。每天做着大体相同的事情，但每天都有不同的收获。</p>
<p>相比之前的基础性知识的积累，现在的unreal engine给到我的正向反馈，让我学习兴趣大大增加，也报了<a target="_blank" rel="noopener" href="https://space.bilibili.com/31898841">谌嘉诚</a>的虚幻课程，这个月底就要开始正式进行一个完整的项目了，这让我对未来充满了信心。</p>
<p>再就是健身，这一个月以来，每天坚持健身，特别是每次在镜子里看到我的肌肉线条慢慢明显的时候，就很开心——我要变成猛男了哈哈哈！</p>
<p>虽然也有苦恼的，就是右臂肌肉比左臂大一倍，这一点目前还没有什么很好解决的办法。</p>
<p>偶尔晚上健身完之后我会试试正念冥想——虽然还没有感受到实质性的好处，但是我是在冥想结束后动了写下这篇文字的念头的——这样想来，也许冥想能让我沉静下来，将我原本并未意识到的需求在这时告诉我。</p>
<p>再来说一说社交情况，实话实说，目前为止我基本已经停止了大部分社交活动，也不再出席任何社交场合，室友去图书馆备战考研，我就在寝室自己学自己的，我们一天也见不了几面，晚上回来和我的交流兴许也是寥寥几句。现在我的社交完全就是靠着和高中同学以及发小的吹牛打屁撑着的。本来我以为我会在某一刻崩掉，但是到目前为止，我的状态还算ok。哦，还有一件事，有个高中同学前几天跟对象掰了。来找我倾诉，我能有啥立场？自然是跟他穿一条裤子呗。他可能觉得，我这会是听他倾诉了，他觉得我很铁，但不完全是，我心态没崩可能也和他有关，他在我要崩的那个临界点出现了。也算是相互拉了一把。</p>
<p>还有每天都会在网上看各种各样的美女，因为听说看美女能够益寿延年。</p>
<p>哈哈，果然只有当人处于悲伤的状态下才会文思泉涌，我现在就完全没话说了。</p>
<p>补充一点我的名人名言吧！</p>
<ul>
<li><p>那个下午做出了足以改变人生轨迹的决定，多年后回想起来仍然觉得惊心动魄，只不过当时还以为这只是一个普通平凡的午后。</p>
</li>
<li><p>人类的高贵之处在于克制与忍耐。</p>
</li>
</ul>
<p>那，就这样吧！</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/03/UE4-%E8%93%9D%E5%9B%BE-%E5%BC%80%E5%85%B3%E9%97%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="williny">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Williny'home">
      <meta itemprop="description" content="孤独是人生的常态">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Williny'home">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/05/03/UE4-%E8%93%9D%E5%9B%BE-%E5%BC%80%E5%85%B3%E9%97%A8/" class="post-title-link" itemprop="url">UE4-蓝图-开关门</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-05-03 16:21:55 / 修改时间：17:30:09" itemprop="dateCreated datePublished" datetime="2022-05-03T16:21:55+08:00">2022-05-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/unreal-engine/" itemprop="url" rel="index"><span itemprop="name">unreal engine</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>本博客是根据哔哩哔哩UP主<a target="_blank" rel="noopener" href="https://space.bilibili.com/31898841">谌嘉诚</a>出品的<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV164411Y732?p=28">UE4初学者系列教程合集-全中文新手入门教程</a>进行整理的，他把基础部分和蓝图部分讲解地非常细致而且通俗易懂，有兴趣的可以去看看。</p>
<h1 id="按E键实现开关门"><a href="#按E键实现开关门" class="headerlink" title="按E键实现开关门"></a>按E键实现开关门</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul>
<li><p>我们根据碰撞盒子（box collision）来判断啥时候可以按E开门，也就是进入到这个碰撞盒子的范围的时候，我们就可以按E了</p>
</li>
<li><p>我们在组件面板里面添加一个box collision，然后左键选中它，添加两个碰撞事件——开始重叠和离开重叠</p>
</li>
<li><p>然后我们要明确一点——输入E是要启用输入的！于是创建enable input结点和disable input两个结点来启用和禁用输入，在这个节点上会有player controller这个东西，那就创建一个get palyer controller结点连接上即可！</p>
</li>
<li><p>接下来是流程控制结点gate，启用输入连接到open，禁用输入连接到close，把按键E链接到Enter</p>
</li>
<li><p>后面是另一个流程控制结点——Filp Flop这个东西的意思是，第一次执行则从A点输出，第二次执行则从B点输出，以此往复，后面就可以将AB分别连接到时间轴的play和reverse上，即可实现正向开门和关门了</p>
</li>
<li><p>创建时间轴——创建一个时间轴，双击编辑他并创建一个浮点型轨道“开关门时间轴”，在这里要注意的是——浮点型轨道的长度必须是最后一个关键帧结束的位置</p>
<ul>
<li><p>创建开始结点和结束结点</p>
</li>
<li><p>开始节点时间为0，值为0</p>
</li>
<li><p>结束结点时间为2，值为门旋转的角度</p>
</li>
<li><p>然后右键结点点击自动，让曲线变得平滑</p>
</li>
</ul>
</li>
<li><p>退出之后，我们可以开到在时间轴结点的右下角多了一个“开关门时间轴”的点</p>
</li>
<li><p>设置相对旋转，目标为门，把时间轴的update连接上，并且将xyz中的z轴连接到“关门时间轴”点上</p>
</li>
</ul>
<h2 id="知识点小结"><a href="#知识点小结" class="headerlink" title="知识点小结"></a>知识点小结</h2><p>流程控制：</p>
<ul>
<li><p>启用输入和禁用输入</p>
</li>
<li><p>获取玩家控制器</p>
</li>
<li><p>Gate：启用输入时Open，禁用输入时Close，Enter为按键输入</p>
</li>
<li><p>Flip Flop：第一次输入执行A，第二次输入执行B</p>
</li>
<li><p>时间轴：浮点型轨道的长度要注意</p>
</li>
<li><p>设置相对旋转：与时间旋转不同</p>
</li>
</ul>
<h1 id="鼠标点击实现开关门"><a href="#鼠标点击实现开关门" class="headerlink" title="鼠标点击实现开关门"></a>鼠标点击实现开关门</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>其实跟按E键实现开关门差不多，区别就在于要设置玩家控制器</p>
<p>世界场景设置-&gt;游戏模式-&gt;选中的游戏模式-&gt;玩家控制器类-&gt;新建一个-&gt;启用点击事件</p>
<p>然后在编辑-&gt;项目设置-&gt;地图和模式-&gt;默认玩家控制器-&gt;旋转刚刚创建的那个蓝图类</p>
<p>在“获取玩家控制器”的</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/03/UE4-%E7%AC%AC%E4%B8%80%E4%BA%BA%E7%A7%B0FPS-%E6%80%9D%E8%B7%AF%E5%B0%8F%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="williny">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Williny'home">
      <meta itemprop="description" content="孤独是人生的常态">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Williny'home">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/05/03/UE4-%E7%AC%AC%E4%B8%80%E4%BA%BA%E7%A7%B0FPS-%E6%80%9D%E8%B7%AF%E5%B0%8F%E7%BB%93/" class="post-title-link" itemprop="url">UE4-第一人称FPS-思路小结</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-05-03 08:55:06" itemprop="dateCreated datePublished" datetime="2022-05-03T08:55:06+08:00">2022-05-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-05-30 20:55:14" itemprop="dateModified" datetime="2022-05-30T20:55:14+08:00">2022-05-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/unreal-engine/" itemprop="url" rel="index"><span itemprop="name">unreal engine</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>之前的都是讲解官方文档的代码，属于是微观层面的分析。</p>
<p>现在我们已经跟着官方文档做出了一个简单的第一人称FPS，如果我们要跳出官方的引导，自己做一个的话，从宏观层面的思路分析就很有必要了！</p>
<p>在这里，我基于官方文档的开发流程，将大致思路整理一下</p>
<h1 id="建立项目"><a href="#建立项目" class="headerlink" title="建立项目"></a>建立项目</h1><p>这就很好理解，建立一个空项目嘛！</p>
<h1 id="添加日志信息"><a href="#添加日志信息" class="headerlink" title="添加日志信息"></a>添加日志信息</h1><p>就是在屏幕上打印出日志信息</p>
<h2 id="重载StartPlay"><a href="#重载StartPlay" class="headerlink" title="重载StartPlay()"></a>重载StartPlay()</h2><p>在头文件中声明StartPlay()</p>
<p>然后再cpp文件中使用AddOnScreenDebugMessage()定义</p>
<h1 id="将C-游戏模式类扩展到蓝图"><a href="#将C-游戏模式类扩展到蓝图" class="headerlink" title="将C++游戏模式类扩展到蓝图"></a>将C++游戏模式类扩展到蓝图</h1><p>基于<strong>FPSProjectGameModeBase</strong>创建蓝图类<strong>BP_FPSGameModeBase</strong></p>
<h1 id="修改游戏默认模式"><a href="#修改游戏默认模式" class="headerlink" title="修改游戏默认模式"></a>修改游戏默认模式</h1><p>将<strong>BP_FPSGameModeBase</strong>设置为默认游戏模式</p>
<h1 id="创建角色"><a href="#创建角色" class="headerlink" title="创建角色"></a>创建角色</h1><p>基于Character创建一个C++类</p>
<p>在BeginPlay()函数中添加AddOnScreenDebugMessage()函数来确认正在使用FPSCharacter</p>
<h1 id="扩展C-FPS角色类到蓝图"><a href="#扩展C-FPS角色类到蓝图" class="headerlink" title="扩展C++FPS角色类到蓝图"></a>扩展C++FPS角色类到蓝图</h1><p>将<strong>FPSCharacter</strong>扩展为<strong>BP_FPSCharacter</strong></p>
<p>编辑-&gt;项目设置-&gt;地图和模式-&gt;默认Pawn类</p>
<p>设置为<strong>BP_FPSCharacter</strong></p>
<h1 id="设置映射"><a href="#设置映射" class="headerlink" title="设置映射"></a>设置映射</h1><p>编辑-&gt;项目设置-&gt;输入-&gt;绑定-&gt;轴映射&#x2F;按键映射</p>
<h1 id="实现映射"><a href="#实现映射" class="headerlink" title="实现映射"></a>实现映射</h1><p>在头文件中声明移动函数，变量为映射输入值，也就是Value</p>
<p>然后在cpp文件最下方定义函数</p>
<p>需要注意的是，实现跳跃的函数在内置文件中已经存在，我们只需要确定StartJump和StopJump即可</p>
<h1 id="绑定映射"><a href="#绑定映射" class="headerlink" title="绑定映射"></a>绑定映射</h1><p>在cpp文件中的<code>SetupPlayerInputComponent</code>函数内使用BindAxis()和BindAction()实现绑定映射</p>
<h1 id="导入网格体"><a href="#导入网格体" class="headerlink" title="导入网格体"></a>导入网格体</h1><p>打开<strong>BP_FPSCharacter</strong>图标，组件选项卡中点击网格体组件，细节面板中添加刚刚角色的网格体文件。</p>
<p>修改网格体位置，使得与胶囊体组件契合。</p>
<h1 id="更改摄像机视角"><a href="#更改摄像机视角" class="headerlink" title="更改摄像机视角"></a>更改摄像机视角</h1><p>添加摄像机与胶囊提组件头文件</p>
<p>头文件中声明，cpp中定义</p>
<ul>
<li><p>创建第一人称摄像机组件后，将其附加到胶囊体组件上</p>
</li>
<li><p>更改摄像机位置（SetRelativeLocation()），启用Pawn控制摄像机旋转（bUsePawnControlRotation）</p>
</li>
</ul>
<h1 id="添加第一人称网格体"><a href="#添加第一人称网格体" class="headerlink" title="添加第一人称网格体"></a>添加第一人称网格体</h1><p>头文件中声明FPSMesh</p>
<p>cpp文件中在构造函数内</p>
<ul>
<li><p>创建FPSMesh组件</p>
</li>
<li><p>设置仅所属玩家可以看见此网格体</p>
</li>
<li><p>将FPS网格体附加到FPS摄像机</p>
</li>
<li><p>禁用某些环境阴影，让地上的影子看不到这个第一人称手臂</p>
</li>
<li><p>隐藏所属角色的现有第三人称网格体</p>
</li>
</ul>
<p>最后在蓝图组件的细节面板中添加第一人称手臂资源，再适当地修改位置和旋转角度</p>
<h1 id="添加设计操作映射"><a href="#添加设计操作映射" class="headerlink" title="添加设计操作映射"></a>添加设计操作映射</h1><p>绑定操作映射</p>
<h1 id="添加发射物类"><a href="#添加发射物类" class="headerlink" title="添加发射物类"></a>添加发射物类</h1><p>以Actor为父类创建C++类</p>
<h1 id="添加USpere组件"><a href="#添加USpere组件" class="headerlink" title="添加USpere组件"></a>添加USpere组件</h1><ul>
<li><p>在头文件中添加#include “Components&#x2F;SphereComponent.h”</p>
</li>
<li><p>在头文件中声明球体碰撞组件</p>
</li>
<li><p>在cpp文件中定义碰撞组件</p>
<ul>
<li><p>创建为场景组件类型的根组件</p>
</li>
<li><p>创建球体碰撞组件</p>
</li>
<li><p>设置球体的碰撞半径</p>
</li>
<li><p>将根组件设置为碰撞组件</p>
</li>
</ul>
</li>
</ul>
<h1 id="添加发射物移动组件"><a href="#添加发射物移动组件" class="headerlink" title="添加发射物移动组件"></a>添加发射物移动组件</h1><ul>
<li><p>在头文件中添加#include “GameFramework&#x2F;ProjectileMovementComponent.h”</p>
</li>
<li><p>在头文件中声明发射物移动组件</p>
</li>
<li><p>在cpp文件中定义发射物移动组件</p>
<ul>
<li><p>创建移动组件</p>
</li>
<li><p>将移动组件的更新组件设置为之前定义好的碰撞组件</p>
</li>
<li><p>初始化移动组件速度</p>
</li>
<li><p>初始化移动组件最大速度</p>
</li>
<li><p>打开沿某方向高速旋转开关bRotationFollowsVelocity&#x3D;true</p>
</li>
<li><p>打开允许反弹开关bShouldBounce&#x3D;true</p>
</li>
<li><p>设置弹力大小Bounciness&#x3D;0.3f</p>
</li>
<li><p>设置发射物受到的重力大小ProjectileGravityScale&#x3D;0.0</p>
</li>
</ul>
</li>
</ul>
<h1 id="设置发射物初始方向"><a href="#设置发射物初始方向" class="headerlink" title="设置发射物初始方向"></a>设置发射物初始方向</h1><p>在头文件中声明初始化发射方向的函数</p>
<p>在cpp文件中定义该函数</p>
<p><code>ProjectileMovementComponent-&gt;Velocity = ShootDirection * ProjectileMovementComponent-&gt;InitialSpeed;</code></p>
<p>此处的Velocity可以看作是一个合成力，由方向和速度一同定义</p>
<h1 id="绑定发射输入操作"><a href="#绑定发射输入操作" class="headerlink" title="绑定发射输入操作"></a>绑定发射输入操作</h1><p>在FPSCharacter.h中声明Fire()</p>
<p>在cpp文件中绑定输入操作，并且定义该函数</p>
<p>{在这里可以先不写函数体，因为还没有定义发射物生成位置}</p>
<h1 id="定义发射物生成位置"><a href="#定义发射物生成位置" class="headerlink" title="定义发射物生成位置"></a>定义发射物生成位置</h1><p>在FPSCharacter.h中声明枪口相对于摄像机位置的偏移函数MuzzleOffset</p>
<p>在FPSCharacter.h中protected:下声明要生成的发射物类{TSubclassOf&lt;父类&gt;类名}</p>
<h1 id="实现射击函数"><a href="#实现射击函数" class="headerlink" title="实现射击函数"></a>实现射击函数</h1><p>将FPSCharacter.h中引用FPSProjectile.h文件</p>
<p>在cpp文件中定义Fire()函数</p>
<ul>
<li><p>生成一个发射物类</p>
<ul>
<li><p>获取摄像机位置，将MuzzleOffset位置设置在摄像机前方一点</p>
</li>
<li><p>将MuzzleOffset的相对位置转换成世界位置FTransform().TransformVector()</p>
</li>
<li><p>动态更新摄像机的Pitch角度，看起来就像后坐力一样</p>
</li>
<li><p>获取当前世界</p>
</li>
<li><p>设置一个FActorSpawnParameters</p>
</li>
<li><p>在世界内生成新的Actor（发射物）</p>
</li>
<li><p>设置发射物的初始轨迹</p>
</li>
</ul>
</li>
</ul>
<h1 id="添加发射物网格体及其材质"><a href="#添加发射物网格体及其材质" class="headerlink" title="添加发射物网格体及其材质"></a>添加发射物网格体及其材质</h1><p>导入网格体资源后</p>
<p>在FPSProjectile.h中声明发射物网格体以及其发射材质</p>
<p>在cpp文件中定义发射物网格体以及其材质</p>
<p>后面还要将网格体和材质的相对路径给填写进去</p>
<h1 id="设置发射物的碰撞和声明周期"><a href="#设置发射物的碰撞和声明周期" class="headerlink" title="设置发射物的碰撞和声明周期"></a>设置发射物的碰撞和声明周期</h1><p>在FPSProjectile.cpp中设置发射物生命周期</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">InitialLifeSpan = <span class="number">3.0f</span>;</span><br></pre></td></tr></table></figure>

<h1 id="编辑发射物的碰撞设置"><a href="#编辑发射物的碰撞设置" class="headerlink" title="编辑发射物的碰撞设置"></a>编辑发射物的碰撞设置</h1><p>编辑-&gt;项目设置-&gt;引擎-&gt;碰撞-&gt;展开预设</p>
<p>在对象通道中新建对象通道，将默认相应设置为Block</p>
<h1 id="使用新碰撞通道的设置"><a href="#使用新碰撞通道的设置" class="headerlink" title="使用新碰撞通道的设置"></a>使用新碰撞通道的设置</h1><p>在FPSProjectile.cpp的构造函数中添加</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将球体的碰撞配置文件名称设置为&quot;Projectile&quot;。</span></span><br><span class="line">CollisionComponent-&gt;BodyInstance.<span class="built_in">SetCollisionProfileName</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;Projectile&quot;</span>));</span><br></pre></td></tr></table></figure>

<h1 id="使发射物对碰撞做出相应"><a href="#使发射物对碰撞做出相应" class="headerlink" title="使发射物对碰撞做出相应"></a>使发射物对碰撞做出相应</h1><p>在FPSProjectile.h中声明放发射物击中物体时会调用的函数</p>
<p>参数为</p>
<p><code>void OnHit(UPrimitiveComponent* HitComponent, AActor* OtherActor, UPrimitiveComponent* OtherComponent, FVector NormalImpulse, const FHitResult&amp; Hit)</code></p>
<p>在cpp文件中定义函数</p>
<ul>
<li><p>如果另一个actor不是本身且另一个组件实现模拟物理的话</p>
</li>
<li><p>另一个组件调用AddImpulseAtLocation(ProjectileMovementComponent-&gt;Velocity * 100.0f, Hit.ImpactPoint)</p>
</li>
<li><p>然后Destroy()</p>
</li>
<li><p>在 <code>FPSProjectile</code> 构造函数中，将以下代码行添加到 <code>BodyInstance.SetCollisionProfileName</code> 下方：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 组件击中某物时调用的事件。</span></span><br><span class="line">CollisionComponent-&gt;OnComponentHit.<span class="built_in">AddDynamic</span>(<span class="keyword">this</span>, &amp;AFPSProjectile::OnHit);</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="添加十字准星"><a href="#添加十字准星" class="headerlink" title="添加十字准星"></a>添加十字准星</h1><p>导入十字准星资产，基于HUD创建C++类</p>
<ol>
<li><p><code>FPSHUD.h</code>，添加以下受保护的变量：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">   <span class="comment">// 将被绘制在屏幕中心。</span></span><br><span class="line">   <span class="built_in">UPROPERTY</span>(EditDefaultsOnly)</span><br><span class="line">   UTexture2D* CrosshairTexture;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 <code>FPSHUD.h</code> 中添加以下函数声明：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="comment">// HUD绘制的主要调用。</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">DrawHUD</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将以下头文件添加到FPSHUD.h中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Engine/Canvas.h&quot;</span> </span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在cpp中实现DrawHUD函数</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSHUD::DrawHUD</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">DrawHUD</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (CrosshairTexture)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 找出我们的画布的中心点。</span></span><br><span class="line">        <span class="function">FVector2D <span class="title">Center</span><span class="params">(Canvas-&gt;ClipX * <span class="number">0.5f</span>, Canvas-&gt;ClipY * <span class="number">0.5f</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 偏移纹理大小的一半，以便纹理中心与画布中心对齐。</span></span><br><span class="line">        <span class="function">FVector2D <span class="title">CrossHairDrawPosition</span><span class="params">(Center.X - (CrosshairTexture-&gt;GetSurfaceWidth() * <span class="number">0.5f</span>), Center.Y - (CrosshairTexture-&gt;GetSurfaceHeight() * <span class="number">0.5f</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在中心点绘制十字准星。</span></span><br><span class="line">        <span class="function">FCanvasTileItem <span class="title">TileItem</span><span class="params">(CrossHairDrawPosition, CrosshairTexture-&gt;Resource, FLinearColor::White)</span></span>;</span><br><span class="line">        TileItem.BlendMode = SE_BLEND_Translucent;</span><br><span class="line">        Canvas-&gt;<span class="built_in">DrawItem</span>(TileItem);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="设置默认的HUD"><a href="#设置默认的HUD" class="headerlink" title="设置默认的HUD"></a>设置默认的HUD</h1><p>扩展HUD类到蓝图类中后</p>
<p>编辑-&gt;项目设置-&gt;地图和模式-&gt;默认HUD</p>
<p>选择蓝图HUD</p>
<p>打开HUD蓝图，选择导入的十字准星纹理资产</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/02/UE4-%E7%AC%AC%E4%B8%80%E4%BA%BA%E7%A7%B0FPS-%E4%BB%A3%E7%A0%81%E8%AE%B2%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="williny">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Williny'home">
      <meta itemprop="description" content="孤独是人生的常态">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Williny'home">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/05/02/UE4-%E7%AC%AC%E4%B8%80%E4%BA%BA%E7%A7%B0FPS-%E4%BB%A3%E7%A0%81%E8%AE%B2%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89/" class="post-title-link" itemprop="url">UE4-第一人称FPS-代码讲解（二）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-05-02 14:04:54 / 修改时间：16:11:43" itemprop="dateCreated datePublished" datetime="2022-05-02T14:04:54+08:00">2022-05-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/unreal-engine/" itemprop="url" rel="index"><span itemprop="name">unreal engine</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>此部分主要讲解如何给角色添加动画，依旧是官方案例。</p>
<p>这段说是代码讲解，但其实是蓝图讲解了。</p>
<p>没关系，蓝图是可视化编程，也算是代码哈哈哈！</p>
<p>ok话不多说，我们开始！</p>
<h1 id="设置事件图表"><a href="#设置事件图表" class="headerlink" title="设置事件图表"></a>设置事件图表</h1><p>在事件图表中添加两个新的bool型变量IsRunning和IsFalling之后，我们编辑动画的事件图标，来保证我们的动画过度变量在游戏运行时能被正确触发</p>
<h2 id="Event-Blueprint-Update-Animation"><a href="#Event-Blueprint-Update-Animation" class="headerlink" title="Event Blueprint Update Animation"></a>Event Blueprint Update Animation</h2><p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/4/EventBlueprintUpdateAnimationNode.jpg" alt="EventBlueprintUpdateAnimationNode.png"></p>
<p>这玩意在4.27.2版本中是有中文名称的，当然，直接搜索英文名也是可以直接得到的</p>
<p>中文名称是<strong>事件蓝图更新动画</strong></p>
<p>这玩意有啥用呢？</p>
<p><strong>事件蓝图更新动画：用于在每次更新动画时更新我们的状态变量（IsRunning和IsFalling），使变量和游戏状态同步。</strong></p>
<p>简单来说就是，这是一个函数，参数是动画的更新（从走变成跑），返回值是状态变量（IsRunning和IsFalling）</p>
<h2 id="Try-Get-Pawn-Owner"><a href="#Try-Get-Pawn-Owner" class="headerlink" title="Try Get Pawn Owner"></a>Try Get Pawn Owner</h2><p>同样，在4.27.2版本中的中文名是尝试获取Pawn拥有者</p>
<p>获取拥有这个动画实例的Pawn</p>
<ol>
<li>先获取到动画蓝图所属的组件（<code>OwnerComponent</code>）</li>
<li>然后再获取<code>OwnerComponent</code>的所属<code>OwnerActor</code></li>
<li>最后还要把<code>OwnerActor</code>(<code>AActor</code>类型)向下强制类型转换成<code>APawn</code>。</li>
</ol>
<h2 id="Cast-to-Character"><a href="#Cast-to-Character" class="headerlink" title="Cast to Character"></a>Cast to Character</h2><p>强制转换类型为Character</p>
<h2 id="Get-Character-Movement"><a href="#Get-Character-Movement" class="headerlink" title="Get Character Movement"></a>Get Character Movement</h2><p>获取角色运动情况</p>
<h2 id="Get-Movement-Mode"><a href="#Get-Movement-Mode" class="headerlink" title="Get Movement Mode"></a>Get Movement Mode</h2><p>获取角色运动状态</p>
<h2 id="Equal-enum"><a href="#Equal-enum" class="headerlink" title="Equal(enum)"></a>Equal(enum)</h2><p>查询角色移动状态（下拉菜单中可选择具体移动状态）</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/4/SelectFalling.jpg" alt="SelectFalling.png"></p>
<h2 id="Get-Velocity"><a href="#Get-Velocity" class="headerlink" title="Get Velocity"></a>Get Velocity</h2><p>中文为获取速度</p>
<h2 id="VectorLength"><a href="#VectorLength" class="headerlink" title="VectorLength"></a>VectorLength</h2><p>获取向量长度，就是这东西可以获取速度（力，加速度）的具体数值</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/4/VectorLength.jpg" alt="VectorLength.png"></p>
<h2 id="gt-float"><a href="#gt-float" class="headerlink" title="&gt;(float)"></a>&gt;(float)</h2><p>一个判断语句，看从前一个结点获取的数值是否大于某个设置的常量（这里常量是0）</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/4/ConnectedIsRunning.jpg" alt="ConnectedIsRunning.png"></p>
<h1 id="添加动画状态机"><a href="#添加动画状态机" class="headerlink" title="添加动画状态机"></a>添加动画状态机</h1><h2 id="Add-State"><a href="#Add-State" class="headerlink" title="Add State"></a>Add State</h2><p>就是像图表中添加状态，分别命名为Idle，Run，JumpStart，JumpEnd，JumpLoop</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/4/AnimationSMGraph.jpg" alt="AnimationSMGraph.png"></p>
<p>双击进各个状态内后开始编辑它们</p>
<p>在里面右键-&gt;<strong>play 动画名称</strong></p>
<p>中文标识是播放 <strong>动画名称</strong></p>
<p>将其连接到Output Animation Pose上，也就是表现为这个动画状态</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/4/ConnectedIdleNode.jpg" alt="ConnectedIdleNode.png"></p>
<p>现在从entry中拖出引线连接到idle（因为初始状态是待机状态嘛）</p>
<p>然后根据逻辑尝试，把剩下的几个状态连接起来</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/4/JumpEndtoIdle.jpg" alt="JumpEndtoIdle.png"></p>
<p>最后是这个效果</p>
<h1 id="添加过度"><a href="#添加过度" class="headerlink" title="添加过度"></a>添加过度</h1><p>双击那个圆球，就可以编辑两个状态的过度了</p>
<p>其中的逻辑很简单</p>
<h2 id="待机切换到奔跑状态"><a href="#待机切换到奔跑状态" class="headerlink" title="待机切换到奔跑状态"></a>待机切换到奔跑状态</h2><p>只需要把之前我们已经定义了的变量Is Running（值为true）拖入其中，然后在讲其脱出引线连接到result上即可</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/4/IsRunningtoResult.jpg" alt="IsRunningtoResult.png"></p>
<h2 id="奔跑状态切换到待机状态"><a href="#奔跑状态切换到待机状态" class="headerlink" title="奔跑状态切换到待机状态"></a>奔跑状态切换到待机状态</h2><p>这个和上一个差不多，不过我们需要将Is Running判断一下为false再输出到result</p>
<p>所以，我们将Is Running拖出一条引线，然后创建一个<strong>Not Boolean</strong>结点判断这个bool变量是否为false，如果成立，则将其输出为result</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/4/IsNotRunningtoResult.jpg" alt="IsNotRunningtoResult.png"></p>
<h2 id="奔跑状态切换到跳跃开始"><a href="#奔跑状态切换到跳跃开始" class="headerlink" title="奔跑状态切换到跳跃开始"></a>奔跑状态切换到跳跃开始</h2><p>我们输入的bool变量为Is falling，为啥呢？因为起跳到跳到顶点的这个过程，其实还是受到重力的影响的吧？重力还是会拖拽着你falling，只不过是被你的弹跳力抵消成为一个向上的合力了，本质上你还是falling的状态</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/4/IsFallingtoResult.jpg" alt="IsFallingtoResult.png"></p>
<h2 id="跳跃开始到跳跃循环"><a href="#跳跃开始到跳跃循环" class="headerlink" title="跳跃开始到跳跃循环"></a>跳跃开始到跳跃循环</h2><p>我们需要判断跳跃开始动画的剩余时间，如果该时间小于0.1，则我们输出result，也就是进入到跳跃循环的动画当中。</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/4/TimeRemaining.jpg" alt="TimeRemaining.png"></p>
<p>接下来就是关联动画蓝图和角色蓝图了，按照官网的步骤一点点来就完事了，我这里就不做过多赘述了。</p>
<p>另外提一嘴，这动画效果是真的细微啊，不仔细看还真看不出来。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/01/%E6%9C%89%E5%85%B3%E7%AE%97%E6%B3%95%E4%B8%AD%E7%9A%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E4%BA%8C%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="williny">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Williny'home">
      <meta itemprop="description" content="孤独是人生的常态">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Williny'home">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/05/01/%E6%9C%89%E5%85%B3%E7%AE%97%E6%B3%95%E4%B8%AD%E7%9A%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E4%BA%8C%EF%BC%89/" class="post-title-link" itemprop="url">有关算法中的动态规划（二）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-05-01 09:51:25" itemprop="dateCreated datePublished" datetime="2022-05-01T09:51:25+08:00">2022-05-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-05-10 08:55:14" itemprop="dateModified" datetime="2022-05-10T08:55:14+08:00">2022-05-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>由于动态规划的例题过多，于是多开一章！</p>
<h1 id="零钱兑换"><a href="#零钱兑换" class="headerlink" title="零钱兑换"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/coin-change/">零钱兑换</a></h1><p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p>
<p>你可以认为每种硬币的数量是无限的。</p>
<p>示例 1： 输入：coins &#x3D; [1, 2, 5], amount &#x3D; 11 输出：3 解释：11 &#x3D; 5 + 5 + 1</p>
<p>示例 2： 输入：coins &#x3D; [2], amount &#x3D; 3 输出：-1</p>
<p>示例 3： 输入：coins &#x3D; [1], amount &#x3D; 0 输出：0</p>
<p>示例 4： 输入：coins &#x3D; [1], amount &#x3D; 1 输出：1</p>
<p>示例 5： 输入：coins &#x3D; [1], amount &#x3D; 2 输出：2</p>
<p>提示：</p>
<ul>
<li>1 &lt;&#x3D; coins.length &lt;&#x3D; 12</li>
<li>1 &lt;&#x3D; coins[i] &lt;&#x3D; 2^31 - 1</li>
<li>0 &lt;&#x3D; amount &lt;&#x3D; 10^4</li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题目中说每种硬币的数量是无限的，可以看出是典型的完全背包问题。</p>
<p>动规五部曲分析如下：</p>
<ol>
<li>确定dp数组以及下标的含义</li>
</ol>
<p><strong>dp[j]：凑足总额为j所需钱币的最少个数为dp[j]</strong></p>
<ol start="2">
<li>确定递推公式</li>
</ol>
<p>得到dp[j]（考虑coins[i]），只有一个来源，dp[j - coins[i]]（没有考虑coins[i]）。</p>
<p>凑足总额为j - coins[i]的最少个数为dp[j - coins[i]]，那么只需要加上一个钱币coins[i]即dp[j - coins[i]] + 1就是dp[j]（考虑coins[i]）</p>
<p>所以dp[j] 要取所有 dp[j - coins[i]] + 1 中最小的。</p>
<p>递推公式：<strong>dp[j] &#x3D; min(dp[j - coins[i]] + 1, dp[j]);</strong></p>
<ol start="3">
<li>dp数组如何初始化</li>
</ol>
<p>首先凑足总金额为0所需钱币的个数一定是0，那么dp[0] &#x3D; 0;</p>
<p>其他下标对应的数值呢？</p>
<p>考虑到递推公式的特性，dp[j]<strong>必须初始化为一个最大的数</strong>，否则就会在min(dp[j - coins[i]] + 1, dp[j])比较的过程中被初始值覆盖。</p>
<p>所以下标非0的元素都是应该是最大值。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(amount + <span class="number">1</span>, INT_MAX)</span></span>;</span><br><span class="line">dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>确定遍历顺序</li>
</ol>
<p>本题求钱币最小个数，<strong>那么钱币有顺序和没有顺序都可以，都不影响钱币的最小个数</strong>。</p>
<p>所以本题并不强调集合是组合还是排列。</p>
<p><strong>如果求组合数就是外层for循环遍历物品，内层for遍历背包</strong>。</p>
<p><strong>如果求排列数就是外层for遍历背包，内层for循环遍历物品</strong>。</p>
<p>在动态规划专题我们讲过了求组合数是<a target="_blank" rel="noopener" href="https://programmercarl.com/0518.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2II.html">动态规划：518.零钱兑换II</a>，求排列数是<a target="_blank" rel="noopener" href="https://programmercarl.com/0377.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%E2%85%A3.html">动态规划：377. 组合总和 Ⅳ </a>。</p>
<p><strong>所以本题的两个for循环的关系是：外层for循环遍历物品，内层for遍历背包或者外层for遍历背包，内层for循环遍历物品都是可以的！</strong></p>
<p>那么我采用coins放在外循环，target在内循环的方式。</p>
<p>本题钱币数量可以无限使用，那么是完全背包。所以遍历的内循环是正序</p>
<p>综上所述，遍历顺序为：coins（物品）放在外循环，target（背包）在内循环。且内循环正序。</p>
<ol start="5">
<li>举例推导dp数组</li>
</ol>
<p>以输入：coins &#x3D; [1, 2, 5], amount &#x3D; 5为例</p>
<p><img src="https://img-blog.csdnimg.cn/20210201111833906.jpg" alt="322.零钱兑换"></p>
<p>dp[amount]为最终结果。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(amount + <span class="number">1</span>, INT_MAX)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; coins.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = coins[i]; j &lt;= amount; j++) &#123; <span class="comment">// 遍历背包</span></span><br><span class="line">                <span class="keyword">if</span> (dp[j - coins[i]] != INT_MAX) &#123; <span class="comment">// 如果dp[j - coins[i]]是初始值则跳过</span></span><br><span class="line">                    dp[j] = <span class="built_in">min</span>(dp[j - coins[i]] + <span class="number">1</span>, dp[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dp[amount] == INT_MAX) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://programmercarl.com/0518.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2II.html">动态规划：518.零钱兑换II </a>中求的是组合数，<a target="_blank" rel="noopener" href="https://programmercarl.com/0377.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%E2%85%A3.html">动态规划：377. 组合总和 Ⅳ</a>中求的是排列数。</p>
<p><strong>而本题是要求最少硬币数量，硬币是组合数还是排列数都无所谓！所以两个for循环先后顺序怎样都可以！</strong></p>
<h1 id="完全平方数"><a href="#完全平方数" class="headerlink" title="完全平方数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/perfect-squares/">完全平方数</a></h1><p>给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。</p>
<p>给你一个整数 n ，返回和为 n 的完全平方数的 最少数量 。</p>
<p>完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。</p>
<p>示例 1： 输入：n &#x3D; 12 输出：3 解释：12 &#x3D; 4 + 4 + 4</p>
<p>示例 2： 输入：n &#x3D; 13 输出：2 解释：13 &#x3D; 4 + 9</p>
<p>提示：</p>
<ul>
<li>1 &lt;&#x3D; n &lt;&#x3D; 10^4</li>
</ul>
<h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>可能刚看这种题感觉没啥思路，又平方和的，又最小数的。</p>
<p><strong>我来把题目翻译一下：完全平方数就是物品（可以无限件使用），凑个正整数n就是背包，问凑满这个背包最少有多少物品？</strong></p>
<p>感受出来了没，这么浓厚的完全背包氛围，而且和昨天的题目<a target="_blank" rel="noopener" href="https://programmercarl.com/0322.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2.html">动态规划：322. 零钱兑换 </a>就是一样一样的！</p>
<p>动规五部曲分析如下：</p>
<ol>
<li>确定dp数组（dp table）以及下标的含义</li>
</ol>
<p><strong>dp[j]：和为j的完全平方数的最少数量为dp[j]</strong></p>
<ol start="2">
<li>确定递推公式</li>
</ol>
<p>dp[j] 可以由dp[j - i * i]推出， dp[j - i * i] + 1 便可以凑成dp[j]。</p>
<p>此时我们要选择最小的dp[j]，所以递推公式：dp[j] &#x3D; min(dp[j - i * i] + 1, dp[j]);</p>
<ol start="3">
<li>dp数组如何初始化</li>
</ol>
<p>dp[0]表示 和为0的完全平方数的最小数量，那么dp[0]一定是0。</p>
<p>有同学问题，那0 * 0 也算是一种啊，为啥dp[0] 就是 0呢？</p>
<p>看题目描述，找到若干个完全平方数（比如 1, 4, 9, 16, …），题目描述中可没说要从0开始，dp[0]&#x3D;0完全是为了递推公式。</p>
<p>非0下标的dp[j]应该是多少呢？</p>
<p>从递归公式dp[j] &#x3D; min(dp[j - i * i] + 1, dp[j]);中可以看出每次dp[j]都要选最小的，<strong>所以非0下标的dp[j]一定要初始为最大值，这样dp[j]在递推的时候才不会被初始值覆盖</strong>。</p>
<ol start="4">
<li>确定遍历顺序</li>
</ol>
<p>我们知道这是完全背包，</p>
<p>如果求组合数就是外层for循环遍历物品，内层for遍历背包。</p>
<p>如果求排列数就是外层for遍历背包，内层for循环遍历物品。</p>
<p>在<a target="_blank" rel="noopener" href="https://programmercarl.com/0322.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2.html">动态规划：322. 零钱兑换 </a>中我们就深入探讨了这个问题，本题也是一样的，是求最小数！</p>
<p><strong>所以本题外层for遍历背包，内层for遍历物品，还是外层for遍历物品，内层for遍历背包，都是可以的！</strong></p>
<p>我这里先给出外层遍历背包，内层遍历物品的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, INT_MAX)</span></span>;</span><br><span class="line">dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123; <span class="comment">// 遍历背包</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j * j &lt;= i; j++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">        dp[i] = <span class="built_in">min</span>(dp[i - j * j] + <span class="number">1</span>, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<ol start="5">
<li>举例推导dp数组</li>
</ol>
<p>已输入n为5例，dp状态图如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20210202112617341.jpg" alt="279.完全平方数"></p>
<p>dp[0] &#x3D; 0 dp[1] &#x3D; min(dp[0] + 1) &#x3D; 1 dp[2] &#x3D; min(dp[1] + 1) &#x3D; 2 dp[3] &#x3D; min(dp[2] + 1) &#x3D; 3 dp[4] &#x3D; min(dp[3] + 1, dp[0] + 1) &#x3D; 1 dp[5] &#x3D; min(dp[4] + 1, dp[1] + 1) &#x3D; 2</p>
<p>最后的dp[n]为最终结果。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numSquares</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, INT_MAX)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123; <span class="comment">// 遍历背包</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j * j &lt;= i; j++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">                dp[i] = <span class="built_in">min</span>(dp[i - j * j] + <span class="number">1</span>, dp[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="单词拆分"><a href="#单词拆分" class="headerlink" title="单词拆分"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/word-break/">单词拆分</a></h1><p>给定一个非空字符串 s 和一个包含非空单词的列表 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。</p>
<p>说明：</p>
<p>拆分时可以重复使用字典中的单词。</p>
<p>你可以假设字典中没有重复的单词。</p>
<p>示例 1： </p>
<p>输入: s &#x3D; “leetcode”, wordDict &#x3D; [“leet”, “code”] </p>
<p>输出: true </p>
<p>解释: 返回 true 因为 “leetcode” 可以被拆分成 “leet code”。</p>
<p>示例 2： </p>
<p>输入: s &#x3D; “applepenapple”, wordDict &#x3D; [“apple”, “pen”] </p>
<p>输出: true </p>
<p>解释: 返回 true 因为 “applepenapple” 可以被拆分成 “apple pen apple”。   </p>
<p>注意你可以重复使用字典中的单词。</p>
<p>示例 3： </p>
<p>输入: s &#x3D; “catsandog”, wordDict &#x3D; [“cats”, “dog”, “sand”, “and”, “cat”] </p>
<p>输出: false</p>
<h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><h3 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h3><p>看到这道题目的时候，大家应该回想起我们之前讲解回溯法专题的时候，讲过的一道题目<a target="_blank" rel="noopener" href="https://programmercarl.com/0131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.html">回溯算法：分割回文串 </a>，就是枚举字符串的所有分割情况。</p>
<p><a target="_blank" rel="noopener" href="https://programmercarl.com/0131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.html">回溯算法：分割回文串 </a>：是枚举分割后的所有子串，判断是否回文。</p>
<p>本道是枚举分割所有字符串，判断是否在字典里出现过。</p>
<p>那么这里我也给出回溯法C++代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">backtracking</span> <span class="params">(<span class="type">const</span> string&amp; s, <span class="type">const</span> unordered_set&lt;string&gt;&amp; wordSet, <span class="type">int</span> startIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (startIndex &gt;= s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            string word = s.<span class="built_in">substr</span>(startIndex, i - startIndex + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (wordSet.<span class="built_in">find</span>(word) != wordSet.<span class="built_in">end</span>() &amp;&amp; <span class="built_in">backtracking</span>(s, wordSet, i + <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">wordBreak</span><span class="params">(string s, vector&lt;string&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="function">unordered_set&lt;string&gt; <span class="title">wordSet</span><span class="params">(wordDict.begin(), wordDict.end())</span></span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">backtracking</span>(s, wordSet, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>单词就是物品，字符串s就是背包，单词能否组成字符串s，就是问物品能不能把背包装满。</p>
<p>拆分时可以重复使用字典中的单词，说明就是一个完全背包！</p>
<p>动规五部曲分析如下：</p>
<ol>
<li>确定dp数组以及下标的含义</li>
</ol>
<p><strong>dp[i] : 字符串长度为i的话，dp[i]为true，表示可以拆分为一个或多个在字典中出现的单词</strong></p>
<ol start="2">
<li>确定递推公式</li>
</ol>
<p>如果确定dp[j] 是true，且 [j, i] 这个区间的子串出现在字典里，那么dp[i]一定是true。（j &lt; i ）。</p>
<p>所以递推公式是 if([j, i] 这个区间的子串出现在字典里 &amp;&amp; dp[j]是true) 那么 dp[i] &#x3D; true。</p>
<ol start="3">
<li>dp数组如何初始化</li>
</ol>
<p>从递归公式中可以看出，dp[i] 的状态依靠 dp[j]是否为true，那么dp[0]就是递归的根基，dp[0]一定要为true，否则递归下去后面都都是false了。</p>
<p>那么dp[0]有没有意义呢？</p>
<p>dp[0]表示如果字符串为空的话，说明出现在字典里。</p>
<p>但题目中说了“给定一个非空字符串 s” 所以测试数据中不会出现i为0的情况，那么dp[0]初始为true完全就是为了推导公式。</p>
<p>下标非0的dp[i]初始化为false，只要没有被覆盖说明都是不可拆分为一个或多个在字典中出现的单词。</p>
<ol start="4">
<li>确定遍历顺序</li>
</ol>
<p>题目中说是拆分为一个或多个在字典中出现的单词，所以这是完全背包。</p>
<p>还要讨论两层for循环的前后循序。</p>
<p><strong>如果求组合数就是外层for循环遍历物品，内层for遍历背包</strong>。</p>
<p><strong>如果求排列数就是外层for遍历背包，内层for循环遍历物品</strong>。</p>
<p>对这个结论还有疑问的同学可以看这篇<a target="_blank" rel="noopener" href="https://programmercarl.com/%E5%91%A8%E6%80%BB%E7%BB%93/20210204%E5%8A%A8%E8%A7%84%E5%91%A8%E6%9C%AB%E6%80%BB%E7%BB%93.html">本周小结！（动态规划系列五）</a>，这篇本周小节中，我做了如下总结：</p>
<p>求组合数：<a target="_blank" rel="noopener" href="https://programmercarl.com/0518.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2II.html">动态规划：518.零钱兑换II</a>求排列数：<a target="_blank" rel="noopener" href="https://programmercarl.com/0377.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C.html">动态规划：377. 组合总和 Ⅳ</a>、<a target="_blank" rel="noopener" href="https://programmercarl.com/0070.%E7%88%AC%E6%A5%BC%E6%A2%AF%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E7%89%88%E6%9C%AC.html">动态规划：70. 爬楼梯进阶版（完全背包）</a>求最小数：<a target="_blank" rel="noopener" href="https://programmercarl.com/0322.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2.html">动态规划：322. 零钱兑换</a>、<a target="_blank" rel="noopener" href="https://programmercarl.com/0279.%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0.html">动态规划：279.完全平方数</a></p>
<p>本题最终要求的是是否都出现过，所以对出现单词集合里的元素是组合还是排列，并不在意！</p>
<p><strong>那么本题使用求排列的方式，还是求组合的方式都可以</strong>。</p>
<p>即：外层for循环遍历物品，内层for遍历背包 或者 外层for遍历背包，内层for循环遍历物品 都是可以的。</p>
<p>但本题还有特殊性，因为是要求子串，最好是遍历背包放在外循环，将遍历物品放在内循环。</p>
<p>如果要是外层for循环遍历物品，内层for遍历背包，就需要把所有的子串都预先放在一个容器里。（如果不理解的话，可以自己尝试这么写一写就理解了）</p>
<p><strong>所以最终我选择的遍历顺序为：遍历背包放在外循环，将遍历物品放在内循环。内循环从前到后</strong>。</p>
<ol start="5">
<li>举例推导dp[i]</li>
</ol>
<p>以输入: s &#x3D; “leetcode”, wordDict &#x3D; [“leet”, “code”]为例，dp状态如图：</p>
<p><img src="https://img-blog.csdnimg.cn/20210202162652727.jpg" alt="139.单词拆分"></p>
<p>dp[s.size()]就是最终结果。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">wordBreak</span><span class="params">(string s, vector&lt;string&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="function">unordered_set&lt;string&gt; <span class="title">wordSet</span><span class="params">(wordDict.begin(), wordDict.end())</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">dp</span><span class="params">(s.size() + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= s.<span class="built_in">size</span>(); i++) &#123;   <span class="comment">// 遍历背包</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;       <span class="comment">// 遍历物品</span></span><br><span class="line">                string word = s.<span class="built_in">substr</span>(j, i - j); <span class="comment">//substr(起始位置，截取的个数)</span></span><br><span class="line">                <span class="keyword">if</span> (wordSet.<span class="built_in">find</span>(word) != wordSet.<span class="built_in">end</span>() &amp;&amp; dp[j]) &#123;</span><br><span class="line">                    dp[i] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="多重背包理论基础"><a href="#多重背包理论基础" class="headerlink" title="多重背包理论基础"></a>多重背包理论基础</h1><p>对于多重背包，我在力扣上还没发现对应的题目，所以这里就做一下简单介绍，大家大概了解一下。</p>
<p>有N种物品和一个容量为V 的背包。<strong>第i种物品最多有Mi件可用</strong>，每件耗费的空间是Ci ，价值是Wi 。求解将哪些物品装入背包可使这些物品的耗费的空间 总和不超过背包容量，且价值总和最大。</p>
<p>多重背包和01背包是非常像的， 为什么和01背包像呢？</p>
<p>每件物品最多有Mi件可用，把Mi件摊开，其实就是一个01背包问题了。</p>
<p>例如：</p>
<p>背包最大重量为10。</p>
<p>物品为：</p>
<table>
<thead>
<tr>
<th></th>
<th>重量</th>
<th>价值</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>物品0</td>
<td>1</td>
<td>15</td>
<td>2</td>
</tr>
<tr>
<td>物品1</td>
<td>3</td>
<td>20</td>
<td>3</td>
</tr>
<tr>
<td>物品2</td>
<td>4</td>
<td>30</td>
<td>2</td>
</tr>
</tbody></table>
<p>问背包能背的物品最大价值是多少？</p>
<p>和如下情况有区别么？</p>
<table>
<thead>
<tr>
<th></th>
<th>重量</th>
<th>价值</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>物品0</td>
<td>1</td>
<td>15</td>
<td>1</td>
</tr>
<tr>
<td>物品0</td>
<td>1</td>
<td>15</td>
<td>1</td>
</tr>
<tr>
<td>物品1</td>
<td>3</td>
<td>20</td>
<td>1</td>
</tr>
<tr>
<td>物品1</td>
<td>3</td>
<td>20</td>
<td>1</td>
</tr>
<tr>
<td>物品1</td>
<td>3</td>
<td>20</td>
<td>1</td>
</tr>
<tr>
<td>物品2</td>
<td>4</td>
<td>30</td>
<td>1</td>
</tr>
<tr>
<td>物品2</td>
<td>4</td>
<td>30</td>
<td>1</td>
</tr>
</tbody></table>
<p>毫无区别，这就转成了一个01背包问题了，且每个物品只用一次。</p>
<p>这种方式来实现多重背包的代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_multi_pack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; weight = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; value = &#123;<span class="number">15</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="type">int</span> bagWeight = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (nums[i] &gt; <span class="number">1</span>) &#123; <span class="comment">// nums[i]保留到1，把其他物品都展开</span></span><br><span class="line">            weight.<span class="built_in">push_back</span>(weight[i]);</span><br><span class="line">            value.<span class="built_in">push_back</span>(value[i]);</span><br><span class="line">            nums[i]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(bagWeight + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; weight.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = bagWeight; j &gt;= weight[i]; j--) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">            dp[j] = <span class="built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= bagWeight; j++) &#123;</span><br><span class="line">            cout &lt;&lt; dp[j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[bagWeight] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test_multi_pack</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(m × n × k)，m：物品种类个数，n背包容量，k单类物品数量</li>
</ul>
<p>也有另一种实现方式，就是把每种商品遍历的个数放在01背包里面在遍历一遍。</p>
<p>代码如下：（详看注释）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_multi_pack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; weight = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; value = &#123;<span class="number">15</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="type">int</span> bagWeight = <span class="number">10</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(bagWeight + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; weight.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = bagWeight; j &gt;= weight[i]; j--) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">            <span class="comment">// 以上为01背包，然后加一个遍历个数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= nums[i] &amp;&amp; (j - k * weight[i]) &gt;= <span class="number">0</span>; k++) &#123; <span class="comment">// 遍历个数</span></span><br><span class="line">                dp[j] = <span class="built_in">max</span>(dp[j], dp[j - k * weight[i]] + k * value[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 打印一下dp数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= bagWeight; j++) &#123;</span><br><span class="line">            cout &lt;&lt; dp[j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[bagWeight] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test_multi_pack</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：O(m × n × k)，m：物品种类个数，n背包容量，k单类物品数量</li>
</ul>
<p>从代码里可以看出是01背包里面在加一个for循环遍历一个每种商品的数量。 和01背包还是如出一辙的。</p>
<p>当然还有那种二进制优化的方法，其实就是把每种物品的数量，打包成一个个独立的包。</p>
<p>和以上在循环遍历上有所不同，因为是分拆为各个包最后可以组成一个完整背包，具体原理我就不做过多解释了，大家了解一下就行，面试的话基本不会考完这个深度了，感兴趣可以自己深入研究一波。</p>
<h1 id="打家劫舍"><a href="#打家劫舍" class="headerlink" title="打家劫舍"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/house-robber/">打家劫舍</a></h1><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p>
<p>示例 1：</p>
<p>输入：[1,2,3,1] </p>
<p>输出：4 </p>
<p>解释：偷窃 1 号房屋 (金额 &#x3D; 1) ，然后偷窃 3 号房屋 (金额 &#x3D; 3)。   偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 </p>
<p>示例 2： </p>
<p>输入：[2,7,9,3,1] </p>
<p>输出：12 </p>
<p>解释：偷窃 1 号房屋 (金额 &#x3D; 2), 偷窃 3 号房屋 (金额 &#x3D; 9)，接着偷窃 5 号房屋 (金额 &#x3D; 1)。   偷窃到的最高金额 &#x3D; 2 + 9 + 1 &#x3D; 12 。</p>
<p>提示：</p>
<ul>
<li>0 &lt;&#x3D; nums.length &lt;&#x3D; 100</li>
<li>0 &lt;&#x3D; nums[i] &lt;&#x3D; 400</li>
</ul>
<h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>打家劫舍是dp解决的经典问题，动规五部曲分析如下：</p>
<ol>
<li>确定dp数组（dp table）以及下标的含义</li>
</ol>
<p>**dp[i]：考虑下标i（包括i）以内的房屋，最多可以偷窃的金额为dp[i]**。</p>
<ol start="2">
<li>确定递推公式</li>
</ol>
<p>决定dp[i]的因素就是第i房间偷还是不偷。</p>
<p>如果偷第i房间，那么dp[i] &#x3D; dp[i - 2] + nums[i] ，即：第i-1房一定是不考虑的，找出 下标i-2（包括i-2）以内的房屋，最多可以偷窃的金额为dp[i-2] 加上第i房间偷到的钱。</p>
<p>如果不偷第i房间，那么dp[i] &#x3D; dp[i - 1]，即考虑i-1房，（<strong>注意这里是考虑，并不是一定要偷i-1房，这是很多同学容易混淆的点</strong>）</p>
<p>然后dp[i]取最大值，即dp[i] &#x3D; max(dp[i - 2] + nums[i], dp[i - 1]);</p>
<ol start="3">
<li>dp数组如何初始化</li>
</ol>
<p>从递推公式dp[i] &#x3D; max(dp[i - 2] + nums[i], dp[i - 1]);可以看出，递推公式的基础就是dp[0] 和 dp[1]</p>
<p>从dp[i]的定义上来讲，dp[0] 一定是 nums[0]，dp[1]就是nums[0]和nums[1]的最大值即：dp[1] &#x3D; max(nums[0], nums[1]);</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">dp[<span class="number">1</span>] = <span class="built_in">max</span>(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>确定遍历顺序</li>
</ol>
<p>dp[i] 是根据dp[i - 2] 和 dp[i - 1] 推导出来的，那么一定是从前到后遍历！</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    dp[i] = <span class="built_in">max</span>(dp[i - <span class="number">2</span>] + nums[i], dp[i - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>举例推导dp数组</li>
</ol>
<p>以示例二，输入[2,7,9,3,1]为例。</p>
<p><img src="https://img-blog.csdnimg.cn/20210221170954115.jpg" alt="198.打家劫舍"></p>
<p>红框dp[nums.size() - 1]为结果。</p>
<p>以上分析完毕，C++代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="built_in">max</span>(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(dp[i - <span class="number">2</span>] + nums[i], dp[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[nums.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="打家劫舍II"><a href="#打家劫舍II" class="headerlink" title="打家劫舍II"></a>打家劫舍II</h1><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，能够偷窃到的最高金额。</p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [2,3,2] 输出：3 解释：你不能先偷窃 1 号房屋（金额 &#x3D; 2），然后偷窃 3 号房屋（金额 &#x3D; 2）, 因为他们是相邻的。</p>
<p>示例 2： 输入：nums &#x3D; [1,2,3,1] 输出：4 解释：你可以先偷窃 1 号房屋（金额 &#x3D; 1），然后偷窃 3 号房屋（金额 &#x3D; 3）。偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。</p>
<p>示例 3： 输入：nums &#x3D; [0] 输出：0</p>
<p>提示：</p>
<ul>
<li>1 &lt;&#x3D; nums.length &lt;&#x3D; 100</li>
<li>0 &lt;&#x3D; nums[i] &lt;&#x3D; 1000</li>
</ul>
<h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>这道题目和<a target="_blank" rel="noopener" href="https://programmercarl.com/0198.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D.html">198.打家劫舍 </a>是差不多的，唯一区别就是成环了。</p>
<p>对于一个数组，成环的话主要有如下三种情况：</p>
<ul>
<li>情况一：考虑不包含首尾元素</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20210129160748643.jpg" alt="213.打家劫舍II"></p>
<ul>
<li>情况二：考虑包含首元素，不包含尾元素</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20210129160821374.jpg" alt="213.打家劫舍II1"></p>
<ul>
<li>情况三：考虑包含尾元素，不包含首元素</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20210129160842491.jpg" alt="213.打家劫舍II2"></p>
<p>**注意我这里用的是”考虑”**，例如情况三，虽然是考虑包含尾元素，但不一定要选尾部元素！ 对于情况三，取nums[1] 和 nums[3]就是最大的。</p>
<p><strong>而情况二 和 情况三 都包含了情况一了，所以只考虑情况二和情况三就可以了</strong>。</p>
<p>分析到这里，本题其实比较简单了。 剩下的和<a target="_blank" rel="noopener" href="https://programmercarl.com/0198.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D.html">198.打家劫舍</a>就是一样的了。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意注释中的情况二情况三，以及把198.打家劫舍的代码抽离出来了</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> result1 = <span class="built_in">robRange</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">2</span>); <span class="comment">// 情况二</span></span><br><span class="line">        <span class="type">int</span> result2 = <span class="built_in">robRange</span>(nums, <span class="number">1</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>); <span class="comment">// 情况三</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(result1, result2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 198.打家劫舍的逻辑</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">robRange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (end == start) <span class="keyword">return</span> nums[start];</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">        dp[start] = nums[start];</span><br><span class="line">        dp[start + <span class="number">1</span>] = <span class="built_in">max</span>(nums[start], nums[start + <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = start + <span class="number">2</span>; i &lt;= end; i++) &#123;</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(dp[i - <span class="number">2</span>] + nums[i], dp[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[end];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="打家劫舍-III"><a href="#打家劫舍-III" class="headerlink" title="打家劫舍 III"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/house-robber-iii/">打家劫舍 III</a></h1><p>在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。</p>
<p>计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。</p>
<p><img src="https://img-blog.csdnimg.cn/20210223173849619.png" alt="337.打家劫舍III"></p>
<h2 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h2><p><strong>本题一定是要后序遍历，因为通过递归函数的返回值来做下一步计算</strong>。</p>
<p>与198.打家劫舍，213.打家劫舍II一样，关键是要讨论当前节点抢还是不抢。</p>
<p>如果抢了当前节点，两个孩子就不能动，如果没抢当前节点，就可以考虑抢左右孩子（<strong>注意这里说的是“考虑”</strong>）</p>
<p>动态规划其实就是使用状态转移容器来记录状态的变化，这里可以使用一个长度为2的数组，记录当前节点偷与不偷所得到的的最大金钱。</p>
<p><strong>这道题目算是树形dp的入门题目，因为是在树上进行状态转移，我们在讲解二叉树的时候说过递归三部曲，那么下面我以递归三部曲为框架，其中融合动规五部曲的内容来进行讲解</strong>。</p>
<ol>
<li>确定递归函数的参数和返回值</li>
</ol>
<p>这里我们要求一个节点 偷与不偷的两个状态所得到的金钱，那么返回值就是一个长度为2的数组。</p>
<p>参数为当前节点，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">robTree</span><span class="params">(TreeNode* cur)</span> </span>&#123;</span><br></pre></td></tr></table></figure>

<p>其实这里的返回数组就是dp数组。</p>
<p>所以dp数组（dp table）以及下标的含义：下标为0记录不偷该节点所得到的的最大金钱，下标为1记录偷该节点所得到的的最大金钱。</p>
<p><strong>所以本题dp数组就是一个长度为2的数组！</strong></p>
<p>那么有同学可能疑惑，长度为2的数组怎么标记树中每个节点的状态呢？</p>
<p><strong>别忘了在递归的过程中，系统栈会保存每一层递归的参数</strong>。</p>
<p>如果还不理解的话，就接着往下看，看到代码就理解了哈。</p>
<ol start="2">
<li>确定终止条件</li>
</ol>
<p>在遍历的过程中，如果遇到空节点的话，很明显，无论偷还是不偷都是0，所以就返回</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt;&#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>这也相当于dp数组的初始化</p>
<ol start="3">
<li>确定遍历顺序</li>
</ol>
<p>首先明确的是使用后序遍历。 因为通过递归函数的返回值来做下一步计算。</p>
<p>通过递归左节点，得到左节点偷与不偷的金钱。</p>
<p>通过递归右节点，得到右节点偷与不偷的金钱。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下标0：不偷，下标1：偷</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; left = <span class="built_in">robTree</span>(cur-&gt;left); <span class="comment">// 左</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; right = <span class="built_in">robTree</span>(cur-&gt;right); <span class="comment">// 右</span></span><br><span class="line"><span class="comment">// 中</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>确定单层递归的逻辑</li>
</ol>
<p>如果是偷当前节点，那么左右孩子就不能偷，val1 &#x3D; cur-&gt;val + left[0] + right[0]; （<strong>如果对下标含义不理解就在回顾一下dp数组的含义</strong>）</p>
<p>如果不偷当前节点，那么左右孩子就可以偷，至于到底偷不偷一定是选一个最大的，所以：val2 &#x3D; max(left[0], left[1]) + max(right[0], right[1]);</p>
<p>最后当前节点的状态就是{val2, val1}; 即：{不偷当前节点得到的最大金钱，偷当前节点得到的最大金钱}</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; left = <span class="built_in">robTree</span>(cur-&gt;left); <span class="comment">// 左</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; right = <span class="built_in">robTree</span>(cur-&gt;right); <span class="comment">// 右</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 偷cur</span></span><br><span class="line"><span class="type">int</span> val1 = cur-&gt;val + left[<span class="number">0</span>] + right[<span class="number">0</span>];</span><br><span class="line"><span class="comment">// 不偷cur</span></span><br><span class="line"><span class="type">int</span> val2 = <span class="built_in">max</span>(left[<span class="number">0</span>], left[<span class="number">1</span>]) + <span class="built_in">max</span>(right[<span class="number">0</span>], right[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">return</span> &#123;val2, val1&#125;;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>举例推导dp数组</li>
</ol>
<p>以示例1为例，dp数组状态如下：（<strong>注意用后序遍历的方式推导</strong>）</p>
<p><img src="https://code-thinking.cdn.bcebos.com/pics/337.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DIII.jpg" alt="337.打家劫舍III"></p>
<p><strong>最后头结点就是 取下标0 和 下标1的最大值就是偷得的最大金钱</strong>。</p>
<p>递归三部曲与动规五部曲分析完毕，C++代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result = <span class="built_in">robTree</span>(root);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(result[<span class="number">0</span>], result[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 长度为2的数组，0：不偷，1：偷</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">robTree</span><span class="params">(TreeNode* cur)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt;&#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; left = <span class="built_in">robTree</span>(cur-&gt;left);</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; right = <span class="built_in">robTree</span>(cur-&gt;right);</span><br><span class="line">        <span class="comment">// 偷cur</span></span><br><span class="line">        <span class="type">int</span> val1 = cur-&gt;val + left[<span class="number">0</span>] + right[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 不偷cur</span></span><br><span class="line">        <span class="type">int</span> val2 = <span class="built_in">max</span>(left[<span class="number">0</span>], left[<span class="number">1</span>]) + <span class="built_in">max</span>(right[<span class="number">0</span>], right[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> &#123;val2, val1&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：$O(n)$，每个节点只遍历了一次</li>
<li>空间复杂度：$O(\log n)$，算上递推系统栈的空间</li>
</ul>
<h1 id="买卖股票的最佳时机"><a href="#买卖股票的最佳时机" class="headerlink" title="买卖股票的最佳时机"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">买卖股票的最佳时机</a></h1><p>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。</p>
<p>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p>
<p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p>
<p>示例 1：<br>输入：[7,1,5,3,6,4]<br>输出：5<br>解释：在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出，最大利润 &#x3D; 6-1 &#x3D; 5 。注意利润不能是 7-1 &#x3D; 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</p>
<p>示例 2：<br>输入：prices &#x3D; [7,6,4,3,1]<br>输出：0<br>解释：在这种情况下, 没有交易完成, 所以最大利润为 0。</p>
<h2 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h2><p>动规五部曲分析如下：</p>
<ol>
<li>确定dp数组（dp table）以及下标的含义</li>
</ol>
<p>dp[i][0] 表示第i天持有股票所得最多现金 ，<strong>这里可能有同学疑惑，本题中只能买卖一次，持有股票之后哪还有现金呢？</strong></p>
<p>其实一开始现金是0，那么加入第i天买入股票现金就是 -prices[i]， 这是一个负数。</p>
<p>dp[i][1] 表示第i天不持有股票所得最多现金</p>
<p><strong>注意这里说的是“持有”，“持有”不代表就是当天“买入”！也有可能是昨天就买入了，今天保持持有的状态</strong></p>
<p>很多同学把“持有”和“买入”没分区分清楚。</p>
<p>在下面递推公式分析中，我会进一步讲解。</p>
<ol start="2">
<li>确定递推公式</li>
</ol>
<p>如果第i天持有股票即dp[i][0]， 那么可以由两个状态推出来</p>
<ul>
<li>第i-1天就持有股票，那么就保持现状，所得现金就是昨天持有股票的所得现金 即：dp[i - 1][0]</li>
<li>第i天买入股票，所得现金就是买入今天的股票后所得现金即：-prices[i]</li>
</ul>
<p>那么dp[i][0]应该选所得现金最大的，所以<strong>dp[i][0] &#x3D; max(dp[i - 1][0], -prices[i])</strong>;</p>
<p>如果第i天不持有股票即dp[i][1]， 也可以由两个状态推出来</p>
<ul>
<li>第i-1天就不持有股票，那么就保持现状，所得现金就是昨天不持有股票的所得现金 即：dp[i - 1][1]</li>
<li>第i天卖出股票，所得现金就是按照今天股票佳价格卖出后所得现金即：prices[i] + dp[i - 1][0]</li>
</ul>
<p>同样dp[i][1]取最大的，<strong>dp[i][1] &#x3D; max(dp[i - 1][1], prices[i] + dp[i - 1][0])</strong>;</p>
<p>这样递归公式我们就分析完了</p>
<ol start="3">
<li>dp数组如何初始化</li>
</ol>
<p>由递推公式 dp[i][0] &#x3D; max(dp[i - 1][0], -prices[i]); 和 dp[i][1] &#x3D; max(dp[i - 1][1], prices[i] + dp[i - 1][0]);可以看出</p>
<p>其基础都是要从dp[0][0]和dp[0][1]推导出来。</p>
<p>那么dp[0][0]表示第0天持有股票，此时的持有股票就一定是买入股票了，因为不可能有前一天推出来，所以dp[0][0] -&#x3D; prices[0];</p>
<p>dp[0][1]表示第0天不持有股票，不持有股票那么现金就是0，所以dp[0][1] &#x3D; 0;</p>
<ol start="4">
<li>确定遍历顺序</li>
</ol>
<p>从递推公式可以看出dp[i]都是有dp[i - 1]推导出来的，那么一定是从前向后遍历。</p>
<ol start="5">
<li>举例推导dp数组</li>
</ol>
<p>以示例1，输入：[7,1,5,3,6,4]为例，dp数组状态如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20210224225642465.png" alt="121.买卖股票的最佳时机"></p>
<p>dp[5][1]就是最终结果。</p>
<p>为什么不是dp[5][0]呢？</p>
<p><strong>因为本题中不持有股票状态所得金钱一定比持有股票状态得到的多！</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 版本一</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(len, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] -= prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>], -prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>], prices[i] + dp[i - <span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="买卖股票的最佳时机II"><a href="#买卖股票的最佳时机II" class="headerlink" title="买卖股票的最佳时机II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">买卖股票的最佳时机II</a></h1><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p>
<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p>示例 1:<br>输入: [7,1,5,3,6,4]<br>输出: 7<br>解释: 在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 3 天（股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5-1 &#x3D; 4。随后，在第 4 天（股票价格 &#x3D; 3）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出, 这笔交易所能获得利润 &#x3D; 6-3 &#x3D; 3 。</p>
<p>示例 2:<br>输入: [1,2,3,4,5]<br>输出: 4<br>解释: 在第 1 天（股票价格 &#x3D; 1）的时候买入，在第 5 天 （股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5-1 &#x3D; 4 。注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</p>
<p>示例 3:<br>输入: [7,6,4,3,1]<br>输出: 0<br>解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</p>
<p>提示：</p>
<ul>
<li>1 &lt;&#x3D; prices.length &lt;&#x3D; 3 * 10 ^ 4</li>
<li>0 &lt;&#x3D; prices[i] &lt;&#x3D; 10 ^ 4</li>
</ul>
<h1 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h1><p>本题和<a target="_blank" rel="noopener" href="https://programmercarl.com/0121.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA.html">121. 买卖股票的最佳时机</a>的唯一区别本题股票可以买卖多次了（注意只有一只股票，所以再次购买前要出售掉之前的股票）</p>
<p>在动规五部曲中，这个区别主要是体现在递推公式上，其他都和<a target="_blank" rel="noopener" href="https://programmercarl.com/0121.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA.html">121. 买卖股票的最佳时机 </a>一样一样的。</p>
<p>所以我们重点讲一讲递推公式。</p>
<p>这里重申一下dp数组的含义：</p>
<ul>
<li>dp[i][0] 表示第i天持有股票所得现金。</li>
<li>dp[i][1] 表示第i天不持有股票所得最多现金</li>
</ul>
<p>如果第i天持有股票即dp[i][0]， 那么可以由两个状态推出来</p>
<ul>
<li>第i-1天就持有股票，那么就保持现状，所得现金就是昨天持有股票的所得现金 即：dp[i - 1][0]</li>
<li>第i天买入股票，所得现金就是昨天不持有股票的所得现金减去 今天的股票价格 即：dp[i - 1][1] - prices[i]</li>
</ul>
<p>注意这里和<a target="_blank" rel="noopener" href="https://programmercarl.com/0121.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA.html">121. 买卖股票的最佳时机 </a>唯一不同的地方，就是推导dp[i][0]的时候，第i天买入股票的情况。</p>
<p>在<a target="_blank" rel="noopener" href="https://programmercarl.com/0121.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA.html">121. 买卖股票的最佳时机</a>中，因为股票全程只能买卖一次，所以如果买入股票，那么第i天持有股票即dp[i][0]一定就是 -prices[i]。</p>
<p>而本题，因为一只股票可以买卖多次，所以当第i天买入股票的时候，所持有的现金可能有之前买卖过的利润。</p>
<p>那么第i天持有股票即dp[i][0]，如果是第i天买入股票，所得现金就是昨天不持有股票的所得现金 减去 今天的股票价格 即：dp[i - 1][1] - prices[i]。</p>
<p>在来看看如果第i天不持有股票即dp[i][1]的情况， 依然可以由两个状态推出来</p>
<ul>
<li>第i-1天就不持有股票，那么就保持现状，所得现金就是昨天不持有股票的所得现金 即：dp[i - 1][1]</li>
<li>第i天卖出股票，所得现金就是按照今天股票佳价格卖出后所得现金即：prices[i] + dp[i - 1][0]</li>
</ul>
<p><strong>注意这里和<a target="_blank" rel="noopener" href="https://programmercarl.com/0121.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA.html">121. 买卖股票的最佳时机 </a>就是一样的逻辑，卖出股票收获利润（可能是负值）天经地义！</strong></p>
<p>代码如下：（注意代码中的注释，标记了和121.买卖股票的最佳时机唯一不同的地方）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = prices.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(len, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] -= prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] - prices[i]); <span class="comment">// 注意这里是和121. 买卖股票的最佳时机唯一不同的地方。</span></span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="买卖股票的最佳时机III"><a href="#买卖股票的最佳时机III" class="headerlink" title="买卖股票的最佳时机III"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/">买卖股票的最佳时机III</a></h1><p>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。</p>
<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p>示例 1: 输入：prices &#x3D; [3,3,5,0,0,3,1,4] 输出：6 解释：在第 4 天（股票价格 &#x3D; 0）的时候买入，在第 6 天（股票价格 &#x3D; 3）的时候卖出，这笔交易所能获得利润 &#x3D; 3-0 &#x3D; 3 。随后，在第 7 天（股票价格 &#x3D; 1）的时候买入，在第 8 天 （股票价格 &#x3D; 4）的时候卖出，这笔交易所能获得利润 &#x3D; 4-1 &#x3D; 3。</p>
<p>示例 2： 输入：prices &#x3D; [1,2,3,4,5] 输出：4 解释：在第 1 天（股票价格 &#x3D; 1）的时候买入，在第 5 天 （股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5-1 &#x3D; 4。注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</p>
<p>示例 3： 输入：prices &#x3D; [7,6,4,3,1] 输出：0 解释：在这个情况下, 没有交易完成, 所以最大利润为0。</p>
<p>示例 4： 输入：prices &#x3D; [1] 输出：0</p>
<p>提示：</p>
<ul>
<li>1 &lt;&#x3D; prices.length &lt;&#x3D; 10^5</li>
<li>0 &lt;&#x3D; prices[i] &lt;&#x3D; 10^5</li>
</ul>
<h2 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h2><p>这道题目相对 <a target="_blank" rel="noopener" href="https://programmercarl.com/0121.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA.html">121.买卖股票的最佳时机 </a>和 <a target="_blank" rel="noopener" href="https://programmercarl.com/0122.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII.html">122.买卖股票的最佳时机II </a>难了不少。</p>
<p>关键在于至多买卖两次，这意味着<strong>可以买卖一次，可以买卖两次，也可以不买卖</strong>。</p>
<p>接来下我用动态规划五部曲详细分析一下：</p>
<ol>
<li>确定dp数组以及下标的含义</li>
</ol>
<p>一天一共就有五个状态，</p>
<ol start="0">
<li>没有操作</li>
<li>第一次买入</li>
<li>第一次卖出</li>
<li>第二次买入</li>
<li>第二次卖出</li>
</ol>
<p>dp[i][j]中 i表示第i天，j为 [0 - 4] 五个状态，dp[i][j]表示第i天状态j所剩最大现金。</p>
<ol start="2">
<li>确定递推公式</li>
</ol>
<p>需要注意：dp[i][1]，<strong>表示的是第i天，买入股票的状态，并不是说一定要第i天买入股票，这是很多同学容易陷入的误区</strong>。</p>
<p>达到dp[i][1]状态，有两个具体操作：</p>
<ul>
<li>操作一：第i天买入股票了，那么dp[i][1] &#x3D; dp[i-1][0] - prices[i]</li>
<li>操作二：第i天没有操作，而是沿用前一天买入的状态，即：dp[i][1] &#x3D; dp[i - 1][1]</li>
</ul>
<p>那么dp[i][1]究竟选 dp[i-1][0] - prices[i]，还是dp[i - 1][1]呢？</p>
<p>一定是选最大的，所以 dp[i][1] &#x3D; max(dp[i-1][0] - prices[i], dp[i - 1][1]);</p>
<p>同理dp[i][2]也有两个操作：</p>
<ul>
<li>操作一：第i天卖出股票了，那么dp[i][2] &#x3D; dp[i - 1][1] + prices[i]</li>
<li>操作二：第i天没有操作，沿用前一天卖出股票的状态，即：dp[i][2] &#x3D; dp[i - 1][2]</li>
</ul>
<p>所以dp[i][2] &#x3D; max(dp[i - 1][1] + prices[i], dp[i - 1][2])</p>
<p>同理可推出剩下状态部分：</p>
<p>dp[i][3] &#x3D; max(dp[i - 1][3], dp[i - 1][2] - prices[i]);</p>
<p>dp[i][4] &#x3D; max(dp[i - 1][4], dp[i - 1][3] + prices[i]);</p>
<ol start="3">
<li>dp数组如何初始化</li>
</ol>
<p>第0天没有操作，这个最容易想到，就是0，即：dp[0][0] &#x3D; 0;</p>
<p>第0天做第一次买入的操作，dp[0][1] &#x3D; -prices[0];</p>
<p>第0天做第一次卖出的操作，这个初始值应该是多少呢？</p>
<p>首先卖出的操作一定是收获利润，整个股票买卖最差情况也就是没有盈利即全程无操作现金为0，</p>
<p>从递推公式中可以看出每次是取最大值，那么既然是收获利润如果比0还小了就没有必要收获这个利润了。</p>
<p>所以dp[0][2] &#x3D; 0;</p>
<p>第0天第二次买入操作，初始值应该是多少呢？应该不少同学疑惑，第一次还没买入呢，怎么初始化第二次买入呢？</p>
<p>第二次买入依赖于第一次卖出的状态，其实相当于第0天第一次买入了，第一次卖出了，然后在买入一次（第二次买入），那么现在手头上没有现金，只要买入，现金就做相应的减少。</p>
<p>所以第二次买入操作，初始化为：dp[0][3] &#x3D; -prices[0];</p>
<p>同理第二次卖出初始化dp[0][4] &#x3D; 0;</p>
<ol start="4">
<li>确定遍历顺序</li>
</ol>
<p>从递归公式其实已经可以看出，一定是从前向后遍历，因为dp[i]，依靠dp[i - 1]的数值。</p>
<ol start="5">
<li>举例推导dp数组</li>
</ol>
<p>以输入[1,2,3,4,5]为例</p>
<p><img src="https://img-blog.csdnimg.cn/20201228181724295.png" alt="123.买卖股票的最佳时机III"></p>
<p>大家可以看到红色框为最后两次卖出的状态。</p>
<p>现在最大的时候一定是卖出的状态，而两次卖出的状态现金最大一定是最后一次卖出。</p>
<p>所以最终最大利润是dp[4][4]</p>
<p>以上五部都分析完了，不难写出如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(prices.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">5</span>, <span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">3</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">            dp[i][<span class="number">2</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">2</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i][<span class="number">3</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">3</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>] - prices[i]);</span><br><span class="line">            dp[i][<span class="number">4</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">4</span>], dp[i - <span class="number">1</span>][<span class="number">3</span>] + prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[prices.<span class="built_in">size</span>() - <span class="number">1</span>][<span class="number">4</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="买卖股票的最佳时机IV"><a href="#买卖股票的最佳时机IV" class="headerlink" title="买卖股票的最佳时机IV"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/">买卖股票的最佳时机IV</a></h1><p>给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。</p>
<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p>示例 1： 输入：k &#x3D; 2, prices &#x3D; [2,4,1] 输出：2 解释：在第 1 天 (股票价格 &#x3D; 2) 的时候买入，在第 2 天 (股票价格 &#x3D; 4) 的时候卖出，这笔交易所能获得利润 &#x3D; 4-2 &#x3D; 2。</p>
<p>示例 2： 输入：k &#x3D; 2, prices &#x3D; [3,2,6,5,0,3] 输出：7 解释：在第 2 天 (股票价格 &#x3D; 2) 的时候买入，在第 3 天 (股票价格 &#x3D; 6) 的时候卖出, 这笔交易所能获得利润 &#x3D; 6-2 &#x3D; 4。随后，在第 5 天 (股票价格 &#x3D; 0) 的时候买入，在第 6 天 (股票价格 &#x3D; 3) 的时候卖出, 这笔交易所能获得利润 &#x3D; 3-0 &#x3D; 3 。</p>
<p>提示：</p>
<ul>
<li>0 &lt;&#x3D; k &lt;&#x3D; 100</li>
<li>0 &lt;&#x3D; prices.length &lt;&#x3D; 1000</li>
<li>0 &lt;&#x3D; prices[i] &lt;&#x3D; 1000</li>
</ul>
<h2 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h2><p>这道题目可以说是<a target="_blank" rel="noopener" href="https://programmercarl.com/0123.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIII.html">动态规划：123.买卖股票的最佳时机III</a>的进阶版，这里要求至多有k次交易。</p>
<p>动规五部曲，分析如下：</p>
<ol>
<li>确定dp数组以及下标的含义</li>
</ol>
<p>在<a target="_blank" rel="noopener" href="https://programmercarl.com/0123.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIII.html">动态规划：123.买卖股票的最佳时机III </a>中，我是定义了一个二维dp数组，本题其实依然可以用一个二维dp数组。</p>
<p>使用二维数组 dp[i][j] ：第i天的状态为j，所剩下的最大现金是dp[i][j]</p>
<p>j的状态表示为：</p>
<ul>
<li>0 表示不操作</li>
<li>1 第一次买入</li>
<li>2 第一次卖出</li>
<li>3 第二次买入</li>
<li>4 第二次卖出</li>
<li>…..</li>
</ul>
<p><strong>大家应该发现规律了吧 ，除了0以外，偶数就是卖出，奇数就是买入</strong>。</p>
<p>题目要求是至多有K笔交易，那么j的范围就定义为 2 * k + 1 就可以了。</p>
<p>所以二维dp数组的C++定义为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(prices.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span> * k + <span class="number">1</span>, <span class="number">0</span>));</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>确定递推公式</li>
</ol>
<p>还要强调一下：dp[i][1]，<strong>表示的是第i天，买入股票的状态，并不是说一定要第i天买入股票，这是很多同学容易陷入的误区</strong>。</p>
<p>达到dp[i][1]状态，有两个具体操作：</p>
<ul>
<li>操作一：第i天买入股票了，那么dp[i][1] &#x3D; dp[i - 1][0] - prices[i]</li>
<li>操作二：第i天没有操作，而是沿用前一天买入的状态，即：dp[i][1] &#x3D; dp[i - 1][1]</li>
</ul>
<p>选最大的，所以 dp[i][1] &#x3D; max(dp[i - 1][0] - prices[i], dp[i - 1][1]);</p>
<p>同理dp[i][2]也有两个操作：</p>
<ul>
<li>操作一：第i天卖出股票了，那么dp[i][2] &#x3D; dp[i - 1][1] + prices[i]</li>
<li>操作二：第i天没有操作，沿用前一天卖出股票的状态，即：dp[i][2] &#x3D; dp[i - 1][2]</li>
</ul>
<p>所以dp[i][2] &#x3D; max(dp[i - 1][1] + prices[i], dp[i - 1][2])</p>
<p>同理可以类比剩下的状态，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span> * k - <span class="number">1</span>; j += <span class="number">2</span>) &#123;</span><br><span class="line">    dp[i][j + <span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j + <span class="number">1</span>], dp[i - <span class="number">1</span>][j] - prices[i]);</span><br><span class="line">    dp[i][j + <span class="number">2</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j + <span class="number">2</span>], dp[i - <span class="number">1</span>][j + <span class="number">1</span>] + prices[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本题和<a target="_blank" rel="noopener" href="https://programmercarl.com/0123.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIII.html">动态规划：123.买卖股票的最佳时机III</a>最大的区别就是这里要类比j为奇数是买，偶数是卖的状态。</p>
<ol start="3">
<li>dp数组如何初始化</li>
</ol>
<p>第0天没有操作，这个最容易想到，就是0，即：dp[0][0] &#x3D; 0;</p>
<p>第0天做第一次买入的操作，dp[0][1] &#x3D; -prices[0];</p>
<p>第0天做第一次卖出的操作，这个初始值应该是多少呢？</p>
<p>首先卖出的操作一定是收获利润，整个股票买卖最差情况也就是没有盈利即全程无操作现金为0，</p>
<p>从递推公式中可以看出每次是取最大值，那么既然是收获利润如果比0还小了就没有必要收获这个利润了。</p>
<p>所以dp[0][2] &#x3D; 0;</p>
<p>第0天第二次买入操作，初始值应该是多少呢？</p>
<p>不用管第几次，现在手头上没有现金，只要买入，现金就做相应的减少。</p>
<p>第二次买入操作，初始化为：dp[0][3] &#x3D; -prices[0];</p>
<p><strong>所以同理可以推出dp[0][j]当j为奇数的时候都初始化为 -prices[0]</strong></p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; <span class="number">2</span> * k; j += <span class="number">2</span>) &#123;</span><br><span class="line">    dp[<span class="number">0</span>][j] = -prices[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在初始化的地方同样要类比j为偶数是卖、奇数是买的状态</strong>。</p>
<ol start="4">
<li>确定遍历顺序</li>
</ol>
<p>从递归公式其实已经可以看出，一定是从前向后遍历，因为dp[i]，依靠dp[i - 1]的数值。</p>
<ol start="5">
<li>举例推导dp数组</li>
</ol>
<p>以输入[1,2,3,4,5]，k&#x3D;2为例。</p>
<p><img src="https://img-blog.csdnimg.cn/20201229100358221.png" alt="188.买卖股票的最佳时机IV"></p>
<p>最后一次卖出，一定是利润最大的，dp[prices.size() - 1][2 * k]即红色部分就是最后求解。</p>
<p>以上分析完毕，C++代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(<span class="type">int</span> k, vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (prices.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(prices.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span> * k + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; <span class="number">2</span> * k; j += <span class="number">2</span>) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = -prices[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt; prices.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span> * k - <span class="number">1</span>; j += <span class="number">2</span>) &#123;</span><br><span class="line">                dp[i][j + <span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j + <span class="number">1</span>], dp[i - <span class="number">1</span>][j] - prices[i]);</span><br><span class="line">                dp[i][j + <span class="number">2</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j + <span class="number">2</span>], dp[i - <span class="number">1</span>][j + <span class="number">1</span>] + prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[prices.<span class="built_in">size</span>() - <span class="number">1</span>][<span class="number">2</span> * k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="最佳买卖股票时机含冷冻期"><a href="#最佳买卖股票时机含冷冻期" class="headerlink" title="最佳买卖股票时机含冷冻期"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/">最佳买卖股票时机含冷冻期</a></h1><p>给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。</p>
<p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p>
<ul>
<li>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</li>
<li>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</li>
</ul>
<p>示例: 输入: [1,2,3,0,2] 输出: 3 解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]</p>
<h2 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h2><p>相对于<a target="_blank" rel="noopener" href="https://programmercarl.com/0122.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89.html">动态规划：122.买卖股票的最佳时机II </a>，本题加上了一个冷冻期</p>
<p>在<a target="_blank" rel="noopener" href="https://programmercarl.com/0122.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89.html">动态规划：122.买卖股票的最佳时机II </a>中有两个状态，持有股票后的最多现金，和不持有股票的最多现金。</p>
<p>动规五部曲，分析如下：</p>
<ol>
<li>确定dp数组以及下标的含义</li>
</ol>
<p>dp[i][j]，第i天状态为j，所剩的最多现金为dp[i][j]。</p>
<p><strong>其实本题很多同学搞的比较懵，是因为出现冷冻期之后，状态其实是比较复杂度</strong>，例如今天买入股票、今天卖出股票、今天是冷冻期，都是不能操作股票的。 具体可以区分出如下四个状态：</p>
<ul>
<li>状态一：买入股票状态（今天买入股票，或者是之前就买入了股票然后没有操作）</li>
<li>卖出股票状态，这里就有两种卖出股票状态<ul>
<li>状态二：两天前就卖出了股票，度过了冷冻期，一直没操作，今天保持卖出股票状态</li>
<li>状态三：今天卖出了股票</li>
</ul>
</li>
<li>状态四：今天为冷冻期状态，但冷冻期状态不可持续，只有一天！</li>
</ul>
<p>j的状态为：</p>
<ul>
<li>0：状态一</li>
<li>1：状态二</li>
<li>2：状态三</li>
<li>3：状态四</li>
</ul>
<p>很多题解为什么讲的比较模糊，是因为把这四个状态合并成三个状态了，其实就是把状态二和状态四合并在一起了。</p>
<p>从代码上来看确实可以合并，但从逻辑上分析合并之后就很难理解了，所以我下面的讲解是按照这四个状态来的，把每一个状态分析清楚。</p>
<p><strong>注意这里的每一个状态，例如状态一，是买入股票状态并不是说今天已经就买入股票，而是说保存买入股票的状态即：可能是前几天买入的，之后一直没操作，所以保持买入股票的状态</strong>。</p>
<ol start="2">
<li>确定递推公式</li>
</ol>
<p>达到买入股票状态（状态一）即：dp[i][0]，有两个具体操作：</p>
<ul>
<li>操作一：前一天就是持有股票状态（状态一），dp[i][0] &#x3D; dp[i - 1][0]</li>
<li>操作二：今天买入了，有两种情况<ul>
<li>前一天是冷冻期（状态四），dp[i - 1][3] - prices[i]</li>
<li>前一天是保持卖出股票状态（状态二），dp[i - 1][1] - prices[i]</li>
</ul>
</li>
</ul>
<p>所以操作二取最大值，即：max(dp[i - 1][3], dp[i - 1][1]) - prices[i]</p>
<p>那么dp[i][0] &#x3D; max(dp[i - 1][0], max(dp[i - 1][3], dp[i - 1][1]) - prices[i]);</p>
<p>达到保持卖出股票状态（状态二）即：dp[i][1]，有两个具体操作：</p>
<ul>
<li>操作一：前一天就是状态二</li>
<li>操作二：前一天是冷冻期（状态四）</li>
</ul>
<p>dp[i][1] &#x3D; max(dp[i - 1][1], dp[i - 1][3]);</p>
<p>达到今天就卖出股票状态（状态三），即：dp[i][2] ，只有一个操作：</p>
<ul>
<li>操作一：昨天一定是买入股票状态（状态一），今天卖出</li>
</ul>
<p>即：dp[i][2] &#x3D; dp[i - 1][0] + prices[i];</p>
<p>达到冷冻期状态（状态四），即：dp[i][3]，只有一个操作：</p>
<ul>
<li>操作一：昨天卖出了股票（状态三）</li>
</ul>
<p>dp[i][3] &#x3D; dp[i - 1][2];</p>
<p>综上分析，递推代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>], <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">3</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>]) - prices[i]);</span><br><span class="line">dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">3</span>]);</span><br><span class="line">dp[i][<span class="number">2</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i];</span><br><span class="line">dp[i][<span class="number">3</span>] = dp[i - <span class="number">1</span>][<span class="number">2</span>];</span><br></pre></td></tr></table></figure>



<ol start="3">
<li>dp数组如何初始化</li>
</ol>
<p>这里主要讨论一下第0天如何初始化。</p>
<p>如果是持有股票状态（状态一）那么：dp[0][0] &#x3D; -prices[0]，买入股票所剩现金为负数。</p>
<p>保持卖出股票状态（状态二），第0天没有卖出dp[0][1]初始化为0就行，</p>
<p>今天卖出了股票（状态三），同样dp[0][2]初始化为0，因为最少收益就是0，绝不会是负数。</p>
<p>同理dp[0][3]也初始为0。</p>
<ol start="4">
<li>确定遍历顺序</li>
</ol>
<p>从递归公式上可以看出，dp[i] 依赖于 dp[i-1]，所以是从前向后遍历。</p>
<ol start="5">
<li>举例推导dp数组</li>
</ol>
<p>以 [1,2,3,0,2] 为例，dp数组如下：</p>
<p><img src="https://img-blog.csdnimg.cn/2021032317451040.png" alt="309.最佳买卖股票时机含冷冻期"></p>
<p>最后结果是取 状态二，状态三，和状态四的最大值，不少同学会把状态四忘了，状态四是冷冻期，最后一天如果是冷冻期也可能是最大值。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">4</span>, <span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] -= prices[<span class="number">0</span>]; <span class="comment">// 持股票</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>], <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">3</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>]) - prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">3</span>]);</span><br><span class="line">            dp[i][<span class="number">2</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i];</span><br><span class="line">            dp[i][<span class="number">3</span>] = dp[i - <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp[n - <span class="number">1</span>][<span class="number">3</span>],<span class="built_in">max</span>(dp[n - <span class="number">1</span>][<span class="number">1</span>], dp[n - <span class="number">1</span>][<span class="number">2</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="买卖股票的最佳时机含手续费"><a href="#买卖股票的最佳时机含手续费" class="headerlink" title="买卖股票的最佳时机含手续费"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">买卖股票的最佳时机含手续费</a></h1><p>给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。</p>
<p>你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</p>
<p>返回获得利润的最大值。</p>
<p>注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。</p>
<p>示例 1: 输入: prices &#x3D; [1, 3, 2, 8, 4, 9], fee &#x3D; 2 输出: 8</p>
<p>解释: 能够达到的最大利润: 在此处买入 prices[0] &#x3D; 1 在此处卖出 prices[3] &#x3D; 8 在此处买入 prices[4] &#x3D; 4 在此处卖出 prices[5] &#x3D; 9 总利润: ((8 - 1) - 2) + ((9 - 4) - 2) &#x3D; 8.</p>
<p>注意:</p>
<ul>
<li>0 &lt; prices.length &lt;&#x3D; 50000.</li>
<li>0 &lt; prices[i] &lt; 50000.</li>
<li>0 &lt;&#x3D; fee &lt; 50000.</li>
</ul>
<h2 id="思路-11"><a href="#思路-11" class="headerlink" title="思路"></a>思路</h2><p>在讲解贪心专题的时候，我们已经讲过本题了<a target="_blank" rel="noopener" href="https://programmercarl.com/0714.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9.html">贪心算法：买卖股票的最佳时机含手续费</a></p>
<p>使用贪心算法，的性能是：</p>
<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)</li>
</ul>
<p>那么我们再来看看是使用动规的方法如何解题。</p>
<p>相对于<a target="_blank" rel="noopener" href="https://programmercarl.com/0122.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89.html">动态规划：122.买卖股票的最佳时机II </a>，本题只需要在计算卖出操作的时候减去手续费就可以了，代码几乎是一样的。</p>
<p>唯一差别在于递推公式部分，所以本篇也就不按照动规五部曲详细讲解了，主要讲解一下递推公式部分。</p>
<p>这里重申一下dp数组的含义：</p>
<p>dp[i][0] 表示第i天持有股票所省最多现金。 dp[i][1] 表示第i天不持有股票所得最多现金</p>
<p>如果第i天持有股票即dp[i][0]， 那么可以由两个状态推出来</p>
<ul>
<li>第i-1天就持有股票，那么就保持现状，所得现金就是昨天持有股票的所得现金 即：dp[i - 1][0]</li>
<li>第i天买入股票，所得现金就是昨天不持有股票的所得现金减去 今天的股票价格 即：dp[i - 1][1] - prices[i]</li>
</ul>
<p>所以：dp[i][0] &#x3D; max(dp[i - 1][0], dp[i - 1][1] - prices[i]);</p>
<p>在来看看如果第i天不持有股票即dp[i][1]的情况， 依然可以由两个状态推出来</p>
<ul>
<li>第i-1天就不持有股票，那么就保持现状，所得现金就是昨天不持有股票的所得现金 即：dp[i - 1][1]</li>
<li>第i天卖出股票，所得现金就是按照今天股票价格卖出后所得现金，<strong>注意这里需要有手续费了</strong>即：dp[i - 1][0] + prices[i] - fee</li>
</ul>
<p>所以：dp[i][1] &#x3D; max(dp[i - 1][1], dp[i - 1][0] + prices[i] - fee);</p>
<p>本题和<a target="_blank" rel="noopener" href="https://programmercarl.com/0122.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89.html">动态规划：122.买卖股票的最佳时机II </a>的区别就是这里需要多一个减去手续费的操作。</p>
<p>以上分析完毕，C++代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices, <span class="type">int</span> fee)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] -= prices[<span class="number">0</span>]; <span class="comment">// 持股票</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] - prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i] - fee);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp[n - <span class="number">1</span>][<span class="number">0</span>], dp[n - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>















































<p>声明：</p>
<p>本博客整理主要参考《代码随想录》，题目来自leetcode</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/29/UE4-%E7%AC%AC%E4%B8%80%E4%BA%BA%E7%A7%B0FPS-%E4%BB%A3%E7%A0%81%E8%AE%B2%E8%A7%A3%EF%BC%88%E4%B8%80%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="williny">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Williny'home">
      <meta itemprop="description" content="孤独是人生的常态">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Williny'home">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/04/29/UE4-%E7%AC%AC%E4%B8%80%E4%BA%BA%E7%A7%B0FPS-%E4%BB%A3%E7%A0%81%E8%AE%B2%E8%A7%A3%EF%BC%88%E4%B8%80%EF%BC%89/" class="post-title-link" itemprop="url">UE4-第一人称FPS-代码讲解（一）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-04-29 14:38:10" itemprop="dateCreated datePublished" datetime="2022-04-29T14:38:10+08:00">2022-04-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-05-02 14:07:27" itemprop="dateModified" datetime="2022-05-02T14:07:27+08:00">2022-05-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/unreal-engine/" itemprop="url" rel="index"><span itemprop="name">unreal engine</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>案例是来自官方文档的<a target="_blank" rel="noopener" href="https://docs.unrealengine.com/4.27/zh-CN/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/1/">第一人称射击游戏教程</a>，详细实施步骤可以看我之前的博客，或者直接取官网查看，此处仅仅讲解实现项目的代码</p>
<h1 id="添加日志消息"><a href="#添加日志消息" class="headerlink" title="添加日志消息"></a>添加日志消息</h1><h2 id="FPSProjectGameMode-h"><a href="#FPSProjectGameMode-h" class="headerlink" title="FPSProjectGameMode.h"></a>FPSProjectGameMode.h</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CoreMinimal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GameFramework/GameModeBase.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;FPSProjectGameModeBase.generated.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FPSPROJECT_API</span> AFPSProjectGameModeBase : <span class="keyword">public</span> AGameModeBase</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于重载StartPlay()函数</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">StartPlay</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这一段没啥好说的，唯一修改的地方就是在此声明StartPlay()函数，使我们可以将其重载</p>
<h2 id="FPSProjectGameModeBase-cpp"><a href="#FPSProjectGameModeBase-cpp" class="headerlink" title="FPSProjectGameModeBase.cpp"></a>FPSProjectGameModeBase.cpp</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Epic Games, Inc版权所有。保留所有权利。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;FPSProjectGameMode.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSProjectGameModeBase::StartPlay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Super::<span class="built_in">StartPlay</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">check</span>(GEngine != <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示调试消息五秒。 </span></span><br><span class="line"><span class="comment">// -1&quot;键&quot;值参数防止该消息被更新或刷新。</span></span><br><span class="line">GEngine-&gt;<span class="built_in">AddOnScreenDebugMessage</span>(<span class="number">-1</span>, <span class="number">5.0f</span>, FColor::Yellow, <span class="built_in">TEXT</span>(<span class="string">&quot;Hello World, this is FPSGameModeBase!&quot;</span>));</span><br></pre></td></tr></table></figure>

<h3 id="check"><a href="#check" class="headerlink" title="check()"></a><a target="_blank" rel="noopener" href="https://docs.unrealengine.com/5.0/zh-CN/asserts-in-unreal-engine/">check()</a></h3><p>check()为断言</p>
<p>在C和C++编程中，<code>assert</code> 可在开发期间帮助检测和诊断不正常或无效的运行时条件。</p>
<p>这些条件通常检查是否指针为非空、除数为非零、函数并非递归运行，或代码要求的其他重要假设。但每次检查会使得效率十分低下。某些情况下，<code>assert</code> 会在延迟崩溃发生之前发现导致该崩溃的bug，例如删除未来tick所需的对象，协助开发人员发现引起崩溃的根本原因。</p>
<p><code>assert</code> 的关键特性之一是不存在于发布代码中，这意味着不但不会影响发布产品的性能，也没有任何副作用。对 <code>assert</code> 最简单的理解就是：**”断言”必须一律为true，否则程序会停止运行**。</p>
<p>虚幻引擎4（UE4）提供 <code>assert</code> 等同项的三个不同族系：<code>check</code>、<code>verify</code> 和 <code>ensure</code>。各个功能的行为略有不同，但它们都是开发期间使用的诊断工具，目标大致相同。</p>
<p>Check族系最接近基础 <code>assert</code>，因为当第一个参数得出的值为false时，此族系的成员会停止执行，且默认不会在发布版本中运行。以下Check宏可用：</p>
<table>
<thead>
<tr>
<th>宏</th>
<th>参数</th>
<th>行为</th>
</tr>
</thead>
<tbody><tr>
<td><code>check</code> 或 <code>checkSlow</code></td>
<td><code>Expression</code></td>
<td>若 <code>Expression</code> 为false，停止执行</td>
</tr>
<tr>
<td><code>checkf</code> 或 <code>checkfSlow</code></td>
<td><code>Expression</code>、<code>FormattedText</code>、<code>...</code></td>
<td>若 <code>Expression</code> 为false，则停止执行并将 <code>FormattedText</code> 输出到日志</td>
</tr>
<tr>
<td><code>checkCode</code></td>
<td><code>Code</code></td>
<td>在运行一次的do-while循环结构中执行 <code>Code</code>；主要用于准备另一个Check所需的信息</td>
</tr>
<tr>
<td><code>checkNoEntry</code></td>
<td>（无）</td>
<td>若此行被hit，则停止执行，类似于 <code>check(false)</code>，但主要用于应不可到达的代码路径</td>
</tr>
<tr>
<td><code>checkNoReentry</code></td>
<td>（无）</td>
<td>若此行被hit超过一次，则停止执行</td>
</tr>
<tr>
<td><code>checkNoRecursion</code></td>
<td>（无）</td>
<td>若此行被hit超过一次而未离开作用域，则停止执行</td>
</tr>
<tr>
<td><code>unimplemented</code></td>
<td>（无）</td>
<td>若此行被hit，则停止执行，类似于 <code>check(false)</code>，但主要用于应被覆盖而不会被调用的虚拟函数</td>
</tr>
</tbody></table>
<h3 id="GEngine"><a href="#GEngine" class="headerlink" title="GEngine"></a>GEngine</h3><p>看作一个全局指针，并且是只读的。</p>
<p>其经常使用为拿到当前的World: </p>
<ul>
<li><p>使用的成员方法为:GetWorldFromContextObject</p>
</li>
<li><p>参数为World的一个Uobject</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!GEngine || !GEngine-&gt;<span class="built_in">UseSound</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">UWorld* ThisWorld = GEngine-&gt;<span class="built_in">GetWorldFromContextObject</span>(WorldContextObject, EGetWorldErrorMode::L</span><br></pre></td></tr></table></figure>

<h2 id="AddOnScreenDebugMessage"><a href="#AddOnScreenDebugMessage" class="headerlink" title="AddOnScreenDebugMessage()"></a>AddOnScreenDebugMessage()</h2><p>在屏幕上打印试错信息</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GEngine-&gt;<span class="built_in">AddOnScreenDebugMessage</span>(<span class="number">-1</span>, <span class="number">5.0f</span>, FColor::Yellow, <span class="built_in">TEXT</span>(<span class="string">&quot;Hello World, this is FPSGameMode!&quot;</span>));</span><br></pre></td></tr></table></figure>

<p><code>AddOnScreenDebugMessage(uint64 Key, float TimeToDisplay, FColor DisplayColor, const FString&amp; DebugMessage, bool bNewerOnTop, const FVector2D&amp; TextScale)</code></p>
<ul>
<li><p>第一个参数默认为-1</p>
</li>
<li><p>第二个参数是debug显示时间</p>
</li>
<li><p>第三个参数是显示颜色</p>
</li>
<li><p>第四个参数是显示信息</p>
</li>
<li><p>第五个参数是是否在上面显示更新的消息（可不填）</p>
</li>
<li><p>第六个是显示字体大小（可不填）</p>
</li>
</ul>
<h1 id="实现角色移动"><a href="#实现角色移动" class="headerlink" title="实现角色移动"></a>实现角色移动</h1><h2 id="FPSCharacter-h"><a href="#FPSCharacter-h" class="headerlink" title="FPSCharacter.h"></a>FPSCharacter.h</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CoreMinimal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GameFramework/Character.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;FPSCharacter.generated.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FPSPROJECT_API</span> AFPSCharacter : <span class="keyword">public</span> ACharacter</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 为此角色的属性设置默认值</span></span><br><span class="line">    <span class="built_in">AFPSCharacter</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// 当游戏开始或重生（Spawn）时被调用</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BeginPlay</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 每一帧都被调用</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Tick</span><span class="params">( <span class="type">float</span> DeltaTime )</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 被调用，将功能与输入绑定</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SetupPlayerInputComponent</span><span class="params">(<span class="keyword">class</span> UInputComponent* PlayerInputComponent)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理用于前后移动的输入。</span></span><br><span class="line">    <span class="built_in">UFUNCTION</span>()</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">MoveForward</span><span class="params">(<span class="type">float</span> Value)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理用于左右移动的输入。</span></span><br><span class="line">    <span class="built_in">UFUNCTION</span>()</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">MoveRight</span><span class="params">(<span class="type">float</span> Value)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>声明前进和左右移动的函数，参数为Value，来自于在编辑界面中绑定的那个值</p>
<h2 id="FPSCharacter-cpp"><a href="#FPSCharacter-cpp" class="headerlink" title="FPSCharacter.cpp"></a>FPSCharacter.cpp</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;FPSCharacter.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置默认值</span></span><br><span class="line">AFPSCharacter::<span class="built_in">AFPSCharacter</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 将此角色设置为每帧调用Tick()。  如果不需要此特性，可以关闭以提升性能。</span></span><br><span class="line">    PrimaryActorTick.bCanEverTick = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当游戏开始或重生（Spawn）时被调用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::BeginPlay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">BeginPlay</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">check</span>(GEngine != <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 显示调试消息五秒。 </span></span><br><span class="line">    <span class="comment">// -1&quot;键&quot;值参数可以防止更新或刷新消息。</span></span><br><span class="line">      GEngine-&gt;<span class="built_in">AddOnScreenDebugMessage</span>(<span class="number">-1</span>, <span class="number">5.0f</span>, FColor::Red, <span class="built_in">TEXT</span>(<span class="string">&quot;We are using FPSCharacter.&quot;</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每一帧都被调用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::Tick</span><span class="params">( <span class="type">float</span> DeltaTime )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">Tick</span>( DeltaTime );</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 被调用，将功能与输入绑定</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::SetupPlayerInputComponent</span><span class="params">(UInputComponent* PlayerInputComponent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">SetupPlayerInputComponent</span>(PlayerInputComponent);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置&quot;移动&quot;绑定。</span></span><br><span class="line">    PlayerInputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="string">&quot;MoveForward&quot;</span>, <span class="keyword">this</span>, &amp;AFPSCharacter::MoveForward);</span><br><span class="line">    PlayerInputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="string">&quot;MoveRight&quot;</span>, <span class="keyword">this</span>, &amp;AFPSCharacter::MoveRight);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::MoveForward</span><span class="params">(<span class="type">float</span> Value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 找出&quot;前进&quot;方向，并记录玩家想向该方向移动。</span></span><br><span class="line">    FVector Direction = <span class="built_in">FRotationMatrix</span>(Controller-&gt;<span class="built_in">GetControlRotation</span>()).<span class="built_in">GetScaledAxis</span>(EAxis::X);</span><br><span class="line">    <span class="built_in">AddMovementInput</span>(Direction, Value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::MoveRight</span><span class="params">(<span class="type">float</span> Value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 找出&quot;右侧&quot;方向，并记录玩家想向该方向移动。</span></span><br><span class="line">    FVector Direction = <span class="built_in">FRotationMatrix</span>(Controller-&gt;<span class="built_in">GetControlRotation</span>()).<span class="built_in">GetScaledAxis</span>(EAxis::Y);</span><br><span class="line">    <span class="built_in">AddMovementInput</span>(Direction, Value);</span><br><span class="line">&#125;<span class="built_in">mponent</span>(PlayerInputComponent);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看移动函数，功能和输入绑定那块我们一会儿回过头来再看！</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::MoveForward</span><span class="params">(<span class="type">float</span> Value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 找出&quot;前进&quot;方向，并记录玩家想向该方向移动。</span></span><br><span class="line">    FVector Direction = <span class="built_in">FRotationMatrix</span>(Controller-&gt;<span class="built_in">GetControlRotation</span>()).<span class="built_in">GetScaledAxis</span>(EAxis::X);</span><br><span class="line">    <span class="built_in">AddMovementInput</span>(Direction, Value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本函数首先通过<code>GetScaledAxis(EAxis::X)</code>获取方向，比如此处是沿X轴（在编辑器中X轴代表前方，Y轴代表右方）</p>
<p>再通过<code>Controller-&gt;GetControlRotation()</code>获取管理员的旋转方位作为<code>FRotationMatrix()</code>的值并记录在变量Direction中</p>
<p>最后<code>AddMovementInput(Direction, Value)</code>函数实现向前移动</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 被调用，将功能与输入绑定</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::SetupPlayerInputComponent</span><span class="params">(UInputComponent* PlayerInputComponent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">SetupPlayerInputComponent</span>(PlayerInputComponent);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置&quot;移动&quot;绑定。</span></span><br><span class="line">    PlayerInputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="string">&quot;MoveForward&quot;</span>, <span class="keyword">this</span>, &amp;AFPSCharacter::MoveForward);</span><br><span class="line">    PlayerInputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="string">&quot;MoveRight&quot;</span>, <span class="keyword">this</span>, &amp;AFPSCharacter::MoveRight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再回过头来看绑定操作</p>
<p>很眼熟是不是？和我之前那篇博客里面实现小球的移动的绑定方式一模一样</p>
<p>在这里简述一下</p>
<p><code>BindAxis</code>绑定轴映射，与编辑-&gt;项目设置-&gt;输入-&gt;轴映射里面的命名必须一致</p>
<p>第一个参数为事件，此事件作用于第二个参数所指定的指针，由第三个参数（一个函数）来实现这个事件！</p>
<h1 id="实现鼠标摄像机控制"><a href="#实现鼠标摄像机控制" class="headerlink" title="实现鼠标摄像机控制"></a>实现鼠标摄像机控制</h1><h2 id="FPSCharacter-cpp-1"><a href="#FPSCharacter-cpp-1" class="headerlink" title="FPSCharacter.cpp"></a>FPSCharacter.cpp</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 被调用，将功能与输入绑定</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::SetupPlayerInputComponent</span><span class="params">(UInputComponent* PlayerInputComponent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">SetupPlayerInputComponent</span>(PlayerInputComponent);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置&quot;移动&quot;绑定。</span></span><br><span class="line">    PlayerInputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="string">&quot;MoveForward&quot;</span>, <span class="keyword">this</span>, &amp;AFPSCharacter::MoveForward);</span><br><span class="line">    PlayerInputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="string">&quot;MoveRight&quot;</span>, <span class="keyword">this</span>, &amp;AFPSCharacter::MoveRight);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置&quot;观看&quot;绑定。</span></span><br><span class="line">    PlayerInputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="string">&quot;Turn&quot;</span>, <span class="keyword">this</span>, &amp;AFPSCharacter::AddControllerYawInput);</span><br><span class="line">    PlayerInputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="string">&quot;LookUp&quot;</span>, <span class="keyword">this</span>, &amp;AFPSCharacter::AddControllerPitchInput);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里只需要设置鼠标对应的轴映射即可，与上文的移动绑定并无太大区别</p>
<h1 id="实现角色跳跃"><a href="#实现角色跳跃" class="headerlink" title="实现角色跳跃"></a>实现角色跳跃</h1><h2 id="FPSCharacter-h-1"><a href="#FPSCharacter-h-1" class="headerlink" title="FPSCharacter.h"></a>FPSCharacter.h</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CoreMinimal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GameFramework/Character.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;FPSCharacter.generated.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FPSPROJECT_API</span> AFPSCharacter : <span class="keyword">public</span> ACharacter</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 为此角色的属性设置默认值</span></span><br><span class="line">    <span class="built_in">AFPSCharacter</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// 当游戏开始或重生（Spawn）时被调用</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BeginPlay</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 每一帧都被调用</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Tick</span><span class="params">( <span class="type">float</span> DeltaTime )</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 被调用，将功能与输入绑定</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SetupPlayerInputComponent</span><span class="params">(<span class="keyword">class</span> UInputComponent* PlayerInputComponent)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理用于前后移动的输入。</span></span><br><span class="line">    <span class="built_in">UFUNCTION</span>()</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">MoveForward</span><span class="params">(<span class="type">float</span> Value)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理用于左右移动的输入。</span></span><br><span class="line">    <span class="built_in">UFUNCTION</span>()</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">MoveRight</span><span class="params">(<span class="type">float</span> Value)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按下键时，设置跳跃标记。</span></span><br><span class="line">    <span class="built_in">UFUNCTION</span>()</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">StartJump</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放键时，清除跳跃标记。</span></span><br><span class="line">    <span class="built_in">UFUNCTION</span>()</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">StopJump</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在Acharacter基类接口文件中，已经有了支持跳跃的成员方法。</p>
<p>角色跳跃与<code>bPressedJump</code>变量绑定，因此我们只需要在跳跃惭怍按下时将该布尔值设置为true，在跳跃操作释放时将该布尔值设置为false</p>
<p>现在我们通过StartJump()和StopJump()两个函数来完成改变布尔值的操作</p>
<p>于是我们首先在FPSCharacter.h中声明两个函数的声明</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按下键时，设置跳跃标记。</span></span><br><span class="line"><span class="built_in">UFUNCTION</span>()</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StartJump</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放键时，清除跳跃标记。</span></span><br><span class="line"><span class="built_in">UFUNCTION</span>()</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StopJump</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>接来下，我们在FPSCharacter.cpp中将其定义</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::StartJump</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bPressedJump = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::StopJump</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bPressedJump = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，我们对其进行按键绑定</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置&quot;操作&quot;绑定。</span></span><br><span class="line">PlayerInputComponent-&gt;<span class="built_in">BindAction</span>(<span class="string">&quot;Jump&quot;</span>, IE_Pressed, <span class="keyword">this</span>, &amp;AFPSCharacter::StartJump);</span><br><span class="line">PlayerInputComponent-&gt;<span class="built_in">BindAction</span>(<span class="string">&quot;Jump&quot;</span>, IE_Released, <span class="keyword">this</span>, &amp;AFPSCharacter::StopJump);</span><br></pre></td></tr></table></figure>

<p>BindAction()函数在我的前一篇博客中也做了详细讲解</p>
<p>这里提醒一下IE_Preesed和IE_Released分别代表了按压按键和松开按键的行为</p>
<h1 id="更改摄像机视角"><a href="#更改摄像机视角" class="headerlink" title="更改摄像机视角"></a>更改摄像机视角</h1><p>在此步骤中，你将设置FPS摄像机，这样你可以调整摄像机的属性（例如位置和视野）</p>
<p>在FPSCharacter.h中添加头文件</p>
<p><code>Camera/CameraComponent.h</code>摄像机组件</p>
<p><code>Components/CapsuleComonent.h</code> 胶囊体组件</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Camera/CameraComponent.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Components/CapsuleComponent.h&quot;</span></span></span><br></pre></td></tr></table></figure>

<h2 id="FPSCharacter-h-2"><a href="#FPSCharacter-h-2" class="headerlink" title="FPSCharacter.h"></a>FPSCharacter.h</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FPS摄像机。</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(VisibleAnywhere)</span><br><span class="line">UCameraComponent* FPSCameraComponent;</span><br></pre></td></tr></table></figure>

<p>声明一个摄像机组件，并且使其可视化</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CoreMinimal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GameFramework/Character.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Camera/CameraComponent.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Components/CapsuleComponent.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;FPSCharacter.generated.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FPSPROJECT_API</span> AFPSCharacter : <span class="keyword">public</span> ACharacter</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 为此角色的属性设置默认值</span></span><br><span class="line"><span class="built_in">AFPSCharacter</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="comment">// 当游戏开始或重生（Spawn）时被调用</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BeginPlay</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:     </span><br><span class="line"><span class="comment">// 每一帧都被调用</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Tick</span><span class="params">( <span class="type">float</span> DeltaTime )</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 被调用，将功能与输入绑定</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SetupPlayerInputComponent</span><span class="params">(<span class="keyword">class</span> UInputComponent* PlayerInputComponent)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理用于前后移动的输入。</span></span><br><span class="line"><span class="built_in">UFUNCTION</span>()</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MoveForward</span><span class="params">(<span class="type">float</span> Value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理用于左右移动的输入。</span></span><br><span class="line"><span class="built_in">UFUNCTION</span>()</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MoveRight</span><span class="params">(<span class="type">float</span> Value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按下键时，设置跳跃标记。</span></span><br><span class="line"><span class="built_in">UFUNCTION</span>()</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StartJump</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放键时，清除跳跃标记。</span></span><br><span class="line"><span class="built_in">UFUNCTION</span>()</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StopJump</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// FPS摄像机</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(VisibleAnywhere)</span><br><span class="line">UCameraComponent* FPSCameraComponent;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="FPSCharacter-cpp-2"><a href="#FPSCharacter-cpp-2" class="headerlink" title="FPSCharacter.cpp"></a>FPSCharacter.cpp</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建第一人称摄像机组件。</span></span><br><span class="line">FPSCameraComponent = <span class="built_in">CreateDefaultSubobject</span>&lt;UCameraComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;FirstPersonCamera&quot;</span>));</span><br><span class="line"><span class="built_in">check</span>(FPSCameraComponent != <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将摄像机组件附加到我们的胶囊体组件。</span></span><br><span class="line">FPSCameraComponent-&gt;<span class="built_in">SetupAttachment</span>(<span class="built_in">CastChecked</span>&lt;USceneComponent, UCapsuleComponent&gt;(<span class="built_in">GetCapsuleComponent</span>()));</span><br></pre></td></tr></table></figure>

<p>创建FPSCameraComponent组件</p>
<p>加上一个断言，保证创建成功</p>
<p>然后将摄像机组件附加到胶囊体，但这个时候会出现类型不匹配的问题</p>
<p>SetupAttachment()函数里面的参数必须是一个场景类型的组件，而此时我们想要将摄像机组件附加到一个胶囊体类型的组件上面。</p>
<p>所以我们需要将胶囊体类型组件进行强制转换。</p>
<p>有两种方式</p>
<p>方式一：</p>
<p>直接进行强制转换</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FPSCameraComponent-&gt;<span class="built_in">SetupAttachment</span>((USceneComponent *)<span class="built_in">GetCapsuleComponent</span>());</span><br></pre></td></tr></table></figure>

<p>方式二：</p>
<p>通过<code>CastCheck&lt;目标类型,原类型&gt;(组件)</code>进行强制转换</p>
<p>通过这个函数有什么好处呢？就是强制转换成功就照常进行，但如果强制转换失败，则会抛出异常</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FPSCameraComponent-&gt;<span class="built_in">SetupAttachment</span>(<span class="built_in">CastChecked</span>&lt;USceneComponent, UCapsuleComponent&gt;(<span class="built_in">GetCapsuleComponent</span>()));</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将摄像机置于略高于眼睛上方的位置。</span></span><br><span class="line">FPSCameraComponent-&gt;<span class="built_in">SetRelativeLocation</span>(<span class="built_in">FVector</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">50.0f</span> + BaseEyeHeight));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启用Pawn控制摄像机旋转。</span></span><br><span class="line">FPSCameraComponent-&gt;bUsePawnControlRotation = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<p><code>SetRelativeLocation</code> 用于设置组件的默认值。不过，上一个值仍然会在设置在编辑器中。为纠正这点，请打开蓝图编辑器。点击 <code>FPSCameraComponent</code>，然后在 <strong>细节</strong> 面板中找到 <strong>变换 -&gt; 位置（Transform -&gt; Location）</strong> 数值。点击这个值旁边的 <strong>重置为默认（Reset to Default）</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;FPSCharacter.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置默认值</span></span><br><span class="line">AFPSCharacter::<span class="built_in">AFPSCharacter</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 将此角色设置为每帧调用Tick()。  如果不需要此特性，可以关闭以提升性能。</span></span><br><span class="line">    PrimaryActorTick.bCanEverTick = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建第一人称摄像机组件。</span></span><br><span class="line">    FPSCameraComponent = <span class="built_in">CreateDefaultSubobject</span>&lt;UCameraComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;FirstPersonCamera&quot;</span>));</span><br><span class="line">    <span class="built_in">check</span>(FPSCameraComponent != <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将摄像机组件附加到我们的胶囊体组件。</span></span><br><span class="line">    FPSCameraComponent-&gt;<span class="built_in">SetupAttachment</span>(<span class="built_in">CastChecked</span>&lt;USceneComponent, UCapsuleComponent&gt;(<span class="built_in">GetCapsuleComponent</span>()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将摄像机置于略高于眼睛上方的位置。</span></span><br><span class="line">    FPSCameraComponent-&gt;<span class="built_in">SetRelativeLocation</span>(<span class="built_in">FVector</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">50.0f</span> + BaseEyeHeight));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启用Pawn控制摄像机旋转。</span></span><br><span class="line">    FPSCameraComponent-&gt;bUsePawnControlRotation = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当游戏开始或重生（Spawn）时被调用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::BeginPlay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">BeginPlay</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">check</span>(GEngine != <span class="literal">nullptr</span>)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 显示调试消息五秒。 </span></span><br><span class="line">     <span class="comment">// -1&quot;键&quot;值（第一个参数）表示我们从不需要更新或刷新此消息。</span></span><br><span class="line">      GEngine-&gt;<span class="built_in">AddOnScreenDebugMessage</span>(<span class="number">-1</span>, <span class="number">5.0f</span>, FColor::Red, <span class="built_in">TEXT</span>(<span class="string">&quot;We are using FPSCharacter.&quot;</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每一帧都被调用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::Tick</span><span class="params">( <span class="type">float</span> DeltaTime )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">Tick</span>( DeltaTime );</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 被调用，将功能与输入绑定</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::SetupPlayerInputComponent</span><span class="params">(UInputComponent* PlayerInputComponent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">SetupPlayerInputComponent</span>(PlayerInputComponent);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置&quot;移动&quot;绑定。</span></span><br><span class="line">    PlayerInputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="string">&quot;MoveForward&quot;</span>, <span class="keyword">this</span>, &amp;AFPSCharacter::MoveForward);</span><br><span class="line">    PlayerInputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="string">&quot;MoveRight&quot;</span>, <span class="keyword">this</span>, &amp;AFPSCharacter::MoveRight);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置&quot;观看&quot;绑定。</span></span><br><span class="line">    PlayerInputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="string">&quot;Turn&quot;</span>, <span class="keyword">this</span>, &amp;AFPSCharacter::AddControllerYawInput);</span><br><span class="line">    PlayerInputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="string">&quot;LookUp&quot;</span>, <span class="keyword">this</span>, &amp;AFPSCharacter::AddControllerPitchInput);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置&quot;操作&quot;绑定。</span></span><br><span class="line">    PlayerInputComponent-&gt;<span class="built_in">BindAction</span>(<span class="string">&quot;Jump&quot;</span>, IE_Pressed, <span class="keyword">this</span>, &amp;AFPSCharacter::StartJump);</span><br><span class="line">    PlayerInputComponent-&gt;<span class="built_in">BindAction</span>(<span class="string">&quot;Jump&quot;</span>, IE_Released, <span class="keyword">this</span>, &amp;AFPSCharacter::StopJump);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::MoveForward</span><span class="params">(<span class="type">float</span> Value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 找出&quot;前进&quot;方向，并记录玩家想向该方向移动。</span></span><br><span class="line">    FVector Direction = <span class="built_in">FRotationMatrix</span>(Controller-&gt;<span class="built_in">GetControlRotation</span>()).<span class="built_in">GetScaledAxis</span>(EAxis::X);</span><br><span class="line">    <span class="built_in">AddMovementInput</span>(Direction, Value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::MoveRight</span><span class="params">(<span class="type">float</span> Value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 找出&quot;右侧&quot;方向，并记录玩家想向该方向移动。</span></span><br><span class="line">    FVector Direction = <span class="built_in">FRotationMatrix</span>(Controller-&gt;<span class="built_in">GetControlRotation</span>()).<span class="built_in">GetScaledAxis</span>(EAxis::Y);</span><br><span class="line">    <span class="built_in">AddMovementInput</span>(Direction, Value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::StartJump</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bPressedJump = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::StopJump</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bPressedJump = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="将第一人称网格体添加到角色中"><a href="#将第一人称网格体添加到角色中" class="headerlink" title="将第一人称网格体添加到角色中"></a>将第一人称网格体添加到角色中</h1><h2 id="FPSCharacter-h-3"><a href="#FPSCharacter-h-3" class="headerlink" title="FPSCharacter.h"></a>FPSCharacter.h</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一人称网格体（手臂），仅对所属玩家可见。</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(VisibleDefaultsOnly, Category = Mesh)</span><br><span class="line">USkeletalMeshComponent* FPSMesh;</span><br></pre></td></tr></table></figure>

<p>在头文件中声明第一人称网格体，将其命名为FPSMesh</p>
<h2 id="FPSCharacter-cpp-3"><a href="#FPSCharacter-cpp-3" class="headerlink" title="FPSCharacter.cpp"></a>FPSCharacter.cpp</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为所属玩家创建第一人称网格体组件。</span></span><br><span class="line">FPSMesh = <span class="built_in">CreateDefaultSubobject</span>&lt;USkeletalMeshComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;FirstPersonMesh&quot;</span>));</span><br><span class="line"><span class="built_in">check</span>(FPSMesh != <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 仅所属玩家可以看见此网格体。</span></span><br><span class="line">FPSMesh-&gt;<span class="built_in">SetOnlyOwnerSee</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 FPS 网格体附加到 FPS 摄像机。</span></span><br><span class="line">FPSMesh-&gt;<span class="built_in">SetupAttachment</span>(FPSCameraComponent);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 禁用某些环境阴影以便实现只有单个网格体的感觉。</span></span><br><span class="line">FPSMesh-&gt;bCastDynamicShadow = <span class="literal">false</span>;</span><br><span class="line">FPSMesh-&gt;CastShadow = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<p>定义第一人称网格体</p>
<p>做一个断言</p>
<p>将第一人称网格体设定为仅所属玩家可见</p>
<p>将第一人称网格体附加到摄像机上</p>
<p>将第一人称网格体（手臂）的阴影禁用掉，这样就不会在地面上看到一个人有四条手臂的情况了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将第一人称网格体设置为仅所属玩家可见</span></span><br><span class="line"><span class="built_in">GetMesh</span>()-&gt;<span class="built_in">SetOwnerNoSee</span>(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<p>将手臂设置为仅自己可见，免得到时候其他玩家看到你一个人前面悬浮着一双手！</p>
<p>这一处官网的解释是：所属玩家看不到常规（第三人称）全身网格体。</p>
<p>我觉得是有问题的，像我这样理解的话更清楚直白</p>
<h1 id="将发射物添加到游戏"><a href="#将发射物添加到游戏" class="headerlink" title="将发射物添加到游戏"></a>将发射物添加到游戏</h1><h2 id="FPSProjectile-h"><a href="#FPSProjectile-h" class="headerlink" title="FPSProjectile.h"></a>FPSProjectile.h</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Components/SphereComponent.h&quot;</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 球体碰撞组件。</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(VisibleDefaultsOnly, Category = Projectile)</span><br><span class="line">USphereComponent* CollisionComponent;</span><br></pre></td></tr></table></figure>

<p>这就很常规，首先引入头文件，然后声明球体碰撞逐渐，并将其命名为CollisionComponent</p>
<h2 id="FPSProjectile-cpp"><a href="#FPSProjectile-cpp" class="headerlink" title="FPSProjectile.cpp"></a>FPSProjectile.cpp</h2><p>在构造函数中添加</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!RootComponent)</span><br><span class="line">&#123;</span><br><span class="line">RootComponent = <span class="built_in">CreateDefaultSubobject</span>&lt;USceneComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;ProjectileSceneComponent&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!CollisionComponent)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 用球体进行简单的碰撞展示。</span></span><br><span class="line">CollisionComponent = <span class="built_in">CreateDefaultSubobject</span>&lt;USphereComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;SphereComponent&quot;</span>));</span><br><span class="line"><span class="comment">// 设置球体的碰撞半径。</span></span><br><span class="line">CollisionComponent-&gt;<span class="built_in">InitSphereRadius</span>(<span class="number">15.0f</span>);</span><br><span class="line"><span class="comment">// 将根组件设置为碰撞组件。</span></span><br><span class="line">RootComponent = CollisionComponent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把 <code>CollisionComponent</code> 设为 <code>RootComponent</code>，接下来的操作就都是对CollisionComponent直接进行的了。</p>
<p>每一次都会生成一个新的CollisionComponent，然后根组件也随之更新到新的CollisionComponent上，这样我们每次进行的操作都是对新的CollisionComponent进行的。</p>
<h1 id="添加发射物移动组件"><a href="#添加发射物移动组件" class="headerlink" title="添加发射物移动组件"></a>添加发射物移动组件</h1><h2 id="FPSProjectile-h-1"><a href="#FPSProjectile-h-1" class="headerlink" title="FPSProjectile.h"></a>FPSProjectile.h</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GameFramework/ProjectileMovementComponent.h&quot;</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发射物移动组件。</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(VisibleAnywhere, Category = Movement)</span><br><span class="line">UProjectileMovementComponent* ProjectileMovementComponent;</span><br></pre></td></tr></table></figure>

<p>引入头文件，声明发射物移动组件并命名为ProjectileMovementCompone</p>
<h2 id="FPSProjectile-cpp-1"><a href="#FPSProjectile-cpp-1" class="headerlink" title="FPSProjectile.cpp"></a>FPSProjectile.cpp</h2><p>在FPSProjectile.cpp的构造函数中添加</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!ProjectileMovementComponent)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 使用此组件驱动发射物的移动。</span></span><br><span class="line">    ProjectileMovementComponent = <span class="built_in">CreateDefaultSubobject</span>&lt;UProjectileMovementComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;ProjectileMovementComponent&quot;</span>));</span><br><span class="line">    ProjectileMovementComponent-&gt;<span class="built_in">SetUpdatedComponent</span>(CollisionComponent);</span><br><span class="line">    ProjectileMovementComponent-&gt;InitialSpeed = <span class="number">3000.0f</span>;</span><br><span class="line">    ProjectileMovementComponent-&gt;MaxSpeed = <span class="number">3000.0f</span>;</span><br><span class="line">    ProjectileMovementComponent-&gt;bRotationFollowsVelocity = <span class="literal">true</span>;</span><br><span class="line">    ProjectileMovementComponent-&gt;bShouldBounce = <span class="literal">true</span>;</span><br><span class="line">    ProjectileMovementComponent-&gt;Bounciness = <span class="number">0.3f</span>;</span><br><span class="line">    ProjectileMovementComponent-&gt;ProjectileGravityScale = <span class="number">0.0f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>定义移动组件</p>
</li>
<li><p>将移动组件进行更新</p>
</li>
<li><p>InitialSpeed初始速度设置为3000.0f</p>
</li>
<li><p>MaxSpeed最大速度设置为3000.0f</p>
</li>
<li><p>bRotationFollowsVelocity是否沿某方向进行高速旋转</p>
</li>
<li><p>bShouldBounce能否被反弹</p>
</li>
<li><p>Bounciness受到阻碍之后的反弹力是多少</p>
</li>
<li><p>ProjectileGravityScale受到的重力大小（弹道抛物线）</p>
</li>
</ul>
<h1 id="设置发射物的方向"><a href="#设置发射物的方向" class="headerlink" title="设置发射物的方向"></a>设置发射物的方向</h1><p>在官网上此标题为“设置发射物的初始速度”</p>
<p>但是我觉得不妥，因为在上一小节中，我们已经在发射物的移动组件内设置了发射物的初始速度，在这一小节中，我们只需要定义一个函数，此函数为发射物提供一个方向，然后再根据已经初始化的速度，进行发射即可</p>
<h2 id="FPSProjectile-h-2"><a href="#FPSProjectile-h-2" class="headerlink" title="FPSProjectile.h"></a>FPSProjectile.h</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化射击方向上发射物速度的函数。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FireInDirection</span><span class="params">(<span class="type">const</span> FVector&amp; ShootDirection)</span></span>;</span><br></pre></td></tr></table></figure>

<p>声明发射物方向函数，参数为设计方向（记住这里是引用传递）</p>
<h2 id="FPSProjectile-cpp-2"><a href="#FPSProjectile-cpp-2" class="headerlink" title="FPSProjectile.cpp"></a>FPSProjectile.cpp</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化射击方向上发射物速度的函数。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSProjectile::FireInDirection</span><span class="params">(<span class="type">const</span> FVector&amp; ShootDirection)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ProjectileMovementComponent-&gt;Velocity = ShootDirection * ProjectileMovementComponent-&gt;InitialSpeed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Velocity的中文意思是沿某一方向的速度</p>
<p>所以这个值是由两个参数共同决定的-&gt;方向和速度</p>
<p>Velocity更像是一个向量，可以将其理解为一个合成力，它的两个子力为方向和速度</p>
<p>于是我们直接调用射击方向*已在移动函数中设置好的速度</p>
<h1 id="绑定发射输入操作"><a href="#绑定发射输入操作" class="headerlink" title="绑定发射输入操作"></a>绑定发射输入操作</h1><h2 id="FPSCharacter-h-4"><a href="#FPSCharacter-h-4" class="headerlink" title="FPSCharacter.h"></a>FPSCharacter.h</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理发射物射击的函数。</span></span><br><span class="line"><span class="built_in">UFUNCTION</span>()</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Fire</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>声明函数，没啥好多说的。</p>
<h2 id="FPSCharacter-cpp-4"><a href="#FPSCharacter-cpp-4" class="headerlink" title="FPSCharacter.cpp"></a>FPSCharacter.cpp</h2><p>将其下内容添加到<code>SetupPlayerInputComponent</code>中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PlayerInputComponent-&gt;<span class="built_in">BindAction</span>(<span class="string">&quot;Fire&quot;</span>, IE_Pressed, <span class="keyword">this</span>, &amp;AFPSCharacter::Fire);</span><br></pre></td></tr></table></figure>

<p>绑定操作按键，也没啥好多说的</p>
<p>先将fire()的定义添加到cpp文件中，后面咱再详细定义具体实现</p>
<h1 id="定义发射物的生成位置"><a href="#定义发射物的生成位置" class="headerlink" title="定义发射物的生成位置"></a>定义发射物的生成位置</h1><ol>
<li><p>生成 <code>FPSProjectile</code> actor并实现 <code>OnFire</code> 函数时需要考虑两点，即：</p>
<ul>
<li><p>发射物的生成位置。</p>
</li>
<li><p>发射物对应的类（让 <code>FPSCharacter</code> 及其派生蓝图知道要生成哪种发射物）。</p>
</li>
</ul>
</li>
</ol>
<p>你将使用一个摄像机空间中的偏移向量来确定发射物的生成位置。设置该参数为可编辑参数，这样你就可以在 <code>BP_FPSCharacter</code> 蓝图中对其进行设置和调整。最终，你可以基于这些数据计算发射物的初始位置。</p>
<h2 id="FPSCharacter-h-5"><a href="#FPSCharacter-h-5" class="headerlink" title="FPSCharacter.h"></a>FPSCharacter.h</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 枪口相对于摄像机位置的偏移。</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadWrite, Category = Gameplay)</span><br><span class="line">FVector MuzzleOffset;</span><br></pre></td></tr></table></figure>

<p>MuzzleOffset是一个跟随着摄像机的中间量</p>
<p>在后面我们会根据这个中间量定义枪口的世界位置</p>
<p>将以下代码添加到protected:下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 要生成的发射物类。</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditDefaultsOnly, Category = Projectile)</span><br><span class="line">TSubclassOf&lt;<span class="keyword">class</span> <span class="title class_">AFPSProjectile</span>&gt; ProjectileClass;</span><br></pre></td></tr></table></figure>

<p><code>EditDefaultsOnly</code> 意味着你只能将发射物类设置为蓝图上的默认值，而不是每个蓝图实例上的默认值。</p>
<p>在蓝图或C++层面调用SpawnActor创建一个actor对象，或者调用SpawnActorDeferred</p>
<p>延迟创建一个actor对象时，都需要一个class类型的参数。</p>
<p>如果在C++层面，对象类型是我们自己在蓝图里做的蓝图类</p>
<p>那么C++层面需要得到蓝图类型</p>
<p>做法如下：</p>
<p>建立一个成员变量并暴露给蓝图</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UPROPERTY</span>(EditDefaultsOnly, Category = XXX)</span><br><span class="line"></span><br><span class="line">TSubclassOf&lt;<span class="keyword">class</span> 蓝图类的C++父类&gt; 变量名称</span><br></pre></td></tr></table></figure>

<p>接下来就可以再蓝图里面给这个变量设置蓝图类型</p>
<p>最后调用SpawnActor或SpawnActorDeferred将上面定义的变量传入给class参数即可生成对象</p>
<p>简单来说，就是需要依托某个类（父类）生成一个Actor对象时，就可以使用TSubclassOf</p>
<h1 id="实现射击"><a href="#实现射击" class="headerlink" title="实现射击"></a>实现射击</h1><h2 id="FPSCharacter-h-6"><a href="#FPSCharacter-h-6" class="headerlink" title="FPSCharacter.h"></a>FPSCharacter.h</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;FPSProjectile.h&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>引入发射物的头文件</p>
<h2 id="FPSCharacter-cpp-5"><a href="#FPSCharacter-cpp-5" class="headerlink" title="FPSCharacter.cpp"></a>FPSCharacter.cpp</h2><p>用以下代码段定义fire()函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ProjectileClass)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 获取摄像机变换。</span></span><br><span class="line">FVector CameraLocation;</span><br><span class="line">FRotator CameraRotation;</span><br><span class="line"><span class="built_in">GetActorEyesViewPoint</span>(CameraLocation, CameraRotation);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置MuzzleOffset，在略靠近摄像机前生成发射物。</span></span><br><span class="line">MuzzleOffset.<span class="built_in">Set</span>(<span class="number">100.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将MuzzleOffset从摄像机空间变换到世界空间。</span></span><br><span class="line">FVector MuzzleLocation = CameraLocation + <span class="built_in">FTransform</span>(CameraRotation).<span class="built_in">TransformVector</span>(MuzzleOffset);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使目标方向略向上倾斜。</span></span><br><span class="line">FRotator MuzzleRotation = CameraRotation;</span><br><span class="line">MuzzleRotation.Pitch += <span class="number">10.0f</span>;</span><br><span class="line"></span><br><span class="line">UWorld* World = <span class="built_in">GetWorld</span>();</span><br><span class="line"><span class="keyword">if</span> (World)</span><br><span class="line">&#123;</span><br><span class="line">    FActorSpawnParameters SpawnParams;</span><br><span class="line">    SpawnParams.Owner = <span class="keyword">this</span>;</span><br><span class="line">    SpawnParams.Instigator = <span class="built_in">GetInstigator</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在枪口位置生成发射物。</span></span><br><span class="line">    AFPSProjectile* Projectile = World-&gt;<span class="built_in">SpawnActor</span>&lt;AFPSProjectile&gt;(ProjectileClass, MuzzleLocation, MuzzleRotation, SpawnParams);</span><br><span class="line">    <span class="keyword">if</span> (Projectile)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 设置发射物的初始轨迹。</span></span><br><span class="line">        FVector LaunchDirection = MuzzleRotation.<span class="built_in">Vector</span>();</span><br><span class="line">        Projectile-&gt;<span class="built_in">FireInDirection</span>(LaunchDirection);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="将枪口位置转换为世界坐标中的位置"><a href="#将枪口位置转换为世界坐标中的位置" class="headerlink" title="将枪口位置转换为世界坐标中的位置"></a>将枪口位置转换为世界坐标中的位置</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置MuzzleOffset，在略靠近摄像机前生成发射物。</span></span><br><span class="line">MuzzleOffset.<span class="built_in">Set</span>(<span class="number">100.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将MuzzleOffset从摄像机空间变换到世界空间。</span></span><br><span class="line">FVector MuzzleLocation = CameraLocation + <span class="built_in">FTransform</span>(CameraRotation).<span class="built_in">TransformVector</span>(MuzzleOffset);</span><br></pre></td></tr></table></figure>

<p>先设置枪口的位置，然后根据枪口位置和相机位置转换为世界坐标中的位置</p>
<p><code>CameraLocation + FTransform(CameraRotation).TransformVector(MuzzleOffset);</code></p>
<h3 id="模拟后坐力"><a href="#模拟后坐力" class="headerlink" title="模拟后坐力"></a>模拟后坐力</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使目标方向略向上倾斜。</span></span><br><span class="line">FRotator MuzzleRotation = CameraRotation;</span><br><span class="line">MuzzleRotation.Pitch += <span class="number">10.0f</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">UWorld* World = <span class="built_in">GetWorld</span>();</span><br><span class="line"><span class="keyword">if</span> (World)</span><br><span class="line"> &#123;</span><br><span class="line">FActorSpawnParameters SpawnParams;</span><br><span class="line">SpawnParams.Owner = <span class="keyword">this</span>;</span><br><span class="line">SpawnParams.Instigator = <span class="built_in">GetInstigator</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在枪口位置生成发射物。</span></span><br><span class="line">AFPSProjectile* Projectile = World-&gt;<span class="built_in">SpawnActor</span>&lt;AFPSProjectile&gt;(ProjectileClass, MuzzleLocation, MuzzleRotation, SpawnParams);</span><br><span class="line"><span class="keyword">if</span> (Projectile)&#123;<span class="comment">//如果生成成功</span></span><br><span class="line">     <span class="comment">// 设置发射物的初始轨迹。</span></span><br><span class="line">     FVector LaunchDirection = MuzzleRotation.<span class="built_in">Vector</span>();</span><br><span class="line">     Projectile-&gt;<span class="built_in">FireInDirection</span>(LaunchDirection);</span><br><span class="line">               &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="FActorSpwanParamenters"><a href="#FActorSpwanParamenters" class="headerlink" title="FActorSpwanParamenters"></a>FActorSpwanParamenters</h3><p>是一个传递给SpawnActor函数的可选参数的结构体</p>
<p>它有很多的对象</p>
<p>Name：衍生Actor的名称（不填写的话就会有一个默认值）</p>
<p>Templat：将用模板值对新生成的Actor进行初始化</p>
<p>Owner：衍生的Actor</p>
<p>Instigator：敌方</p>
<p>定义一个FPSProjectile类的对象（发射物），这个对象要在世界坐标内，所以就需要在世界坐标内生成发射物，所以此时我们需要调用world中的SpawnActor&lt;&gt;()函数</p>
<h3 id="SpawnActor"><a href="#SpawnActor" class="headerlink" title="SpawnActor"></a>SpawnActor</h3><p>SpawnActor&lt;发射物的构造函数&gt;(要生成的发射物类，发射物位置，发射物角度，FActorSpawnParameters的对象)</p>
<p>用来生成发射物</p>
<p>最后是设置发射物的初始轨迹</p>
<p>以枪口的角度定义一个FVector</p>
<p>再将该FVector作为参数填入到FireInDirection()中（此函数再前文已经讲解过）</p>
<h1 id="添加发射物网格体"><a href="#添加发射物网格体" class="headerlink" title="添加发射物网格体"></a>添加发射物网格体</h1><h2 id="FPSProjectile-h-3"><a href="#FPSProjectile-h-3" class="headerlink" title="FPSProjectile.h"></a>FPSProjectile.h</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发射物网格体</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(VisibleDefaultsOnly, Category = Projectile)</span><br><span class="line">UStaticMeshComponent* ProjectileMeshComponent;</span><br></pre></td></tr></table></figure>

<h2 id="FPSProjectile-cpp-3"><a href="#FPSProjectile-cpp-3" class="headerlink" title="FPSProjectile.cpp"></a>FPSProjectile.cpp</h2><p>构造函数中添加</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!ProjectileMeshComponent)</span><br><span class="line">&#123;</span><br><span class="line">    ProjectileMeshComponent = <span class="built_in">CreateDefaultSubobject</span>&lt;UStaticMeshComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;ProjectileMeshComponent&quot;</span>));</span><br><span class="line">    <span class="type">static</span> ConstructorHelpers::FObjectFinder&lt;UStaticMesh&gt;<span class="built_in">Mesh</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;&#x27;/Game/Sphere.Sphere&#x27;&quot;</span>));</span><br><span class="line">    <span class="keyword">if</span>(Mesh.<span class="built_in">Succeeded</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        ProjectileMeshComponent-&gt;<span class="built_in">SetStaticMesh</span>(Mesh.Object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="添加发射物材质"><a href="#添加发射物材质" class="headerlink" title="添加发射物材质"></a>添加发射物材质</h1><h2 id="FPSProjectile-h-4"><a href="#FPSProjectile-h-4" class="headerlink" title="FPSProjectile.h"></a>FPSProjectile.h</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发射物材质</span></span><br><span class="line"><span class="built_in">UPROPERTY</span>(VisibleDefaultsOnly, Category = Movement)</span><br><span class="line">UMaterialInstanceDynamic* ProjectileMaterialInstance;</span><br></pre></td></tr></table></figure>

<h2 id="FPSProjectile-cpp-4"><a href="#FPSProjectile-cpp-4" class="headerlink" title="FPSProjectile.cpp"></a>FPSProjectile.cpp</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> ConstructorHelpers::FObjectFinder&lt;UMaterial&gt;<span class="built_in">Material</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;&#x27;/Game/SphereMaterial.SphereMaterial&#x27;&quot;</span>));</span><br><span class="line"><span class="keyword">if</span> (Material.<span class="built_in">Succeeded</span>())</span><br><span class="line">&#123;</span><br><span class="line">    ProjectileMaterialInstance = UMaterialInstanceDynamic::<span class="built_in">Create</span>(Material.Object, ProjectileMeshComponent);</span><br><span class="line">&#125;</span><br><span class="line">ProjectileMeshComponent-&gt;<span class="built_in">SetMaterial</span>(<span class="number">0</span>, ProjectileMaterialInstance);</span><br><span class="line">ProjectileMeshComponent-&gt;<span class="built_in">SetRelativeScale3D</span>(<span class="built_in">FVector</span>(<span class="number">0.09f</span>, <span class="number">0.09f</span>, <span class="number">0.09f</span>));</span><br><span class="line">ProjectileMeshComponent-&gt;<span class="built_in">SetupAttachment</span>(RootComponent);</span><br></pre></td></tr></table></figure>

<p>SetMaterial()源文件</p>
<ul>
<li><p>第一个参数：必须大于等于0的，具体啥玩意，确实还没搞懂，等我以后搞懂了，再做补充说明</p>
</li>
<li><p>第二个参数：材质名称</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">SetMaterial</span>(int32 ElementIndex, UMaterialInterface* Material)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">check</span>(ElementIndex &gt;= <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (ElementIndex &gt;= BaseMaterials.<span class="built_in">Num</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        BaseMaterials.<span class="built_in">SetNum</span>(ElementIndex + <span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    BaseMaterials[ElementIndex] = Material;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他的就都没什么好讲解的了，如果看不懂的话，可以看看我之前的博客内容</p>
<h1 id="限制发射物的生命周期"><a href="#限制发射物的生命周期" class="headerlink" title="限制发射物的生命周期"></a>限制发射物的生命周期</h1><h2 id="FPSProjectile-cpp-5"><a href="#FPSProjectile-cpp-5" class="headerlink" title="FPSProjectile.cpp"></a>FPSProjectile.cpp</h2><p>添加到构造函数中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3 秒后删除发射物。</span></span><br><span class="line">InitialLifeSpan = <span class="number">3.0f</span>;</span><br></pre></td></tr></table></figure>

<p>这玩意叫初始化声明周期</p>
<h1 id="编辑发射物的碰撞设置"><a href="#编辑发射物的碰撞设置" class="headerlink" title="编辑发射物的碰撞设置"></a>编辑发射物的碰撞设置</h1><p>虚幻引擎自带了数个预设碰撞通道；不过，引擎也支持游戏项目使用自定义通道。</p>
<ol>
<li><p>要创建自定义碰撞通道，打开项目设置（Project Settings），在引擎（Engine） - 碰撞（Collision）中，展开预设（Preset）。</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/3/SettingCollisionChannels.jpg" alt="SettingCollisionChannels.png"></p>
</li>
<li><p>在对象通道（Object Channels）中，选择 <strong>新建对象通道…（New Object Channel…）</strong>，创建新碰撞通道。将新碰撞通道命名为”Projectile”，确保将默认响应（Default Response）设置为阻止（Block），然后点击接受（Accept）。</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/3/NewChannel.jpg" alt="NewChannel.png"></p>
</li>
<li><p>在预设（Preset）中选择 <strong>新建…（New…）</strong>，将新配置文件命名为”Projectile”。参考以下图片来设置你的碰撞预设。然后点击”接受（Accept）”。</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/3/NewProfile.jpg" alt="NewProfile.png"></p>
</li>
</ol>
<p>此碰撞配置文件将发射物设定为将被静态Actor、动态Actor、模拟物理Actor、载具和可破坏Actor阻挡。此外，此碰撞配置文件设定发射物与Pawn重叠。</p>
<h1 id="使用新的发射物的碰撞设置"><a href="#使用新的发射物的碰撞设置" class="headerlink" title="使用新的发射物的碰撞设置"></a>使用新的发射物的碰撞设置</h1><h2 id="FPSProjectile-cpp-6"><a href="#FPSProjectile-cpp-6" class="headerlink" title="FPSProjectile.cpp"></a>FPSProjectile.cpp</h2><p>在FPSProjectile构造函数中，将以下代码行添加到CreateDefaultSubobject下方</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将球体的碰撞配置文件名称设置为&quot;Projectile&quot;。</span></span><br><span class="line">CollisionComponent-&gt;BodyInstance.<span class="built_in">SetCollisionProfileName</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;Projectile&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>这是在修改碰撞组件的形体实例的碰撞配置文件</p>
<h1 id="使发射物对碰撞做出响应"><a href="#使发射物对碰撞做出响应" class="headerlink" title="使发射物对碰撞做出响应"></a>使发射物对碰撞做出响应</h1><h2 id="FPSProjectile-h-5"><a href="#FPSProjectile-h-5" class="headerlink" title="FPSProjectile.h"></a>FPSProjectile.h</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当发射物击中物体时会调用的函数。</span></span><br><span class="line"><span class="built_in">UFUNCTION</span>()</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OnHit</span><span class="params">(UPrimitiveComponent* HitComponent, AActor* OtherActor, UPrimitiveComponent* OtherComponent, FVector NormalImpulse, <span class="type">const</span> FHitResult&amp; Hit)</span></span>;</span><br></pre></td></tr></table></figure>

<p>声明击中物体时的函数</p>
<h2 id="FPSProjectile-cpp-7"><a href="#FPSProjectile-cpp-7" class="headerlink" title="FPSProjectile.cpp"></a>FPSProjectile.cpp</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当发射物击中物体时会调用的函数。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSProjectile::OnHit</span><span class="params">(UPrimitiveComponent* HitComponent, AActor* OtherActor, UPrimitiveComponent* OtherComponent, FVector NormalImpulse, <span class="type">const</span> FHitResult&amp; Hit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (OtherActor != <span class="keyword">this</span> &amp;&amp; OtherComponent-&gt;<span class="built_in">IsSimulatingPhysics</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        OtherComponent-&gt;<span class="built_in">AddImpulseAtLocation</span>(ProjectileMovementComponent-&gt;Velocity * <span class="number">100.0f</span>, Hit.ImpactPoint);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Destroy</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果另一个actor不是本actor，而且另一个actor的组件上使模拟物理状态的</p>
<p>那么另一个组件就调用AddImpulseAtLocation()函数来模拟被击中的反馈</p>
<p><code>AddImpulseAtLocation(ProjectileMovementComponent-&gt;Velocity * 100.0f, Hit.ImpactPoint);</code></p>
<p>第一个参数为冲击力，第二个参数为冲击点。</p>
<p>在 <code>FPSProjectile</code> 构造函数中，将以下代码行添加到 <code>BodyInstance.SetCollisionProfileName</code> 下方：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 组件击中某物时调用的事件。</span></span><br><span class="line">CollisionComponent-&gt;OnComponentHit.<span class="built_in">AddDynamic</span>(<span class="keyword">this</span>, &amp;AFPSProjectile::OnHit);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>OnComponentHit：当组件（被）碰撞时调用的函数</p>
</li>
<li><p>AddDynamic( UserObject, FuncName )：给某物添加一个力</p>
<ul>
<li><p>第一个参数：调用的对象</p>
</li>
<li><p>第二个参数：调用的函数</p>
</li>
</ul>
</li>
</ul>
<h1 id="将十字准星导入到视口"><a href="#将十字准星导入到视口" class="headerlink" title="将十字准星导入到视口"></a>将十字准星导入到视口</h1><h2 id="FPSHUD-h"><a href="#FPSHUD-h" class="headerlink" title="FPSHUD.h"></a>FPSHUD.h</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line">   <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CoreMinimal.h&quot;</span></span></span><br><span class="line">   <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GameFramework/HUD.h&quot;</span></span></span><br><span class="line">   <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Engine/Canvas.h&quot;</span></span></span><br><span class="line">   <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;FPSHUD.generated.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="built_in">UCLASS</span>()</span><br><span class="line">   <span class="keyword">class</span> <span class="title class_">FPSPROJECT_API</span> AFPSHUD : <span class="keyword">public</span> AHUD</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">       <span class="comment">// HUD绘制的主要调用。</span></span><br><span class="line">       <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">DrawHUD</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">protected</span>:</span><br><span class="line">       <span class="comment">// 将被绘制在屏幕中心。</span></span><br><span class="line">       <span class="built_in">UPROPERTY</span>(EditDefaultsOnly)</span><br><span class="line">       UTexture2D* CrosshairTexture;</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure>

<h2 id="FPSHUD-cpp"><a href="#FPSHUD-cpp" class="headerlink" title="FPSHUD.cpp"></a>FPSHUD.cpp</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;FPSHUD.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">AFPSHUD::DrawHUD</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      Super::<span class="built_in">DrawHUD</span>();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (CrosshairTexture)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="comment">// 找出我们的画布的中心点。</span></span><br><span class="line">          <span class="function">FVector2D <span class="title">Center</span><span class="params">(Canvas-&gt;ClipX * <span class="number">0.5f</span>, Canvas-&gt;ClipY * <span class="number">0.5f</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 偏移纹理大小的一半，以便纹理中心与画布中心对齐。</span></span><br><span class="line">          <span class="function">FVector2D <span class="title">CrossHairDrawPosition</span><span class="params">(Center.X - (CrosshairTexture-&gt;GetSurfaceWidth() * <span class="number">0.5f</span>), Center.Y - (CrosshairTexture-&gt;GetSurfaceHeight() * <span class="number">0.5f</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 在中心点绘制十字准星。</span></span><br><span class="line">          <span class="function">FCanvasTileItem <span class="title">TileItem</span><span class="params">(CrossHairDrawPosition, CrosshairTexture-&gt;Resource, FLinearColor::White)</span></span>;</span><br><span class="line">          TileItem.BlendMode = SE_BLEND_Translucent;</span><br><span class="line">          Canvas-&gt;<span class="built_in">DrawItem</span>(TileItem);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="FVector2D"><a href="#FVector2D" class="headerlink" title="FVector2D"></a>FVector2D</h3><p>2D类型的vector，定义方式是两条线确定的一个交点（更像是提供一个位置信息，而不是Vector2D本身）</p>
<p><code>FVector2D Center(Canvas-&gt;ClipX * 0.5f, Canvas-&gt;ClipY * 0.5f);</code></p>
<ul>
<li><p>第一个参数：第一条线（x轴）</p>
</li>
<li><p>第二个参数：第二条线（Y轴）</p>
</li>
</ul>
<h3 id="FCanvasTileItem"><a href="#FCanvasTileItem" class="headerlink" title="FCanvasTileItem"></a>FCanvasTileItem</h3><p>理解为画布基本色块，类似于，这玩意就是一个颜料，我们调用绘制函数就是画笔。</p>
<p>只不过这个颜料可以直接添加位置信息，就不用在绘制的时候额外添加位置信息。</p>
<p><code>FCanvasTileItem::FCanvasTileItem(const FVector2D&amp; InPosition, const FTexture* InTexture, const FLinearColor&amp; InColor)</code></p>
<ul>
<li><p>第一个参数：位置信息</p>
</li>
<li><p>第二个参数：资产</p>
</li>
<li><p>第三个参数：线性颜色</p>
</li>
</ul>
<h3 id="BlendMode"><a href="#BlendMode" class="headerlink" title="BlendMode"></a>BlendMode</h3><p>用来设置材质颜色如何与背景混合</p>
<p>SE_BLEND_Translucent-&gt;半透明模式</p>
<h3 id="DrawItem"><a href="#DrawItem" class="headerlink" title="DrawItem()"></a>DrawItem()</h3><p><code>DrawItem(FCanvasItem&amp; Item, float PosX, float PosY)</code></p>
<p>绘制函数（画笔），用于将第一个参数绘制进画布中</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/29/UE4-%E7%AC%AC%E4%B8%80%E4%BA%BA%E7%A7%B0FPS-%E5%AE%9E%E7%8E%B0%E8%A7%92%E8%89%B2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="williny">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Williny'home">
      <meta itemprop="description" content="孤独是人生的常态">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Williny'home">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/04/29/UE4-%E7%AC%AC%E4%B8%80%E4%BA%BA%E7%A7%B0FPS-%E5%AE%9E%E7%8E%B0%E8%A7%92%E8%89%B2/" class="post-title-link" itemprop="url">UE4-第一人称FPS-实现角色</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-04-29 14:20:16 / 修改时间：14:37:22" itemprop="dateCreated datePublished" datetime="2022-04-29T14:20:16+08:00">2022-04-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/unreal-engine/" itemprop="url" rel="index"><span itemprop="name">unreal engine</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="建立项目"><a href="#建立项目" class="headerlink" title="建立项目"></a><a target="_blank" rel="noopener" href="https://docs.unrealengine.com/4.27/zh-CN/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/1/">建立项目</a></h1><ol>
<li><p>通过Epic启动器打开 <strong>虚幻引擎</strong>，然后选择创建新项目。</p>
</li>
<li><p>点击 <strong>游戏（Games）</strong> 新项目类别，然后点击 <strong>下一步（Next）</strong>。</p>
</li>
<li><p>选择 <strong>空白模板（Blank template）</strong>，然后点击 <strong>下一步（Next）</strong>。</p>
</li>
<li><p>将项目类型更改为 **C++**（而非 <strong>蓝图（Blueprint）</strong>），确保选中 <strong>无初学者内容（No Starter Content）</strong>。</p>
</li>
<li><p>将新项目命名为”FPSProject”。</p>
</li>
<li><p>转到 <strong>内容浏览器（Content Browser）</strong>（通常在屏幕底部附近），在 <strong>内容（Content）</strong> 文件夹下创建一个 <strong>地图（Maps）</strong> 文件夹（选择内容文件夹，在其中任意位置点击右键，选择 <strong>文件夹（Folder）</strong> &gt; <strong>新建文件夹（New Folder）</strong>）。</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/1/MapsFolder.jpg" alt="MapsFolder.png"></p>
</li>
<li><p>在 <strong>文件（File）</strong> 菜单中，选择 <strong>将当前内容另存为（Save Current as…）</strong>，然后点击地图文件夹。将新地图命名为”FPSMap”，然后点击 <strong>保存（Save）</strong>。</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/1/SaveLevelAs.jpg" alt="SaveLevelAs.png"></p>
</li>
<li><p>从 <strong>编辑（Edit）</strong> 菜单中，点击 <strong>项目设置（Project Settings）</strong>。</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/1/EditProjectSettings.jpg" alt="EditProjectSettings.png"></p>
</li>
<li><p>在 <strong>项目设置（Project Settings）</strong> 选项卡左侧的 <strong>项目（Project）</strong> 标题下，点击 <strong>地图和模式（Maps &amp; Modes）</strong>。</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/1/ProjectMaps_Modes.jpg" alt="ProjectMaps_Modes.png"></p>
</li>
<li><p>展开 <strong>编辑器启动地图（Editor Startup Map）</strong> 下拉菜单，选择 <strong>FPSMap</strong>。</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/1/EditorDefaultMap.jpg" alt="EditorDefaultMap.png"></p>
<p>从现在开始，编辑器将自动加载FPSMap作为默认地图。</p>
</li>
</ol>
<h1 id="添加日志消息"><a href="#添加日志消息" class="headerlink" title="添加日志消息"></a>添加日志消息</h1><p>日志消息对于在开发期间验证和调试代码非常有用。在这一步中，你将使用日志消息来验证自己确实在使用FPSGameMode而非虚幻引擎提供的默认游戏模式。</p>
<h2 id="FPSProjectGameMode头文件"><a href="#FPSProjectGameMode头文件" class="headerlink" title="FPSProjectGameMode头文件"></a>FPSProjectGameMode头文件</h2><ol>
<li><p>在 <strong>解决方案资源管理器</strong> 中，展开 <strong>FPSProject</strong> &gt; <strong>源（Source）</strong> &gt; <strong>FPSProject</strong>。</p>
</li>
<li><p>双击 <code>FPSProjectGameModeBase.h</code> 打开 <strong>FPSGameMode</strong> 类的头文件。</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/1/InterfaceFile.jpg" alt="InterfaceFile.png"></p>
</li>
<li><p>类声明应该如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FPSPROJECT_API</span> AFPSProjectGameModeBase : <span class="keyword">public</span> AGameModeBase</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 <code>AFPSProjectGameMode</code> 构造函数声明下方添加以下函数声明：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">StartPlay</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br></pre></td></tr></table></figure>

<p>此函数声明允许你重载<a target="_blank" rel="noopener" href="https://docs.unrealengine.com/en-US/API/Runtime/Engine/GameFramework/AGameModeBase/StartPlay/index.html">StartPlay</a>，以便游戏启动时在屏幕上打印日志消息。</p>
</li>
<li><p><code>FPSProjectGameMode.h</code> 应如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Epic Games, Inc版权所有。保留所有权利。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CoreMinimal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GameFramework/GameModeBase.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;FPSProjectGameModeBase.generated.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** *  */</span></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FPSPROJECT_API</span> AFPSProjectGameModeBase : <span class="keyword">public</span> AGameModeBase</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">StartPlay</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在Visual Studio中保存你的头文件。</p>
</li>
</ol>
<h3 id="FPSProjectGameMode-CPP文件"><a href="#FPSProjectGameMode-CPP文件" class="headerlink" title="FPSProjectGameMode CPP文件"></a>FPSProjectGameMode CPP文件</h3><ol>
<li><p>在 <strong>解决方案资源管理器</strong> 中，定位到 <code>FPSProjectGameModeBase.cpp</code>（<strong>FPSProject &gt;源（Source）&gt; FPSProject</strong>）。</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/1/ImplementationFile.jpg" alt="ImplementationFile.png"></p>
</li>
<li><p>双击 <code>FPSProjectGameModeBase.cpp</code> 打开 <strong>FPSGameModeBase</strong> 类的实现文件。</p>
</li>
<li><p>现在将以下代码行添加到该文件中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSProjectGameModeBase::StartPlay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Super::<span class="built_in">StartPlay</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">check</span>(GEngine != <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 显示调试消息五秒。 </span></span><br><span class="line"> <span class="comment">// 参数中的-1&quot;键&quot;值类型参数能防止该消息被更新或刷新。</span></span><br><span class="line"> GEngine-&gt;<span class="built_in">AddOnScreenDebugMessage</span>(<span class="number">-1</span>, <span class="number">5.0f</span>, FColor::Yellow, <span class="built_in">TEXT</span>(<span class="string">&quot;Hello World, this is FPSGameMode!&quot;</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>游戏启动时，StartPlay()将在屏幕上打印一条新的调试消息（”Hello World, this is FPSGameModeBase!”），采用黄色文本，显示五秒钟。</p>
</li>
<li><p><code>FPSProjectGameModeBase.cpp</code> 应如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Epic Games, Inc版权所有。保留所有权利。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;FPSProjectGameMode.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSProjectGameModeBase::StartPlay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Super::<span class="built_in">StartPlay</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">check</span>(GEngine != <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示调试消息五秒。 </span></span><br><span class="line"><span class="comment">// -1&quot;键&quot;值参数防止该消息被更新或刷新。</span></span><br><span class="line">GEngine-&gt;<span class="built_in">AddOnScreenDebugMessage</span>(<span class="number">-1</span>, <span class="number">5.0f</span>, FColor::Yellow, <span class="built_in">TEXT</span>(<span class="string">&quot;Hello World, this is FPSGameModeBase!&quot;</span>));</span><br></pre></td></tr></table></figure>
</li>
<li><p>在Visual Studio中保存CPP文件。</p>
</li>
<li><p>在”内容”文件夹中创建一个 <strong>蓝图（Blueprints）</strong> 文件夹。</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/1/BlueprintsFolder.jpg" alt="BlueprintsFolder.png"></p>
</li>
<li><p>现在右键点击 <strong>FPSProjectGameModeBase</strong> 类（在 <strong>C++类（C++ Classes）</strong> &gt; <strong>FPSProject</strong> 中），打开 <strong>C++类操作（C++ Class Actions）</strong> 菜单。</p>
</li>
<li><p>点击 <strong>基于FPSProjectGameModeBase创建蓝图类（Create Blueprint class based on FPSProjectGameModeBase）</strong> 打开 <strong>添加蓝图类（Add Blueprint Class）</strong> 对话框菜单。</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/1/CreateDerivedBPClass.jpg" alt="CreateDerivedBPClass.png"></p>
</li>
<li><p>将你的新蓝图类命名为”BP_FPSProjectGameModeBase”，然后选择蓝图文件夹，之后点击 <strong>创建蓝图类（Create Blueprint Class）</strong> 按钮。</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/1/AddBPClass.jpg" alt="AddBPClass.png"></p>
</li>
<li><p>到目前为止，你应该有一个新创建的 <code>BP_FPSProjectGameModeBase</code> 蓝图类，位于蓝图文件夹内。</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/1/AddedBPClass.jpg" alt="AddedBPClass.png"></p>
</li>
<li><p>请确保在关闭蓝图编辑器之前保存你的 <code>BP_FPSProjectGameModeBase</code> 蓝图。</p>
</li>
<li><p>展开 <strong>编辑（Edit）</strong> 菜单，点击 <strong>项目设置（Project Settings）</strong>。</p>
</li>
<li><p>在 <strong>项目设置（Project Settings）</strong> 选项卡左侧的 <strong>项目（Project）</strong> 标题下，点击 <strong>地图和模式（Maps &amp; Modes）</strong>。</p>
</li>
<li><p>展开 <strong>默认游戏模式（Default GameMode）</strong> 下拉菜单，选择 <strong>BP_FPSGameModeBase</strong>。</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/1/SettingFPSGameMode.jpg" alt="SettingFPSGameMode.png"></p>
</li>
<li><p>关闭 <strong>项目设置（Project Settings）</strong> 菜单。</p>
</li>
<li><p>点击关卡编辑器工具栏中的 <strong>运行（Play）</strong> 按钮。”Hello World, this is FPSGameMode!”这句话应在视口左上角以黄色文本显示五秒钟。</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/1/SectionResult.jpg" alt="SectionResult.png"></p>
</li>
<li><p>按 <strong>退出键（Escape key）</strong> 或在关卡编辑器中点击 <strong>停止（Stop）</strong> 按钮，即可退出编辑器内运行（PIE）模式。</p>
</li>
</ol>
<h1 id="创建新角色"><a href="#创建新角色" class="headerlink" title="创建新角色"></a>创建新角色</h1><h2 id="添加角色类"><a href="#添加角色类" class="headerlink" title="添加角色类"></a>添加角色类</h2><p>虽然你可以手动将.h和.cpp文件添加到你的Visual Studio (VS)解决方案，但使用C++类向导将新类添加到你的项目是一种很好的做法。</p>
<p>使用C++类向导，引擎可创建头文件和源文件模板，这些模板文件将为你预先设置一些虚幻特定的宏。</p>
<ol>
<li><p>在UE中启动FPS项目（如果你尚未完成此操作）。</p>
</li>
<li><p>在文件（File）菜单中，选择 <strong>新建C++类…（New C++ Class…）</strong>，以选择新的父类。</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/SelectNewCPPClass.jpg" alt="SelectNewCPPClass.png"></p>
</li>
<li><p>以上操作将打开 <strong>选择父类（Choose Parent Class）</strong> 菜单。向下滚动，选择 <strong>角色</strong> 作为父类，然后点击 <strong>下一步（Next）</strong>。</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/ChooseCharacterClass.jpg" alt="ChooseCharacterClass.png"></p>
</li>
<li><p>将新类命名为”FPSCharacter”，然后点击 <strong>创建类（Create Class）</strong>。</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/MakeFPSCharacterClass.jpg" alt="MakeFPSCharacterClass.png"></p>
</li>
</ol>
<h2 id="确认角色类"><a href="#确认角色类" class="headerlink" title="确认角色类"></a>确认角色类</h2><ol>
<li><p>在VS的 <strong>解决方案浏览器</strong> 中，依次展开 <strong>FPSProject</strong> &gt; <strong>源（Source）</strong> &gt; <strong>FPSProject</strong>。</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/ExpandedSolutionExplorer.jpg" alt="ExpandedSolutionExplorer.png"></p>
</li>
<li><p>点击 <code>FPSCharacter.cpp</code>，打开 <strong>FPSCharacter</strong> 类的实现文件。</p>
</li>
<li><p>在 <code>BeginPlay()</code> 函数中添加以下代码行（在 <code>Super::BeginPlay();</code> 下面），以便确认正在使用 <code>FPSCharacter</code> 类：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">check</span>(GEngine != <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示调试消息五秒。 </span></span><br><span class="line"><span class="comment">// -1&quot;键&quot;值参数可以防止更新或刷新消息。</span></span><br><span class="line">GEngine-&gt;<span class="built_in">AddOnScreenDebugMessage</span>(<span class="number">-1</span>, <span class="number">5.0f</span>, FColor::Red, <span class="built_in">TEXT</span>(<span class="string">&quot;We are using FPSCharacter.&quot;</span>));</span><br></pre></td></tr></table></figure>
</li>
<li><p>现在 <code>FPSCharacter.cpp</code> 的内容应如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版权所有Epic Games, Inc。保留所有权利。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;FPSCharacter.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置默认值</span></span><br><span class="line">AFPSCharacter::<span class="built_in">AFPSCharacter</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 将此角色设置为每帧调用Tick()。  如果不需要此特性，可以关闭以提升性能。</span></span><br><span class="line">PrimaryActorTick.bCanEverTick = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当游戏开始或重生（Spawn）时被调用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::BeginPlay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Super::<span class="built_in">BeginPlay</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">check</span>(GEngine != <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示调试消息五秒。 </span></span><br><span class="line"><span class="comment">// -1&quot;键&quot;值参数可以防止更新或刷新消息。</span></span><br><span class="line">GEngine-&gt;<span class="built_in">AddOnScreenDebugMessage</span>(<span class="number">-1</span>, <span class="number">5.0f</span>, FColor::Red, <span class="built_in">TEXT</span>(<span class="string">&quot;We are using FPSCharacter.&quot;</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每一帧都被调用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::Tick</span><span class="params">(<span class="type">float</span> DeltaTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Super::<span class="built_in">Tick</span>(DeltaTime);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 被调用，将功能与输入绑定</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::SetupPlayerInputComponent</span><span class="params">(UInputComponent* PlayerInputComponent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Super::<span class="built_in">SetupPlayerInputComponent</span>(PlayerInputComponent);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在Visual Studio中保存 <code>FPSCharacter</code> CPP文件。</p>
</li>
<li><p>在 <strong>解决方案浏览器（Solution Explorer）</strong> 中找到 <strong>FPSProject</strong>。</p>
<p>到目前为止，你一直在使用编辑器的 <strong>构建(Build)</strong> 按钮编译项目。在此步骤中，你将使用Visual Studio的构建功能来编译代码。要从Visual Studio中编译代码，请右键点击 <strong>FPSProject</strong>，并选择 <strong>构建（Build）</strong> 来编译项目。</p>
</li>
<li><p>要从VS中编译代码，请右键点击 <strong>FPSProject</strong>，并选择 <strong>构建（Build）</strong> 来编译项目。</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/BuildProject.jpg" alt="BuildProject.png"></p>
<p>如果你使用的是VS的默认设置，则在界面底部附近（可能在代码编辑器的下方），你应该会看到一个对话框。当你点击构建（Build）后，在生成过程中该对话框中应该会显示一些信息，我们最希望显示的是构建成功的信息。 如果构建失败，不要紧张！回头看看你之前的操作步骤，确保你的代码与此处和第1分段中列出的内容相同。</p>
</li>
<li><p>构建完成后，打开虚幻编辑器，确认新编译的 <strong>FPSCharacter</strong> 类在 <strong>内容浏览器</strong> 中可见。</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/FPSCharacterContentBrowser.jpg" alt="FPSCharacterContentBrowser.png"></p>
</li>
</ol>
<h3 id="扩展你的C-FPS角色类到蓝图"><a href="#扩展你的C-FPS角色类到蓝图" class="headerlink" title="扩展你的C++ FPS角色类到蓝图"></a>扩展你的C++ FPS角色类到蓝图</h3><p>现在可以扩展C++ FPS角色类到蓝图了（类似之前进行的FPSProject游戏模式操作）。请随时前往我们的<a target="_blank" rel="noopener" href="https://docs.unrealengine.com/4.27/zh-CN/ProgrammingAndScripting/ClassCreation/CodeAndBlueprints">C++和蓝图</a>参考页面，以了解更多关于扩展C++类到蓝图的信息。</p>
<ol>
<li><p>右键点击FPSCharacter类，打开 <strong>C++类操作（C++ Class Actions）</strong> 菜单。</p>
</li>
<li><p>点击 <strong>基于FPSCharacter创建蓝图类（Create Blueprint class based on FPSHUD）</strong>，打开 <strong>添加蓝图类（Add Blueprint Class）</strong> 对话框菜单。</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/CreateDerivedBPClass.jpg" alt="CreateDerivedBPClass.png"></p>
</li>
<li><p>将新的蓝图类命名为 <code>BP_FPSCharacter</code>，选择蓝图（Blueprints）文件夹，然后点击 <strong>创建蓝图类（Create Blueprint Class）</strong> 按钮。</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/AddBPClass.jpg" alt="AddBPClass.png"></p>
</li>
<li><p>现在，在蓝图（Blueprints）文件夹内，你应该可以看到新创建的 <code>BP_FPSCharacter</code> 蓝图类。</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/AddedBPClass.jpg" alt="AddedBPClass.png"></p>
</li>
<li><p>请确保在关闭蓝图编辑器前保存 <code>BP_FPSCharacter</code> 蓝图。</p>
</li>
</ol>
<h2 id="设置默认的Pawn类"><a href="#设置默认的Pawn类" class="headerlink" title="设置默认的Pawn类"></a>设置默认的Pawn类</h2><p>现在你已经成功地把新修改的游戏模式扩展到了蓝图，接下来你需要在此步骤中设置项目，将 <code>BP_FPSCharacter</code> 作为默认的 <strong>Pawn</strong>。</p>
<ol>
<li><p>在 <strong>编辑（Edit）</strong> 菜单中点击 <strong>项目设置（Project Settings）</strong>。</p>
</li>
<li><p>在 <strong>项目设置（Project Settings）</strong> 选项卡左侧的 <strong>项目（Project）</strong> 标题栏下，点击 <strong>地图和模式（Maps &amp; Modes）</strong>。</p>
</li>
<li><p>展开 <strong>已选择的游戏模式（Selected GameMode）</strong> 段，并在 <strong>默认Pawn类（Default Pawn Class）</strong> 下拉菜单中选择 <strong>BP_FPSCharacter</strong>。</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/SettingFPSCharacter.jpg" alt="SettingFPSCharacter.png"></p>
</li>
<li><p>关闭 <strong>项目设置（Project Settings）</strong> 菜单。</p>
</li>
<li><p>在关卡编辑器工具栏中点击 <strong>运行（Play）</strong> 按钮。在视口左上角，红色文本”We are using FPSCharacter.”将显示在”Hello World, this is FPSGameMode!”的下方，并持续5秒钟。</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/VerifyingFPSCharacterResult.jpg" alt="VerifyingFPSCharacterResult.png"></p>
<p>如果你无法移动，说明你已经正确地将FPSCharacter用作了Pawn！你的新角色还没有任何移动功能按钮，因此你还不能在关卡中四处移动。</p>
</li>
<li><p>在进入下一步前，按退出键（Escape）或在关卡编辑器中点击 <strong>停止（Stop）</strong>，退出在编辑器中运行（Play in Editor）（PIE）模式。</p>
</li>
</ol>
<h1 id="设置轴映射"><a href="#设置轴映射" class="headerlink" title="设置轴映射"></a>设置轴映射</h1><p>通常，轴映射支持将键盘、鼠标和控制器输入映射到”友好名称”，该名称稍后可以绑定到游戏行为上（例如移动）。轴映射会不断被轮询，从而实现无缝的移动过渡和流畅的游戏行为。硬件轴（例如游戏摇杆）所提供的输入值为程度值，而不是离散的数字输入（例如，按下为1，不按下为0）。虽然游戏摇杆输入方法在提供可平滑伸缩的移动输入方面很有效，但轴映射也可以将常见的移动键（如WASD键或箭头键）映射到持续轮询的游戏行为。</p>
<p>在继续此步骤之前，如果你想要了解有关玩家输入的更多信息，请参阅<a target="_blank" rel="noopener" href="https://docs.unrealengine.com/4.27/zh-CN/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/PlayerInput">玩家输入和Pawn</a>教程。在此步骤中，你将设置W、A、S和D键的输入轴映射，从而使新角色可以在地图上四处移动。</p>
<h2 id="向前移动轴映射"><a href="#向前移动轴映射" class="headerlink" title="向前移动轴映射"></a>向前移动轴映射</h2><ol>
<li><p>在 <strong>编辑（Edit）</strong> 菜单中，点击 <strong>项目设置（Project Settings）</strong>。</p>
</li>
<li><p>在 <strong>项目设置（Project Settings）</strong> 选项卡左侧的 <strong>引擎（Engine）</strong> 标题栏下，点击 <strong>输入（Input）</strong>。</p>
</li>
<li><p>在 <strong>绑定（Bindings）</strong> 中，点击 <strong>轴映射（Axis Mappings）</strong> 旁边的+号。</p>
</li>
<li><p>点击 <strong>轴映射（Axis Mappings）</strong> 左侧的箭头。</p>
</li>
<li><p>在界面显示的文本框中输入”MoveForward”，然后点击文本框左侧的箭头，展开轴绑定选项。</p>
</li>
<li><p>在下拉菜单中，从 <strong>键盘（Keyboard）</strong> 下拉列表中选择 <strong>W</strong>。</p>
</li>
<li><p>现在输入设置界面应如下图所示：</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/MoveForwardAxisMap_W.jpg" alt="MoveForwardAxisMap_W.png"></p>
</li>
<li><p>点击 <strong>MoveForward</strong> 旁边的+号。</p>
</li>
<li><p>在第二个下拉菜单中，从 <strong>键盘（Keyboard）</strong> 下拉列表中选择 <strong>S</strong>。</p>
</li>
<li><p>在 <strong>S</strong> 旁边的 <strong>比例（Scale）</strong> 字段中输入”-1”。</p>
</li>
<li><p>现在输入设置界面应如下图所示：</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/MoveForwardAxisMap_S.jpg" alt="MoveForwardAxisMap_S.png"></p>
</li>
</ol>
<h2 id="向右移动轴映射"><a href="#向右移动轴映射" class="headerlink" title="向右移动轴映射"></a>向右移动轴映射</h2><ol>
<li><p>在 <strong>绑定（Bindings）</strong> 中，点击 <strong>轴映射（Axis Mappings）</strong> 旁边的+号。</p>
</li>
<li><p>在显示的文本字段中输入”向右移动（MoveForward）”，然后点击文本框左侧的箭头，展开轴绑定选项。</p>
</li>
<li><p>在下拉菜单中，从 <strong>键盘（Keyboard）</strong> 下拉列表中选择 <strong>D</strong>。</p>
</li>
<li><p>现在输入设置界面应如下图所示：</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/MoveRightAxisMap_D.jpg" alt="MoveRightAxisMap_D.png"></p>
</li>
<li><p>点击 <strong>向右移动（MoveRight）</strong> 旁边的+号。</p>
</li>
<li><p>在第二个下拉菜单中，从 <strong>键盘（Keyboard）</strong> 下拉列表中选择 <strong>A</strong>。</p>
</li>
<li><p>在 <strong>A</strong> 旁边的 <strong>比例（Scale）</strong> 字段中输入”-1”。</p>
</li>
<li><p>现在输入设置界面应如下图所示：</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/MoveRightAxisMap_A.jpg" alt="MoveRightAxisMap_A.png"></p>
</li>
<li><p>现在你已设置好向左移动（MoveLeft）和向右移动（MoveRight）轴映射，请关闭 <strong>项目设置（Project Settings）</strong> 菜单并继续。</p>
</li>
</ol>
<h1 id="实现角色移动函数"><a href="#实现角色移动函数" class="headerlink" title="实现角色移动函数"></a>实现角色移动函数</h1><p>在此步骤中，我们将设置玩家输入组件，并在FPSCharacter类中实现以下函数：</p>
<ul>
<li><p><code>MoveForward</code></p>
</li>
<li><p><code>MoveRight</code></p>
</li>
</ul>
<h2 id="移动函数接口"><a href="#移动函数接口" class="headerlink" title="移动函数接口"></a>移动函数接口</h2><p>你已经设置好FPSCharacter的轴映射，现在可以切换到VS中的项目界面。</p>
<ol>
<li><p>在 <code>FPSCharacter.h</code> 中，将以下函数声明添加到 <code>SetupPlayerInputComponent</code> 成员函数的下方。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理用于前后移动的输入。</span></span><br><span class="line"><span class="built_in">UFUNCTION</span>()</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MoveForward</span><span class="params">(<span class="type">float</span> Value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理用于左右移动的输入。</span></span><br><span class="line"><span class="built_in">UFUNCTION</span>()</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MoveRight</span><span class="params">(<span class="type">float</span> Value)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>UFUNCTION</code> 宏（位于每个函数上方）让引擎可以发觉这些函数，以便将它们纳入序列化和其他引擎功能中。</p>
</li>
<li><p>现在 <code>FPSCharacter.h</code> 的内容应如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版权所有Epic Games, Inc。保留所有权利。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CoreMinimal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GameFramework/Character.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;FPSCharacter.generated.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FPSPROJECT_API</span> AFPSCharacter : <span class="keyword">public</span> ACharacter</span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="comment">// 为此角色的属性设置默认值</span></span><br><span class="line">   <span class="built_in">AFPSCharacter</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">   <span class="comment">// 当游戏开始或重生（Spawn）时被调用</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BeginPlay</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="comment">// 每一帧都被调用</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Tick</span><span class="params">( <span class="type">float</span> DeltaTime )</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 被调用，将功能与输入绑定</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SetupPlayerInputComponent</span><span class="params">(<span class="keyword">class</span> UInputComponent* PlayerInputComponent)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 处理用于前后移动的输入。</span></span><br><span class="line">   <span class="built_in">UFUNCTION</span>()</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">MoveForward</span><span class="params">(<span class="type">float</span> Value)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 处理用于左右移动的输入。</span></span><br><span class="line">   <span class="built_in">UFUNCTION</span>()</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">MoveRight</span><span class="params">(<span class="type">float</span> Value)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="移动函数的实现"><a href="#移动函数的实现" class="headerlink" title="移动函数的实现"></a>移动函数的实现</h2><p>在典型的FPS控制模式中，角色的移动轴是相对于摄像机的。”向前”移动是指”摄像机指向的方向”，”向右”是指”摄像机指向方向的右侧”。你将使用 <code>PlayerController</code> 获取角色的控制旋转输入值。另外， <code>MoveForward</code> 函数将忽略控制旋转输入值的俯仰（Pitch）分量，将输入限制在XY平面上，以确保在你向上或向下看时，你的角色将沿着地面移动。</p>
<ol>
<li><p>在 <code>FPSCharacter.cpp</code> 中，将以下行添加到<code>SetupPlayerInputComponent </code>函数中的<code> Super::SetupPlayerInputComponent(PlayerInputComponent);</code> 下方 。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置&quot;移动&quot;绑定。</span></span><br><span class="line">PlayerInputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="string">&quot;MoveForward&quot;</span>, <span class="keyword">this</span>, &amp;AFPSCharacter::MoveForward);</span><br><span class="line">PlayerInputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="string">&quot;MoveRight&quot;</span>, <span class="keyword">this</span>, &amp;AFPSCharacter::MoveRight);</span><br></pre></td></tr></table></figure>

<p><code>InputComponent</code> 是定义如何处理输入数据的组件。可以将 <code>InputComponent</code> 附加到想要接收输入的actor。</p>
</li>
<li><p>在 <code>FPSCharacter.cpp</code> 中， <code>SetupPlayerInputComponent</code> 下方，添加以下 <code>MoveForward</code> 函数定义。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::MoveForward</span><span class="params">(<span class="type">float</span> Value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// 找出&quot;前进&quot;方向，并记录玩家想向该方向移动。</span></span><br><span class="line">   FVector Direction = <span class="built_in">FRotationMatrix</span>(Controller-&gt;<span class="built_in">GetControlRotation</span>()).<span class="built_in">GetScaledAxis</span>(EAxis::X);</span><br><span class="line">   <span class="built_in">AddMovementInput</span>(Direction, Value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 <code>FPSCharacter.cpp</code> 中添加以下 <code>MoveRight</code> 函数定义（<code>MoveForward</code> 下方）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::MoveRight</span><span class="params">(<span class="type">float</span> Value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// 找出&quot;右侧&quot;方向，并记录玩家想向该方向移动。</span></span><br><span class="line">   FVector Direction = <span class="built_in">FRotationMatrix</span>(Controller-&gt;<span class="built_in">GetControlRotation</span>()).<span class="built_in">GetScaledAxis</span>(EAxis::Y);</span><br><span class="line">   <span class="built_in">AddMovementInput</span>(Direction, Value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>现在 <code>FPSCharacter.cpp</code> 的内容应如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版权所有Epic Games, Inc。保留所有权利。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;FPSCharacter.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置默认值</span></span><br><span class="line">AFPSCharacter::<span class="built_in">AFPSCharacter</span>()</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 将此角色设置为每帧调用Tick()。  如果不需要此特性，可以关闭以提升性能。</span></span><br><span class="line">   PrimaryActorTick.bCanEverTick = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当游戏开始或重生（Spawn）时被调用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::BeginPlay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Super::<span class="built_in">BeginPlay</span>();</span><br><span class="line"></span><br><span class="line">   <span class="built_in">check</span>(GEngine != <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 显示调试消息五秒。 </span></span><br><span class="line">   <span class="comment">// -1&quot;键&quot;值参数可以防止更新或刷新消息。</span></span><br><span class="line">     GEngine-&gt;<span class="built_in">AddOnScreenDebugMessage</span>(<span class="number">-1</span>, <span class="number">5.0f</span>, FColor::Red, <span class="built_in">TEXT</span>(<span class="string">&quot;We are using FPSCharacter.&quot;</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每一帧都被调用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::Tick</span><span class="params">( <span class="type">float</span> DeltaTime )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Super::<span class="built_in">Tick</span>( DeltaTime );</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 被调用，将功能与输入绑定</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::SetupPlayerInputComponent</span><span class="params">(UInputComponent* PlayerInputComponent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Super::<span class="built_in">SetupPlayerInputComponent</span>(PlayerInputComponent);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 设置&quot;移动&quot;绑定。</span></span><br><span class="line">   PlayerInputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="string">&quot;MoveForward&quot;</span>, <span class="keyword">this</span>, &amp;AFPSCharacter::MoveForward);</span><br><span class="line">   PlayerInputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="string">&quot;MoveRight&quot;</span>, <span class="keyword">this</span>, &amp;AFPSCharacter::MoveRight);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::MoveForward</span><span class="params">(<span class="type">float</span> Value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// 找出&quot;前进&quot;方向，并记录玩家想向该方向移动。</span></span><br><span class="line">   FVector Direction = <span class="built_in">FRotationMatrix</span>(Controller-&gt;<span class="built_in">GetControlRotation</span>()).<span class="built_in">GetScaledAxis</span>(EAxis::X);</span><br><span class="line">   <span class="built_in">AddMovementInput</span>(Direction, Value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::MoveRight</span><span class="params">(<span class="type">float</span> Value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// 找出&quot;右侧&quot;方向，并记录玩家想向该方向移动。</span></span><br><span class="line">   FVector Direction = <span class="built_in">FRotationMatrix</span>(Controller-&gt;<span class="built_in">GetControlRotation</span>()).<span class="built_in">GetScaledAxis</span>(EAxis::Y);</span><br><span class="line">   <span class="built_in">AddMovementInput</span>(Direction, Value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="测试角色移动"><a href="#测试角色移动" class="headerlink" title="测试角色移动"></a>测试角色移动</h2><p>现在我们来编译和测试新实现的角色移动函数。</p>
<ol>
<li><p>在VS中保存 <code>FPSCharacter</code> 头文件（.h）和C++（.cpp）文件。</p>
</li>
<li><p>在 <strong>解决方案浏览器（Solution Explorer）</strong> 中找到 <strong>FPSProject</strong>。</p>
</li>
<li><p>右键点击 <strong>FPSProject</strong> 并选择 <strong>构建（Build）</strong>，编译你的项目。</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/BuildProject.jpg" alt="BuildProject.png"></p>
</li>
<li><p>构建完毕后，在虚幻引擎中打开 <strong>FPSProject</strong>。</p>
</li>
<li><p>在关卡编辑器工具栏中点击 <strong>运行（Play）</strong>。现在，你应该能够向前、向后、向左和向右移动。</p>
</li>
<li><p>按退出键（Escape）或在关卡编辑器中点击 <strong>停止（Stop）</strong>，退出PIE模式。</p>
</li>
</ol>
<h1 id="实现鼠标摄像机控制"><a href="#实现鼠标摄像机控制" class="headerlink" title="实现鼠标摄像机控制"></a>实现鼠标摄像机控制</h1><p>在此步骤中，你将为角色添加能够环顾四周并用鼠标操纵的功能。</p>
<h2 id="转向轴映射"><a href="#转向轴映射" class="headerlink" title="转向轴映射"></a>转向轴映射</h2><ol>
<li><p>在FPS项目中，展开 <strong>编辑（Edit）</strong> 菜单，并点击 <strong>项目设置（Project Settings）</strong>。</p>
</li>
<li><p>在 <strong>项目设置（Project Settings）</strong> 选项卡左侧的 <strong>引擎（Engine）</strong> 标题栏下，点击 <strong>输入（Input）</strong>。</p>
</li>
<li><p>在 <strong>绑定（Bindings）</strong> 中，点击 <strong>轴映射（Axis Mappings）</strong> 旁边的+号。</p>
</li>
<li><p>点击 <strong>轴映射（Axis Mappings）</strong> 左侧的箭头。</p>
</li>
<li><p>在显示的文本输入框中输入”Turn”，然后点击文本框左侧的箭头，以便展开轴绑定选项</p>
</li>
<li><p>在下拉菜单中，从 <strong>鼠标（Mouse）</strong> 下拉列表中选择 <strong>鼠标X（Mouse X）</strong>。</p>
</li>
<li><p>现在输入设置界面应如下图所示：</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/TurnAxisMapping_MouseX.jpg" alt="TurnAxisMapping_MouseX.png"></p>
</li>
</ol>
<h2 id="查找轴映射"><a href="#查找轴映射" class="headerlink" title="查找轴映射"></a>查找轴映射</h2><ol>
<li><p>在 <strong>绑定（Bindings）</strong> 中，点击 <strong>轴映射（Axis Mappings）</strong> 旁边的+号。</p>
</li>
<li><p>在显示的文本输入框中输入”LookUp”，然后点击文本框左侧的箭头，以便展开轴绑定选项。</p>
</li>
<li><p>在下拉菜单中，从 <strong>鼠标（Mouse）</strong> 下拉列表中选择 <strong>鼠标Y（Mouse Y）</strong>。</p>
</li>
<li><p>在 <strong>鼠标Y（Mouse Y）</strong> 旁边的 <strong>比例（Scale）</strong> 输入框中输入”-1.0”。</p>
</li>
<li><p>现在输入设置界面应如下图所示：</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/TurnAxisMapping_MouseY.jpg" alt="TurnAxisMapping_MouseY.png"></p>
</li>
<li><p>关闭 <strong>项目设置（Project Settings）</strong> 菜单。</p>
</li>
</ol>
<h2 id="实现输入处理"><a href="#实现输入处理" class="headerlink" title="实现输入处理"></a>实现输入处理</h2><p>现在可以添加代码处理鼠标输入以便进行转向和抬头看。<code>角色</code> 基类为我们定义了两个必要函数，即：</p>
<ul>
<li><p><code>AddControllerYawInput</code></p>
</li>
<li><p><code>AddControllerPitchInput</code></p>
<p>如果你想要执行更多的处理，例如增加对灵敏度或轴反转的支持，那么你可以提供自己的函数，以便在将输入值传递给函数之前对其进行调整。但是，在本示例中，你将直接将输入绑定到 <code>AddControllerYawInput</code> 和 <code>AddControllerPitchInput</code> 函数。</p>
</li>
</ul>
<ol>
<li><p>将以下代码行添加到 <code>FPSCharacter.cpp</code> 中的 <code>SetupPlayerInputComponent</code> 函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置&quot;观看&quot;绑定。</span></span><br><span class="line">PlayerInputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="string">&quot;Turn&quot;</span>, <span class="keyword">this</span>, &amp;AFPSCharacter::AddControllerYawInput);</span><br><span class="line">PlayerInputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="string">&quot;LookUp&quot;</span>, <span class="keyword">this</span>, &amp;AFPSCharacter::AddControllerPitchInput);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>SetupPlayerInputComponent</code> 函数应如下图所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 被调用，将功能与输入绑定</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::SetupPlayerInputComponent</span><span class="params">(UInputComponent* PlayerInputComponent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Super::<span class="built_in">SetupPlayerInputComponent</span>(PlayerInputComponent);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 设置&quot;移动&quot;绑定。</span></span><br><span class="line">   PlayerInputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="string">&quot;MoveForward&quot;</span>, <span class="keyword">this</span>, &amp;AFPSCharacter::MoveForward);</span><br><span class="line">   PlayerInputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="string">&quot;MoveRight&quot;</span>, <span class="keyword">this</span>, &amp;AFPSCharacter::MoveRight);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 设置&quot;观看&quot;绑定。</span></span><br><span class="line">   PlayerInputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="string">&quot;Turn&quot;</span>, <span class="keyword">this</span>, &amp;AFPSCharacter::AddControllerYawInput);</span><br><span class="line">   PlayerInputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="string">&quot;LookUp&quot;</span>, <span class="keyword">this</span>, &amp;AFPSCharacter::AddControllerPitchInput);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="测试鼠标摄像机控制"><a href="#测试鼠标摄像机控制" class="headerlink" title="测试鼠标摄像机控制"></a>测试鼠标摄像机控制</h2><ol>
<li><p>在VS中保存 <code>FPSCharacter</code> 的实现文件。</p>
</li>
<li><p>在 <strong>解决方案浏览器（Solution Explorer）</strong> 中找到 <strong>FPSProject</strong>。</p>
</li>
<li><p>右键点击 <strong>FPSProject</strong> 并选择 <strong>构建（Build）</strong>，编译你的项目。</p>
</li>
<li><p>构建完毕后，在虚幻引擎中打开 <strong>FPSProject</strong>。</p>
</li>
<li><p>在关卡编辑器工具栏中点击 <strong>运行（Play）</strong>。现在，你可以通过鼠标控制摄像机。</p>
</li>
<li><p>按 <strong>退出键（Escape key）</strong> 或在关卡编辑器中点击 <strong>停止（Stop）</strong>，退出PIE模式。</p>
</li>
</ol>
<h1 id="实现角色跳跃"><a href="#实现角色跳跃" class="headerlink" title="实现角色跳跃"></a>实现角色跳跃</h1><p>通常，操作映射处理离散事件的输入，让你可以将输入映射到”友好名称”，该名称稍后可以与事件驱动的行为绑定。最终效果是，按下和&#x2F;或释放单个键、鼠标按钮或辅助键盘按钮可以直接触发游戏行为。在此步骤中，你将为空格键设置输入操作映射，增加角色的跳跃能力。</p>
<h2 id="跳跃操作映射"><a href="#跳跃操作映射" class="headerlink" title="跳跃操作映射"></a>跳跃操作映射</h2><ol>
<li><p>在 <strong>编辑（Edit）</strong> 菜单中，点击 <strong>项目设置（Project Settings）</strong>。</p>
</li>
<li><p>在 <strong>项目设置（Project Settings）</strong> 选项卡左侧的 <strong>引擎（Engine）</strong> 标题栏下，点击 <strong>输入（Input）</strong>。</p>
</li>
<li><p>在 <strong>绑定（Bindings）</strong> 中，点击 <strong>操作映射（Action Mappings）</strong> 旁边的+号。</p>
</li>
<li><p>点击 <strong>操作映射（Action Mappings）</strong> 左侧的箭头。</p>
</li>
<li><p>在显示的文本输入框中输入”Jump”，然后点击文本框左侧的箭头，展开操作绑定选项。</p>
</li>
<li><p>在下拉菜单中，从 <strong>键盘（Keyboard）</strong> 下拉列表中选择 <strong>空格键（Space Bar）</strong>。</p>
</li>
<li><p>现在输入设置界面应如下图所示：</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/JumpActionMapping_SpaceBar.jpg" alt="JumpActionMapping_SpaceBar.png"></p>
</li>
<li><p>关闭 <strong>项目设置（Project Settings）</strong> 菜单。</p>
</li>
</ol>
<h2 id="实现输入处理-1"><a href="#实现输入处理-1" class="headerlink" title="实现输入处理"></a>实现输入处理</h2><p>如果你查看 <code>Acharacter</code> 基类的接口文件（.h）的内容，你会看到角色跳跃的内置支持。角色跳跃与 <code>bPressedJump</code> 变量绑定，因此我们需要做的就是，在跳跃操作按下时将该布尔值设置为 <code>true</code>，在跳跃操作释放时将该布尔值设置为 <code>false</code>。你需要添加以下两个函数完成此操作：</p>
<ul>
<li><p><code>StartJump</code></p>
</li>
<li><p><code>StopJump</code></p>
</li>
</ul>
<p>返回Visual Studio，将代码添加到 <code>FPSCharacter</code> 类。</p>
<ol>
<li><p>在 <code>FPSCharacter.h</code> 中，添加以下公共函数声明：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按下键时，设置跳跃标记。</span></span><br><span class="line"><span class="built_in">UFUNCTION</span>()</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StartJump</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放键时，清除跳跃标记。</span></span><br><span class="line"><span class="built_in">UFUNCTION</span>()</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StopJump</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>现在 <code>FPSCharacter.h</code> 的内容应如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版权所有Epic Games, Inc。保留所有权利。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CoreMinimal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GameFramework/Character.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;FPSCharacter.generated.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FPSPROJECT_API</span> AFPSCharacter : <span class="keyword">public</span> ACharacter</span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="comment">// 为此角色的属性设置默认值</span></span><br><span class="line">   <span class="built_in">AFPSCharacter</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">   <span class="comment">// 当游戏开始或重生（Spawn）时被调用</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BeginPlay</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="comment">// 每一帧都被调用</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Tick</span><span class="params">( <span class="type">float</span> DeltaTime )</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 被调用，将功能与输入绑定</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SetupPlayerInputComponent</span><span class="params">(<span class="keyword">class</span> UInputComponent* PlayerInputComponent)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 处理用于前后移动的输入。</span></span><br><span class="line">   <span class="built_in">UFUNCTION</span>()</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">MoveForward</span><span class="params">(<span class="type">float</span> Value)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 处理用于左右移动的输入。</span></span><br><span class="line">   <span class="built_in">UFUNCTION</span>()</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">MoveRight</span><span class="params">(<span class="type">float</span> Value)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 按下键时，设置跳跃标记。</span></span><br><span class="line">   <span class="built_in">UFUNCTION</span>()</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">StartJump</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 释放键时，清除跳跃标记。</span></span><br><span class="line">   <span class="built_in">UFUNCTION</span>()</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">StopJump</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 <code>FPSCharacter.cpp</code> 中，将以下函数定义添加到代码底部：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::StartJump</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   bPressedJump = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::StopJump</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   bPressedJump = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>现在，将以下代码添加到 <code>SetupPlayerInputComponent</code>，以便将跳跃操作与刚才编写的函数绑定：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置&quot;操作&quot;绑定。</span></span><br><span class="line">PlayerInputComponent-&gt;<span class="built_in">BindAction</span>(<span class="string">&quot;Jump&quot;</span>, IE_Pressed, <span class="keyword">this</span>, &amp;AFPSCharacter::StartJump);</span><br><span class="line">PlayerInputComponent-&gt;<span class="built_in">BindAction</span>(<span class="string">&quot;Jump&quot;</span>, IE_Released, <span class="keyword">this</span>, &amp;AFPSCharacter::StopJump);</span><br></pre></td></tr></table></figure>
</li>
<li><p>现在 <code>FPSCharacter.cpp</code> 的内容应如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版权所有Epic Games, Inc。保留所有权利。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;FPSCharacter.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置默认值</span></span><br><span class="line">AFPSCharacter::<span class="built_in">AFPSCharacter</span>()</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 将此角色设置为每帧调用Tick()。  如果不需要此特性，可以关闭以提升性能。</span></span><br><span class="line">   PrimaryActorTick.bCanEverTick = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当游戏开始或重生（Spawn）时被调用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::BeginPlay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Super::<span class="built_in">BeginPlay</span>();</span><br><span class="line"></span><br><span class="line">   <span class="built_in">check</span>(GEngine != <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 显示调试消息五秒。 </span></span><br><span class="line">   <span class="comment">// -1&quot;键&quot;值参数可以防止更新或刷新消息。</span></span><br><span class="line">     GEngine-&gt;<span class="built_in">AddOnScreenDebugMessage</span>(<span class="number">-1</span>, <span class="number">5.0f</span>, FColor::Red, <span class="built_in">TEXT</span>(<span class="string">&quot;We are using FPSCharacter.&quot;</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每一帧都被调用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::Tick</span><span class="params">( <span class="type">float</span> DeltaTime )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Super::<span class="built_in">Tick</span>( DeltaTime );</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 被调用，将功能与输入绑定</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::SetupPlayerInputComponent</span><span class="params">(UInputComponent* PlayerInputComponent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Super::<span class="built_in">SetupPlayerInputComponent</span>(PlayerInputComponent);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 设置&quot;移动&quot;绑定。</span></span><br><span class="line">   PlayerInputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="string">&quot;MoveForward&quot;</span>, <span class="keyword">this</span>, &amp;AFPSCharacter::MoveForward);</span><br><span class="line">   PlayerInputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="string">&quot;MoveRight&quot;</span>, <span class="keyword">this</span>, &amp;AFPSCharacter::MoveRight);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 设置&quot;观看&quot;绑定。</span></span><br><span class="line">   PlayerInputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="string">&quot;Turn&quot;</span>, <span class="keyword">this</span>, &amp;AFPSCharacter::AddControllerYawInput);</span><br><span class="line">   PlayerInputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="string">&quot;LookUp&quot;</span>, <span class="keyword">this</span>, &amp;AFPSCharacter::AddControllerPitchInput);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 设置&quot;操作&quot;绑定。</span></span><br><span class="line">   PlayerInputComponent-&gt;<span class="built_in">BindAction</span>(<span class="string">&quot;Jump&quot;</span>, IE_Pressed, <span class="keyword">this</span>, &amp;AFPSCharacter::StartJump);</span><br><span class="line">   PlayerInputComponent-&gt;<span class="built_in">BindAction</span>(<span class="string">&quot;Jump&quot;</span>, IE_Released, <span class="keyword">this</span>, &amp;AFPSCharacter::StopJump);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::MoveForward</span><span class="params">(<span class="type">float</span> Value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// 找出&quot;前进&quot;方向，并记录玩家想向该方向移动。</span></span><br><span class="line">   FVector Direction = <span class="built_in">FRotationMatrix</span>(Controller-&gt;<span class="built_in">GetControlRotation</span>()).<span class="built_in">GetScaledAxis</span>(EAxis::X);</span><br><span class="line">   <span class="built_in">AddMovementInput</span>(Direction, Value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::MoveRight</span><span class="params">(<span class="type">float</span> Value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// 找出&quot;右侧&quot;方向，并记录玩家想向该方向移动。</span></span><br><span class="line">   FVector Direction = <span class="built_in">FRotationMatrix</span>(Controller-&gt;<span class="built_in">GetControlRotation</span>()).<span class="built_in">GetScaledAxis</span>(EAxis::Y);</span><br><span class="line">   <span class="built_in">AddMovementInput</span>(Direction, Value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::StartJump</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   bPressedJump = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AFPSCharacter::StopJump</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   bPressedJump = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="测试角色跳跃"><a href="#测试角色跳跃" class="headerlink" title="测试角色跳跃"></a>测试角色跳跃</h2><p>现在我们来编译和测试新实现的角色移动函数。</p>
<ol>
<li><p>在VS中保存FPSCharacter 头文件（.h）和C++（.cpp）文件。</p>
</li>
<li><p>在 <strong>解决方案浏览器（Solution Explorer）</strong> 中找到 <strong>FPSProject</strong>。</p>
</li>
<li><p>右键点击 <strong>FPSProject</strong> 并选择 <strong>构建（Build）</strong>，编译你的项目。</p>
</li>
<li><p>构建完毕后，在虚幻引擎中打开 <strong>FPSProject</strong>。</p>
</li>
<li><p>在关卡编辑器工具栏中点击 <strong>运行（Play）</strong>。你应该能够在地图上跳跃。</p>
</li>
<li><p>按 <strong>退出（Escape）</strong> 键或在关卡编辑器中点击 <strong>停止（Stop）</strong>，退出PIE模式。</p>
</li>
</ol>
<p>步骤完成</p>
<h1 id="将网格体添加到角色"><a href="#将网格体添加到角色" class="headerlink" title="将网格体添加到角色"></a>将网格体添加到角色</h1><p>通过以下链接下载并提取示例网格体：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.unrealengine.com/4.27/Attachments/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/6/GenericMale.zip">示例网格体</a></li>
</ul>
<p>在此步骤中，你将为角色提供骨骼网格体。默认情况下，角色类为你创建了SkeletalMeshComponent对象，因此仅需了解使用哪个SkeletalMesh资产。</p>
<h2 id="导入骨骼网格体"><a href="#导入骨骼网格体" class="headerlink" title="导入骨骼网格体"></a>导入骨骼网格体</h2><ol>
<li><p>导航返回内容浏览器文件框内的内容（Content）文件夹。</p>
</li>
<li><p>现在，右键点击内容浏览器的文件框，打开 <strong>导入资产（Import Asset）</strong> 对话框。</p>
</li>
<li><p>点击 **‘导入&#x2F;游戏…（Import to &#x2F;Game…）’**，打开 <strong>导入（Import）</strong> 对话框。</p>
</li>
<li><p>找到并选择 <strong>GenericMale.fbx</strong> 网格体文件。</p>
</li>
<li><p>点击 <strong>打开（Open）</strong>，开始将网格体导入到你的项目中。</p>
</li>
<li><p><strong>内容浏览器（Content Browser）</strong> 中将显示 <strong>FBX导入选项（FBX Import Options）</strong> 对话框。点击 <strong>全部导入（Import All）</strong>，将你的网格体添加到项目。</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/ImportGenericMale.jpg" alt="ImportGenericMale.png"></p>
</li>
<li><p>点击 <strong>保存（Save）</strong> 按钮保存导入的网格体。</p>
</li>
</ol>
<h2 id="设置第三人称网格体"><a href="#设置第三人称网格体" class="headerlink" title="设置第三人称网格体"></a>设置第三人称网格体</h2><ol>
<li><p>在 <strong>内容（Content）</strong> &gt; <strong>蓝图（Blueprints）</strong> 中，双击 <strong>BP_FPSCharacter</strong> 蓝图类图标，在 <strong>蓝图编辑器</strong> 中打开它。</p>
<p>如果你看到有关此蓝图为仅数据蓝图的说明，请点击 <strong>打开完整蓝图编辑器（Open Full Blueprint Editor）</strong>。</p>
</li>
<li><p>在 <strong>组件（Components）</strong> 选项卡中点击 <strong>网格体（Mesh）</strong> 组件。</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/MeshComponent.jpg" alt="MeshComponent.png"></p>
</li>
<li><p>滚动到 <strong>细节（Details）</strong> 选项卡（屏幕右侧，或在 <strong>窗口（Window）</strong> &gt; <strong>细节（Details）</strong> 中）的 <strong>网格体（Mesh）</strong> 段。</p>
</li>
<li><p>点击骨骼网格体（Skeletal Mesh）行中显示为”无”的下拉列表，然后选择 <strong>GenericMale</strong> 骨骼网格体。</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/SelectSkeletalMesh.jpg" alt="SelectSkeletalMesh.png"></p>
</li>
<li><p>滚动到 <strong>细节（Details）</strong> 窗格中的 <strong>变换（Transform）</strong> 段，然后，将变换的 <strong>Z</strong> 轴向位置设置为 **”-88.0”**，使 <code>SkeletalMeshComponent</code> 与 <code>CapsuleComponent</code> 对齐。</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/NewZLoc_Mesh.jpg" alt="NewZLoc_Mesh.png"></p>
</li>
<li><p>打开视口（Viewport）预览骨骼网格体。骨骼网格体应该如下图所示：</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/SkeletalMeshLocation.jpg" alt="SkeletalMeshLocation.png"></p>
<p>确认骨骼网格体在 <code>CapsuleComponent</code> 内部，并且网格体的朝向与 <code>ArrowComponent</code> 相同。正确确定骨骼网格体组件的朝向，将确保你的角色朝正确的方向在整个世界中移动。</p>
</li>
<li><p>请确保在关闭 <strong>蓝图编辑器（Blueprint Editor）</strong> 之前 <strong>编译（Compile)</strong> 并 <strong>保存（Save）</strong> <strong>BP_FPSCharacter</strong> 蓝图。</p>
</li>
</ol>
<h2 id="确认处于PIE模式的新网格体"><a href="#确认处于PIE模式的新网格体" class="headerlink" title="确认处于PIE模式的新网格体"></a>确认处于PIE模式的新网格体</h2><p>现在可在编辑器中查看新增网格体。</p>
<ol>
<li><p>在关卡编辑器工具栏中点击 <strong>运行（Play）</strong> 按钮。在你四处移动时，你应该能看到角色的影子。</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/PawnwithShadow.jpg" alt="PawnwithShadow.png"></p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/Section0206.jpg" alt="Section0206.gif"></p>
<p>如果你要在编辑器的视口中查看角色的网格体，请按F8键，使自己从pawn中弹出来。按下F8键后，你将可以在关卡中自由移动摄像机。要移动摄像机，请在移动鼠标的同时按住鼠标左键。</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/FreelyMovingCamera.jpg" alt="FreelyMovingCamera.png"></p>
</li>
<li><p>按 <strong>退出（Escape）</strong> 键或在关卡编辑器中点击 <strong>停止（Stop）</strong> 按钮，退出在编辑器中运行（Play in Editor）（PIE）模式。</p>
</li>
</ol>
<h1 id="更改摄像机视角"><a href="#更改摄像机视角" class="headerlink" title="更改摄像机视角"></a>更改摄像机视角</h1><p>在上一步结束时，默认摄像机放置在网格体的颈部。在此步骤中，你将设置FPS摄像机，这样你可以调整摄像机的属性（例如位置和视野）。 在开始之前，你需要在 <code>FPSCharacter.h</code> 中包含更多的头文件。这将使你的代码可以访问更多与摄像机相关的函数，并最终使你能够操纵摄像机的位置。</p>
<ol>
<li><p>打开Visual Studio项目，然后导航至 <code>FPSCharacter.h</code>。</p>
</li>
<li><p>将以下头文件添加到 <code>FPSCharacter.h</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;Camera/CameraComponent.h&quot;</span><br><span class="line">#include &quot;Components/CapsuleComponent.h&quot;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="附加摄像机组件"><a href="#附加摄像机组件" class="headerlink" title="附加摄像机组件"></a>附加摄像机组件</h3><ol>
<li><p>打开 <code>FPSCharacter.h</code>，添加以下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// FPS摄像机。</span><br><span class="line">UPROPERTY(VisibleAnywhere)</span><br><span class="line">UCameraComponent* FPSCameraComponent;</span><br></pre></td></tr></table></figure>
</li>
<li><p>现在 <code>FPSCharacter.h</code> 的内容应如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">//版权所有Epic Games, Inc。保留所有权利。</span><br><span class="line"></span><br><span class="line">#pragma once</span><br><span class="line"></span><br><span class="line">#include &quot;CoreMinimal.h&quot;</span><br><span class="line">#include &quot;GameFramework/Character.h&quot;</span><br><span class="line">#include &quot;Camera/CameraComponent.h&quot;</span><br><span class="line">#include &quot;Components/CapsuleComponent.h&quot;</span><br><span class="line">#include &quot;FPSCharacter.generated.h&quot;</span><br><span class="line"></span><br><span class="line">UCLASS()</span><br><span class="line">class FPSPROJECT_API AFPSCharacter : public ACharacter</span><br><span class="line">&#123;</span><br><span class="line">GENERATED_BODY()</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">// 为此角色的属性设置默认值</span><br><span class="line">AFPSCharacter();</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line">// 当游戏开始或重生（Spawn）时被调用</span><br><span class="line">virtual void BeginPlay() override;</span><br><span class="line"></span><br><span class="line">public:     </span><br><span class="line">// 每一帧都被调用</span><br><span class="line">virtual void Tick( float DeltaTime ) override;</span><br><span class="line"></span><br><span class="line">// 被调用，将功能与输入绑定</span><br><span class="line">virtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;</span><br><span class="line"></span><br><span class="line">// 处理用于前后移动的输入。</span><br><span class="line">UFUNCTION()</span><br><span class="line">void MoveForward(float Value);</span><br><span class="line"></span><br><span class="line">// 处理用于左右移动的输入。</span><br><span class="line">UFUNCTION()</span><br><span class="line">void MoveRight(float Value);</span><br><span class="line"></span><br><span class="line">// 按下键时，设置跳跃标记。</span><br><span class="line">UFUNCTION()</span><br><span class="line">void StartJump();</span><br><span class="line"></span><br><span class="line">// 释放键时，清除跳跃标记。</span><br><span class="line">UFUNCTION()</span><br><span class="line">void StopJump();</span><br><span class="line"></span><br><span class="line">// FPS摄像机</span><br><span class="line">UPROPERTY(VisibleAnywhere)</span><br><span class="line">UCameraComponent* FPSCameraComponent;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>打开 <code>FPSCharacter.cpp</code>，将以下代码添加到构造函数中： <code>PrimaryActorTick.bCanEverTick = true:</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 创建第一人称摄像机组件。</span><br><span class="line">FPSCameraComponent = CreateDefaultSubobject&lt;UCameraComponent&gt;(TEXT(&quot;FirstPersonCamera&quot;));</span><br><span class="line">check(FPSCameraComponent != nullptr);</span><br><span class="line"></span><br><span class="line">// 将摄像机组件附加到我们的胶囊体组件。</span><br><span class="line">FPSCameraComponent-&gt;SetupAttachment(CastChecked&lt;USceneComponent, UCapsuleComponent&gt;(GetCapsuleComponent()));</span><br></pre></td></tr></table></figure>

<p>此代码创建 <code>UCameraComponent</code>，并将其附加到角色的 <code>CapsuleComponent</code>。</p>
</li>
<li><p>现在，将以下代码添加到你刚刚在构造函数中编写的代码块下面：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 将摄像机置于略高于眼睛上方的位置。</span><br><span class="line">FPSCameraComponent-&gt;SetRelativeLocation(FVector(0.0f, 0.0f, 50.0f + BaseEyeHeight));</span><br><span class="line"></span><br><span class="line">// 启用Pawn控制摄像机旋转。</span><br><span class="line">FPSCameraComponent-&gt;bUsePawnControlRotation = true;</span><br></pre></td></tr></table></figure>

<p>此代码将摄像机的位置调整为略高于角色眼睛的位置，同时允许pawn控制摄像机的旋转。</p>
<p><code>SetRelativeLocation</code> 用于设置组件的默认值。不过，上一个值仍然会在设置在编辑器中。为纠正这点，请打开蓝图编辑器。点击 <code>FPSCameraComponent</code>，然后在 <strong>细节</strong> 面板中找到 <strong>变换 -&gt; 位置（Transform -&gt; Location）</strong> 数值。点击这个值旁边的 <strong>重置为默认（Reset to Default）</strong>。</p>
</li>
<li><p>现在 <code>FPSCharacter.cpp</code> 的内容应如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">//版权所有Epic Games, Inc。保留所有权利。</span><br><span class="line"></span><br><span class="line">#include &quot;FPSCharacter.h&quot;</span><br><span class="line"></span><br><span class="line">// 设置默认值</span><br><span class="line">AFPSCharacter::AFPSCharacter()</span><br><span class="line">&#123;</span><br><span class="line">   // 将此角色设置为每帧调用Tick()。  如果不需要此特性，可以关闭以提升性能。</span><br><span class="line">   PrimaryActorTick.bCanEverTick = true;</span><br><span class="line"></span><br><span class="line">   // 创建第一人称摄像机组件。</span><br><span class="line">   FPSCameraComponent = CreateDefaultSubobject&lt;UCameraComponent&gt;(TEXT(&quot;FirstPersonCamera&quot;));</span><br><span class="line">   check(FPSCameraComponent != nullptr);</span><br><span class="line"></span><br><span class="line">   // 将摄像机组件附加到我们的胶囊体组件。</span><br><span class="line">   FPSCameraComponent-&gt;SetupAttachment(CastChecked&lt;USceneComponent, UCapsuleComponent&gt;(GetCapsuleComponent()));</span><br><span class="line"></span><br><span class="line">   // 将摄像机置于略高于眼睛上方的位置。</span><br><span class="line">   FPSCameraComponent-&gt;SetRelativeLocation(FVector(0.0f, 0.0f, 50.0f + BaseEyeHeight));</span><br><span class="line"></span><br><span class="line">   // 启用Pawn控制摄像机旋转。</span><br><span class="line">   FPSCameraComponent-&gt;bUsePawnControlRotation = true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 当游戏开始或重生（Spawn）时被调用</span><br><span class="line">void AFPSCharacter::BeginPlay()</span><br><span class="line">&#123;</span><br><span class="line">   Super::BeginPlay();</span><br><span class="line"></span><br><span class="line">   check(GEngine != nullptr)</span><br><span class="line"></span><br><span class="line">     // 显示调试消息五秒。 </span><br><span class="line">    // -1&quot;键&quot;值（第一个参数）表示我们从不需要更新或刷新此消息。</span><br><span class="line">     GEngine-&gt;AddOnScreenDebugMessage(-1, 5.0f, FColor::Red, TEXT(&quot;We are using FPSCharacter.&quot;));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 每一帧都被调用</span><br><span class="line">void AFPSCharacter::Tick( float DeltaTime )</span><br><span class="line">&#123;</span><br><span class="line">   Super::Tick( DeltaTime );</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 被调用，将功能与输入绑定</span><br><span class="line">void AFPSCharacter::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)</span><br><span class="line">&#123;</span><br><span class="line">   Super::SetupPlayerInputComponent(PlayerInputComponent);</span><br><span class="line"></span><br><span class="line">   // 设置&quot;移动&quot;绑定。</span><br><span class="line">   PlayerInputComponent-&gt;BindAxis(&quot;MoveForward&quot;, this, &amp;AFPSCharacter::MoveForward);</span><br><span class="line">   PlayerInputComponent-&gt;BindAxis(&quot;MoveRight&quot;, this, &amp;AFPSCharacter::MoveRight);</span><br><span class="line"></span><br><span class="line">   // 设置&quot;观看&quot;绑定。</span><br><span class="line">   PlayerInputComponent-&gt;BindAxis(&quot;Turn&quot;, this, &amp;AFPSCharacter::AddControllerYawInput);</span><br><span class="line">   PlayerInputComponent-&gt;BindAxis(&quot;LookUp&quot;, this, &amp;AFPSCharacter::AddControllerPitchInput);</span><br><span class="line"></span><br><span class="line">   // 设置&quot;操作&quot;绑定。</span><br><span class="line">   PlayerInputComponent-&gt;BindAction(&quot;Jump&quot;, IE_Pressed, this, &amp;AFPSCharacter::StartJump);</span><br><span class="line">   PlayerInputComponent-&gt;BindAction(&quot;Jump&quot;, IE_Released, this, &amp;AFPSCharacter::StopJump);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void AFPSCharacter::MoveForward(float Value)</span><br><span class="line">&#123;</span><br><span class="line">   // 找出&quot;前进&quot;方向，并记录玩家想向该方向移动。</span><br><span class="line">   FVector Direction = FRotationMatrix(Controller-&gt;GetControlRotation()).GetScaledAxis(EAxis::X);</span><br><span class="line">   AddMovementInput(Direction, Value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void AFPSCharacter::MoveRight(float Value)</span><br><span class="line">&#123;</span><br><span class="line">   // 找出&quot;右侧&quot;方向，并记录玩家想向该方向移动。</span><br><span class="line">   FVector Direction = FRotationMatrix(Controller-&gt;GetControlRotation()).GetScaledAxis(EAxis::Y);</span><br><span class="line">   AddMovementInput(Direction, Value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void AFPSCharacter::StartJump()</span><br><span class="line">&#123;</span><br><span class="line">   bPressedJump = true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void AFPSCharacter::StopJump()</span><br><span class="line">&#123;</span><br><span class="line">   bPressedJump = false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="测试新摄像机"><a href="#测试新摄像机" class="headerlink" title="测试新摄像机"></a>测试新摄像机</h3><p>现在我们来编译和测试新实现的摄像机代码。</p>
<ol>
<li><p>在Visual Studio中保存 <code>FPSCharacter</code> 头文件（.h）和C++（.cpp）文件。</p>
</li>
<li><p>在 <strong>解决方案浏览器（Solution Explorer）</strong> 中找到 <strong>FPSProject</strong>。</p>
</li>
<li><p>右键点击 <strong>FPSProject</strong> 并选择 <strong>构建（Build）</strong>，编译你的项目。</p>
</li>
<li><p>构建完毕后，在虚幻引擎中打开 <strong>FPSProject</strong>。</p>
</li>
<li><p>在关卡编辑器工具栏中点击 <strong>运行（Play）</strong>。</p>
</li>
</ol>
<p>现在，摄像机应该略高于角色的头部。</p>
<p>你还可以通过打开BP_FPSCharacter视口来确认新添加的摄像机组件。 <img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/NewCameraComponent.jpg" alt="NewCameraComponent.png"></p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/NewCameraPosition.jpg" alt="NewCameraPosition.png"></p>
<h1 id="将第一人称网格体添加到角色"><a href="#将第一人称网格体添加到角色" class="headerlink" title="将第一人称网格体添加到角色"></a>将第一人称网格体添加到角色</h1><p>构建FPS游戏的常见方法是使用两个分开的角色网格体，其中一个是全身网格体，另一个是”武器和手部”网格体。全身网格体用于从第三人称视角观察角色。但是，当玩家以第一人称视角进行游戏时，全身网格体是隐藏的。”武器和手部”网格体通常附着到摄像机，并且仅当玩家以第一人称视角查看地图时才对玩家可见。在此步骤中，你将向角色添加第一人称网格体。</p>
<h3 id="添加第一人称角色网格体"><a href="#添加第一人称角色网格体" class="headerlink" title="添加第一人称角色网格体"></a>添加第一人称角色网格体</h3><ol>
<li><p>切换回Visual Studio并打开 <code>FPSCharacter.h</code>，在 <strong>public:</strong> 下添加以下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 第一人称网格体（手臂），仅对所属玩家可见。</span><br><span class="line">UPROPERTY(VisibleDefaultsOnly, Category = Mesh)</span><br><span class="line">USkeletalMeshComponent* FPSMesh;</span><br></pre></td></tr></table></figure>
</li>
<li><p>现在，打开 <code>FPSCharacter.cpp</code>，找到构造函数，添加以下代码，创建和配置第一人称网格体：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 为所属玩家创建第一人称网格体组件。</span><br><span class="line">FPSMesh = CreateDefaultSubobject&lt;USkeletalMeshComponent&gt;(TEXT(&quot;FirstPersonMesh&quot;));</span><br><span class="line">check(FPSMesh != nullptr);</span><br><span class="line"></span><br><span class="line">// 仅所属玩家可以看见此网格体。</span><br><span class="line">FPSMesh-&gt;SetOnlyOwnerSee(true);</span><br><span class="line"></span><br><span class="line">// 将 FPS 网格体附加到 FPS 摄像机。</span><br><span class="line">FPSMesh-&gt;SetupAttachment(FPSCameraComponent);</span><br><span class="line"></span><br><span class="line">// 禁用某些环境阴影以便实现只有单个网格体的感觉。</span><br><span class="line">FPSMesh-&gt;bCastDynamicShadow = false;</span><br><span class="line">FPSMesh-&gt;CastShadow = false;</span><br></pre></td></tr></table></figure>

<p><code>SetOnlyOwnerSee</code> 表示此网格体仅对拥有此角色的 <code>PlayerController</code> 可见。此代码还将网格体附加到摄像机，并禁用某些环境阴影。让手臂投射阴影会破坏第一人称角色应该只有单个网格体的感觉。</p>
</li>
<li><p>最后，将以下代码添加到FPSCharacter.cpp的构造函数中，以便隐藏所属角色的现有第三人称网格体：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 所属玩家看不到常规（第三人称）全身网格体。</span><br><span class="line">GetMesh()-&gt;SetOwnerNoSee(true);</span><br></pre></td></tr></table></figure>
</li>
<li><p>在Visual Studio中保存FPSCharacter头文件（.h）和实现（.cpp）文件。</p>
</li>
<li><p>在 <strong>解决方案浏览器（Solution Explorer）</strong> 中找到 <strong>FPSProject</strong>。</p>
</li>
<li><p>右键点击 <strong>FPSProject</strong> 并选择 <strong>构建（Build）</strong>，编译你的项目。</p>
</li>
<li><p>构建完成后，打开并以PIE模式运行 <strong>FPSProject</strong>。</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/HiddenMeshInGame.jpg" alt="HiddenMeshInGame.png"></p>
</li>
</ol>
<p>此时，你的角色网格体在编辑器中应该不可见。</p>
<p>如果你仍然看到网格体及其阴影投射，请关闭并重新启动编辑器。</p>
<h3 id="构建网格体蓝图"><a href="#构建网格体蓝图" class="headerlink" title="构建网格体蓝图"></a>构建网格体蓝图</h3><p>在继续之前，请通过以下链接下载并提取示例网格体： <a target="_blank" rel="noopener" href="https://docs.unrealengine.com/4.27/Attachments/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/8/HeroFPP.zip">“第一人称骨骼网格体”</a></p>
<ol>
<li><p>右键点击内容浏览器的文件框，打开 <strong>导入资产（Import Asset）</strong> 对话框。</p>
</li>
<li><p>点击 <strong>导入&#x2F;游戏…（Import to &#x2F;Game…）</strong>，打开 <strong>导入（Import）</strong> 对话框。</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/RightClickImport.jpg" alt="RightClickImport.png"></p>
</li>
<li><p>找到并选择 <strong>HeroFPP.fbx</strong> 网格体文件。</p>
</li>
<li><p>点击 <strong>打开（Open）</strong>，开始将网格体导入到你的项目中。</p>
</li>
<li><p><strong>内容浏览器（Content Browser）</strong> 中将显示 <strong>FBX导入选项（FBX Import Options）</strong> 对话框。</p>
</li>
<li><p>请确保将 <strong>骨架（Skeleton）</strong> 设置为 <strong>无（None）</strong>，然后点击 <strong>全部导入（Import All）</strong>。</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/ClearSkeletonMesh.jpg" alt="ClearSkeletonMesh.png"></p>
</li>
<li><p>关闭以下消息日志。  </p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/FBXWarning.jpg" alt="FBXWarning.png">  </p>
<p>此网格体仍展示第一人称网格体设置，它将与你在后面分段中设置的动画一起使用。</p>
</li>
<li><p>点击 <strong>保存（Save）</strong>，保存导入的网格体。</p>
</li>
<li><p>导航返回 <strong>内容浏览器（Content Browser）</strong> 中的 <strong>蓝图（Blueprints）</strong> 文件夹。</p>
</li>
<li><p>双击 <strong>BP_FPSCharacter</strong> 图标，在 <strong>蓝图编辑器</strong> 中打开它。</p>
</li>
<li><p>在 <strong>组件（Components）</strong> 选项卡中找到新的 <strong>FPSMesh</strong> 组件。首先，你可能需要打开 <strong>完整的蓝图编辑器</strong>。</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/LocateFPSMeshComponent.jpg" alt="LocateFPSMeshComponent.png">  </p>
<p><strong>FPSMesh</strong> 组件是 <strong>FPSCameraComponent</strong> 组件的子项，这意味着它将始终附加到摄像机。</p>
</li>
<li><p>在 <strong>组件（Components）</strong> 菜单中点击 <strong>FPSMesh</strong>。</p>
</li>
<li><p>滚动到 <strong>细节（Details）</strong> 选项卡的 <strong>网格体（Mesh）</strong> 段，然后点击显示为”无（None）”的下拉菜单。现在，选择 <strong>HeroFPP</strong> 骨骼网格体，将手臂添加到 <strong>视口（Viewport）</strong>。</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/SelectHeroFPPSkeletalMesh.jpg" alt="SelectHeroFPPSkeletalMesh.png"></p>
</li>
<li><p>在 <strong>视口（Viewport）</strong> 中，新增的 <strong>HeroFPP</strong> 骨骼网格体应如下图所示。</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/HeroFPPMesh_Viewport.jpg" alt="HeroFPPMesh_Viewport.png"></p>
</li>
<li><p>将新增网格体的变换属性调整为在摄像机前面：将其 <strong>位置（Location）</strong> 设置为{220, 0, 35}，将其 <strong>旋转（Rotation）</strong> 设置为{180, 50, 180}。</p>
<p><a target="_blank" rel="noopener" href="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/AdjustingArmsTransform.png"><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/AdjustingArmsTransform.jpg" alt="AdjustingArmsTransform.png"></a></p>
<p>点击查看大图。</p>
</li>
<li><p>请确保在关闭 <strong>蓝图编辑器（Blueprint Editor）</strong> 之前 <strong>编译（Compile)</strong> 并 <strong>保存（Save）</strong> <strong>BP_FPSCharacter</strong> 蓝图。</p>
</li>
</ol>
<h3 id="在游戏中查看新网格体"><a href="#在游戏中查看新网格体" class="headerlink" title="在游戏中查看新网格体"></a>在游戏中查看新网格体</h3><ol>
<li><p>点击 <strong>关卡编辑器工具栏</strong> 中的 <strong>运行（Play）</strong> 按钮**，在游戏中查看新网格体。</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/FirstPersonShooter/2/Section0208.jpg" alt="Section0208.gif"></p>
</li>
<li><p>按 <strong>退出（Escape）</strong> 键或在关卡编辑器中点击 <strong>停止（Stop）</strong> 按钮，退出在编辑器中运行（Play in Editor）（PIE）模式。</p>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/27/UE4-API/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="williny">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Williny'home">
      <meta itemprop="description" content="孤独是人生的常态">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Williny'home">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/04/27/UE4-API/" class="post-title-link" itemprop="url">UE4-API</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-04-27 09:06:23 / 修改时间：14:34:34" itemprop="dateCreated datePublished" datetime="2022-04-27T09:06:23+08:00">2022-04-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/unreal-engine/" itemprop="url" rel="index"><span itemprop="name">unreal engine</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>在这里记录一些目前遇到的unreal engine中的API</p>
<h1 id="组件与碰撞"><a href="#组件与碰撞" class="headerlink" title="组件与碰撞"></a>组件与碰撞</h1><p>在官方案例——<a target="_blank" rel="noopener" href="https://docs.unrealengine.com/4.27/zh-CN/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/Components/">组件与碰撞</a>中的API</p>
<h2 id="CreateDefaultSubject-lt-gt"><a href="#CreateDefaultSubject-lt-gt" class="headerlink" title="CreateDefaultSubject&lt;&gt;()"></a>CreateDefaultSubject&lt;&gt;()</h2><p>创建默认子网格体&lt;&gt;中是子网格体的类型</p>
<p><code>USphereComponent* SphereComponent = CreateDefaultSubobject&lt;USphereComponent&gt;(TEXT(&quot;RootComponent&quot;))</code></p>
<h2 id="InitSphereRadius"><a href="#InitSphereRadius" class="headerlink" title="InitSphereRadius()"></a>InitSphereRadius()</h2><p>初始化球体半径</p>
<p><code>SphereComponent-&gt;InitSphereRadius(40.0f);</code></p>
<h2 id="SetCollisionProfileName"><a href="#SetCollisionProfileName" class="headerlink" title="SetCollisionProfileName()"></a>SetCollisionProfileName()</h2><p>设置碰撞预设名称</p>
<p><code>SphereComponent-&gt;SetCollisionProfileName(TEXT(&quot;Pawn&quot;));</code></p>
<h2 id="SetupAttachment"><a href="#SetupAttachment" class="headerlink" title="SetupAttachment()"></a>SetupAttachment()</h2><p>将某组件添加到括号内的组件上</p>
<p><code>SphereVisual-&gt;SetupAttachment(RootComponent);</code></p>
<h2 id="static-ConstructorHelpers-FObjectFinder-lt-gt"><a href="#static-ConstructorHelpers-FObjectFinder-lt-gt" class="headerlink" title="static ConstructorHelpers::FObjectFinder&lt;&gt;"></a>static ConstructorHelpers::FObjectFinder&lt;&gt;</h2><p>直接在代码中设置静态网格体资源</p>
<p><code>static ConstructorHelpers::FObjectFinder&lt;UStaticMesh&gt; SphereVisualAsset(TEXT(&quot;/Game/StarterContent/Shapes/Shape_Sphere.Shape_Sphere&quot;));</code></p>
<h2 id="SetStaticMesh"><a href="#SetStaticMesh" class="headerlink" title="SetStaticMesh()"></a>SetStaticMesh()</h2><p>将找到的网格体附加到括号内的组件上</p>
<p>SphereVisual-&gt;SetStaticMesh(SphereVisualAsset.Object);</p>
<h2 id="SetRelativeLocation"><a href="#SetRelativeLocation" class="headerlink" title="SetRelativeLocation()"></a>SetRelativeLocation()</h2><p>设置相对位置</p>
<p><code>SphereVisual-&gt;SetRelativeLocation(FVector(0.0f, 0.0f, -40.0f));</code></p>
<h2 id="SetWorldScale3D"><a href="#SetWorldScale3D" class="headerlink" title="SetWorldScale3D()"></a>SetWorldScale3D()</h2><p>设置缩放大小</p>
<p><code>SphereVisual-&gt;SetWorldScale3D(FVector(0.8f));</code></p>
<h2 id="bAutoActivate"><a href="#bAutoActivate" class="headerlink" title="bAutoActivate"></a>bAutoActivate</h2><p>粒子效果开关</p>
<p><code>OurParticleSystem-&gt;bAutoActivate = false;</code></p>
<h2 id="SetTemplate"><a href="#SetTemplate" class="headerlink" title="SetTemplate"></a>SetTemplate</h2><p>给粒子系统设定模板</p>
<p><code>OurParticleSystem-&gt;SetTemplate(ParticleAsset.Object);</code></p>
<h2 id="TargetArmLength"><a href="#TargetArmLength" class="headerlink" title="TargetArmLength"></a>TargetArmLength</h2><p>弹簧臂长度</p>
<p><code>SpringArm-&gt;TargetArmLength = 400.0f;</code></p>
<h2 id="bEnableCameraLag"><a href="#bEnableCameraLag" class="headerlink" title="bEnableCameraLag"></a>bEnableCameraLag</h2><p>弹簧臂平滑效果开关</p>
<p><code>SpringArm-&gt;bEnableCameraLag = true;</code></p>
<h2 id="CameraLagSpeed"><a href="#CameraLagSpeed" class="headerlink" title="CameraLagSpeed"></a>CameraLagSpeed</h2><p>平滑效果切换速度</p>
<p><code>SpringArm-&gt;CameraLagSpeed = 3.0f;</code></p>
<h2 id="SocketName"><a href="#SocketName" class="headerlink" title="SocketName"></a>SocketName</h2><p>弹簧臂插槽</p>
<p><code>Camera-&gt;SetupAttachment(SpringArm, USpringArmComponent::SocketName);</code></p>
<h2 id="AutoPossessPlayer"><a href="#AutoPossessPlayer" class="headerlink" title="AutoPossessPlayer"></a>AutoPossessPlayer</h2><p>默认控制玩家</p>
<p><code>AutoPossessPlayer = EAutoReceiveInput::Player0;</code></p>
<h2 id="UpdatedComonent"><a href="#UpdatedComonent" class="headerlink" title="UpdatedComonent"></a>UpdatedComonent</h2><p>更新某组件</p>
<p><code>OurMovementComponent-&gt;UpdatedComponent = RootComponent;</code></p>
<h2 id="BindAxtion"><a href="#BindAxtion" class="headerlink" title="BindAxtion()"></a>BindAxtion()</h2><p>绑定输入映射</p>
<p><code>InInputComponent-&gt;BindAction(&quot;ParticleToggle&quot;, IE_Pressed, this, &amp;ACollidingPawn::ParticleToggle);</code></p>
<ul>
<li><p>参数一：为 虚幻4-&gt;设置 -&gt;输入-&gt;按键绑定的名称</p>
</li>
<li><p>参数二：事件名称 IE_Pressed 按下 IE_Released松开 IE_DoubleClick双击</p>
</li>
<li><p>参数三：当前对象——this</p>
</li>
<li><p>参数四：事件方法的函数指针 例 &amp;类名::方法名的写法</p>
</li>
</ul>
<h2 id="BindAxis"><a href="#BindAxis" class="headerlink" title="BindAxis()"></a>BindAxis()</h2><p>绑定轴映射</p>
<p><code>InInputComponent-&gt;BindAxis(&quot;MoveForward&quot;, this, &amp;ACollidingPawn::MoveForward);</code></p>
<ul>
<li><p>参数一：为 虚幻4-&gt;设置 -&gt;输入-&gt;按键绑定的名称 一定要一样 重要！！！ </p>
</li>
<li><p>参数二 ：当前对象——this</p>
</li>
<li><p>参数三 事件方法的函数指针 例 &amp;类名::方法名 的写法</p>
</li>
</ul>
<h2 id="AddInputVector"><a href="#AddInputVector" class="headerlink" title="AddInputVector()"></a>AddInputVector()</h2><p>根据输入更改Vector位置</p>
<p><code>OurMovementComponent-&gt;AddInputVector(GetActorForwardVector() * AxisValue);</code></p>
<h2 id="GetActorForwardVector"><a href="#GetActorForwardVector" class="headerlink" title="GetActorForwardVector()"></a>GetActorForwardVector()</h2><p>更新Actor向前运动的vector</p>
<p><code>OurMovementComponent-&gt;AddInputVector(GetActorForwardVector() * AxisValue);</code></p>
<h2 id="GetActorRightVector"><a href="#GetActorRightVector" class="headerlink" title="GetActorRightVector()"></a>GetActorRightVector()</h2><p>更新Actor向右运动的vector</p>
<p><code>OurMovementComponent-&gt;AddInputVector(GetActorRightVector() * AxisValue);</code></p>
<h2 id="GetActorRotation"><a href="#GetActorRotation" class="headerlink" title="GetActorRotation()"></a>GetActorRotation()</h2><p>获取Actor的旋转角度</p>
<p><code>FRotator NewRotation = GetActorRotation();</code></p>
<h2 id="SetActorRotation"><a href="#SetActorRotation" class="headerlink" title="SetActorRotation();"></a>SetActorRotation();</h2><p>设置Actor的新角度</p>
<p><code>SetActorRotation(NewRotation);</code></p>
<h2 id="ToggleActive"><a href="#ToggleActive" class="headerlink" title="ToggleActive()"></a>ToggleActive()</h2><p>转换粒子效果状态（开关）</p>
<p><code>OurParticleSystem-&gt;ToggleActive();</code></p>
<p>GetClampedToMaxSize()</p>
<p>用于更新vector的位置</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FVector <span class="title">FVector::GetClampedToMaxSize</span><span class="params">(<span class="type">float</span> MaxSize)</span></span></span><br></pre></td></tr></table></figure>

<p>用于创建一个新的vector，方向与原本的方向一直，距离为MaxSize</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FVector <span class="title">FVector::GetClampedToSize</span><span class="params">(<span class="type">float</span> Min,<span class="type">float</span> Max)</span> </span></span><br></pre></td></tr></table></figure>

<p>创建一个新的Vector，方向与原方向一致</p>
<p>距离为</p>
<ol>
<li><p>若距离&lt;Min，则新的vector距离为Min</p>
</li>
<li><p>若距离&gt;Max，则新的vector距离为Max</p>
</li>
<li><p>若距离在Min和Max之间，则新的vector等于原本的vector</p>
</li>
</ol>
<h2 id="ConsumeInputVector-1-0f"><a href="#ConsumeInputVector-1-0f" class="headerlink" title="ConsumeInputVector(1.0f)"></a>ConsumeInputVector(1.0f)</h2><p>报告并清空用于存储移动输入的内置变量值。</p>
<h2 id="SafeMoveUpdatedComponent"><a href="#SafeMoveUpdatedComponent" class="headerlink" title="SafeMoveUpdatedComponent()"></a>SafeMoveUpdatedComponent()</h2><p><code>SafeMoveUpdatedComponent(const FVector&amp; Delta, const FRotator&amp; NewRotation, bool bSweep, FHitResult&amp; OutHit, ETeleportType Teleport)</code></p>
<p><code>SafeMoveUpdatedComponent(DesiredMovementThisFrame, UpdatedComponent-&gt;GetComponentRotation(), true, Hit);</code></p>
<p>利用虚幻引擎物理移动Pawn移动组件，同时考虑固体障碍。</p>
<ul>
<li><p>第一个参数：要移动的Vector</p>
</li>
<li><p>第二个参数：旋转参数</p>
</li>
<li><p>第三个参数：是否考虑物理障碍（如果为true，将在移动过程中扫描以阻止碰撞。如果为false，它将简单地传送到下一个位置并忽略碰撞。）</p>
</li>
<li><p>第四个参数：碰撞结果</p>
</li>
<li><p>第五个参数：可省略，远距离传送类型</p>
</li>
</ul>
<h2 id="SlideAlongSurface"><a href="#SlideAlongSurface" class="headerlink" title="SlideAlongSurface()"></a>SlideAlongSurface()</h2><p><code>SlideAlongSurface(const FVector&amp; Delta, float Time, const FQuat Rotation, const FVector&amp; Normal, FHitResult&amp; Hit, bool bHandleImpact)</code></p>
<ul>
<li><p>第一个参数：要移动的vector</p>
</li>
<li><p>第二个参数：运动时间</p>
</li>
<li><p>第三个参数：旋转情况（可省略）</p>
</li>
<li><p>第四个参数：vector类型？（这个不太确定）</p>
</li>
<li><p>第五个参数：碰撞结果（必须为bBlockingHit）</p>
</li>
<li><p>第六个参数：手柄反馈？（这个扎找不到源文件）</p>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/25/UE4-HowTo-Components/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="williny">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Williny'home">
      <meta itemprop="description" content="孤独是人生的常态">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Williny'home">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/04/25/UE4-HowTo-Components/" class="post-title-link" itemprop="url">UE4-HowTo_Components</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-04-25 17:08:45" itemprop="dateCreated datePublished" datetime="2022-04-25T17:08:45+08:00">2022-04-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-04-27 09:11:14" itemprop="dateModified" datetime="2022-04-27T09:11:14+08:00">2022-04-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/unreal-engine/" itemprop="url" rel="index"><span itemprop="name">unreal engine</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>官方案例——<a target="_blank" rel="noopener" href="https://docs.unrealengine.com/4.27/zh-CN/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/Components/">解组件和碰撞</a></p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li><p>明确目标：创建一个有物理性质的球体，能和其他物体碰撞，并且拥有火焰粒子效果</p>
</li>
<li><p>创建CollidingPawn</p>
</li>
<li><p>创建这个球体本身需要什么头文件</p>
</li>
<li><p>修改根组件为对物理反应的球体</p>
</li>
<li><p>创建球体并附加到根组件上</p>
</li>
<li><p>将粒子系统直接附加到球体上（不是根组件）</p>
</li>
<li><p>添加弹簧臂组件，并在其上插槽内添加摄像机组件</p>
</li>
<li><p>将此Pawn设为受默认玩家控制</p>
</li>
<li><p>配置输入：编辑-&gt;设置项目-&gt;输入-&gt;操作映射（粒子系统）-&gt;轴映射(移动和转动)</p>
</li>
<li><p>创建Pawn移动组件类（PawnMovementComponent）CollidingPawnMovementComponent</p>
</li>
<li><p>定义TickComonent函数，告知逐帧移动方式</p>
</li>
<li><p>将Pawn移动组件添加到Pawn内</p>
</li>
<li><p>创建Pawn移动组件并将其与Pawn关联，使其更新根组件</p>
</li>
<li><p>声明并定义一些函数处理Pawn会接收的输入</p>
</li>
<li><p>将函数绑定到输入事件</p>
</li>
</ol>
<h1 id="CollidingPawn-h"><a href="#CollidingPawn-h" class="headerlink" title="CollidingPawn.h"></a>CollidingPawn.h</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CoreMinimal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GameFramework/Pawn.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CollidingPawn.generated.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HOWTO_COMPONENTS_API</span> ACollidingPawn : <span class="keyword">public</span> APawn</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 设置此Pawn属性的默认值</span></span><br><span class="line">    <span class="built_in">ACollidingPawn</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// 游戏开始或生成时调用</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BeginPlay</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 逐帧调用</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Tick</span><span class="params">( <span class="type">float</span> DeltaSeconds )</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用以将功能与输入绑定（也就是将要设定的wasd和空格的输入功能）</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SetupPlayerInputComponent</span><span class="params">(<span class="keyword">class</span> UInputComponent* InInputComponent)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明粒子系统（火焰燃烧效果等）</span></span><br><span class="line">    <span class="built_in">UPROPERTY</span>()</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">UParticleSystemComponent</span>* OurParticleSystem;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明移动组件，使其可以追踪变量</span></span><br><span class="line">    <span class="built_in">UPROPERTY</span>()</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">UCollidingPawnMovementComponent</span>* OurMovementComponent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Pawn拥有名为 GetMovementComponent 的函数，用于提供引擎中其他类访问该Pawn当前所用Pawn移动组件的权限。需覆盖该函数，使其返回自定义Pawn移动组件</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> UPawnMovementComponent* <span class="title">GetMovementComponent</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建代码处理pawn接受过来的输入</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">MoveForward</span><span class="params">(<span class="type">float</span> AxisValue)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">MoveRight</span><span class="params">(<span class="type">float</span> AxisValue)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Turn</span><span class="params">(<span class="type">float</span> AxisValue)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ParticleToggle</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="CollidingPawn-cpp"><a href="#CollidingPawn-cpp" class="headerlink" title="CollidingPawn.cpp"></a>CollidingPawn.cpp</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CollidingPawn.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CollidingPawnMovementComponent.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;UObject/ConstructorHelpers.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Particles/ParticleSystemComponent.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Components/SphereComponent.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Camera/CameraComponent.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GameFramework/SpringArmComponent.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置默认值</span></span><br><span class="line">ACollidingPawn::<span class="built_in">ACollidingPawn</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 设置该Pawn以逐帧调用Tick()。如无需此功能，可关闭以提高性能。</span></span><br><span class="line">    PrimaryActorTick.bCanEverTick = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根组件将成为对物理反应的球体</span></span><br><span class="line">    USphereComponent* SphereComponent = <span class="built_in">CreateDefaultSubobject</span>&lt;USphereComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;RootComponent&quot;</span>));</span><br><span class="line">    RootComponent = SphereComponent;</span><br><span class="line">    SphereComponent-&gt;<span class="built_in">InitSphereRadius</span>(<span class="number">40.0f</span>);<span class="comment">//初始化球的半径</span></span><br><span class="line">    SphereComponent-&gt;<span class="built_in">SetCollisionProfileName</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;Pawn&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建并放置网格体组件，以便查看球体位置</span></span><br><span class="line">    UStaticMeshComponent* SphereVisual = <span class="built_in">CreateDefaultSubobject</span>&lt;UStaticMeshComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;VisualRepresentation&quot;</span>));</span><br><span class="line">    SphereVisual-&gt;<span class="built_in">SetupAttachment</span>(RootComponent);</span><br><span class="line">    <span class="function"><span class="type">static</span> ConstructorHelpers::FObjectFinder&lt;UStaticMesh&gt; <span class="title">SphereVisualAsset</span><span class="params">(TEXT(<span class="string">&quot;/Game/StarterContent/Shapes/Shape_Sphere.Shape_Sphere&quot;</span>))</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (SphereVisualAsset.<span class="built_in">Succeeded</span>())<span class="comment">//如果找到了绑定的网格体</span></span><br><span class="line">    &#123;</span><br><span class="line">        SphereVisual-&gt;<span class="built_in">SetStaticMesh</span>(SphereVisualAsset.Object);<span class="comment">//则将找到的网格体附加到SphereVisual上！</span></span><br><span class="line">        SphereVisual-&gt;<span class="built_in">SetRelativeLocation</span>(<span class="built_in">FVector</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">-40.0f</span>));<span class="comment">//设置相对位置</span></span><br><span class="line">        SphereVisual-&gt;<span class="built_in">SetWorldScale3D</span>(<span class="built_in">FVector</span>(<span class="number">0.8f</span>));<span class="comment">//缩放为80%</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建可激活或停止的粒子系统</span></span><br><span class="line">    <span class="comment">// 粒子系统组件直接附加到静态网格体组件，而非附加到根。其同时略微偏离网格体底部中心，以便在运行时清晰显示。</span></span><br><span class="line">    OurParticleSystem = <span class="built_in">CreateDefaultSubobject</span>&lt;UParticleSystemComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;MovementParticles&quot;</span>));</span><br><span class="line">    OurParticleSystem-&gt;<span class="built_in">SetupAttachment</span>(SphereVisual);<span class="comment">//将粒子效果组件添加到SphereVisual上！</span></span><br><span class="line">    OurParticleSystem-&gt;bAutoActivate = <span class="literal">false</span>;<span class="comment">//关闭激活粒子效果</span></span><br><span class="line">    OurParticleSystem-&gt;<span class="built_in">SetRelativeLocation</span>(<span class="built_in">FVector</span>(<span class="number">-20.0f</span>, <span class="number">0.0f</span>, <span class="number">20.0f</span>));<span class="comment">//设定粒子效果在网格体上的相对位置</span></span><br><span class="line">    <span class="function"><span class="type">static</span> ConstructorHelpers::FObjectFinder&lt;UParticleSystem&gt; <span class="title">ParticleAsset</span><span class="params">(TEXT(<span class="string">&quot;/Game/StarterContent/Particles/P_Fire.P_Fire&quot;</span>))</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (ParticleAsset.<span class="built_in">Succeeded</span>())<span class="comment">//如果在资源中找到指定的粒子效果</span></span><br><span class="line">    &#123;</span><br><span class="line">        OurParticleSystem-&gt;<span class="built_in">SetTemplate</span>(ParticleAsset.Object);<span class="comment">//将找到的粒子效果附加到PartcleAsset上！</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用弹簧臂给予摄像机平滑自然的运动感。</span></span><br><span class="line">    USpringArmComponent* SpringArm = <span class="built_in">CreateDefaultSubobject</span>&lt;USpringArmComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;CameraAttachmentArm&quot;</span>));</span><br><span class="line">    SpringArm-&gt;<span class="built_in">SetupAttachment</span>(RootComponent);<span class="comment">//将弹簧臂附加到根组件上</span></span><br><span class="line">    SpringArm-&gt;<span class="built_in">SetRelativeRotation</span>(<span class="built_in">FRotator</span>(<span class="number">-45.f</span>, <span class="number">0.f</span>, <span class="number">0.f</span>));<span class="comment">//设定弹簧臂相对于转子的位置</span></span><br><span class="line">    SpringArm-&gt;TargetArmLength = <span class="number">400.0f</span>;<span class="comment">//弹簧臂长度</span></span><br><span class="line">    SpringArm-&gt;bEnableCameraLag = <span class="literal">true</span>;<span class="comment">//打开平滑效果</span></span><br><span class="line">    SpringArm-&gt;CameraLagSpeed = <span class="number">3.0f</span>;<span class="comment">//设置平滑效果时间</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建摄像机并附加到弹簧臂</span></span><br><span class="line">    <span class="comment">// 弹簧臂内置一个特殊的插槽，可供我们添加对象，这样就不必将对象直接添加到组件的根节点上。</span></span><br><span class="line">    UCameraComponent* Camera = <span class="built_in">CreateDefaultSubobject</span>&lt;UCameraComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;ActualCamera&quot;</span>));</span><br><span class="line">    Camera-&gt;<span class="built_in">SetupAttachment</span>(SpringArm, USpringArmComponent::SocketName);<span class="comment">//将摄像机添加到弹簧臂的插槽上！</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 控制默认玩家</span></span><br><span class="line">    AutoPossessPlayer = EAutoReceiveInput::Player0;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建移动组件的实例，并要求其更新根组件。</span></span><br><span class="line">    OurMovementComponent = <span class="built_in">CreateDefaultSubobject</span>&lt;UCollidingPawnMovementComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;CustomMovementComponent&quot;</span>));</span><br><span class="line">    OurMovementComponent-&gt;UpdatedComponent = RootComponent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 游戏开始或生成时调用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ACollidingPawn::BeginPlay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">BeginPlay</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 逐帧调用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ACollidingPawn::Tick</span><span class="params">( <span class="type">float</span> DeltaTime )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">Tick</span>( DeltaTime );</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置键盘输入将会发生的事件，其中前进左右转弯等等函数将在下文定义</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ACollidingPawn::SetupPlayerInputComponent</span><span class="params">(<span class="keyword">class</span> UInputComponent* InInputComponent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">SetupPlayerInputComponent</span>(InInputComponent);</span><br><span class="line"></span><br><span class="line">    InInputComponent-&gt;<span class="built_in">BindAction</span>(<span class="string">&quot;ParticleToggle&quot;</span>, IE_Pressed, <span class="keyword">this</span>, &amp;ACollidingPawn::ParticleToggle);</span><br><span class="line"></span><br><span class="line">    InInputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="string">&quot;MoveForward&quot;</span>, <span class="keyword">this</span>, &amp;ACollidingPawn::MoveForward);</span><br><span class="line">    InInputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="string">&quot;MoveRight&quot;</span>, <span class="keyword">this</span>, &amp;ACollidingPawn::MoveRight);</span><br><span class="line">    InInputComponent-&gt;<span class="built_in">BindAxis</span>(<span class="string">&quot;Turn&quot;</span>, <span class="keyword">this</span>, &amp;ACollidingPawn::Turn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于提供引擎中其他类访问该Pawn当前所用Pawn移动组件的权限。</span></span><br><span class="line"><span class="function">UPawnMovementComponent* <span class="title">ACollidingPawn::GetMovementComponent</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> OurMovementComponent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义前后移动的函数代码</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ACollidingPawn::MoveForward</span><span class="params">(<span class="type">float</span> AxisValue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//保证移动组件存在并且移动组件用来更新根组件</span></span><br><span class="line">    <span class="keyword">if</span> (OurMovementComponent &amp;&amp; (OurMovementComponent-&gt;UpdatedComponent == RootComponent))</span><br><span class="line">    &#123;</span><br><span class="line">        OurMovementComponent-&gt;<span class="built_in">AddInputVector</span>(<span class="built_in">GetActorForwardVector</span>() * AxisValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义左右转动的函数代码</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ACollidingPawn::MoveRight</span><span class="params">(<span class="type">float</span> AxisValue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (OurMovementComponent &amp;&amp; (OurMovementComponent-&gt;UpdatedComponent == RootComponent))</span><br><span class="line">    &#123;</span><br><span class="line">        OurMovementComponent-&gt;<span class="built_in">AddInputVector</span>(<span class="built_in">GetActorRightVector</span>() * AxisValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义转向代码</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ACollidingPawn::Turn</span><span class="params">(<span class="type">float</span> AxisValue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FRotator NewRotation = <span class="built_in">GetActorRotation</span>();<span class="comment">//获取actor当前位置</span></span><br><span class="line">    NewRotation.Yaw += AxisValue;<span class="comment">//围绕Z轴旋转更新actor</span></span><br><span class="line">    <span class="built_in">SetActorRotation</span>(NewRotation);<span class="comment">//更新actor的旋转角度</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义粒子效果开关代码</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ACollidingPawn::ParticleToggle</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//保证粒子效果存在且已经设定好了模板</span></span><br><span class="line">    <span class="keyword">if</span> (OurParticleSystem &amp;&amp; OurParticleSystem-&gt;Template)</span><br><span class="line">    &#123;</span><br><span class="line">        OurParticleSystem-&gt;<span class="built_in">ToggleActive</span>();<span class="comment">//ToggleActor的意思是切换状态</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="有关BindAction-与BindAction"><a href="#有关BindAction-与BindAction" class="headerlink" title="有关BindAction()与BindAction()"></a>有关BindAction()与BindAction()</h2><p><code>BindAction(&quot;ZoomIn&quot;, IE_Pressed, this, &amp;APawnWithCamera::ZoomIn);</code></p>
<ul>
<li><p>参数一：为 虚幻4-&gt;设置 -&gt;输入-&gt;按键绑定的名称 </p>
</li>
<li><p>参数二：事件名称 IE_Pressed 按下 IE_Released松开 IE_DoubleClick双击 </p>
</li>
<li><p>参数三：当前对象——this</p>
</li>
<li><p>参数四：事件方法的函数指针 例 &amp;类名::方法名的写法</p>
</li>
</ul>
<p><code>BindAxis(&quot;MoveForward&quot;, this, &amp;ACollidingPawn::MoveForward);</code></p>
<p>参数一：为 虚幻4-&gt;设置 -&gt;输入-&gt;按键绑定的名称 一定要一样 重要！！！<br>参数二 ：当前对象——this<br>参数三 事件方法的函数指针 例 &amp;类名::方法名 的写法</p>
<h1 id="CollidingPawnMovementComponent-h"><a href="#CollidingPawnMovementComponent-h" class="headerlink" title="CollidingPawnMovementComponent.h"></a>CollidingPawnMovementComponent.h</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CoreMinimal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GameFramework/PawnMovementComponent.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CollidingPawnMovementComponent.generated.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HOWTO_COMPONENTS_API</span> UCollidingPawnMovementComponent : <span class="keyword">public</span> UPawnMovementComponent</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">//TickComponent函数类似于Tick，意思是逐帧刷新</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">TickComponent</span><span class="params">(<span class="type">float</span> DeltaTime, <span class="keyword">enum</span> ELevelTick TickType, FActorComponentTickFunction *ThisTickFunction)</span> <span class="keyword">override</span></span>;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="CollidingPawnMovementComponent-cpp"><a href="#CollidingPawnMovementComponent-cpp" class="headerlink" title="CollidingPawnMovementComponent.cpp"></a>CollidingPawnMovementComponent.cpp</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CollidingPawnMovementComponent.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UCollidingPawnMovementComponent::TickComponent</span><span class="params">(<span class="type">float</span> DeltaTime, <span class="keyword">enum</span> ELevelTick TickType, FActorComponentTickFunction *ThisTickFunction)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">TickComponent</span>(DeltaTime, TickType, ThisTickFunction);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确保所有事物持续有效，以便进行移动。</span></span><br><span class="line">    <span class="keyword">if</span> (!PawnOwner || !UpdatedComponent || <span class="built_in">ShouldSkipUpdate</span>(DeltaTime))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取（然后清除）ACollidingPawn::Tick中设置的移动向量</span></span><br><span class="line">    <span class="comment">// 设定一个变量来存储移动输入的变量值（ConsumeInputVector()），然后通过运行时间来设置运动速度</span></span><br><span class="line">    FVector DesiredMovementThisFrame = <span class="built_in">ConsumeInputVector</span>().<span class="built_in">GetClampedToMaxSize</span>(<span class="number">1.0f</span>) * DeltaTime * <span class="number">150.0f</span>;</span><br><span class="line">    <span class="keyword">if</span> (!DesiredMovementThisFrame.<span class="built_in">IsNearlyZero</span>())</span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="comment">//Hit变量来记录碰撞结果</span></span><br><span class="line">        FHitResult Hit;</span><br><span class="line">        <span class="comment">//用虚幻引擎物理移动pawn移动组件，同时会考虑到固体障碍物</span></span><br><span class="line">        <span class="built_in">SafeMoveUpdatedComponent</span>(DesiredMovementThisFrame, UpdatedComponent-&gt;<span class="built_in">GetComponentRotation</span>(), <span class="literal">true</span>, Hit);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若发生碰撞，尝试滑过去</span></span><br><span class="line">        <span class="keyword">if</span> (Hit.<span class="built_in">IsValidBlockingHit</span>())</span><br><span class="line">        &#123;    </span><br><span class="line">            <span class="comment">//移动导致碰撞时， SlideAlongSurface 会处理沿墙壁和斜坡等碰撞表面平滑滑动所涉及的计算和物理，而非直接停留原地，粘在墙壁或斜坡上。</span></span><br><span class="line">            <span class="built_in">SlideAlongSurface</span>(DesiredMovementThisFrame, <span class="number">1.f</span> - Hit.Time, Hit.Normal, Hit);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="GetClampedToMaxSize"><a href="#GetClampedToMaxSize" class="headerlink" title="GetClampedToMaxSize()"></a>GetClampedToMaxSize()</h2><p>用于更新vector的位置</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FVector <span class="title">FVector::GetClampedToMaxSize</span><span class="params">(<span class="type">float</span> MaxSize)</span></span></span><br></pre></td></tr></table></figure>

<p>用于创建一个新的vector，方向与原本的方向一直，距离为MaxSize</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FVector <span class="title">FVector::GetClampedToSize</span><span class="params">(<span class="type">float</span> Min,<span class="type">float</span> Max)</span> </span></span><br></pre></td></tr></table></figure>

<p>创建一个新的Vector，方向与原方向一致</p>
<p>距离为</p>
<ol>
<li><p>若距离&lt;Min，则新的vector距离为Min</p>
</li>
<li><p>若距离&gt;Max，则新的vector距离为Max</p>
</li>
<li><p>若距离在Min和Max之间，则新的vector等于原本的vector</p>
</li>
</ol>
<h2 id="ConsumeInputVector-1-0f"><a href="#ConsumeInputVector-1-0f" class="headerlink" title="ConsumeInputVector(1.0f)"></a>ConsumeInputVector(1.0f)</h2><p>报告并清空用于存储移动输入的内置变量值。</p>
<h2 id="SafeMoveUpdatedComponent"><a href="#SafeMoveUpdatedComponent" class="headerlink" title="SafeMoveUpdatedComponent()"></a>SafeMoveUpdatedComponent()</h2><p><code>SafeMoveUpdatedComponent(const FVector&amp; Delta, const FRotator&amp; NewRotation, bool bSweep, FHitResult&amp; OutHit, ETeleportType Teleport)</code></p>
<p><code>SafeMoveUpdatedComponent(DesiredMovementThisFrame, UpdatedComponent-&gt;GetComponentRotation(), true, Hit);</code></p>
<p>利用虚幻引擎物理移动Pawn移动组件，同时考虑固体障碍。</p>
<ul>
<li><p>第一个参数：要移动的Vector</p>
</li>
<li><p>第二个参数：旋转参数</p>
</li>
<li><p>第三个参数：是否考虑物理障碍（如果为true，将在移动过程中扫描以阻止碰撞。如果为false，它将简单地传送到下一个位置并忽略碰撞。）</p>
</li>
<li><p>第四个参数：碰撞结果</p>
</li>
<li><p>第五个参数：可省略，远距离传送类型</p>
</li>
</ul>
<h2 id="SlideAlongSurface"><a href="#SlideAlongSurface" class="headerlink" title="SlideAlongSurface()"></a>SlideAlongSurface()</h2><p><code>SlideAlongSurface(const FVector&amp; Delta, float Time, const FQuat Rotation, const FVector&amp; Normal, FHitResult&amp; Hit, bool bHandleImpact)</code></p>
<ul>
<li><p>第一个参数：要移动的vector</p>
</li>
<li><p>第二个参数：运动时间</p>
</li>
<li><p>第三个参数：旋转情况（可省略）</p>
</li>
<li><p>第四个参数：vector类型？（这个不太确定）</p>
</li>
<li><p>第五个参数：碰撞结果（必须为bBlockingHit）</p>
</li>
<li><p>第六个参数：手柄反馈？（这个扎找不到源文件）</p>
</li>
</ul>
<h1 id="配置项目输入设置"><a href="#配置项目输入设置" class="headerlink" title="配置项目输入设置"></a>配置项目输入设置</h1><p>这里要注意的一点是，在给动作映射和轴映射命名的时候一定要和代码中定义的函数名相同否则无效。</p>
<ol>
<li><p>回到 <strong>虚幻编辑器</strong>，开始配置项目输入设置。可在 <strong>编辑</strong> 下拉菜单中的 <strong>项目设置</strong> 下找到相关设置。</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/Components/EditProjectSettings.jpg" alt="EditProjectSettings.png"></p>
<p>进入该菜单后，可在左侧面板中的 <strong>引擎</strong> 部分中选择 <strong>输入</strong>。同时需要设置粒子系统切换的 <strong>操作映射</strong> 、移动 <strong>Pawn</strong> 的两个 <strong>轴映射</strong>，和转动 <strong>Pawn</strong> 的一个 <strong>轴映射</strong>。</p>
<table>
<thead>
<tr>
<th>操作映射</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>ParticleToggle</td>
<td>空格</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>轴映射</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>MoveForward</td>
<td>W</td>
<td>1.0</td>
</tr>
<tr>
<td></td>
<td>S</td>
<td>-1.0</td>
</tr>
<tr>
<td>MoveRight</td>
<td>A</td>
<td>-1.0</td>
</tr>
<tr>
<td></td>
<td>D</td>
<td>1.0</td>
</tr>
<tr>
<td>Turn</td>
<td>Mouse X</td>
<td>1.0</td>
</tr>
</tbody></table>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/Components/InputSettings.jpg" alt="InputSettings.png"></p>
</li>
</ol>
<p>将创建 <strong>移动组件</strong> 管理移动，而非直接在Pawn类中处理所有移动。本教程中将扩展 <strong>Pawn移动组件</strong> 类。首先在 <strong>文件</strong> 下拉菜单中选择 <strong>将代码添加到项目（Add Code to Project）</strong> 命令。</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/Components/AddCPPCode.jpg" alt="AddCPPCode.png"></p>
<p>与Pawn类不同的，Pawn移动组件类默认为不可见。要找到该组件，需选中 <strong>显示所有类（Show All Classes）</strong> 选项。</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/Components/ShowAllClasses.jpg" alt="ShowAllClasses.png"></p>
<p>在搜索栏中输入”movement”，以便快速缩小列表范围。</p>
<p><img src="https://docs.unrealengine.com/4.27/Images/ProgrammingAndScripting/ProgrammingWithCPP/CPPTutorials/Components/ChooseParentClass2.jpg" alt="ChooseParentClass2.png"></p>
<p>Pawn移动组件拥有部分强大内置功能，以便使用常见物理功能，同时便于在大量Pawn类型间共享移动代码。使用组件分隔不同功能是上佳方法，可在项目增大、Pawn越加复杂时减少杂乱。</p>
<p>这里放一个来自于的<a target="_blank" rel="noopener" href="https://blog.csdn.net/heneyT" title="heneyT">heneyT</a>移动组件的继承树</p>
<p><img src="https://img-blog.csdn.net/20171130205337919?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjk5OTk4NQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/12/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><span class="page-number current">13</span><a class="page-number" href="/page/14/">14</a><a class="page-number" href="/page/15/">15</a><a class="extend next" rel="next" href="/page/14/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">williny</span>
</div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  





</body>
</html>
