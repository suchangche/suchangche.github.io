<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.1.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.0.0/css/all.min.css" integrity="sha256-jTIdiMuX/e3DGJUGwl3pKSxuc6YOuqtJYkM0bGQESA4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.10.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="孤独是人生的常态">
<meta property="og:type" content="website">
<meta property="og:title" content="Williny&#39;home">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Williny&#39;home">
<meta property="og:description" content="孤独是人生的常态">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="williny">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Williny'home</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Williny'home</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="williny"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">williny</p>
  <div class="site-description" itemprop="description">孤独是人生的常态</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">119</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/suchangche" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;suchangche" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:469478061@qq.com" title="E-Mail → mailto:469478061@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/09/17/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88%E4%B8%89%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="williny">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Williny'home">
      <meta itemprop="description" content="孤独是人生的常态">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Williny'home">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/09/17/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88%E4%B8%89%EF%BC%89/" class="post-title-link" itemprop="url">算法-二叉树（三）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-09-17 10:11:00 / 修改时间：11:41:29" itemprop="dateCreated datePublished" datetime="2022-09-17T10:11:00+08:00">2022-09-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="二叉搜索树中的众数"><a href="#二叉搜索树中的众数" class="headerlink" title="二叉搜索树中的众数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-mode-in-binary-search-tree/">二叉搜索树中的众数</a></h1><p>给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。</p>
<p>假定 BST 有如下定义：</p>
<ul>
<li>结点左子树中所含结点的值小于等于当前结点的值</li>
<li>结点右子树中所含结点的值大于等于当前结点的值</li>
<li>左子树和右子树都是二叉搜索树</li>
</ul>
<p>例如：</p>
<p>给定 BST [1,null,2,2],</p>
<p><img src="https://img-blog.csdnimg.cn/20201014221532206.png" alt="501. 二叉搜索树中的众数"></p>
<p>返回[2].</p>
<p>提示：如果众数超过1个，不需考虑输出顺序</p>
<p>进阶：你可以不使用额外的空间吗？（假设由递归产生的隐式调用栈的开销不被计算在内）</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题目呢，递归法我从两个维度来讲。</p>
<p>首先如果不是二叉搜索树的话，应该怎么解题，是二叉搜索树，又应该如何解题，两种方式做一个比较，可以加深大家对二叉树的理解。</p>
<h3 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h3><h4 id="如果不是二叉搜索树"><a href="#如果不是二叉搜索树" class="headerlink" title="如果不是二叉搜索树"></a>如果不是二叉搜索树</h4><p>如果不是二叉搜索树，最直观的方法一定是把这个树都遍历了，用map统计频率，把频率排个序，最后取前面高频的元素的集合。</p>
<p>具体步骤如下：</p>
<ol>
<li>这个树都遍历了，用map统计频率</li>
</ol>
<p>至于用前中后序那种遍历也不重要，因为就是要全遍历一遍，怎么个遍历法都行，层序遍历都没毛病！</p>
<p>这里采用前序遍历，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// map&lt;int, int&gt; key:元素，value:出现频率</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">searchBST</span><span class="params">(TreeNode* cur, unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; map)</span> </span>&#123; <span class="comment">// 前序遍历</span></span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    map[cur-&gt;val]++; <span class="comment">// 统计元素频率</span></span><br><span class="line">    <span class="built_in">searchBST</span>(cur-&gt;left, map);</span><br><span class="line">    <span class="built_in">searchBST</span>(cur-&gt;right, map);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>把统计的出来的出现频率（即map中的value）排个序</li>
</ol>
<p>有的同学可能可以想直接对map中的value排序，还真做不到，C++中如果使用std::map或者std::multimap可以对key排序，但不能对value排序。</p>
<p>所以要把map转化数组即vector，再进行排序，当然vector里面放的也是<code>pair&lt;int, int&gt;</code>类型的数据，第一个int为元素，第二个int为出现频率。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="type">static</span> <span class="title">cmp</span> <span class="params">(<span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; a, <span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.second &gt; b.second; <span class="comment">// 按照频率从大到小排序</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; <span class="built_in">vec</span>(map.<span class="built_in">begin</span>(), map.<span class="built_in">end</span>());</span><br><span class="line"><span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), cmp); <span class="comment">// 给频率排个序</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>取前面高频的元素</li>
</ol>
<p>此时数组vector中已经是存放着按照频率排好序的pair，那么把前面高频的元素取出来就可以了。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">result.<span class="built_in">push_back</span>(vec[<span class="number">0</span>].first);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; vec.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="comment">// 取最高的放到result数组中</span></span><br><span class="line">    <span class="keyword">if</span> (vec[i].second == vec[<span class="number">0</span>].second) result.<span class="built_in">push_back</span>(vec[i].first);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure>

<p>整体C++代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">searchBST</span><span class="params">(TreeNode* cur, unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; map)</span> </span>&#123; <span class="comment">// 前序遍历</span></span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    map[cur-&gt;val]++; <span class="comment">// 统计元素频率</span></span><br><span class="line">    <span class="built_in">searchBST</span>(cur-&gt;left, map);</span><br><span class="line">    <span class="built_in">searchBST</span>(cur-&gt;right, map);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="type">static</span> <span class="title">cmp</span> <span class="params">(<span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; a, <span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.second &gt; b.second;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findMode</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; map; <span class="comment">// key:元素，value:出现频率</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> result;</span><br><span class="line">        <span class="built_in">searchBST</span>(root, map);</span><br><span class="line">        vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; <span class="built_in">vec</span>(map.<span class="built_in">begin</span>(), map.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), cmp); <span class="comment">// 给频率排个序</span></span><br><span class="line">        result.<span class="built_in">push_back</span>(vec[<span class="number">0</span>].first);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; vec.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 取最高的放到result数组中</span></span><br><span class="line">            <span class="keyword">if</span> (vec[i].second == vec[<span class="number">0</span>].second) result.<span class="built_in">push_back</span>(vec[i].first);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="是二叉搜索树"><a href="#是二叉搜索树" class="headerlink" title="是二叉搜索树"></a>是二叉搜索树</h4><p><strong>既然是搜索树，它中序遍历就是有序的</strong>。</p>
<p>如图：</p>
<p><img src="https://img-blog.csdnimg.cn/20210204152758889.png" alt="501.二叉搜索树中的众数1"></p>
<p>中序遍历代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">searchBST</span><span class="params">(TreeNode* cur)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">searchBST</span>(cur-&gt;left);       <span class="comment">// 左</span></span><br><span class="line">    （处理节点）                <span class="comment">// 中</span></span><br><span class="line">    <span class="built_in">searchBST</span>(cur-&gt;right);      <span class="comment">// 右</span></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遍历有序数组的元素出现频率，从头遍历，那么一定是相邻两个元素作比较，然后就把出现频率最高的元素输出就可以了。</p>
<p>关键是在有序数组上的话，好搞，在树上怎么搞呢？</p>
<p>这就考察对树的操作了。</p>
<p>在<a target="_blank" rel="noopener" href="https://programmercarl.com/0530.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE.html">二叉树：搜索树的最小绝对差</a>中我们就使用了pre指针和cur指针的技巧，这次又用上了。</p>
<p>弄一个指针指向前一个节点，这样每次cur（当前节点）才能和pre（前一个节点）作比较。</p>
<p>而且初始化的时候pre &#x3D; NULL，这样当pre为NULL时候，我们就知道这是比较的第一个元素。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (pre == <span class="literal">NULL</span>) &#123; <span class="comment">// 第一个节点</span></span><br><span class="line">    count = <span class="number">1</span>; <span class="comment">// 频率为1</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pre-&gt;val == cur-&gt;val) &#123; <span class="comment">// 与前一个节点数值相同</span></span><br><span class="line">    count++;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 与前一个节点数值不同</span></span><br><span class="line">    count = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">pre = cur; <span class="comment">// 更新上一个节点</span></span><br></pre></td></tr></table></figure>

<p>此时又有问题了，因为要求最大频率的元素集合（注意是集合，不是一个元素，可以有多个众数），如果是数组上大家一般怎么办？</p>
<p>应该是先遍历一遍数组，找出最大频率（maxCount），然后再重新遍历一遍数组把出现频率为maxCount的元素放进集合。（因为众数有多个）</p>
<p>这种方式遍历了两遍数组。</p>
<p>那么我们遍历两遍二叉搜索树，把众数集合算出来也是可以的。</p>
<p>但这里其实只需要遍历一次就可以找到所有的众数。</p>
<p>那么如何只遍历一遍呢？</p>
<p>如果 频率count 等于 maxCount（最大频率），当然要把这个元素加入到结果集中（以下代码为result数组），代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (count == maxCount) &#123; <span class="comment">// 如果和最大值相同，放进result中</span></span><br><span class="line">    result.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>是不是感觉这里有问题，result怎么能轻易就把元素放进去了呢，万一，这个maxCount此时还不是真正最大频率呢。</p>
<p>所以下面要做如下操作：</p>
<p>频率count 大于 maxCount的时候，不仅要更新maxCount，而且要清空结果集（以下代码为result数组），因为结果集之前的元素都失效了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (count &gt; maxCount) &#123; <span class="comment">// 如果计数大于最大值</span></span><br><span class="line">    maxCount = count;   <span class="comment">// 更新最大频率</span></span><br><span class="line">    result.<span class="built_in">clear</span>();     <span class="comment">// 很关键的一步，不要忘记清空result，之前result里的元素都失效了</span></span><br><span class="line">    result.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关键代码都讲完了，完整代码如下：（<strong>只需要遍历一遍二叉搜索树，就求出了众数的集合</strong>）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> maxCount; <span class="comment">// 最大频率</span></span><br><span class="line">    <span class="type">int</span> count; <span class="comment">// 统计频率</span></span><br><span class="line">    TreeNode* pre;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">searchBST</span><span class="params">(TreeNode* cur)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">searchBST</span>(cur-&gt;left);       <span class="comment">// 左</span></span><br><span class="line">                                    <span class="comment">// 中</span></span><br><span class="line">        <span class="keyword">if</span> (pre == <span class="literal">NULL</span>) &#123; <span class="comment">// 第一个节点</span></span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pre-&gt;val == cur-&gt;val) &#123; <span class="comment">// 与前一个节点数值相同</span></span><br><span class="line">            count++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 与前一个节点数值不同</span></span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = cur; <span class="comment">// 更新上一个节点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (count == maxCount) &#123; <span class="comment">// 如果和最大值相同，放进result中</span></span><br><span class="line">            result.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (count &gt; maxCount) &#123; <span class="comment">// 如果计数大于最大值频率</span></span><br><span class="line">            maxCount = count;   <span class="comment">// 更新最大频率</span></span><br><span class="line">            result.<span class="built_in">clear</span>();     <span class="comment">// 很关键的一步，不要忘记清空result，之前result里的元素都失效了</span></span><br><span class="line">            result.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">searchBST</span>(cur-&gt;right);      <span class="comment">// 右</span></span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findMode</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        maxCount = <span class="number">0</span>;</span><br><span class="line">        TreeNode* pre = <span class="literal">NULL</span>; <span class="comment">// 记录前一个节点</span></span><br><span class="line">        result.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">searchBST</span>(root);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h3><p>只要把中序遍历转成迭代，中间节点的处理逻辑完全一样。</p>
<p>下面我给出其中的一种中序遍历的迭代法，其中间处理逻辑一点都没有变（我从递归法直接粘过来的代码，连注释都没改，哈哈）</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findMode</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line">        TreeNode* pre = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="type">int</span> maxCount = <span class="number">0</span>; <span class="comment">// 最大频率</span></span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>; <span class="comment">// 统计频率</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">NULL</span> || !st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur != <span class="literal">NULL</span>) &#123; <span class="comment">// 指针来访问节点，访问到最底层</span></span><br><span class="line">                st.<span class="built_in">push</span>(cur); <span class="comment">// 将访问的节点放进栈</span></span><br><span class="line">                cur = cur-&gt;left;                <span class="comment">// 左</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();                       <span class="comment">// 中</span></span><br><span class="line">                <span class="keyword">if</span> (pre == <span class="literal">NULL</span>) &#123; <span class="comment">// 第一个节点</span></span><br><span class="line">                    count = <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pre-&gt;val == cur-&gt;val) &#123; <span class="comment">// 与前一个节点数值相同</span></span><br><span class="line">                    count++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 与前一个节点数值不同</span></span><br><span class="line">                    count = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (count == maxCount) &#123; <span class="comment">// 如果和最大值相同，放进result中</span></span><br><span class="line">                    result.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (count &gt; maxCount) &#123; <span class="comment">// 如果计数大于最大值频率</span></span><br><span class="line">                    maxCount = count;   <span class="comment">// 更新最大频率</span></span><br><span class="line">                    result.<span class="built_in">clear</span>();     <span class="comment">// 很关键的一步，不要忘记清空result，之前result里的元素都失效了</span></span><br><span class="line">                    result.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">                &#125;</span><br><span class="line">                pre = cur;</span><br><span class="line">                cur = cur-&gt;right;               <span class="comment">// 右</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="二叉树的最近公共祖先"><a href="#二叉树的最近公共祖先" class="headerlink" title="二叉树的最近公共祖先"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">二叉树的最近公共祖先</a></h1><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
<p>例如，给定如下二叉树:  root &#x3D; [3,5,1,6,2,0,8,null,null,7,4]</p>
<p><img src="https://img-blog.csdnimg.cn/20201016173414722.png" alt="236. 二叉树的最近公共祖先"></p>
<p>示例 1: 输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 1 输出: 3 解释: 节点 5 和节点 1 的最近公共祖先是节点 3。</p>
<p>示例 2: 输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 4 输出: 5 解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。</p>
<p>说明:</p>
<ul>
<li>所有节点的值都是唯一的。</li>
<li>p、q 为不同节点且均存在于给定的二叉树中。</li>
</ul>
<h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>遇到这个题目首先想的是要是能自底向上查找就好了，这样就可以找到公共祖先了。</p>
<p>那么二叉树如何可以自底向上查找呢？</p>
<p>回溯啊，二叉树回溯的过程就是从低到上。</p>
<p>后序遍历就是天然的回溯过程，最先处理的一定是叶子节点。</p>
<p>接下来就看如何判断一个节点是节点q和节点p的公共公共祖先呢。</p>
<p><strong>首先最容易想到的一个情况：如果找到一个节点，发现左子树出现结点p，右子树出现节点q，或者 左子树出现结点q，右子树出现节点p，那么该节点就是节点p和q的最近公共祖先。</strong></p>
<p><strong>但是很多人容易忽略一个情况，就是节点本身p(q)，它拥有一个子孙节点q(p)。</strong></p>
<p>使用后序遍历，回溯的过程，就是从低向上遍历节点，一旦发现满足第一种情况的节点，就是最近公共节点了。</p>
<p><strong>但是如果p或者q本身就是最近公共祖先呢？其实只需要找到一个节点是p或者q的时候，直接返回当前节点，无需继续递归子树。如果接下来的遍历中找到了后继节点满足第一种情况则修改返回值为后继节点，否则，继续返回已找到的节点即可。为什么满足第一种情况的节点一定是p或q的后继节点呢?大家可以仔细思考一下。</strong></p>
<p>递归三部曲：</p>
<ul>
<li>确定递归函数返回值以及参数</li>
</ul>
<p>需要递归函数返回值，来告诉我们是否找到节点q或者p，那么返回值为bool类型就可以了。</p>
<p>但我们还要返回最近公共节点，可以利用上题目中返回值是TreeNode * ，那么如果遇到p或者q，就把q或者p返回，返回值不为空，就说明找到了q或者p。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>确定终止条件</li>
</ul>
<p>如果找到了 节点p或者q，或者遇到空节点，就返回。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (root == q || root == p || root == <span class="literal">NULL</span>) <span class="keyword">return</span> root;</span><br></pre></td></tr></table></figure>

<ul>
<li>确定单层递归逻辑</li>
</ul>
<p>值得注意的是 本题函数有返回值，是因为回溯的过程需要递归函数的返回值做判断，但本题我们依然要遍历树的所有节点。</p>
<p>我们在<a target="_blank" rel="noopener" href="https://programmercarl.com/0112.%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C.html">二叉树：递归函数究竟什么时候需要返回值，什么时候不要返回值？</a>中说了 递归函数有返回值就是要遍历某一条边，但有返回值也要看如何处理返回值！</p>
<p>如果递归函数有返回值，如何区分要搜索一条边，还是搜索整个树呢？</p>
<p>搜索一条边的写法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (递归函数(root-&gt;left)) <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (递归函数(root-&gt;right)) <span class="keyword">return</span> ;</span><br></pre></td></tr></table></figure>

<p>搜索整个树写法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">left = 递归函数(root-&gt;left);</span><br><span class="line">right = 递归函数(root-&gt;right);</span><br><span class="line">left与right的逻辑处理;</span><br></pre></td></tr></table></figure>

<p>看出区别了没？</p>
<p><strong>在递归函数有返回值的情况下：如果要搜索一条边，递归函数返回值不为空的时候，立刻返回，如果搜索整个树，直接用一个变量left、right接住返回值，这个left、right后序还有逻辑处理的需要，也就是后序遍历中处理中间节点的逻辑（也是回溯）</strong>。</p>
<p>那么为什么要遍历整棵树呢？直观上来看，找到最近公共祖先，直接一路返回就可以了。</p>
<p>如图：</p>
<p><img src="https://img-blog.csdnimg.cn/2021020415105872.png" alt="236.二叉树的最近公共祖先"></p>
<p>就像图中一样直接返回7，多美滋滋。</p>
<p>但事实上还要遍历根节点右子树（即使此时已经找到了目标节点了），也就是图中的节点4、15、20。</p>
<p>因为在如下代码的后序遍历中，如果想利用left和right做逻辑处理， 不能立刻返回，而是要等left与right逻辑处理完之后才能返回。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">left = 递归函数(root-&gt;left);</span><br><span class="line">right = 递归函数(root-&gt;right);</span><br><span class="line">left与right的逻辑处理;</span><br></pre></td></tr></table></figure>

<p>所以此时大家要知道我们要遍历整棵树。知道这一点，对本题就有一定深度的理解了。</p>
<p>那么先用left和right接住左子树和右子树的返回值，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* left = <span class="built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);</span><br><span class="line">TreeNode* right = <span class="built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);</span><br></pre></td></tr></table></figure>

<p><strong>如果left 和 right都不为空，说明此时root就是最近公共节点。这个比较好理解</strong></p>
<p><strong>如果left为空，right不为空，就返回right，说明目标节点是通过right返回的，反之依然</strong>。</p>
<p>这里有的同学就理解不了了，为什么left为空，right不为空，目标节点通过right返回呢？</p>
<p>如图：</p>
<p><img src="https://img-blog.csdnimg.cn/20210204151125844.png" alt="236.二叉树的最近公共祖先1"></p>
<p>图中节点10的左子树返回null，右子树返回目标值7，那么此时节点10的处理逻辑就是把右子树的返回值（最近公共祖先7）返回上去！</p>
<p>这里点也很重要，可能刷过这道题目的同学，都不清楚结果究竟是如何从底层一层一层传到头结点的。</p>
<p>那么如果left和right都为空，则返回left或者right都是可以的，也就是返回空。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (left == <span class="literal">NULL</span> &amp;&amp; right != <span class="literal">NULL</span>) <span class="keyword">return</span> right;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (left != <span class="literal">NULL</span> &amp;&amp; right == <span class="literal">NULL</span>) <span class="keyword">return</span> left;</span><br><span class="line"><span class="keyword">else</span>  &#123; <span class="comment">//  (left == NULL &amp;&amp; right == NULL)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么寻找最小公共祖先，完整流程图如下：</p>
<p><img src="https://img-blog.csdnimg.cn/202102041512582.png" alt="236.二叉树的最近公共祖先2"></p>
<p><strong>从图中，大家可以看到，我们是如何回溯遍历整棵二叉树，将结果返回给头结点的！</strong></p>
<p>整体代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == q || root == p || root == <span class="literal">NULL</span>) <span class="keyword">return</span> root;</span><br><span class="line">        TreeNode* left = <span class="built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);</span><br><span class="line">        TreeNode* right = <span class="built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);</span><br><span class="line">        <span class="keyword">if</span> (left != <span class="literal">NULL</span> &amp;&amp; right != <span class="literal">NULL</span>) <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left == <span class="literal">NULL</span> &amp;&amp; right != <span class="literal">NULL</span>) <span class="keyword">return</span> right;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left != <span class="literal">NULL</span> &amp;&amp; right == <span class="literal">NULL</span>) <span class="keyword">return</span> left;</span><br><span class="line">        <span class="keyword">else</span>  &#123; <span class="comment">//  (left == NULL &amp;&amp; right == NULL)</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>稍加精简，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == q || root == p || root == <span class="literal">NULL</span>) <span class="keyword">return</span> root;</span><br><span class="line">        TreeNode* left = <span class="built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);</span><br><span class="line">        TreeNode* right = <span class="built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);</span><br><span class="line">        <span class="keyword">if</span> (left != <span class="literal">NULL</span> &amp;&amp; right != <span class="literal">NULL</span>) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="literal">NULL</span>) <span class="keyword">return</span> right;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这道题目刷过的同学未必真正了解这里面回溯的过程，以及结果是如何一层一层传上去的。</p>
<p><strong>那么我给大家归纳如下三点</strong>：</p>
<ol>
<li><p>求最小公共祖先，需要从底向上遍历，那么二叉树，只能通过后序遍历（即：回溯）实现从低向上的遍历方式。</p>
</li>
<li><p>在回溯的过程中，必然要遍历整棵二叉树，即使已经找到结果了，依然要把其他节点遍历完，因为要使用递归函数的返回值（也就是代码中的left和right）做逻辑判断。</p>
</li>
<li><p>要理解如果返回值left为空，right不为空为什么要返回right，为什么可以用返回right传给上一层结果。</p>
</li>
</ol>
<p>可以说这里每一步，都是有难度的，都需要对二叉树，递归和回溯有一定的理解。</p>
<p>本题没有给出迭代法，因为迭代法不适合模拟回溯的过程。理解递归的解法就够了。</p>
<h1 id="二叉搜索树的最近公共祖先"><a href="#二叉搜索树的最近公共祖先" class="headerlink" title="二叉搜索树的最近公共祖先"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/">二叉搜索树的最近公共祖先</a></h1><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
<p>例如，给定如下二叉搜索树:  root &#x3D; [6,2,8,0,4,7,9,null,null,3,5]</p>
<p><img src="https://img-blog.csdnimg.cn/20201018172243602.png" alt="235. 二叉搜索树的最近公共祖先"></p>
<p>示例 1:</p>
<ul>
<li>输入: root &#x3D; [6,2,8,0,4,7,9,null,null,3,5], p &#x3D; 2, q &#x3D; 8</li>
<li>输出: 6</li>
<li>解释: 节点 2 和节点 8 的最近公共祖先是 6。</li>
</ul>
<p>示例 2:</p>
<ul>
<li>输入: root &#x3D; [6,2,8,0,4,7,9,null,null,3,5], p &#x3D; 2, q &#x3D; 4</li>
<li>输出: 2</li>
<li>解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。</li>
</ul>
<p>说明:</p>
<ul>
<li>所有节点的值都是唯一的。</li>
<li>p、q 为不同节点且均存在于给定的二叉搜索树中。</li>
</ul>
<h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>做过<a target="_blank" rel="noopener" href="https://programmercarl.com/0236.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html">二叉树：公共祖先问题</a>的同学应该知道，利用回溯从底向上搜索，遇到一个节点的左子树里有p，右子树里有q，那么当前节点就是最近公共祖先。</p>
<p>那么本题是二叉搜索树，二叉搜索树是有序的，那得好好利用一下这个特点。</p>
<p>在有序树里，如果判断一个节点的左子树里有p，右子树里有q呢？</p>
<p>其实只要从上到下遍历的时候，cur节点是数值在[p, q]区间中则说明该节点cur就是最近公共祖先了。</p>
<p>理解这一点，本题就很好解了。</p>
<p>和<a target="_blank" rel="noopener" href="https://programmercarl.com/0236.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html">二叉树：公共祖先问题</a>不同，普通二叉树求最近公共祖先需要使用回溯，从底向上来查找，二叉搜索树就不用了，因为搜索树有序（相当于自带方向），那么只要从上向下遍历就可以了。</p>
<p>那么我们可以采用前序遍历（其实这里没有中节点的处理逻辑，遍历顺序无所谓了）。</p>
<p>如图所示：p为节点3，q为节点5</p>
<p><img src="https://img-blog.csdnimg.cn/20210204150858927.png" alt="235.二叉搜索树的最近公共祖先"></p>
<p>可以看出直接按照指定的方向，就可以找到节点4，为最近公共祖先，而且不需要遍历整棵树，找到结果直接返回！</p>
<h3 id="递归法-1"><a href="#递归法-1" class="headerlink" title="递归法"></a>递归法</h3><p>递归三部曲如下：</p>
<ul>
<li>确定递归函数返回值以及参数</li>
</ul>
<p>参数就是当前节点，以及两个结点 p、q。</p>
<p>返回值是要返回最近公共祖先，所以是TreeNode * 。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">traversal</span><span class="params">(TreeNode* cur, TreeNode* p, TreeNode* q)</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>确定终止条件</li>
</ul>
<p>遇到空返回就可以了，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span> cur;</span><br></pre></td></tr></table></figure>

<p>其实都不需要这个终止条件，因为题目中说了p、q 为不同节点且均存在于给定的二叉搜索树中。也就是说一定会找到公共祖先的，所以并不存在遇到空的情况。</p>
<ul>
<li>确定单层递归的逻辑</li>
</ul>
<p>在遍历二叉搜索树的时候就是寻找区间[p-&gt;val, q-&gt;val]（注意这里是左闭又闭）</p>
<p>那么如果 cur-&gt;val 大于 p-&gt;val，同时 cur-&gt;val 大于q-&gt;val，那么就应该向左遍历（说明目标区间在左子树上）。</p>
<p><strong>需要注意的是此时不知道p和q谁大，所以两个都要判断</strong></p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (cur-&gt;val &gt; p-&gt;val &amp;&amp; cur-&gt;val &gt; q-&gt;val) &#123;</span><br><span class="line">    TreeNode* left = <span class="built_in">traversal</span>(cur-&gt;left, p, q);</span><br><span class="line">    <span class="keyword">if</span> (left != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>细心的同学会发现，在这里调用递归函数的地方，把递归函数的返回值left，直接return</strong>。</p>
<p>在<a target="_blank" rel="noopener" href="https://programmercarl.com/0236.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html">二叉树：公共祖先问题</a>中，如果递归函数有返回值，如何区分要搜索一条边，还是搜索整个树。</p>
<p>搜索一条边的写法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (递归函数(root-&gt;left)) <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">if</span> (递归函数(root-&gt;right)) <span class="keyword">return</span> ;</span><br></pre></td></tr></table></figure>

<p>搜索整个树写法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">left = 递归函数(root-&gt;left);</span><br><span class="line">right = 递归函数(root-&gt;right);</span><br><span class="line">left与right的逻辑处理;</span><br></pre></td></tr></table></figure>

<p>本题就是标准的搜索一条边的写法，遇到递归函数的返回值，如果不为空，立刻返回。</p>
<p>如果 cur-&gt;val 小于 p-&gt;val，同时 cur-&gt;val 小于 q-&gt;val，那么就应该向右遍历（目标区间在右子树）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (cur-&gt;val &lt; p-&gt;val &amp;&amp; cur-&gt;val &lt; q-&gt;val) &#123;</span><br><span class="line">    TreeNode* right = <span class="built_in">traversal</span>(cur-&gt;right, p, q);</span><br><span class="line">    <span class="keyword">if</span> (right != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>剩下的情况，就是cur节点在区间（p-&gt;val &lt;&#x3D; cur-&gt;val &amp;&amp; cur-&gt;val &lt;&#x3D; q-&gt;val）或者 （q-&gt;val &lt;&#x3D; cur-&gt;val &amp;&amp; cur-&gt;val &lt;&#x3D; p-&gt;val）中，那么cur就是最近公共祖先了，直接返回cur。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> cur;</span><br></pre></td></tr></table></figure>

<p>那么整体递归代码如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">traversal</span><span class="params">(TreeNode* cur, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span> cur;</span><br><span class="line">                                                        <span class="comment">// 中</span></span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;val &gt; p-&gt;val &amp;&amp; cur-&gt;val &gt; q-&gt;val) &#123;   <span class="comment">// 左</span></span><br><span class="line">            TreeNode* left = <span class="built_in">traversal</span>(cur-&gt;left, p, q);</span><br><span class="line">            <span class="keyword">if</span> (left != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;val &lt; p-&gt;val &amp;&amp; cur-&gt;val &lt; q-&gt;val) &#123;   <span class="comment">// 右</span></span><br><span class="line">            TreeNode* right = <span class="built_in">traversal</span>(cur-&gt;right, p, q);</span><br><span class="line">            <span class="keyword">if</span> (right != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">traversal</span>(root, p, q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="迭代法-1"><a href="#迭代法-1" class="headerlink" title="迭代法"></a>迭代法</h3><p>对于二叉搜索树的迭代法，大家应该在<a target="_blank" rel="noopener" href="https://programmercarl.com/0700.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2.html">二叉树：二叉搜索树登场！</a>就了解了。</p>
<p>利用其有序性，迭代的方式还是比较简单的，解题思路在递归中已经分析了。</p>
<p>迭代代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(root) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;val &gt; p-&gt;val &amp;&amp; root-&gt;val &gt; q-&gt;val) &#123;</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;val &lt; p-&gt;val &amp;&amp; root-&gt;val &lt; q-&gt;val) &#123;</span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="二叉搜索树中的插入操作"><a href="#二叉搜索树中的插入操作" class="headerlink" title="二叉搜索树中的插入操作"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/">二叉搜索树中的插入操作</a></h1><p>给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据保证，新值和原始二叉搜索树中的任意节点值都不同。</p>
<p>注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回任意有效的结果。</p>
<p><img src="https://img-blog.csdnimg.cn/20201019173259554.png" alt="701.二叉搜索树中的插入操作"></p>
<p>提示：</p>
<ul>
<li>给定的树上的节点数介于 0 和 10^4 之间</li>
<li>每个节点都有一个唯一整数值，取值范围从 0 到 10^8</li>
<li>-10^8 &lt;&#x3D; val &lt;&#x3D; 10^8</li>
<li>新值和原始二叉搜索树中的任意节点值都不同</li>
</ul>
<h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>其实这道题目其实是一道简单题目，<strong>但是题目中的提示：有多种有效的插入方式，还可以重构二叉搜索树，一下子吓退了不少人</strong>，瞬间感觉题目复杂了很多。</p>
<p>其实<strong>可以不考虑题目中提示所说的改变树的结构的插入方式。</strong></p>
<p>如下演示视频中可以看出：只要按照二叉搜索树的规则去遍历，遇到空节点就插入节点就可以了。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gnbk63ina5g30eo08waja.gif" alt="701.二叉搜索树中的插入操作"></p>
<p>例如插入元素10 ，需要找到末尾节点插入便可，一样的道理来插入元素15，插入元素0，插入元素6，<strong>需要调整二叉树的结构么？ 并不需要。</strong>。</p>
<p>只要遍历二叉搜索树，找到空节点 插入元素就可以了，那么这道题其实就简单了。</p>
<p>接下来就是遍历二叉搜索树的过程了。</p>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>递归三部曲：</p>
<ul>
<li>确定递归函数参数以及返回值</li>
</ul>
<p>参数就是根节点指针，以及要插入元素，这里递归函数要不要有返回值呢？</p>
<p>可以有，也可以没有，但递归函数如果没有返回值的话，实现是比较麻烦的，下面也会给出其具体实现代码。</p>
<p><strong>有返回值的话，可以利用返回值完成新加入的节点与其父节点的赋值操作</strong>。（下面会进一步解释）</p>
<p>递归函数的返回类型为节点类型TreeNode * 。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">insertIntoBST</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>确定终止条件</li>
</ul>
<p>终止条件就是找到遍历的节点为null的时候，就是要插入节点的位置了，并把插入的节点返回。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    TreeNode* node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里把添加的节点返回给上一层，就完成了父子节点的赋值操作了，详细再往下看。</p>
<ul>
<li>确定单层递归的逻辑</li>
</ul>
<p>此时要明确，需要遍历整棵树么？</p>
<p>别忘了这是搜索树，遍历整棵搜索树简直是对搜索树的侮辱，哈哈。</p>
<p>搜索树是有方向了，可以根据插入元素的数值，决定递归方向。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (root-&gt;val &gt; val) root-&gt;left = <span class="built_in">insertIntoBST</span>(root-&gt;left, val);</span><br><span class="line"><span class="keyword">if</span> (root-&gt;val &lt; val) root-&gt;right = <span class="built_in">insertIntoBST</span>(root-&gt;right, val);</span><br><span class="line"><span class="keyword">return</span> root;</span><br></pre></td></tr></table></figure>

<p><strong>到这里，大家应该能感受到，如何通过递归函数返回值完成了新加入节点的父子关系赋值操作了，下一层将加入节点返回，本层用root-&gt;left或者root-&gt;right将其接住</strong>。</p>
<p>整体代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">insertIntoBST</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            TreeNode* node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &gt; val) root-&gt;left = <span class="built_in">insertIntoBST</span>(root-&gt;left, val);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &lt; val) root-&gt;right = <span class="built_in">insertIntoBST</span>(root-&gt;right, val);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看出代码并不复杂。</p>
<p>刚刚说了递归函数不用返回值也可以，找到插入的节点位置，直接让其父节点指向插入节点，结束递归，也是可以的。</p>
<p>那么递归函数定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* parent; <span class="comment">// 记录遍历节点的父节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur, <span class="type">int</span> val)</span></span></span><br></pre></td></tr></table></figure>

<p>没有返回值，需要记录上一个节点（parent），遇到空节点了，就让parent左孩子或者右孩子指向新插入的节点。然后结束递归。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TreeNode* parent;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            TreeNode* node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">            <span class="keyword">if</span> (val &gt; parent-&gt;val) parent-&gt;right = node;</span><br><span class="line">            <span class="keyword">else</span> parent-&gt;left = node;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        parent = cur;</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;val &gt; val) <span class="built_in">traversal</span>(cur-&gt;left, val);</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;val &lt; val) <span class="built_in">traversal</span>(cur-&gt;right, val);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">insertIntoBST</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">traversal</span>(root, val);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看出还是麻烦一些的。</p>
<p>我之所以举这个例子，是想说明通过递归函数的返回值完成父子节点的赋值是可以带来便利的。</p>
<p><strong>网上千变一律的代码，可能会误导大家认为通过递归函数返回节点 这样的写法是天经地义，其实这里是有优化的！</strong></p>
<h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p>再来看看迭代法，对二叉搜索树迭代写法不熟悉，可以看这篇：<a target="_blank" rel="noopener" href="https://programmercarl.com/0700.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2.html">二叉树：二叉搜索树登场！</a></p>
<p>在迭代法遍历的过程中，需要记录一下当前遍历的节点的父节点，这样才能做插入节点的操作。</p>
<p>在<a target="_blank" rel="noopener" href="https://programmercarl.com/0530.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE.html">二叉树：搜索树的最小绝对差</a>和<a target="_blank" rel="noopener" href="https://programmercarl.com/0501.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%97%E6%95%B0.html">二叉树：我的众数是多少？</a>中，都是用了记录pre和cur两个指针的技巧，本题也是一样的。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">insertIntoBST</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            TreeNode* node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line">        TreeNode* parent = root; <span class="comment">// 这个很重要，需要记录上一个节点，否则无法赋值新节点</span></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            parent = cur;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;val &gt; val) cur = cur-&gt;left;</span><br><span class="line">            <span class="keyword">else</span> cur = cur-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">        <span class="keyword">if</span> (val &lt; parent-&gt;val) parent-&gt;left = node;<span class="comment">// 此时是用parent节点的进行赋值</span></span><br><span class="line">        <span class="keyword">else</span> parent-&gt;right = node;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="删除二叉搜索树中的节点"><a href="#删除二叉搜索树中的节点" class="headerlink" title="删除二叉搜索树中的节点"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/delete-node-in-a-bst/">删除二叉搜索树中的节点</a></h1><p>给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p>
<p>一般来说，删除节点可分为两个步骤：</p>
<p>首先找到需要删除的节点； 如果找到了，删除它。 说明： 要求算法时间复杂度为 $O(h)$，h 为树的高度。</p>
<p>示例:</p>
<p><img src="https://img-blog.csdnimg.cn/20201020171048265.png" alt="450.删除二叉搜索树中的节点"></p>
<h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>搜索树的节点删除要比节点增加复杂的多，有很多情况需要考虑，做好心里准备。</p>
<h3 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h3><p>递归三部曲：</p>
<ul>
<li>确定递归函数参数以及返回值</li>
</ul>
<p>说道递归函数的返回值，在<a target="_blank" rel="noopener" href="https://programmercarl.com/0701.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C.html">二叉树：搜索树中的插入操作</a>中通过递归返回值来加入新节点， 这里也可以通过递归返回值删除节点。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">deleteNode</span><span class="params">(TreeNode* root, <span class="type">int</span> key)</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>确定终止条件</li>
</ul>
<p>遇到空返回，其实这也说明没找到删除的节点，遍历到空节点直接返回了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> root;</span><br></pre></td></tr></table></figure>

<ul>
<li>确定单层递归的逻辑</li>
</ul>
<p>这里就把二叉搜索树中删除节点遇到的情况都搞清楚。</p>
<p>有以下五种情况：</p>
<ul>
<li>第一种情况：没找到删除的节点，遍历到空节点直接返回了</li>
<li>找到删除的节点<ul>
<li>第二种情况：左右孩子都为空（叶子节点），直接删除节点， 返回NULL为根节点</li>
<li>第三种情况：删除节点的左孩子为空，右孩子不为空，删除节点，右孩子补位，返回右孩子为根节点</li>
<li>第四种情况：删除节点的右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子为根节点</li>
<li>第五种情况：左右孩子节点都不为空，则将删除节点的左子树头结点（左孩子）放到删除节点的右子树的最左面节点的左孩子上，返回删除节点右孩子为新的根节点。</li>
</ul>
</li>
</ul>
<p>第五种情况有点难以理解，看下面动画：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gnbj3k596mg30dq0aigyz.gif" alt="450.删除二叉搜索树中的节点"></p>
<p>动画中棵二叉搜索树中，删除元素7， 那么删除节点（元素7）的左孩子就是5，删除节点（元素7）的右子树的最左面节点是元素8。</p>
<p>将删除节点（元素7）的左孩子放到删除节点（元素7）的右子树的最左面节点（元素8）的左孩子上，就是把5为根节点的子树移到了8的左孩子的位置。</p>
<p>要删除的节点（元素7）的右孩子（元素9）为新的根节点。.</p>
<p>这样就完成删除元素7的逻辑，最好动手画一个图，尝试删除一个节点试试。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (root-&gt;val == key) &#123;</span><br><span class="line">    <span class="comment">// 第二种情况：左右孩子都为空（叶子节点），直接删除节点， 返回NULL为根节点</span></span><br><span class="line">    <span class="comment">// 第三种情况：其左孩子为空，右孩子不为空，删除节点，右孩子补位 ，返回右孩子为根节点</span></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left == <span class="literal">nullptr</span>) <span class="keyword">return</span> root-&gt;right;</span><br><span class="line">    <span class="comment">// 第四种情况：其右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子为根节点</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;right == <span class="literal">nullptr</span>) <span class="keyword">return</span> root-&gt;left;</span><br><span class="line">    <span class="comment">// 第五种情况：左右孩子节点都不为空，则将删除节点的左子树放到删除节点的右子树的最左面节点的左孩子的位置</span></span><br><span class="line">    <span class="comment">// 并返回删除节点右孩子为新的根节点。</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        TreeNode* cur = root-&gt;right; <span class="comment">// 找右子树最左面的节点</span></span><br><span class="line">        <span class="keyword">while</span>(cur-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            cur = cur-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;left = root-&gt;left; <span class="comment">// 把要删除的节点（root）左子树放在cur的左孩子的位置</span></span><br><span class="line">        TreeNode* tmp = root;   <span class="comment">// 把root节点保存一下，下面来删除</span></span><br><span class="line">        root = root-&gt;right;     <span class="comment">// 返回旧root的右孩子作为新root</span></span><br><span class="line">        <span class="keyword">delete</span> tmp;             <span class="comment">// 释放节点内存（这里不写也可以，但C++最好手动释放一下吧）</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里相当于把新的节点返回给上一层，上一层就要用 root-&gt;left 或者 root-&gt;right接住，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (root-&gt;val &gt; key) root-&gt;left = <span class="built_in">deleteNode</span>(root-&gt;left, key);</span><br><span class="line"><span class="keyword">if</span> (root-&gt;val &lt; key) root-&gt;right = <span class="built_in">deleteNode</span>(root-&gt;right, key);</span><br><span class="line"><span class="keyword">return</span> root;</span><br></pre></td></tr></table></figure>

<p><strong>整体代码如下：（注释中：情况1，2，3，4，5和上面分析严格对应）</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">deleteNode</span><span class="params">(TreeNode* root, <span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> root; <span class="comment">// 第一种情况：没找到删除的节点，遍历到空节点直接返回了</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val == key) &#123;</span><br><span class="line">            <span class="comment">// 第二种情况：左右孩子都为空（叶子节点），直接删除节点， 返回NULL为根节点</span></span><br><span class="line">            <span class="keyword">if</span> (root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="comment">///! 内存释放</span></span><br><span class="line">                <span class="keyword">delete</span> root;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 第三种情况：其左孩子为空，右孩子不为空，删除节点，右孩子补位 ，返回右孩子为根节点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;left == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">auto</span> retNode = root-&gt;right;</span><br><span class="line">                <span class="comment">///! 内存释放</span></span><br><span class="line">                <span class="keyword">delete</span> root;</span><br><span class="line">                <span class="keyword">return</span> retNode;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 第四种情况：其右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子为根节点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">auto</span> retNode = root-&gt;left;</span><br><span class="line">                <span class="comment">///! 内存释放</span></span><br><span class="line">                <span class="keyword">delete</span> root;</span><br><span class="line">                <span class="keyword">return</span> retNode;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 第五种情况：左右孩子节点都不为空，则将删除节点的左子树放到删除节点的右子树的最左面节点的左孩子的位置</span></span><br><span class="line">            <span class="comment">// 并返回删除节点右孩子为新的根节点。</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                TreeNode* cur = root-&gt;right; <span class="comment">// 找右子树最左面的节点</span></span><br><span class="line">                <span class="keyword">while</span>(cur-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    cur = cur-&gt;left;</span><br><span class="line">                &#125;</span><br><span class="line">                cur-&gt;left = root-&gt;left; <span class="comment">// 把要删除的节点（root）左子树放在cur的左孩子的位置</span></span><br><span class="line">                TreeNode* tmp = root;   <span class="comment">// 把root节点保存一下，下面来删除</span></span><br><span class="line">                root = root-&gt;right;     <span class="comment">// 返回旧root的右孩子作为新root</span></span><br><span class="line">                <span class="keyword">delete</span> tmp;             <span class="comment">// 释放节点内存（这里不写也可以，但C++最好手动释放一下吧）</span></span><br><span class="line">                <span class="keyword">return</span> root;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &gt; key) root-&gt;left = <span class="built_in">deleteNode</span>(root-&gt;left, key);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &lt; key) root-&gt;right = <span class="built_in">deleteNode</span>(root-&gt;right, key);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="普通二叉树的删除方式"><a href="#普通二叉树的删除方式" class="headerlink" title="普通二叉树的删除方式"></a>普通二叉树的删除方式</h3><p>这里我在介绍一种通用的删除，普通二叉树的删除方式（没有使用搜索树的特性，遍历整棵树），用交换值的操作来删除目标节点。</p>
<p>代码中目标节点（要删除的节点）被操作了两次：</p>
<ul>
<li>第一次是和目标节点的右子树最左面节点交换。</li>
<li>第二次直接被NULL覆盖了。</li>
</ul>
<p>思路有点绕，感兴趣的同学可以画图自己理解一下。</p>
<p>代码如下：（关键部分已经注释）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">deleteNode</span><span class="params">(TreeNode* root, <span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val == key) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;right == <span class="literal">nullptr</span>) &#123; <span class="comment">// 这里第二次操作目标值：最终删除的作用</span></span><br><span class="line">                <span class="keyword">return</span> root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            TreeNode *cur = root-&gt;right;</span><br><span class="line">            <span class="keyword">while</span> (cur-&gt;left) &#123;</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">swap</span>(root-&gt;val, cur-&gt;val); <span class="comment">// 这里第一次操作目标值：交换目标值其右子树最左面节点。</span></span><br><span class="line">        &#125;</span><br><span class="line">        root-&gt;left = <span class="built_in">deleteNode</span>(root-&gt;left, key);</span><br><span class="line">        root-&gt;right = <span class="built_in">deleteNode</span>(root-&gt;right, key);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个代码是简短一些，思路也巧妙，但是不太好想，实操性不强，推荐第一种写法！</p>
<h3 id="迭代法-2"><a href="#迭代法-2" class="headerlink" title="迭代法"></a>迭代法</h3><p>删除节点的迭代法还是复杂一些的，但其本质我在递归法里都介绍了，最关键就是删除节点的操作（动画模拟的过程）</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 将目标节点（删除节点）的左子树放到 目标节点的右子树的最左面节点的左孩子位置上</span></span><br><span class="line">    <span class="comment">// 并返回目标节点右孩子为新的根节点</span></span><br><span class="line">    <span class="comment">// 是动画里模拟的过程</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deleteOneNode</span><span class="params">(TreeNode* target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="literal">nullptr</span>) <span class="keyword">return</span> target;</span><br><span class="line">        <span class="keyword">if</span> (target-&gt;right == <span class="literal">nullptr</span>) <span class="keyword">return</span> target-&gt;left;</span><br><span class="line">        TreeNode* cur = target-&gt;right;</span><br><span class="line">        <span class="keyword">while</span> (cur-&gt;left) &#123;</span><br><span class="line">            cur = cur-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;left = target-&gt;left;</span><br><span class="line">        <span class="keyword">return</span> target-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">deleteNode</span><span class="params">(TreeNode* root, <span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> root;</span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line">        TreeNode* pre = <span class="literal">nullptr</span>; <span class="comment">// 记录cur的父节点，用来删除cur</span></span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;val == key) <span class="keyword">break</span>;</span><br><span class="line">            pre = cur;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;val &gt; key) cur = cur-&gt;left;</span><br><span class="line">            <span class="keyword">else</span> cur = cur-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pre == <span class="literal">nullptr</span>) &#123; <span class="comment">// 如果搜索树只有头结点</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">deleteOneNode</span>(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// pre 要知道是删左孩子还是右孩子</span></span><br><span class="line">        <span class="keyword">if</span> (pre-&gt;left &amp;&amp; pre-&gt;left-&gt;val == key) &#123;</span><br><span class="line">            pre-&gt;left = <span class="built_in">deleteOneNode</span>(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pre-&gt;right &amp;&amp; pre-&gt;right-&gt;val == key) &#123;</span><br><span class="line">            pre-&gt;right = <span class="built_in">deleteOneNode</span>(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="修剪二叉搜索树"><a href="#修剪二叉搜索树" class="headerlink" title="修剪二叉搜索树"></a>修剪二叉搜索树</h1>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/09/15/UE4-%E9%A1%B9%E7%9B%AE-TowerDefence-%E5%90%84%E7%A7%8D%E5%AD%90%E5%BC%B9%E7%B1%BB%E5%AE%9E%E7%8E%B0%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="williny">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Williny'home">
      <meta itemprop="description" content="孤独是人生的常态">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Williny'home">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/09/15/UE4-%E9%A1%B9%E7%9B%AE-TowerDefence-%E5%90%84%E7%A7%8D%E5%AD%90%E5%BC%B9%E7%B1%BB%E5%AE%9E%E7%8E%B0%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81/" class="post-title-link" itemprop="url">UE4-项目-TowerDefence-各种子弹类实现完整代码</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-09-15 14:36:59 / 修改时间：14:40:18" itemprop="dateCreated datePublished" datetime="2022-09-15T14:36:59+08:00">2022-09-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/unreal-engine/" itemprop="url" rel="index"><span itemprop="name">unreal engine</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="TowerDefenceType-h"><a href="#TowerDefenceType-h" class="headerlink" title="TowerDefenceType.h"></a>TowerDefenceType.h</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CoreMinimal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;TowerDefenceType.generated.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">UENUM</span>(BlueprintType)</span><br><span class="line"><span class="keyword">namespace</span> EGameCharacterType</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">enum</span> <span class="title class_">Type</span></span><br><span class="line">	&#123;</span><br><span class="line">		TOWER,</span><br><span class="line">		MAIN_TOWER,</span><br><span class="line">		MONSTER,</span><br><span class="line">		BOSS_MONSTER,</span><br><span class="line">		MAX</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UENUM</span>(BlueprintType)</span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">EBulletType</span> :uint8</span><br><span class="line">&#123;</span><br><span class="line">	BULLET_NONE,			<span class="comment">//不产生任何效果</span></span><br><span class="line"></span><br><span class="line">	BULLET_DIRECT_LINE,		<span class="comment">//无障碍直线攻击</span></span><br><span class="line">	BULLET_LINE,			<span class="comment">//非跟踪类型，类似手枪子弹；</span></span><br><span class="line">	BULLET_TRACK_LINE,		<span class="comment">//跟踪类型</span></span><br><span class="line">	BULLET_TRACK_LINE_SP,	<span class="comment">//跟踪类型</span></span><br><span class="line">	BULLET_RANGE_LINE,		<span class="comment">//范围伤害，丢手雷；</span></span><br><span class="line">	BULLET_RANGE,			<span class="comment">//范围伤害，类似自爆；</span></span><br><span class="line">	BULLET_CHAIN,			<span class="comment">//链条类型，持续伤害类型;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="RuleOfTheBullet-h"><a href="#RuleOfTheBullet-h" class="headerlink" title="RuleOfTheBullet.h"></a>RuleOfTheBullet.h</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CoreMinimal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GameFramework/Actor.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;TowerDefence\TowerDefenceType.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Character\Core\RuleOfTheCharacter.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Components\SplineComponent.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;RuleOfTheBullet.generated.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TOWERDEFENCE_API</span> ARuleOfTheBullet : <span class="keyword">public</span> AActor</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//碰撞盒子</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(VisibleAnywhere, BlueprintReadOnly, Category = <span class="string">&quot;BaseAttrubute&quot;</span>, meta = (AllowPrivateAccess = <span class="string">&quot;true&quot;</span>))</span><br><span class="line">		<span class="keyword">class</span> <span class="title class_">USphereComponent</span>* BoxDamage;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//作为根组件</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(VisibleAnywhere, BlueprintReadOnly, Category = <span class="string">&quot;BaseAttrubute&quot;</span>, meta = (AllowPrivateAccess = <span class="string">&quot;true&quot;</span>))</span><br><span class="line">		<span class="keyword">class</span> <span class="title class_">USceneComponent</span>* RootBullet;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//具有移动属性的组件</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(VisibleAnywhere, BlueprintReadOnly, Category = <span class="string">&quot;BaseAttrubute&quot;</span>, meta = (AllowPrivateAccess = <span class="string">&quot;true&quot;</span>))</span><br><span class="line">		<span class="keyword">class</span> <span class="title class_">UProjectileMovementComponent</span>* ProjectileMovement;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"><span class="keyword">public</span>:	</span><br><span class="line">	<span class="comment">//技能类型</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(EditDefaultsOnly, Category = <span class="string">&quot;Bullet&quot;</span>)</span><br><span class="line">		TEnumAsByte&lt;EBulletType&gt; BulletType;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//子弹的伤害特效(碰撞后产生的特效)</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(EditDefaultsOnly, Category = <span class="string">&quot;Bullet&quot;</span>)</span><br><span class="line">		UParticleSystem* DamgageParticle;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//开火特效</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(EditDefaultsOnly, Category = <span class="string">&quot;Bullet&quot;</span>)</span><br><span class="line">		UParticleSystem* OpenFireParticle;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//样条线偏移值</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(EditDefaultsOnly, Category = <span class="string">&quot;Bullet track line sp&quot;</span>)</span><br><span class="line">		<span class="type">float</span> SplineOffset;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Sets default values for this actor&#x27;s properties</span></span><br><span class="line">	<span class="built_in">ARuleOfTheBullet</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="comment">// Called when the game starts or when spawned</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BeginPlay</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//球形碰撞组件和pawn进行重叠之后触发的事件</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>()</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">BeginOverlap</span><span class="params">(UPrimitiveComponent* OverlappedComponent<span class="comment">/*重叠的组件*/</span>, AActor* OtherActor<span class="comment">/*目标Actor*/</span>, UPrimitiveComponent* OtherComp<span class="comment">/*目标组件*/</span>, int32 OtherBodyIndex, <span class="type">bool</span> bFromSweep<span class="comment">/*是否开始扫描*/</span>, <span class="type">const</span> FHitResult&amp; SweepResult<span class="comment">/*扫描之后的结果*/</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">RadialDamage</span><span class="params">(<span class="type">const</span> FVector&amp; Origin, ARuleOfTheCharacter* InstigatorCharacter)</span></span>;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">UFUNCTION</span>()</span><br><span class="line">			<span class="function"><span class="type">void</span> <span class="title">ChainAttack</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">UPROPERTY</span>()</span><br><span class="line">		USplineComponent* Spline;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">UPROPERTY</span>()</span><br><span class="line">		<span class="type">float</span> CurrentSplineTime;</span><br><span class="line"></span><br><span class="line">	FTimerHandle ChainAttackHandle;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">UPROPERTY</span>()</span><br><span class="line">		uint8 ChainAttackCount;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:	</span><br><span class="line">	<span class="comment">// Called every frame</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Tick</span><span class="params">(<span class="type">float</span> DeltaTime)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="RuleOfTheBullet-cpp"><a href="#RuleOfTheBullet-cpp" class="headerlink" title="RuleOfTheBullet.cpp"></a>RuleOfTheBullet.cpp</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Character/Bullet/RuleOfTheBullet.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Particles\ParticleSystemComponent.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Components\SceneComponent.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Components/SphereComponent.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GameFramework/ProjectileMovementComponent.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;TowerDefence\StoneDefenceUtils.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Character\Core\RuleOfTheAIController.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Kismet\GameplayStatics.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Components\SceneComponent.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;EngineUtils.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 问题1：怪物发射的子弹没有初速度，所以也无法测试是否开启了跟踪效果</span></span><br><span class="line"><span class="comment">// 问题2：塔的子弹击中怪物没有生成特效</span></span><br><span class="line"><span class="comment">// 问题3：子弹类型为BULLET_RANGE_LINE时子弹就直接卡住了</span></span><br><span class="line"><span class="comment">// 问题4：设置子弹为闪电的时候，方向不对，而且同时也会发射球形子弹（但没有发射子弹的粒子特效）</span></span><br><span class="line"><span class="comment">// 问题5：设置为三重花样子弹的时候，游戏中仅仅显示一发子弹，样条线生成的子弹扭曲轨道也有问题</span></span><br><span class="line"><span class="comment">// 问题5：在RuleOfTheCharacter中声明的OpenFirePoint组件由箭头组件修改为USceneComponent类型，但是在Towers生成的蓝图中依旧是箭头组件</span></span><br><span class="line"><span class="comment">// 问题6：在范围伤害（类似自爆）中，取消了子弹的初速度，这时子弹模型就会悬停在发射点，我想要取消这个模型，怎么做到呢？</span></span><br><span class="line"><span class="comment">// 我怀疑以上大部分的BUG都是下面这个构造函数的警告导致的，但不知道怎么解决</span></span><br><span class="line"><span class="comment">// 未初始化两个粒子特效，但不知道怎么初始化，而且按理说不用初始化的啊，粒子特效在蓝图界面赋值的，为什么这里会出现警告呢？</span></span><br><span class="line">ARuleOfTheBullet::<span class="built_in">ARuleOfTheBullet</span>()</span><br><span class="line">&#123;</span><br><span class="line">	SplineOffset = <span class="number">0.0f</span>;</span><br><span class="line">	CurrentSplineTime = <span class="number">0.0f</span>;</span><br><span class="line">	Spline = <span class="literal">nullptr</span>;</span><br><span class="line">	<span class="comment">// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don&#x27;t need it.</span></span><br><span class="line">	PrimaryActorTick.bCanEverTick = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//ParticleMesh = CreateDefaultSubobject&lt;UParticleSystemComponent&gt;(TEXT(&quot;BulletNoxDamage&quot;));</span></span><br><span class="line">	BoxDamage = <span class="built_in">CreateDefaultSubobject</span>&lt;USphereComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;BulletNoxDamage&quot;</span>));<span class="comment">//此处使用BulletNoxDamage并且上面的一行存在时会产生断点，断点描述为避免多次构造同一子对象。我们只需要检查名称，因为如果已经存在具有相同名称但不同类的对象，ConstructObject无论如何都会失败。</span></span><br><span class="line">	RootBullet = <span class="built_in">CreateDefaultSubobject</span>&lt;USceneComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;BulletRootBullet&quot;</span>));</span><br><span class="line">	ProjectileMovement = <span class="built_in">CreateDefaultSubobject</span>&lt;UProjectileMovementComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;BulletProjectileMovement&quot;</span>));</span><br><span class="line"> 	</span><br><span class="line">	RootComponent = RootBullet;</span><br><span class="line">	BoxDamage-&gt;<span class="built_in">AttachToComponent</span>(RootComponent, FAttachmentTransformRules::KeepRelativeTransform);</span><br><span class="line"></span><br><span class="line">	ProjectileMovement-&gt;MaxSpeed = <span class="number">2000.f</span>;</span><br><span class="line">	ProjectileMovement-&gt;InitialSpeed = <span class="number">1600.f</span>;</span><br><span class="line">	ProjectileMovement-&gt;ProjectileGravityScale = <span class="number">0.f</span>;</span><br><span class="line">	ProjectileMovement-&gt;UpdatedComponent = BoxDamage;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置默认子弹类型</span></span><br><span class="line">	BulletType = EBulletType::BULLET_DIRECT_LINE;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//子弹生命周期</span></span><br><span class="line">	InitialLifeSpan = <span class="number">4.0f</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Called when the game starts or when spawned</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ARuleOfTheBullet::BeginPlay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Super::<span class="built_in">BeginPlay</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//在此处AActor的Instigator已经成为了私有的，所以尝试直接声明一个FActorSpawnParameters变量，获取Instigator，但可行性未可知</span></span><br><span class="line">	<span class="comment">//生成子弹的结构体</span></span><br><span class="line">	FActorSpawnParameters ActorSpawnParameters;</span><br><span class="line">	<span class="comment">//获取施法者Character</span></span><br><span class="line">	<span class="keyword">if</span> (ARuleOfTheCharacter* InstigatorCharacter = <span class="built_in">Cast</span>&lt;ARuleOfTheCharacter&gt;(ActorSpawnParameters.Instigator<span class="comment">/*生成子弹的伤害施加者*/</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//获取施法者的Controller</span></span><br><span class="line">		<span class="keyword">if</span> (ARuleOfTheAIController* InstigatorController = <span class="built_in">Cast</span>&lt;ARuleOfTheAIController&gt;(InstigatorCharacter-&gt;<span class="built_in">GetController</span>()))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//获取施法者的目标</span></span><br><span class="line">			<span class="keyword">if</span> (ARuleOfTheCharacter* TargetCharacter = InstigatorController-&gt;Target.<span class="built_in">Get</span>())</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//遍历枚举，根据子弹类型来生成粒子特效</span></span><br><span class="line">				<span class="keyword">switch</span> (BulletType)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="comment">//无障碍直线攻击，则在Actor位置生成OpenFireParticle特效</span></span><br><span class="line">				<span class="keyword">case</span> EBulletType::BULLET_DIRECT_LINE:</span><br><span class="line">					UGameplayStatics::<span class="built_in">SpawnEmitterAtLocation</span>(<span class="built_in">GetWorld</span>(), OpenFireParticle, <span class="built_in">GetActorLocation</span>());</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">					<span class="comment">//非跟踪类型，类似手枪子弹类型，同上</span></span><br><span class="line">				<span class="keyword">case</span> EBulletType::BULLET_LINE:</span><br><span class="line">					UGameplayStatics::<span class="built_in">SpawnEmitterAtLocation</span>(<span class="built_in">GetWorld</span>(), OpenFireParticle, <span class="built_in">GetActorLocation</span>());</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">					<span class="comment">//Spline实现的跟踪类型</span></span><br><span class="line">				<span class="keyword">case</span> EBulletType::BULLET_TRACK_LINE_SP:</span><br><span class="line">				&#123;</span><br><span class="line">					ProjectileMovement-&gt;<span class="built_in">StopMovementImmediately</span>();</span><br><span class="line">					<span class="comment">//生成特效</span></span><br><span class="line">					UGameplayStatics::<span class="built_in">SpawnEmitterAtLocation</span>(<span class="built_in">GetWorld</span>(), OpenFireParticle, <span class="built_in">GetActorLocation</span>());</span><br><span class="line">					<span class="comment">//在当前组件内（this）生成样条线</span></span><br><span class="line">					Spline = <span class="built_in">NewObject</span>&lt;USplineComponent&gt;(<span class="keyword">this</span>, <span class="built_in">TEXT</span>(<span class="string">&quot;SplineInstance&quot;</span>));</span><br><span class="line">					Spline-&gt;<span class="built_in">RegisterComponent</span>();</span><br><span class="line"></span><br><span class="line">					<span class="comment">//生成样条线的下标为0的节点（起点）</span></span><br><span class="line">					Spline-&gt;<span class="built_in">SetLocationAtSplinePoint</span>(<span class="number">0</span>, <span class="built_in">GetActorLocation</span>(), ESplineCoordinateSpace::Local);</span><br><span class="line">					<span class="comment">//获取施法者和敌人之间的距离</span></span><br><span class="line">					FVector DistanceVector = InstigatorCharacter-&gt;<span class="built_in">GetActorLocation</span>() - TargetCharacter-&gt;<span class="built_in">GetActorLocation</span>();</span><br><span class="line">					<span class="comment">//敌人和施法者之间连线的中点</span></span><br><span class="line">					FVector Position = (DistanceVector / <span class="number">2</span>) + TargetCharacter-&gt;<span class="built_in">GetActorLocation</span>();</span><br><span class="line">					Position.Y += SplineOffset;</span><br><span class="line">					<span class="comment">//设置中点位置的高度</span></span><br><span class="line">					Position.Z = (DistanceVector.<span class="built_in">Size</span>() / <span class="number">2.f</span>) * <span class="number">0.5f</span>;</span><br><span class="line">					<span class="comment">//生成样条线下标为1的点（中点）</span></span><br><span class="line">					Spline-&gt;<span class="built_in">SetLocationAtSplinePoint</span>(<span class="number">1</span>, Position, ESplineCoordinateSpace::Local);</span><br><span class="line">					<span class="comment">//在敌人位置生成终点</span></span><br><span class="line">					Spline-&gt;<span class="built_in">AddSplinePoint</span>(TargetCharacter-&gt;<span class="built_in">GetActorLocation</span>(), ESplineCoordinateSpace::Local);</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">//跟踪类型</span></span><br><span class="line">				<span class="keyword">case</span> EBulletType::BULLET_TRACK_LINE:</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="comment">//在Actor位置生成OpenFireParticle特效</span></span><br><span class="line">					UGameplayStatics::<span class="built_in">SpawnEmitterAtLocation</span>(<span class="built_in">GetWorld</span>(), OpenFireParticle, <span class="built_in">GetActorLocation</span>());</span><br><span class="line">					ProjectileMovement-&gt;bIsHomingProjectile = <span class="literal">true</span>;<span class="comment">//开启跟踪</span></span><br><span class="line">					ProjectileMovement-&gt;bRotationFollowsVelocity = <span class="literal">true</span>;<span class="comment">//旋转方向跟随速度方向进行旋转，使得子弹的拖尾特效效果正常</span></span><br><span class="line">					ProjectileMovement-&gt;HomingAccelerationMagnitude = <span class="number">4000.f</span>;<span class="comment">//设置跟踪导航的加速度</span></span><br><span class="line">					ProjectileMovement-&gt;HomingTargetComponent = TargetCharacter-&gt;<span class="built_in">GetHomingPoint</span>();<span class="comment">//设置跟踪方向是目标身上的跟踪点</span></span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="comment">//物理实现的丢手雷范围伤害</span></span><br><span class="line">				<span class="keyword">case</span> EBulletType::BULLET_RANGE_LINE:</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="comment">//先暂时取消初速度，不然直接就直线射击出去了</span></span><br><span class="line">					ProjectileMovement-&gt;<span class="built_in">StopMovementImmediately</span>();</span><br><span class="line">					<span class="comment">//开启子弹重力</span></span><br><span class="line">					ProjectileMovement-&gt;ProjectileGravityScale = <span class="number">1.f</span>;</span><br><span class="line"></span><br><span class="line">					<span class="comment">//目标位置和子弹生成位置之间的距离</span></span><br><span class="line">					FVector TargetFormOwnerVector = TargetCharacter-&gt;<span class="built_in">GetActorLocation</span>() - <span class="built_in">GetActorLocation</span>();</span><br><span class="line"></span><br><span class="line">					<span class="comment">//子弹在路上的时间=距离/子弹速度</span></span><br><span class="line">					<span class="type">float</span> InTime = (TargetFormOwnerVector.<span class="built_in">Size</span>() / ProjectileMovement-&gt;InitialSpeed);</span><br><span class="line">					<span class="comment">//获取抛射物Z轴的垂直距离=Z轴重力*时间</span></span><br><span class="line">					<span class="type">float</span> Y = ProjectileMovement-&gt;<span class="built_in">GetGravityZ</span>() * InTime;</span><br><span class="line">					<span class="comment">//获取抛射物的水平距离=水平初速度速度*时间</span></span><br><span class="line">					<span class="type">float</span> X = ProjectileMovement-&gt;InitialSpeed * InTime;</span><br><span class="line">					<span class="comment">//勾股定理获取XY的斜边</span></span><br><span class="line">					<span class="type">float</span> V = FMath::<span class="built_in">Sqrt</span>(X * X + Y * Y);</span><br><span class="line"></span><br><span class="line">					<span class="comment">//此公式可推导出来，求出V与水平速度的夹角cos值，再由Acos()转换为弧度CosRadian</span></span><br><span class="line">					<span class="comment">//PI为圆周率</span></span><br><span class="line">					<span class="type">float</span> CosRadian = FMath::<span class="built_in">Acos</span>(TargetFormOwnerVector.<span class="built_in">Size</span>() / V * (InTime * (PI * <span class="number">0.1f</span>)<span class="comment">/*用于修正子弹初始位置与目标位置之间连线不是水平于地面的*/</span>));</span><br><span class="line">					FRotator Rot = <span class="built_in">GetActorRotation</span>();</span><br><span class="line">					<span class="comment">//弧度转换为角度</span></span><br><span class="line">					Rot.Pitch = CosRadian * (<span class="number">180</span> / PI);</span><br><span class="line">					<span class="comment">//设置子弹初始抛射角度</span></span><br><span class="line">					<span class="built_in">SetActorRotation</span>(Rot);</span><br><span class="line">					<span class="comment">//重新设置速度，此时抛射角度已经设定好了，所以发射之后就是抛出状态</span></span><br><span class="line">					ProjectileMovement-&gt;<span class="built_in">SetVelocityInLocalSpace</span>(<span class="built_in">FVector</span>(<span class="number">1.0f</span>, <span class="number">0.f</span>, <span class="number">0.f</span>) * ProjectileMovement-&gt;InitialSpeed);</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="comment">//范围伤害，类似自爆——以自身为圆心，一定半径之内产生爆炸伤害</span></span><br><span class="line">				<span class="keyword">case</span> EBulletType::BULLET_RANGE:</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="comment">//停下子弹的移动</span></span><br><span class="line">					ProjectileMovement-&gt;<span class="built_in">StopMovementImmediately</span>();</span><br><span class="line">					<span class="comment">//设置碰撞为无</span></span><br><span class="line">					BoxDamage-&gt;<span class="built_in">SetCollisionEnabled</span>(ECollisionEnabled::NoCollision);</span><br><span class="line">					<span class="comment">//调用自定义函数RadialDamage(圆心位置，施法者)</span></span><br><span class="line">					<span class="built_in">RadialDamage</span>(<span class="built_in">GetActorLocation</span>(), <span class="built_in">Cast</span>&lt;ARuleOfTheCharacter&gt;(ActorSpawnParameters.Instigator));</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">//链条类型，持续伤害类型;</span></span><br><span class="line">				<span class="keyword">case</span> EBulletType::BULLET_CHAIN:</span><br><span class="line">				&#123;	</span><br><span class="line">				</span><br><span class="line">					ProjectileMovement-&gt;<span class="built_in">StopMovementImmediately</span>();</span><br><span class="line">					BoxDamage-&gt;<span class="built_in">SetCollisionEnabled</span>(ECollisionEnabled::NoCollision);</span><br><span class="line">					<span class="comment">//UGameplayStatics::SpawnEmitterAttached(OpenFireParticle, InstigatorCharacter-&gt;GetHomingPoint());</span></span><br><span class="line">					UGameplayStatics::<span class="built_in">SpawnEmitterAttached</span>(DamgageParticle, TargetCharacter-&gt;<span class="built_in">GetHomingPoint</span>());</span><br><span class="line"></span><br><span class="line">					<span class="comment">//GetWorld()-&gt;GetTimerManager().SetTimer(ChainAttackHandle, this, &amp;ARuleOfTheBullet::ChainAttack, 0.1f);</span></span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="comment">//OnComponentBeginOverlap：是BoxDamage组件中自带的成员变量</span></span><br><span class="line">	<span class="comment">//代理绑定AddUniqueDynamic</span></span><br><span class="line">	BoxDamage-&gt;OnComponentBeginOverlap.<span class="built_in">AddUniqueDynamic</span>(<span class="keyword">this</span>, &amp;ARuleOfTheBullet::BeginOverlap);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//当子弹与目标重叠时触发的函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ARuleOfTheBullet::BeginOverlap</span><span class="params">(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, <span class="type">bool</span> bFromSweep, <span class="type">const</span> FHitResult&amp; SweepResult)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//不知道这里的改动是否可行！！！有待验证！！！</span></span><br><span class="line">	<span class="comment">//生成子弹的结构体</span></span><br><span class="line">	FActorSpawnParameters ActorSpawnParameters;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//找到伤害施加者</span></span><br><span class="line">	<span class="keyword">if</span> (ARuleOfTheCharacter* InstigatorCharacter = <span class="built_in">Cast</span>&lt;ARuleOfTheCharacter&gt;(ActorSpawnParameters.Instigator<span class="comment">/*生成子弹的伤害施加者*/</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//获取目标的Character</span></span><br><span class="line">		<span class="keyword">if</span> (ARuleOfTheCharacter* OtherCharacter = <span class="built_in">Cast</span>&lt;ARuleOfTheCharacter&gt;(OtherActor))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//判断是否为敌方——没有队友伤害</span></span><br><span class="line">			<span class="keyword">if</span> (InstigatorCharacter-&gt;<span class="built_in">IsTeam</span>() != OtherCharacter-&gt;<span class="built_in">IsTeam</span>())</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//判断目标是否活着</span></span><br><span class="line">				<span class="keyword">if</span> (OtherCharacter-&gt;<span class="built_in">IsActive</span>())</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="comment">//生成伤害特效</span></span><br><span class="line">					UGameplayStatics::<span class="built_in">SpawnEmitterAtLocation</span>(<span class="built_in">GetWorld</span>(), DamgageParticle, SweepResult.Location);</span><br><span class="line"></span><br><span class="line">					<span class="keyword">switch</span> (BulletType)</span><br><span class="line">					&#123;</span><br><span class="line">						<span class="comment">//如果是BULLET_LINE类型和BULLET_TRACK_LINE类型，则碰撞之后就销毁Actor</span></span><br><span class="line">					<span class="keyword">case</span> EBulletType::BULLET_DIRECT_LINE:</span><br><span class="line">					<span class="keyword">case</span> EBulletType::BULLET_LINE:</span><br><span class="line">					<span class="keyword">case</span> EBulletType::BULLET_TRACK_LINE:</span><br><span class="line">						&#123;</span><br><span class="line">							<span class="comment">//此函数接口会激活施法者的TakeDamage伤害接口</span></span><br><span class="line">							UGameplayStatics::<span class="built_in">ApplyDamage</span>(</span><br><span class="line">								OtherCharacter,<span class="comment">//被命中者</span></span><br><span class="line">								<span class="number">100.f</span>,<span class="comment">//伤害数值</span></span><br><span class="line">								InstigatorCharacter-&gt;<span class="built_in">GetController</span>(),<span class="comment">//施法者的控制器</span></span><br><span class="line">								InstigatorCharacter,<span class="comment">//施法者</span></span><br><span class="line">								UDamageType::<span class="built_in">StaticClass</span>()<span class="comment">/*默认伤害类型，后面会修改*/</span>);</span><br><span class="line">								<span class="built_in">Destroy</span>();</span><br><span class="line">								<span class="keyword">break</span>;</span><br><span class="line">						&#125;</span><br><span class="line">					<span class="keyword">case</span> EBulletType::BULLET_RANGE_LINE: </span><br><span class="line">						&#123;</span><br><span class="line">							<span class="built_in">RadialDamage</span>(OtherCharacter-&gt;<span class="built_in">GetActorLocation</span>(), InstigatorCharacter);</span><br><span class="line">							<span class="built_in">Destroy</span>();</span><br><span class="line">							<span class="keyword">break</span>;</span><br><span class="line">						&#125;</span><br><span class="line"></span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ARuleOfTheBullet::RadialDamage</span><span class="params">(<span class="type">const</span> FVector&amp; Origin<span class="comment">/*圆心点*/</span>, ARuleOfTheCharacter* InstigatorCharacter<span class="comment">/*施法者*/</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	FActorSpawnParameters ActorSpawnParameters;</span><br><span class="line">	<span class="keyword">if</span> (InstigatorCharacter)<span class="comment">//判断施法者是否有效</span></span><br><span class="line">	&#123;</span><br><span class="line">		TArray&lt;AActor*&gt; IngoreActors;<span class="comment">//友方类数组，用于忽略伤害</span></span><br><span class="line">		TArray&lt;ARuleOfTheCharacter*&gt; TargetActors;<span class="comment">//目标类数组，施加伤害</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//迭代器遍历关卡中的所有ARuleOfTheCharacter类</span></span><br><span class="line">		<span class="keyword">for</span> (TActorIterator&lt;ARuleOfTheCharacter&gt;<span class="built_in">it</span>(<span class="built_in">GetWorld</span>(), ARuleOfTheCharacter::<span class="built_in">StaticClass</span>()); it; ++it)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//TheCharacter用于存储敌方</span></span><br><span class="line">			<span class="keyword">if</span> (ARuleOfTheCharacter* TheCharacter = *it)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//计算施法者与敌方之间的距离</span></span><br><span class="line">				FVector VDistance = TheCharacter-&gt;<span class="built_in">GetActorLocation</span>() - InstigatorCharacter-&gt;<span class="built_in">GetActorLocation</span>();</span><br><span class="line"></span><br><span class="line">				<span class="comment">//如果距离不超过1400即可进攻</span></span><br><span class="line">				<span class="keyword">if</span> (VDistance.<span class="built_in">Size</span>() &lt;= <span class="number">1400</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="comment">//判断敌方是否为敌方</span></span><br><span class="line">					<span class="keyword">if</span> (TheCharacter-&gt;<span class="built_in">IsTeam</span>() == InstigatorCharacter-&gt;<span class="built_in">IsTeam</span>())</span><br><span class="line">					&#123;</span><br><span class="line">						<span class="comment">//不是敌方则添加进友方类数组</span></span><br><span class="line">						IngoreActors.<span class="built_in">Add</span>(TheCharacter);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span></span><br><span class="line">					&#123;</span><br><span class="line">						<span class="comment">//是敌方则添加进目标类数组</span></span><br><span class="line">						TargetActors.<span class="built_in">Add</span>(TheCharacter);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//半径衰减范围伤害</span></span><br><span class="line">		UGameplayStatics::<span class="built_in">ApplyRadialDamageWithFalloff</span></span><br><span class="line">		(</span><br><span class="line">			<span class="built_in">GetWorld</span>()<span class="comment">/*关卡*/</span>,</span><br><span class="line">			<span class="number">100.f</span><span class="comment">/*最大伤害*/</span>,</span><br><span class="line">			<span class="number">10.f</span><span class="comment">/*最小伤害*/</span>,</span><br><span class="line">			Origin<span class="comment">/*伤害圆心点*/</span>,</span><br><span class="line">			<span class="number">400.f</span><span class="comment">/*内圆半径*/</span>,</span><br><span class="line">			<span class="number">1000.f</span><span class="comment">/*外圆半径*/</span>,</span><br><span class="line">			<span class="number">1.f</span><span class="comment">/*伤害衰减系数*/</span>,</span><br><span class="line">			UDamageType::<span class="built_in">StaticClass</span>()<span class="comment">/*伤害类型*/</span>,</span><br><span class="line">			IngoreActors<span class="comment">/*友方Actor*/</span>,</span><br><span class="line">			ActorSpawnParameters.Instigator<span class="comment">/*施法者*/</span></span><br><span class="line">		);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ARuleOfTheBullet::ChainAttack</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//if (ChainAttackHandle.IsValid())</span></span><br><span class="line">	<span class="comment">//&#123;</span></span><br><span class="line">	<span class="comment">//	GetWorld()-&gt;GetTimerManager().ClearTimer(ChainAttackHandle);</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//主要伤害区</span></span><br><span class="line">	FActorSpawnParameters ActorSpawnParameters;</span><br><span class="line">	<span class="keyword">if</span> (ARuleOfTheCharacter* InstigatorCharacter = <span class="built_in">Cast</span>&lt;ARuleOfTheCharacter&gt;(ActorSpawnParameters.Instigator))</span><br><span class="line">		&#123;</span><br><span class="line">		<span class="keyword">if</span> (ARuleOfTheAIController* InstigatorController = <span class="built_in">Cast</span>&lt;ARuleOfTheAIController&gt;(InstigatorCharacter-&gt;<span class="built_in">GetController</span>()))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (ARuleOfTheCharacter* TargetCharacter = InstigatorController-&gt;Target.<span class="built_in">Get</span>())</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//在目标的跟踪点上生成一个特效（敌人被攻击时的特效）</span></span><br><span class="line">				UGameplayStatics::<span class="built_in">SpawnEmitterAttached</span>(DamgageParticle, TargetCharacter-&gt;<span class="built_in">GetHomingPoint</span>());</span><br><span class="line">				<span class="comment">//在自身的开火点上生成一个特效</span></span><br><span class="line">				UGameplayStatics::<span class="built_in">SpawnEmitterAttached</span>(OpenFireParticle, InstigatorCharacter-&gt;<span class="built_in">GetHomingPoint</span>());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">					UGameplayStatics::<span class="built_in">ApplyDamage</span>(</span><br><span class="line">						TargetCharacter,</span><br><span class="line">						<span class="number">100.f</span>,</span><br><span class="line">						InstigatorCharacter-&gt;<span class="built_in">GetController</span>(),</span><br><span class="line">						InstigatorCharacter,</span><br><span class="line">						UDamageType::<span class="built_in">StaticClass</span>());</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="comment">//ChainAttackCount--;</span></span><br><span class="line">	<span class="comment">//if (ChainAttackCount &gt; 0)</span></span><br><span class="line">	<span class="comment">//&#123;</span></span><br><span class="line">	<span class="comment">//	GetWorld()-&gt;GetTimerManager().SetTimer(ChainAttackHandle, this, &amp;ARuleOfTheBullet::ChainAttack, 0.3f);</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Called every frame</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ARuleOfTheBullet::Tick</span><span class="params">(<span class="type">float</span> DeltaTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Super::<span class="built_in">Tick</span>(DeltaTime);</span><br><span class="line"></span><br><span class="line">	FActorSpawnParameters ActorSpawnParameters;</span><br><span class="line">	<span class="keyword">if</span> (ARuleOfTheCharacter* InstigatorCharacter = <span class="built_in">Cast</span>&lt;ARuleOfTheCharacter&gt;(ActorSpawnParameters.Instigator))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (ARuleOfTheAIController* InstigatorController = <span class="built_in">Cast</span>&lt;ARuleOfTheAIController&gt;(InstigatorCharacter-&gt;<span class="built_in">GetController</span>()))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (ARuleOfTheCharacter* TargetCharacter = InstigatorController-&gt;Target.<span class="built_in">Get</span>())</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">switch</span> (BulletType)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">case</span> EBulletType::BULLET_CHAIN:</span><br><span class="line">					&#123;</span><br><span class="line">						TArray&lt;USceneComponent*&gt; SceneComponent;</span><br><span class="line">						RootComponent-&gt;<span class="built_in">GetChildrenComponents</span>(<span class="literal">true</span><span class="comment">/*true包括所有子类*/</span>, SceneComponent);<span class="comment">//遍历附加在根组件的所有组件，将其中的组件添加到SceneComponent中</span></span><br><span class="line">						<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; Tmp : SceneComponent)</span><br><span class="line">						&#123;</span><br><span class="line">							<span class="keyword">if</span> (UParticleSystemComponent* ParticleSystem = <span class="built_in">Cast</span>&lt;UParticleSystemComponent&gt;(Tmp))<span class="comment">//判断SceneComponent中是否存在UParticleSystemComponent类型</span></span><br><span class="line">							&#123;</span><br><span class="line">								<span class="comment">//设置特效的出发点</span></span><br><span class="line">								ParticleSystem-&gt;<span class="built_in">SetBeamSourcePoint</span>(<span class="number">0</span><span class="comment">/*发射器的index*/</span>, InstigatorCharacter-&gt;<span class="built_in">GetFirePoint</span>()-&gt;<span class="built_in">GetComponentLocation</span>(), <span class="number">0</span><span class="comment">/*光束index*/</span>);</span><br><span class="line">								<span class="comment">//设置特效的终点</span></span><br><span class="line">								ParticleSystem-&gt;<span class="built_in">SetBeamTargetPoint</span>(<span class="number">0</span>, TargetCharacter-&gt;<span class="built_in">GetHomingPoint</span>()-&gt;<span class="built_in">GetComponentLocation</span>(), <span class="number">0</span>);</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">case</span> EBulletType::BULLET_TRACK_LINE_SP:</span><br><span class="line">					&#123;</span><br><span class="line">						<span class="keyword">if</span> (Spline)</span><br><span class="line">						&#123;</span><br><span class="line">							<span class="comment">//施法者与敌人之间的距离</span></span><br><span class="line">							FVector DistanceVector = TargetCharacter-&gt;<span class="built_in">GetActorLocation</span>() - InstigatorCharacter-&gt;<span class="built_in">GetActorLocation</span>();</span><br><span class="line">							CurrentSplineTime += DeltaTime;<span class="comment">//样条线生成的时间</span></span><br><span class="line"></span><br><span class="line">							<span class="comment">//动态调整攻击速度，敌人距离很远的时候攻击速度慢，距离近了攻击速度就快了</span></span><br><span class="line">							<span class="type">float</span> Distance = Spline-&gt;<span class="built_in">GetSplineLength</span>() * (CurrentSplineTime / (DistanceVector.<span class="built_in">Size</span>() / <span class="number">1000.f</span>));<span class="comment">//样条线生成时间/子弹发射到打到敌人身上消耗的时间</span></span><br><span class="line">							FVector Loction = Spline-&gt;<span class="built_in">GetWorldLocationAtDistanceAlongSpline</span>(Distance);</span><br><span class="line">							FRotator Rotator = Spline-&gt;<span class="built_in">GetRotationAtDistanceAlongSpline</span>(Distance, ESplineCoordinateSpace::Local);</span><br><span class="line"></span><br><span class="line">							<span class="built_in">SetActorLocationAndRotation</span>(Loction, Rotator);</span><br><span class="line"></span><br><span class="line">							<span class="keyword">if</span> ((Loction - TargetCharacter-&gt;<span class="built_in">GetActorLocation</span>()).<span class="built_in">Size</span>() &lt;= <span class="number">100.f</span>)</span><br><span class="line">							&#123;</span><br><span class="line">								FHitResult SweepResult;</span><br><span class="line">								SweepResult.Location = Loction;</span><br><span class="line">								<span class="built_in">BeginOverlap</span>(<span class="literal">nullptr</span>, TargetCharacter, <span class="literal">nullptr</span>, <span class="number">0</span>, <span class="literal">false</span>, SweepResult);</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;</span><br><span class="line"></span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (!TargetCharacter-&gt;<span class="built_in">IsActive</span>())</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">Destroy</span>();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">Destroy</span>();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/09/15/UE4-%E9%A1%B9%E7%9B%AE-TowerDefence-%E6%A0%B7%E6%9D%A1%E7%BA%BF%E5%AE%9E%E7%8E%B0%E5%AD%90%E5%BC%B9%E8%B7%9F%E8%B8%AA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="williny">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Williny'home">
      <meta itemprop="description" content="孤独是人生的常态">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Williny'home">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/09/15/UE4-%E9%A1%B9%E7%9B%AE-TowerDefence-%E6%A0%B7%E6%9D%A1%E7%BA%BF%E5%AE%9E%E7%8E%B0%E5%AD%90%E5%BC%B9%E8%B7%9F%E8%B8%AA/" class="post-title-link" itemprop="url">UE4-项目-TowerDefence-样条线实现子弹跟踪</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-09-15 14:36:17 / 修改时间：15:44:00" itemprop="dateCreated datePublished" datetime="2022-09-15T14:36:17+08:00">2022-09-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/unreal-engine/" itemprop="url" rel="index"><span itemprop="name">unreal engine</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h1><p>子弹沿着样条线运动，最后击中目标</p>
<p>样条线的轨迹需要自己计算</p>
<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><h2 id="Spline-gt-SetLocationAtSplinePoint"><a href="#Spline-gt-SetLocationAtSplinePoint" class="headerlink" title="Spline-&gt;SetLocationAtSplinePoint()"></a>Spline-&gt;SetLocationAtSplinePoint()</h2><p>生成样条线的节点</p>
<p><code>SetLocationAtSplinePoint(节点下标，节点位置，本地组件相对坐标或者世界坐标)</code></p>
<h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">USplineComponent::SetLocationAtSplinePoint</span><span class="params">(int32 PointIndex, <span class="type">const</span> FVector&amp; InLocation, ESplineCoordinateSpace::Type CoordinateSpace, <span class="type">bool</span> bUpdateSpline)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">const</span> int32 NumPoints = SplineCurves.Position.Points.<span class="built_in">Num</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((PointIndex &gt;= <span class="number">0</span>) &amp;&amp; (PointIndex &lt; NumPoints))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">const</span> FVector TransformedLocation = (CoordinateSpace == ESplineCoordinateSpace::World) ?</span><br><span class="line">			<span class="built_in">GetComponentTransform</span>().<span class="built_in">InverseTransformPosition</span>(InLocation) : InLocation;</span><br><span class="line"></span><br><span class="line">		SplineCurves.Position.Points[PointIndex].OutVal = TransformedLocation;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (bUpdateSpline)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">UpdateSpline</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Spline-gt-AddSplinePoint"><a href="#Spline-gt-AddSplinePoint" class="headerlink" title="Spline-&gt;AddSplinePoint()"></a>Spline-&gt;AddSplinePoint()</h2><p>给样条线末尾添加一个节点</p>
<p><code>AddSplinePoint(节点位置，本地组件相对坐标或者世界坐标)</code></p>
<h3 id="源代码-1"><a href="#源代码-1" class="headerlink" title="源代码"></a>源代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">USplineComponent::AddSplinePoint</span><span class="params">(<span class="type">const</span> FVector&amp; Position, ESplineCoordinateSpace::Type CoordinateSpace, <span class="type">bool</span> bUpdateSpline)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">const</span> FVector TransformedPosition = (CoordinateSpace == ESplineCoordinateSpace::World) ?</span><br><span class="line">		<span class="built_in">GetComponentTransform</span>().<span class="built_in">InverseTransformPosition</span>(Position) : Position;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Add the spline point at the end of the array, adding 1.0 to the current last input key.</span></span><br><span class="line">	<span class="comment">// This continues the former behavior in which spline points had to be separated by an interval of 1.0.</span></span><br><span class="line">	<span class="type">const</span> <span class="type">float</span> InKey = SplineCurves.Position.Points.<span class="built_in">Num</span>() ? SplineCurves.Position.Points.<span class="built_in">Last</span>().InVal + <span class="number">1.0f</span> : <span class="number">0.0f</span>;</span><br><span class="line"></span><br><span class="line">	SplineCurves.Position.Points.<span class="built_in">Emplace</span>(InKey, TransformedPosition, FVector::ZeroVector, FVector::ZeroVector, CIM_CurveAuto);</span><br><span class="line">	SplineCurves.Rotation.Points.<span class="built_in">Emplace</span>(InKey, FQuat::Identity, FQuat::Identity, FQuat::Identity, CIM_CurveAuto);</span><br><span class="line">	SplineCurves.Scale.Points.<span class="built_in">Emplace</span>(InKey, <span class="built_in">FVector</span>(<span class="number">1.0f</span>), FVector::ZeroVector, FVector::ZeroVector, CIM_CurveAuto);</span><br><span class="line">	USplineMetadata* Metadata = <span class="built_in">GetSplinePointsMetadata</span>();</span><br><span class="line">	<span class="keyword">if</span> (Metadata)</span><br><span class="line">	&#123;</span><br><span class="line">		Metadata-&gt;<span class="built_in">AddPoint</span>(InKey);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (bLoopPositionOverride)</span><br><span class="line">	&#123;</span><br><span class="line">		LoopPosition += <span class="number">1.0f</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (bUpdateSpline)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">UpdateSpline</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Spline-gt-GetWorldLocationAtDistanceAlongSpline"><a href="#Spline-gt-GetWorldLocationAtDistanceAlongSpline" class="headerlink" title="Spline-&gt;GetWorldLocationAtDistanceAlongSpline()"></a>Spline-&gt;GetWorldLocationAtDistanceAlongSpline()</h2><p>获取沿样条线距离的世界位置</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FVector Loction = Spline-&gt;<span class="built_in">GetWorldLocationAtDistanceAlongSpline</span>(Distance);</span><br></pre></td></tr></table></figure>

<h3 id="源代码-2"><a href="#源代码-2" class="headerlink" title="源代码"></a>源代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> FVector <span class="title">USplineComponent::GetWorldLocationAtDistanceAlongSpline</span><span class="params">(<span class="type">float</span> Distance)</span> <span class="type">const</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="keyword">return</span> <span class="built_in">GetLocationAtDistanceAlongSpline</span>(Distance, ESplineCoordinateSpace::World); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Spline-gt-GetRotationAtDistanceAlongSpline"><a href="#Spline-gt-GetRotationAtDistanceAlongSpline" class="headerlink" title="Spline-&gt;GetRotationAtDistanceAlongSpline"></a>Spline-&gt;GetRotationAtDistanceAlongSpline</h2><p>获取沿样条线距离的旋转</p>
<h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FRotator Rotator = Spline-&gt;<span class="built_in">GetRotationAtDistanceAlongSpline</span>(Distance, ESplineCoordinateSpace::Local);</span><br></pre></td></tr></table></figure>

<h3 id="源代码-3"><a href="#源代码-3" class="headerlink" title="源代码"></a>源代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FRotator <span class="title">USplineComponent::GetRotationAtDistanceAlongSpline</span><span class="params">(<span class="type">float</span> Distance, ESplineCoordinateSpace::Type CoordinateSpace)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">float</span> Param = SplineCurves.ReparamTable.<span class="built_in">Eval</span>(Distance, <span class="number">0.0f</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">GetRotationAtSplineInputKey</span>(Param, CoordinateSpace);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h1 id="大致思路"><a href="#大致思路" class="headerlink" title="大致思路"></a>大致思路</h1><ol>
<li><p>首先声明一个样条线组件，一个样条线运动时间，一个样条线偏移值</p>
<ul>
<li><p><code>UPROPERTY()     USplineComponent* Spline;</code></p>
</li>
<li><p><code>UPROPERTY()     float CurrentSplineTime;</code></p>
</li>
<li><p><code>UPROPERTY(EditDefaultsOnly, Category = &quot;Bullet track line sp&quot;)     float SplineOffset;</code></p>
</li>
</ul>
</li>
<li><p>在cpp的构造函数中初始化</p>
<ul>
<li><p><code>SplineOffset = 0.0f;</code></p>
</li>
<li><p><code>CurrentSplineTime = 0.0f;</code></p>
</li>
<li><p><code>Spline = nullptr;</code></p>
</li>
</ul>
</li>
<li><p>在<code>begin()</code>函数中遍历类型为<code>BULLET_TRACK_LINE_SP</code>时</p>
<ul>
<li><p>暂时停止抛射物移动组件的移动</p>
</li>
<li><p>在关卡内生成开火特效</p>
</li>
<li><p>在当前组件内生成样条线组件</p>
<ul>
<li><code>Spline = NewObject&lt;USplineComponent&gt;(this, TEXT(&quot;SplineInstance&quot;));</code>注意：this。表示在当前组件内生成</li>
</ul>
</li>
<li><p>在关卡内注册样条线组件</p>
<ul>
<li><code>Spline-&gt;RegisterComponent();</code></li>
</ul>
</li>
<li><p>生成样条线的下标为0的节点（起点）</p>
<ul>
<li><code>Spline-&gt;SetLocationAtSplinePoint(0, GetActorLocation(), ESplineCoordinateSpace::Local);</code></li>
</ul>
</li>
<li><p>获取施法者和敌人之间的距离</p>
<ul>
<li><code>FVector DistanceVector = InstigatorCharacter-&gt;GetActorLocation() - TargetCharacter-&gt;GetActorLocation();</code></li>
</ul>
</li>
<li><p>敌人和施法者之间连线的中点</p>
<ul>
<li><code>FVector Position = (DistanceVector / 2) + TargetCharacter-&gt;GetActorLocation();</code></li>
</ul>
</li>
<li><p>使用SplineOffset更新Position的Y轴</p>
<ul>
<li><code>Position.Y += SplineOffset;</code></li>
</ul>
</li>
<li><p>设置中点位置的Z轴高度</p>
<ul>
<li><code>Position.Z = (DistanceVector.Size() / 2.f) * 0.5f;</code></li>
</ul>
</li>
<li><p>生成样条线下标为1的点（中间点）</p>
<ul>
<li><code>Spline-&gt;SetLocationAtSplinePoint(1, Position, ESplineCoordinateSpace::Local);</code></li>
</ul>
</li>
<li><p>在敌人位置生成终点</p>
<ul>
<li><code>Spline-&gt;AddSplinePoint(TargetCharacter-&gt;GetActorLocation(), ESplineCoordinateSpace::Local);</code></li>
</ul>
</li>
</ul>
</li>
<li><p>帧更新样条线</p>
<ul>
<li><p>敌人是在不断移动的，敌人距离远的时候攻击速度变慢，反之则攻击速度快</p>
</li>
<li><p>在Tick中先判断样条线是否存在</p>
</li>
<li><p>获取施法者与敌人之间的距离</p>
</li>
<li><p>使用<code>DeltaTime</code>更新样条线生成的时间<code>CurrentSplineTime</code></p>
</li>
<li><p>动态调整攻击速度，敌人距离很远的时候攻击速度慢，距离近了攻击速度就快了</p>
<ul>
<li><code>float Distance = Spline-&gt;GetSplineLength() * (CurrentSplineTime / (DistanceVector.Size() / 1000.f));</code>样条线生成时间&#x2F;子弹发射到打到敌人身上消耗的时间</li>
</ul>
</li>
<li><p>获取沿样条线距离的世界位置</p>
<ul>
<li><code>FVector Loction = Spline-&gt;GetWorldLocationAtDistanceAlongSpline(Distance);</code></li>
</ul>
</li>
<li><p>获取沿样条线距离的旋转</p>
<ul>
<li><code>FRotator Rotator = Spline-&gt;GetRotationAtDistanceAlongSpline(Distance, ESplineCoordinateSpace::Local);</code></li>
</ul>
</li>
<li><p>更新样条线的位置和旋转信息</p>
<ul>
<li><code>SetActorLocationAndRotation(Loction, Rotator);</code></li>
</ul>
</li>
<li><p>当样条线和目标距离&lt;&#x3D; 100.f时</p>
<ul>
<li><code>if ((Loction - TargetCharacter-&gt;GetActorLocation()).Size() &lt;= 100.f)</code></li>
</ul>
</li>
<li><p>获取碰撞信息</p>
<ul>
<li><code>FHitResult SweepResult;</code></li>
</ul>
</li>
<li><p>将样条线的位置信息更新给碰撞信息</p>
<ul>
<li><code>weepResult.Location = Loction;</code></li>
</ul>
</li>
<li><p>调用函数BeginOverlap生成伤害特效以及生成伤害等</p>
<ul>
<li><code>BeginOverlap(nullptr, TargetCharacter, nullptr, 0, false, SweepResult);</code></li>
</ul>
</li>
</ul>
</li>
</ol>
<h1 id="部分代码"><a href="#部分代码" class="headerlink" title="部分代码"></a>部分代码</h1><h2 id="在begin-函数中遍历类型为BULLET-TRACK-LINE-SP时"><a href="#在begin-函数中遍历类型为BULLET-TRACK-LINE-SP时" class="headerlink" title="在begin()函数中遍历类型为BULLET_TRACK_LINE_SP时"></a>在<code>begin()</code>函数中遍历类型为<code>BULLET_TRACK_LINE_SP</code>时</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> EBulletType::BULLET_TRACK_LINE_SP:</span><br><span class="line">&#123;</span><br><span class="line">	ProjectileMovement-&gt;<span class="built_in">StopMovementImmediately</span>();</span><br><span class="line">	<span class="comment">//生成特效</span></span><br><span class="line">	UGameplayStatics::<span class="built_in">SpawnEmitterAtLocation</span>(<span class="built_in">GetWorld</span>(), OpenFireParticle, <span class="built_in">GetActorLocation</span>());</span><br><span class="line">	<span class="comment">//在当前组件内（this）生成样条线</span></span><br><span class="line">	Spline = <span class="built_in">NewObject</span>&lt;USplineComponent&gt;(<span class="keyword">this</span>, <span class="built_in">TEXT</span>(<span class="string">&quot;SplineInstance&quot;</span>));</span><br><span class="line">	<span class="comment">//在关卡内注册该组件</span></span><br><span class="line">	Spline-&gt;<span class="built_in">RegisterComponent</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//生成样条线的下标为0的节点（起点）</span></span><br><span class="line">	Spline-&gt;<span class="built_in">SetLocationAtSplinePoint</span>(<span class="number">0</span>, <span class="built_in">GetActorLocation</span>(), ESplineCoordinateSpace::Local);</span><br><span class="line">	<span class="comment">//获取施法者和敌人之间的距离</span></span><br><span class="line">	FVector DistanceVector = InstigatorCharacter-&gt;<span class="built_in">GetActorLocation</span>() - TargetCharacter-&gt;<span class="built_in">GetActorLocation</span>();</span><br><span class="line">	<span class="comment">//敌人和施法者之间连线的中点</span></span><br><span class="line">	FVector Position = (DistanceVector / <span class="number">2</span>) + TargetCharacter-&gt;<span class="built_in">GetActorLocation</span>();</span><br><span class="line">	<span class="comment">//使用SplineOffset更新Position的Y轴</span></span><br><span class="line">	Position.Y += SplineOffset;</span><br><span class="line">	<span class="comment">//设置中点位置的高度</span></span><br><span class="line">	Position.Z = (DistanceVector.<span class="built_in">Size</span>() / <span class="number">2.f</span>) * <span class="number">0.5f</span>;</span><br><span class="line">	<span class="comment">//生成样条线下标为1的点（中点）</span></span><br><span class="line">	Spline-&gt;<span class="built_in">SetLocationAtSplinePoint</span>(<span class="number">1</span>, Position, ESplineCoordinateSpace::Local);</span><br><span class="line">	<span class="comment">//在敌人位置生成终点</span></span><br><span class="line">	Spline-&gt;<span class="built_in">AddSplinePoint</span>(TargetCharacter-&gt;<span class="built_in">GetActorLocation</span>(), ESplineCoordinateSpace::Local);</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="帧更新样条线"><a href="#帧更新样条线" class="headerlink" title="帧更新样条线"></a>帧更新样条线</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> EBulletType::BULLET_TRACK_LINE_SP:</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (Spline)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//施法者与敌人之间的距离</span></span><br><span class="line">		FVector DistanceVector = TargetCharacter-&gt;<span class="built_in">GetActorLocation</span>() - InstigatorCharacter-&gt;<span class="built_in">GetActorLocation</span>();</span><br><span class="line">		CurrentSplineTime += DeltaTime;<span class="comment">//样条线生成的时间</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//动态调整攻击速度，敌人距离很远的时候攻击速度慢，距离近了攻击速度就快了</span></span><br><span class="line">		<span class="type">float</span> Distance = Spline-&gt;<span class="built_in">GetSplineLength</span>() * (CurrentSplineTime / (DistanceVector.<span class="built_in">Size</span>() / <span class="number">1000.f</span>));<span class="comment">//样条线生成时间/子弹发射到打到敌人身上消耗的时间</span></span><br><span class="line">		<span class="comment">//通过长度获取样条线的位置信息</span></span><br><span class="line">		FVector Loction = Spline-&gt;<span class="built_in">GetWorldLocationAtDistanceAlongSpline</span>(Distance);</span><br><span class="line">		<span class="comment">//通过长度获取样条线的旋转信息</span></span><br><span class="line">		FRotator Rotator = Spline-&gt;<span class="built_in">GetRotationAtDistanceAlongSpline</span>(Distance, ESplineCoordinateSpace::Local);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//更新样条线的位置和旋转信息</span></span><br><span class="line">		<span class="built_in">SetActorLocationAndRotation</span>(Loction, Rotator);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//当样条线和目标距离&lt;= 100.f时</span></span><br><span class="line">		<span class="keyword">if</span> ((Loction - TargetCharacter-&gt;<span class="built_in">GetActorLocation</span>()).<span class="built_in">Size</span>() &lt;= <span class="number">100.f</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//获取碰撞信息</span></span><br><span class="line">				FHitResult SweepResult;</span><br><span class="line">				<span class="comment">//将样条线的位置信息更新给碰撞信息</span></span><br><span class="line">				SweepResult.Location = Loction;</span><br><span class="line">				<span class="comment">//调用函数BeginOverlap生成伤害特效以及生成伤害等</span></span><br><span class="line">				<span class="built_in">BeginOverlap</span>(<span class="literal">nullptr</span>, TargetCharacter, <span class="literal">nullptr</span>, <span class="number">0</span>, <span class="literal">false</span>, SweepResult);</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/09/15/UE4-%E9%A1%B9%E7%9B%AE-TowerDefence-%E9%97%AA%E7%94%B5%E5%AD%90%E5%BC%B9%E4%BC%A4%E5%AE%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="williny">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Williny'home">
      <meta itemprop="description" content="孤独是人生的常态">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Williny'home">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/09/15/UE4-%E9%A1%B9%E7%9B%AE-TowerDefence-%E9%97%AA%E7%94%B5%E5%AD%90%E5%BC%B9%E4%BC%A4%E5%AE%B3/" class="post-title-link" itemprop="url">UE4-项目-TowerDefence-闪电子弹伤害</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-09-15 14:03:10 / 修改时间：14:35:17" itemprop="dateCreated datePublished" datetime="2022-09-15T14:03:10+08:00">2022-09-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/unreal-engine/" itemprop="url" rel="index"><span itemprop="name">unreal engine</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h1><p>塔发出一串雷电，一端在塔的位置上，另一端连接上敌方</p>
<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><h2 id="SpawnEmitterAttached"><a href="#SpawnEmitterAttached" class="headerlink" title="SpawnEmitterAttached()"></a>SpawnEmitterAttached()</h2><p>生成一个例子发射器（粒子特效系统）连接上另一个组件</p>
<h2 id="简略使用方式"><a href="#简略使用方式" class="headerlink" title="简略使用方式"></a>简略使用方式</h2><p><code>SpawnEmitterAttached(要生成的粒子特效，要附加到的组件)</code></p>
<h3 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">UParticleSystemComponent* <span class="title">UGameplayStatics::SpawnEmitterAttached</span><span class="params">(UParticleSystem* EmitterTemplate, USceneComponent* AttachToComponent, FName AttachPointName, FVector Location, FRotator Rotation, FVector Scale, EAttachLocation::Type LocationType, <span class="type">bool</span> bAutoDestroy, EPSCPoolMethod PoolingMethod, <span class="type">bool</span> bAutoActivateSystem)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	UParticleSystemComponent* PSC = <span class="literal">nullptr</span>;</span><br><span class="line">	<span class="keyword">if</span> (EmitterTemplate)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (AttachToComponent == <span class="literal">nullptr</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">UE_LOG</span>(LogScript, Warning, <span class="built_in">TEXT</span>(<span class="string">&quot;UGameplayStatics::SpawnEmitterAttached: NULL AttachComponent specified!&quot;</span>));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			UWorld* <span class="type">const</span> World = AttachToComponent-&gt;<span class="built_in">GetWorld</span>();</span><br><span class="line">			<span class="keyword">if</span> (World &amp;&amp; !World-&gt;<span class="built_in">IsNetMode</span>(NM_DedicatedServer))</span><br><span class="line">			&#123;</span><br><span class="line">				PSC = <span class="built_in">CreateParticleSystem</span>(EmitterTemplate, World, AttachToComponent-&gt;<span class="built_in">GetOwner</span>(), bAutoDestroy, PoolingMethod);</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (PSC != <span class="literal">nullptr</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					PSC-&gt;<span class="built_in">SetupAttachment</span>(AttachToComponent, AttachPointName);</span><br><span class="line"></span><br><span class="line">					<span class="keyword">if</span> (LocationType == EAttachLocation::KeepWorldPosition)</span><br><span class="line">					&#123;</span><br><span class="line">						<span class="type">const</span> FTransform ParentToWorld = AttachToComponent-&gt;<span class="built_in">GetSocketTransform</span>(AttachPointName);</span><br><span class="line">						<span class="function"><span class="type">const</span> FTransform <span class="title">ComponentToWorld</span><span class="params">(Rotation, Location, Scale)</span></span>;</span><br><span class="line">						<span class="type">const</span> FTransform RelativeTM = ComponentToWorld.<span class="built_in">GetRelativeTransform</span>(ParentToWorld);</span><br><span class="line">						PSC-&gt;<span class="built_in">SetRelativeLocation_Direct</span>(RelativeTM.<span class="built_in">GetLocation</span>());</span><br><span class="line">						PSC-&gt;<span class="built_in">SetRelativeRotation_Direct</span>(RelativeTM.<span class="built_in">GetRotation</span>().<span class="built_in">Rotator</span>());</span><br><span class="line">						PSC-&gt;<span class="built_in">SetRelativeScale3D_Direct</span>(RelativeTM.<span class="built_in">GetScale3D</span>());</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span></span><br><span class="line">					&#123;</span><br><span class="line">						PSC-&gt;<span class="built_in">SetRelativeLocation_Direct</span>(Location);</span><br><span class="line">						PSC-&gt;<span class="built_in">SetRelativeRotation_Direct</span>(Rotation);</span><br><span class="line"></span><br><span class="line">						<span class="keyword">if</span> (LocationType == EAttachLocation::SnapToTarget)</span><br><span class="line">						&#123;</span><br><span class="line">							<span class="comment">// SnapToTarget indicates we &quot;keep world scale&quot;, this indicates we we want the inverse of the parent-to-world scale </span></span><br><span class="line">							<span class="comment">// to calculate world scale at Scale 1, and then apply the passed in Scale</span></span><br><span class="line">							<span class="type">const</span> FTransform ParentToWorld = AttachToComponent-&gt;<span class="built_in">GetSocketTransform</span>(AttachPointName);</span><br><span class="line">							PSC-&gt;<span class="built_in">SetRelativeScale3D_Direct</span>(Scale * ParentToWorld.<span class="built_in">GetSafeScaleReciprocal</span>(ParentToWorld.<span class="built_in">GetScale3D</span>()));</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">else</span></span><br><span class="line">						&#123;</span><br><span class="line">							PSC-&gt;<span class="built_in">SetRelativeScale3D_Direct</span>(Scale);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">					PSC-&gt;<span class="built_in">RegisterComponentWithWorld</span>(World);</span><br><span class="line">					<span class="keyword">if</span>(bAutoActivateSystem)</span><br><span class="line">					&#123;</span><br><span class="line">						PSC-&gt;<span class="built_in">ActivateSystem</span>(<span class="literal">true</span>);</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">					<span class="comment">// Notify the texture streamer so that PSC gets managed as a dynamic component.</span></span><br><span class="line">					IStreamingManager::<span class="built_in">Get</span>().<span class="built_in">NotifyPrimitiveUpdated</span>(PSC);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !(UE_BUILD_SHIPPING || UE_BUILD_TEST)</span></span><br><span class="line">					<span class="keyword">if</span> (PSC-&gt;Template &amp;&amp; PSC-&gt;Template-&gt;<span class="built_in">IsImmortal</span>())</span><br><span class="line">					&#123;</span><br><span class="line">						<span class="type">const</span> FString OnScreenMessage = FString::<span class="built_in">Printf</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;SpawnEmitterAttached spawned potentially immortal particle system! %s (%s) may stay in world despite never spawning particles after burst spawning is over.&quot;</span>), *(PSC-&gt;<span class="built_in">GetPathName</span>()), *(PSC-&gt;Template-&gt;<span class="built_in">GetName</span>()));</span><br><span class="line">						GEngine-&gt;<span class="built_in">AddOnScreenDebugMessage</span>((uint64)((PTRINT)AttachToComponent), <span class="number">3.f</span>, FColor::Red, OnScreenMessage);</span><br><span class="line">						<span class="built_in">UE_LOG</span>(LogParticles, Log, <span class="built_in">TEXT</span>(<span class="string">&quot;GameplayStatics::SpawnEmitterAttached spawned potentially immortal particle system! %s (%s) may stay in world despite never spawning particles after burst spawning is over.&quot;</span>),</span><br><span class="line">							*(PSC-&gt;<span class="built_in">GetPathName</span>()), *(PSC-&gt;Template-&gt;<span class="built_in">GetPathName</span>())</span><br><span class="line">						);</span><br><span class="line">					&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> PSC;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="GetChildrenComponents"><a href="#GetChildrenComponents" class="headerlink" title="GetChildrenComponents()"></a>GetChildrenComponents()</h2><p><code>GetChildrenComponents(是否包含所有子类,将子类添加进的数组)</code></p>
<p>获取该组件的所有子组件，并添加到第二个参数中</p>
<h3 id="源代码-1"><a href="#源代码-1" class="headerlink" title="源代码"></a>源代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">USceneComponent::GetChildrenComponents</span><span class="params">(<span class="type">bool</span> bIncludeAllDescendants, TArray&lt;USceneComponent*&gt;&amp; Children)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Children.<span class="built_in">Reset</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (bIncludeAllDescendants)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">AppendDescendants</span>(Children);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">const</span> TArray&lt;USceneComponent*&gt;&amp; AttachedChildren = <span class="built_in">GetAttachChildren</span>();</span><br><span class="line">		Children.<span class="built_in">Reserve</span>(AttachedChildren.<span class="built_in">Num</span>());</span><br><span class="line">		<span class="keyword">for</span> (USceneComponent* Child : AttachedChildren)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (Child)</span><br><span class="line">			&#123;</span><br><span class="line">				Children.<span class="built_in">Add</span>(Child);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="ParticleSystem-gt-SetBeamSourcePoint"><a href="#ParticleSystem-gt-SetBeamSourcePoint" class="headerlink" title="ParticleSystem-&gt;SetBeamSourcePoint()"></a>ParticleSystem-&gt;SetBeamSourcePoint()</h2><p>设置特效的出发点</p>
<p><code>SetBeamSourcePoint(发射器index，出发点位置，特效index)</code></p>
<h3 id="源代码-2"><a href="#源代码-2" class="headerlink" title="源代码"></a>源代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UParticleSystemComponent::SetBeamSourcePoint</span><span class="params">(int32 EmitterIndex,FVector NewSourcePoint,int32 SourceIndex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">ForceAsyncWorkCompletion</span>(STALL);</span><br><span class="line">	<span class="keyword">if</span> ((EmitterIndex &gt;= <span class="number">0</span>) &amp;&amp; (EmitterIndex &lt; EmitterInstances.<span class="built_in">Num</span>()))</span><br><span class="line">	&#123;</span><br><span class="line">		FParticleEmitterInstance* EmitterInst = EmitterInstances[EmitterIndex];</span><br><span class="line">		<span class="keyword">if</span> (EmitterInst)</span><br><span class="line">		&#123;</span><br><span class="line">			EmitterInst-&gt;<span class="built_in">SetBeamSourcePoint</span>(NewSourcePoint, SourceIndex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ParticleSystem-gt-SetBeamTargetPoint"><a href="#ParticleSystem-gt-SetBeamTargetPoint" class="headerlink" title="ParticleSystem-&gt;SetBeamTargetPoint()"></a>ParticleSystem-&gt;SetBeamTargetPoint()</h3><p>设置粒子特效的终点</p>
<p><code>SetBeamTargetPoint(发射器index，出发点位置，特效index)</code></p>
<h4 id="源代码-3"><a href="#源代码-3" class="headerlink" title="源代码"></a>源代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UParticleSystemComponent::SetBeamTargetPoint</span><span class="params">(int32 EmitterIndex,FVector NewTargetPoint,int32 TargetIndex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">ForceAsyncWorkCompletion</span>(STALL);</span><br><span class="line">	<span class="keyword">if</span> ((EmitterIndex &gt;= <span class="number">0</span>) &amp;&amp; (EmitterIndex &lt; EmitterInstances.<span class="built_in">Num</span>()))</span><br><span class="line">	&#123;</span><br><span class="line">		FParticleEmitterInstance* EmitterInst = EmitterInstances[EmitterIndex];</span><br><span class="line">		<span class="keyword">if</span> (EmitterInst)</span><br><span class="line">		&#123;</span><br><span class="line">			EmitterInst-&gt;<span class="built_in">SetBeamTargetPoint</span>(NewTargetPoint, TargetIndex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="大致思路"><a href="#大致思路" class="headerlink" title="大致思路"></a>大致思路</h1><ol>
<li><p>初始化这个子弹</p>
<ul>
<li><p>同样，子弹发射之后停留在原地不动，所以需要停止其移动<code>StopMovementImmediately()</code></p>
</li>
<li><p>取消子弹的球形碰撞组件的碰撞</p>
</li>
<li><p>使用函数<code>SpawnEmitterAttached()</code>在子弹位置生成特效，并且另一端连接到目标的追踪点上</p>
</li>
</ul>
</li>
<li><p>因为闪电时动态特效，所以我们需要在<code>Tick</code>内刷新它的初始点和终点</p>
<ul>
<li><p>在<code>Tick</code>内遍历子弹的类型，如果是闪电类型</p>
</li>
<li><p>创建一个场景组件组成的数组<code>TArray&lt;USceneComponent*&gt; SceneComponent</code></p>
</li>
<li><p>获取根组件的所有孩子组件<code>GetChildrenComponents()</code>，将结果添加到<code>SceneComponent</code>中</p>
</li>
<li><p>遍历这个数组，如果<code>SceneComponent</code>中的元素是<code>UParticleSystemComponent</code>类型</p>
</li>
<li><p>则设置这个特效的出发点和终点</p>
</li>
</ul>
</li>
</ol>
<h1 id="部分代码"><a href="#部分代码" class="headerlink" title="部分代码"></a>部分代码</h1><h3 id="初始化子弹（构造函数内）代码"><a href="#初始化子弹（构造函数内）代码" class="headerlink" title="初始化子弹（构造函数内）代码"></a>初始化子弹（构造函数内）代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> EBulletType::BULLET_CHAIN:</span><br><span class="line">&#123;	</span><br><span class="line">	ProjectileMovement-&gt;<span class="built_in">StopMovementImmediately</span>();</span><br><span class="line">	BoxDamage-&gt;<span class="built_in">SetCollisionEnabled</span>(ECollisionEnabled::NoCollision);</span><br><span class="line">	UGameplayStatics::<span class="built_in">SpawnEmitterAttached</span>(DamgageParticle, TargetCharacter-&gt;<span class="built_in">GetHomingPoint</span>());</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="更新闪电特效（Tick函数内）代码"><a href="#更新闪电特效（Tick函数内）代码" class="headerlink" title="更新闪电特效（Tick函数内）代码"></a>更新闪电特效（Tick函数内）代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> EBulletType::BULLET_CHAIN:</span><br><span class="line">&#123;</span><br><span class="line">	TArray&lt;USceneComponent*&gt; SceneComponent;</span><br><span class="line">	RootComponent-&gt;<span class="built_in">GetChildrenComponents</span>(<span class="literal">true</span><span class="comment">/*true包括所有子类*/</span>, SceneComponent);<span class="comment">//遍历附加在根组件的所有组件，将其中的组件添加到SceneComponent中</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; Tmp : SceneComponent)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (UParticleSystemComponent* ParticleSystem = <span class="built_in">Cast</span>&lt;UParticleSystemComponent&gt;(Tmp))<span class="comment">//判断SceneComponent中是否存在UParticleSystemComponent类型</span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="comment">//设置特效的出发点</span></span><br><span class="line">					ParticleSystem-&gt;<span class="built_in">SetBeamSourcePoint</span>(<span class="number">0</span><span class="comment">/*发射器的index*/</span>, InstigatorCharacter-&gt;<span class="built_in">GetFirePoint</span>()-&gt;<span class="built_in">GetComponentLocation</span>(), <span class="number">0</span><span class="comment">/*光束index*/</span>);</span><br><span class="line">					<span class="comment">//设置特效的终点</span></span><br><span class="line">					ParticleSystem-&gt;<span class="built_in">SetBeamTargetPoint</span>(<span class="number">0</span>, TargetCharacter-&gt;<span class="built_in">GetHomingPoint</span>()-&gt;<span class="built_in">GetComponentLocation</span>(), <span class="number">0</span>);</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/09/14/UE4-%E9%A1%B9%E7%9B%AE-TowerDefence-%E7%89%A9%E7%90%86%E5%AE%9E%E7%8E%B0%E4%B8%A2%E6%89%8B%E9%9B%B7%E6%95%88%E6%9E%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="williny">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Williny'home">
      <meta itemprop="description" content="孤独是人生的常态">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Williny'home">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/09/14/UE4-%E9%A1%B9%E7%9B%AE-TowerDefence-%E7%89%A9%E7%90%86%E5%AE%9E%E7%8E%B0%E4%B8%A2%E6%89%8B%E9%9B%B7%E6%95%88%E6%9E%9C/" class="post-title-link" itemprop="url">UE4-项目-TowerDefence-物理实现丢手雷效果</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-09-14 16:00:59 / 修改时间：16:32:45" itemprop="dateCreated datePublished" datetime="2022-09-14T16:00:59+08:00">2022-09-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/unreal-engine/" itemprop="url" rel="index"><span itemprop="name">unreal engine</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><h2 id="FMath-Sqrt"><a href="#FMath-Sqrt" class="headerlink" title="FMath::Sqrt()"></a>FMath::Sqrt()</h2><p>开根号</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> V = FMath::<span class="built_in">Sqrt</span>(X * X + Y * Y);</span><br></pre></td></tr></table></figure>

<h2 id="FMath-Acos"><a href="#FMath-Acos" class="headerlink" title="FMath::Acos()"></a>FMath::Acos()</h2><p>根据两个夹角求夹角之间的弧度</p>
<h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> CosRadian = FMath::<span class="built_in">Acos</span>(A/B)</span><br></pre></td></tr></table></figure>

<h2 id="弧度转换为角度"><a href="#弧度转换为角度" class="headerlink" title="弧度转换为角度"></a>弧度转换为角度</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CosRadian<span class="comment">/*弧度*/</span> * (<span class="number">180</span> / PI);</span><br></pre></td></tr></table></figure>



<h1 id="大致思路"><a href="#大致思路" class="headerlink" title="大致思路"></a>大致思路</h1><ol>
<li><p>根据物理来模拟丢手雷效果，则需要开启子弹的重力效果</p>
</li>
<li><p>求解量</p>
<ul>
<li>子弹发射方向与水平线之间的夹角</li>
</ul>
</li>
<li><p>已知量&#x2F;易得量</p>
<ul>
<li><p>施法者与目标之间的距离</p>
<ul>
<li><code>FVector TargetFormOwnerVector = TargetCharacter-&gt;GetActorLocation() - GetActorLocation();</code></li>
</ul>
</li>
<li><p>子弹在路上的时间&#x3D;距离&#x2F;子弹初速度</p>
<ul>
<li><code>float InTime = (TargetFormOwnerVector.Size() / ProjectileMovement-&gt;InitialSpeed);</code></li>
</ul>
</li>
<li><p>获取抛射物Z轴的垂直距离&#x3D;Z轴重力*时间</p>
<ul>
<li><code>float Y = ProjectileMovement-&gt;GetGravityZ() * InTime;</code></li>
</ul>
</li>
<li><p>获取抛射物的水平距离&#x3D;水平初速度速度*时间</p>
<ul>
<li><code>float X = ProjectileMovement-&gt;InitialSpeed * InTime;</code></li>
</ul>
</li>
<li><p>勾股定理获取XY的斜边</p>
<ul>
<li><code>float V = FMath::Sqrt(X * X + Y * Y);</code></li>
</ul>
</li>
<li><p>求出V与水平速度的夹角cos值，再由Acos()转换为弧度CosRadian，PI为圆周率</p>
<ul>
<li><code>float CosRadian = FMath::Acos(TargetFormOwnerVector.Size() / V * (InTime * (PI * 0.1f)/*用于修正子弹初始位置与目标位置之间连线不是水平于地面的*/));</code></li>
</ul>
</li>
<li><p>获取子弹发射方向与水平线之间的夹角</p>
<ul>
<li><code>CosRadian * (180 / PI);</code></li>
</ul>
</li>
</ul>
</li>
<li><p>获取子弹的旋转信息，将<code>CosRadian * (180 / PI);</code>传入旋转信息的<code>Pitch</code>值内</p>
</li>
<li><p>设置子弹的旋转信息</p>
</li>
<li><p>重新设置子弹速度</p>
</li>
</ol>
<h1 id="部分代码"><a href="#部分代码" class="headerlink" title="部分代码"></a>部分代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> EBulletType::BULLET_RANGE_LINE:</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//先暂时取消初速度，不然直接就直线射击出去了</span></span><br><span class="line">	ProjectileMovement-&gt;<span class="built_in">StopMovementImmediately</span>();</span><br><span class="line">	<span class="comment">//开启子弹重力</span></span><br><span class="line">	ProjectileMovement-&gt;ProjectileGravityScale = <span class="number">1.f</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//目标位置和子弹生成位置之间的距离</span></span><br><span class="line">	FVector TargetFormOwnerVector = TargetCharacter-&gt;<span class="built_in">GetActorLocation</span>() - <span class="built_in">GetActorLocation</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//子弹在路上的时间=距离/子弹速度</span></span><br><span class="line">	<span class="type">float</span> InTime = (TargetFormOwnerVector.<span class="built_in">Size</span>() / ProjectileMovement-&gt;InitialSpeed);</span><br><span class="line">	<span class="comment">//获取抛射物Z轴的垂直距离=Z轴重力*时间</span></span><br><span class="line">	<span class="type">float</span> Y = ProjectileMovement-&gt;<span class="built_in">GetGravityZ</span>() * InTime;</span><br><span class="line">	<span class="comment">//获取抛射物的水平距离=水平初速度速度*时间</span></span><br><span class="line">	<span class="type">float</span> X = ProjectileMovement-&gt;InitialSpeed * InTime;</span><br><span class="line">	<span class="comment">//勾股定理获取XY的斜边</span></span><br><span class="line">	<span class="type">float</span> V = FMath::<span class="built_in">Sqrt</span>(X * X + Y * Y);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//此公式可推导出来，求出V与水平速度的夹角cos值，再由Acos()转换为弧度CosRadian</span></span><br><span class="line">	<span class="comment">//PI为圆周率</span></span><br><span class="line">	<span class="type">float</span> CosRadian = FMath::<span class="built_in">Acos</span>(TargetFormOwnerVector.<span class="built_in">Size</span>() / V * (InTime * (PI * <span class="number">0.1f</span>)<span class="comment">/*用于修正子弹初始位置与目标位置之间连线不是水平于地面的*/</span>));</span><br><span class="line">	FRotator Rot = <span class="built_in">GetActorRotation</span>();</span><br><span class="line">	<span class="comment">//弧度转换为角度</span></span><br><span class="line">	Rot.Pitch = CosRadian * (<span class="number">180</span> / PI);</span><br><span class="line">	<span class="comment">//设置子弹初始抛射角度</span></span><br><span class="line">	<span class="built_in">SetActorRotation</span>(Rot);</span><br><span class="line">	<span class="comment">//重新设置速度，此时抛射角度已经设定好了，所以发射之后就是抛出状态</span></span><br><span class="line">	ProjectileMovement-&gt;<span class="built_in">SetVelocityInLocalSpace</span>(<span class="built_in">FVector</span>(<span class="number">1.0f</span>, <span class="number">0.f</span>, <span class="number">0.f</span>) * ProjectileMovement-&gt;InitialSpeed);</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/09/14/UE4-%E9%A1%B9%E7%9B%AE-TowerDefence-%E5%AD%90%E5%BC%B9%E8%8C%83%E5%9B%B4%E4%BC%A4%E5%AE%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="williny">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Williny'home">
      <meta itemprop="description" content="孤独是人生的常态">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Williny'home">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/09/14/UE4-%E9%A1%B9%E7%9B%AE-TowerDefence-%E5%AD%90%E5%BC%B9%E8%8C%83%E5%9B%B4%E4%BC%A4%E5%AE%B3/" class="post-title-link" itemprop="url">UE4-项目-TowerDefence-子弹范围伤害</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-09-14 15:08:31 / 修改时间：16:00:12" itemprop="dateCreated datePublished" datetime="2022-09-14T15:08:31+08:00">2022-09-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/unreal-engine/" itemprop="url" rel="index"><span itemprop="name">unreal engine</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h1><p>说是子弹范围伤害，其实不然，应该说是以塔为圆心，设定一个半径，在这个圆之内存在范围伤害。</p>
<p>但也可以引申到范围伤害子弹上。</p>
<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><h2 id="UGameplayStatics-ApplyRadialDamageWithFalloff"><a href="#UGameplayStatics-ApplyRadialDamageWithFalloff" class="headerlink" title="UGameplayStatics::ApplyRadialDamageWithFalloff()"></a>UGameplayStatics::ApplyRadialDamageWithFalloff()</h2><p>带范围衰减的范围伤害，本质上是两个同心圆，内圆伤害高，外圆伤害递减</p>
<p><code>ApplyRadialDamageWithFalloff(生成关卡,最大伤害,最小伤害,伤害圆心点,内圆半径,外圆半径，伤害衰减系数，伤害类型，友方类，施法者)</code></p>
<h3 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">UGameplayStatics::ApplyRadialDamageWithFalloff</span><span class="params">(<span class="type">const</span> UObject* WorldContextObject, <span class="type">float</span> BaseDamage, <span class="type">float</span> MinimumDamage, <span class="type">const</span> FVector&amp; Origin, <span class="type">float</span> DamageInnerRadius, <span class="type">float</span> DamageOuterRadius, <span class="type">float</span> DamageFalloff, TSubclassOf&lt;<span class="keyword">class</span> UDamageType&gt; DamageTypeClass, <span class="type">const</span> TArray&lt;AActor*&gt;&amp; IgnoreActors, AActor* DamageCauser, AController* InstigatedByController, ECollisionChannel DamagePreventionChannel)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">FCollisionQueryParams <span class="title">SphereParams</span><span class="params">(SCENE_QUERY_STAT(ApplyRadialDamage),  <span class="literal">false</span>, DamageCauser)</span></span>;</span><br><span class="line"></span><br><span class="line">    SphereParams.<span class="built_in">AddIgnoredActors</span>(IgnoreActors);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// query scene to see what we hit</span></span><br><span class="line">    TArray&lt;FOverlapResult&gt; Overlaps;</span><br><span class="line">    <span class="keyword">if</span> (UWorld* World = GEngine-&gt;<span class="built_in">GetWorldFromContextObject</span>(WorldContextObject, EGetWorldErrorMode::LogAndReturnNull))</span><br><span class="line">    &#123;</span><br><span class="line">        World-&gt;<span class="built_in">OverlapMultiByObjectType</span>(Overlaps, Origin, FQuat::Identity, <span class="built_in">FCollisionObjectQueryParams</span>(FCollisionObjectQueryParams::InitType::AllDynamicObjects), FCollisionShape::<span class="built_in">MakeSphere</span>(DamageOuterRadius), SphereParams);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// collate into per-actor list of hit components</span></span><br><span class="line">    TMap&lt;AActor*, TArray&lt;FHitResult&gt; &gt; OverlapComponentMap;</span><br><span class="line">    <span class="keyword">for</span> (int32 Idx = <span class="number">0</span>; Idx &lt; Overlaps.<span class="built_in">Num</span>(); ++Idx)</span><br><span class="line">    &#123;</span><br><span class="line">        FOverlapResult <span class="type">const</span>&amp; Overlap = Overlaps[Idx];</span><br><span class="line">        AActor* <span class="type">const</span> OverlapActor = Overlap.<span class="built_in">GetActor</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (OverlapActor &amp;&amp;</span><br><span class="line">            OverlapActor-&gt;<span class="built_in">CanBeDamaged</span>() &amp;&amp;</span><br><span class="line">            OverlapActor != DamageCauser &amp;&amp;</span><br><span class="line">            Overlap.Component.<span class="built_in">IsValid</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            FHitResult Hit;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">ComponentIsDamageableFrom</span>(Overlap.Component.<span class="built_in">Get</span>(), Origin, DamageCauser, IgnoreActors, DamagePreventionChannel, Hit))</span><br><span class="line">            &#123;</span><br><span class="line">                TArray&lt;FHitResult&gt;&amp; HitList = OverlapComponentMap.<span class="built_in">FindOrAdd</span>(OverlapActor);</span><br><span class="line">                HitList.<span class="built_in">Add</span>(Hit);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> bAppliedDamage = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (OverlapComponentMap.<span class="built_in">Num</span>() &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// make sure we have a good damage type</span></span><br><span class="line">        TSubclassOf&lt;UDamageType&gt; <span class="type">const</span> ValidDamageTypeClass = DamageTypeClass ? DamageTypeClass : <span class="built_in">TSubclassOf</span>&lt;UDamageType&gt;(UDamageType::<span class="built_in">StaticClass</span>());</span><br><span class="line"></span><br><span class="line">        FRadialDamageEvent DmgEvent;</span><br><span class="line">        DmgEvent.DamageTypeClass = ValidDamageTypeClass;</span><br><span class="line">        DmgEvent.Origin = Origin;</span><br><span class="line">        DmgEvent.Params = <span class="built_in">FRadialDamageParams</span>(BaseDamage, MinimumDamage, DamageInnerRadius, DamageOuterRadius, DamageFalloff);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// call damage function on each affected actors</span></span><br><span class="line">        <span class="keyword">for</span> (TMap&lt;AActor*, TArray&lt;FHitResult&gt; &gt;::TIterator <span class="built_in">It</span>(OverlapComponentMap); It; ++It)</span><br><span class="line">        &#123;</span><br><span class="line">            AActor* <span class="type">const</span> Victim = It.<span class="built_in">Key</span>();</span><br><span class="line">            TArray&lt;FHitResult&gt; <span class="type">const</span>&amp; ComponentHits = It.<span class="built_in">Value</span>();</span><br><span class="line">            DmgEvent.ComponentHits = ComponentHits;</span><br><span class="line"></span><br><span class="line">            Victim-&gt;<span class="built_in">TakeDamage</span>(BaseDamage, DmgEvent, InstigatedByController, DamageCauser);</span><br><span class="line"></span><br><span class="line">            bAppliedDamage = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bAppliedDamage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h1><ol>
<li><p>取消子弹的初速度，碰撞也需要取消，写一个函数，专门实现范围伤害，在<code>BeginPlay()</code>时调用该函数</p>
</li>
<li><p>存在一个函数<code>UGameplayStatics::ApplyRadialDamageWithFalloff()</code>可以直接施加范围衰减伤害</p>
</li>
<li><p>范围伤害函数，计算施法者和敌方之间的距离，小于一定值时遍历关卡中所有<code>Character</code>，如果是友方，则添加到一个友方数组中，如果是敌方，则添加到敌方数组中</p>
</li>
<li><p>使用<code>UGameplayStatics::ApplyRadialDamageWithFalloff()</code>函数</p>
</li>
</ol>
<h1 id="部分代码"><a href="#部分代码" class="headerlink" title="部分代码"></a>部分代码</h1><h3 id="范围伤害代码实现"><a href="#范围伤害代码实现" class="headerlink" title="范围伤害代码实现"></a>范围伤害代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在.h文件中需要声明该函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ARuleOfTheBullet::RadialDamage</span><span class="params">(<span class="type">const</span> FVector&amp; Origin<span class="comment">/*圆心点*/</span>, ARuleOfTheCharacter* InstigatorCharacter<span class="comment">/*施法者*/</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	FActorSpawnParameters ActorSpawnParameters;</span><br><span class="line">	<span class="keyword">if</span> (InstigatorCharacter)<span class="comment">//判断施法者是否有效</span></span><br><span class="line">	&#123;</span><br><span class="line">		TArray&lt;AActor*&gt; IngoreActors;<span class="comment">//友方类数组，用于忽略伤害</span></span><br><span class="line">		TArray&lt;ARuleOfTheCharacter*&gt; TargetActors;<span class="comment">//目标类数组，施加伤害</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//迭代器遍历关卡中的所有ARuleOfTheCharacter类</span></span><br><span class="line">		<span class="keyword">for</span> (TActorIterator&lt;ARuleOfTheCharacter&gt;<span class="built_in">it</span>(<span class="built_in">GetWorld</span>(), ARuleOfTheCharacter::<span class="built_in">StaticClass</span>()); it; ++it)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//TheCharacter用于存储敌方</span></span><br><span class="line">			<span class="keyword">if</span> (ARuleOfTheCharacter* TheCharacter = *it)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//计算施法者与敌方之间的距离</span></span><br><span class="line">				FVector VDistance = TheCharacter-&gt;<span class="built_in">GetActorLocation</span>() - InstigatorCharacter-&gt;<span class="built_in">GetActorLocation</span>();</span><br><span class="line"></span><br><span class="line">				<span class="comment">//如果距离不超过1400即可进攻</span></span><br><span class="line">				<span class="keyword">if</span> (VDistance.<span class="built_in">Size</span>() &lt;= <span class="number">1400</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="comment">//判断敌方是否为敌方</span></span><br><span class="line">					<span class="keyword">if</span> (TheCharacter-&gt;<span class="built_in">IsTeam</span>() == InstigatorCharacter-&gt;<span class="built_in">IsTeam</span>())</span><br><span class="line">					&#123;</span><br><span class="line">						<span class="comment">//不是敌方则添加进友方类数组</span></span><br><span class="line">						IngoreActors.<span class="built_in">Add</span>(TheCharacter);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span></span><br><span class="line">					&#123;</span><br><span class="line">						<span class="comment">//是敌方则添加进目标类数组</span></span><br><span class="line">						TargetActors.<span class="built_in">Add</span>(TheCharacter);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//半径衰减范围伤害</span></span><br><span class="line">		UGameplayStatics::<span class="built_in">ApplyRadialDamageWithFalloff</span></span><br><span class="line">		(</span><br><span class="line">			<span class="built_in">GetWorld</span>()<span class="comment">/*关卡*/</span>,</span><br><span class="line">			<span class="number">100.f</span><span class="comment">/*最大伤害*/</span>,</span><br><span class="line">			<span class="number">10.f</span><span class="comment">/*最小伤害*/</span>,</span><br><span class="line">			Origin<span class="comment">/*伤害圆心点*/</span>,</span><br><span class="line">			<span class="number">400.f</span><span class="comment">/*内圆半径*/</span>,</span><br><span class="line">			<span class="number">1000.f</span><span class="comment">/*外圆半径*/</span>,</span><br><span class="line">			<span class="number">1.f</span><span class="comment">/*伤害衰减系数*/</span>,</span><br><span class="line">			UDamageType::<span class="built_in">StaticClass</span>()<span class="comment">/*伤害类型*/</span>,</span><br><span class="line">			IngoreActors<span class="comment">/*友方Actor*/</span>,</span><br><span class="line">			ActorSpawnParameters.Instigator<span class="comment">/*施法者*/</span></span><br><span class="line">		);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="调用RadialDamage-函数"><a href="#调用RadialDamage-函数" class="headerlink" title="调用RadialDamage()函数"></a>调用RadialDamage()函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> EBulletType::BULLET_RANGE:</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//停下子弹的移动</span></span><br><span class="line">	ProjectileMovement-&gt;<span class="built_in">StopMovementImmediately</span>();</span><br><span class="line">	<span class="comment">//设置碰撞为无</span></span><br><span class="line">	BoxDamage-&gt;<span class="built_in">SetCollisionEnabled</span>(ECollisionEnabled::NoCollision);</span><br><span class="line">	<span class="comment">//调用自定义函数RadialDamage(圆心位置，施法者)</span></span><br><span class="line">	<span class="built_in">RadialDamage</span>(<span class="built_in">GetActorLocation</span>(), <span class="built_in">Cast</span>&lt;ARuleOfTheCharacter&gt;(ActorSpawnParameters.Instigator));</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完整的子弹代码放在写完几种子弹类型最后面，不然代码量实在是太大了</p>
<h1 id="加载子弹"><a href="#加载子弹" class="headerlink" title="加载子弹"></a>加载子弹</h1><ol>
<li><p>在子弹的蓝图类中修改子弹类型</p>
</li>
<li><p>在塔的攻击动画中，调用动画通知，指定生成类为该子弹蓝图类</p>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/09/12/UE4-%E9%A1%B9%E7%9B%AE-TowerDefence-%E5%AD%90%E5%BC%B9%E8%B7%9F%E8%B8%AA%E8%AE%BE%E8%AE%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="williny">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Williny'home">
      <meta itemprop="description" content="孤独是人生的常态">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Williny'home">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/09/12/UE4-%E9%A1%B9%E7%9B%AE-TowerDefence-%E5%AD%90%E5%BC%B9%E8%B7%9F%E8%B8%AA%E8%AE%BE%E8%AE%A1/" class="post-title-link" itemprop="url">UE4-项目-TowerDefence-子弹跟踪设计</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-09-12 15:50:14 / 修改时间：16:22:18" itemprop="dateCreated datePublished" datetime="2022-09-12T15:50:14+08:00">2022-09-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/unreal-engine/" itemprop="url" rel="index"><span itemprop="name">unreal engine</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="不同类型子弹的不同功能"><a href="#不同类型子弹的不同功能" class="headerlink" title="不同类型子弹的不同功能"></a>不同类型子弹的不同功能</h1><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><h3 id="UProjectileMovementComponent"><a href="#UProjectileMovementComponent" class="headerlink" title="UProjectileMovementComponent"></a>UProjectileMovementComponent</h3><p>子弹移动组件，在此介绍一些成员变量以及函数</p>
<p>先声明<code>UProjectileMovementComponent</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UPROPERTY</span>(VisibleAnywhere, BlueprintReadOnly, Category = <span class="string">&quot;BaseAttrubute&quot;</span>, meta = (AllowPrivateAccess = <span class="string">&quot;true&quot;</span>))</span><br><span class="line">		<span class="keyword">class</span> <span class="title class_">UProjectileMovementComponent</span>* ProjectileMovement;</span><br></pre></td></tr></table></figure>

<h4 id="ProjectileMovement-gt-StopMovementImmediately"><a href="#ProjectileMovement-gt-StopMovementImmediately" class="headerlink" title="ProjectileMovement-&gt;StopMovementImmediately()"></a>ProjectileMovement-&gt;StopMovementImmediately()</h4><p>立即停止移动</p>
<h4 id="ProjectileMovement-gt-bIsHomingProjectile-x3D-true"><a href="#ProjectileMovement-gt-bIsHomingProjectile-x3D-true" class="headerlink" title="ProjectileMovement-&gt;bIsHomingProjectile &#x3D; true"></a>ProjectileMovement-&gt;bIsHomingProjectile &#x3D; true</h4><p>开启跟踪</p>
<h4 id="ProjectileMovement-gt-bRotationFollowsVelocity-x3D-true"><a href="#ProjectileMovement-gt-bRotationFollowsVelocity-x3D-true" class="headerlink" title="ProjectileMovement-&gt;bRotationFollowsVelocity &#x3D; true"></a>ProjectileMovement-&gt;bRotationFollowsVelocity &#x3D; true</h4><p>旋转方向跟随速度方向进行旋转，使得子弹的拖尾特效效果正常</p>
<h4 id="ProjectileMovement-gt-HomingAccelerationMagnitude-x3D-4000-f"><a href="#ProjectileMovement-gt-HomingAccelerationMagnitude-x3D-4000-f" class="headerlink" title="ProjectileMovement-&gt;HomingAccelerationMagnitude &#x3D; 4000.f"></a>ProjectileMovement-&gt;HomingAccelerationMagnitude &#x3D; 4000.f</h4><p>设置跟踪导航的加速度</p>
<h4 id="ProjectileMovement-gt-HomingTargetComponent-x3D-TargetCharacter-gt-GetHomingPoint"><a href="#ProjectileMovement-gt-HomingTargetComponent-x3D-TargetCharacter-gt-GetHomingPoint" class="headerlink" title="ProjectileMovement-&gt;HomingTargetComponent &#x3D; TargetCharacter-&gt;GetHomingPoint()"></a>ProjectileMovement-&gt;HomingTargetComponent &#x3D; TargetCharacter-&gt;GetHomingPoint()</h4><p>设置跟踪方向是目标身上的跟踪点</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol>
<li><p>在子弹的<code>BeginPlay()</code>函数中遍历子弹类型</p>
</li>
<li><p><code>BULLET_DIRECT_LINE</code>无障碍直线攻击，则通过函数<code>UGameplayStatics::SpawnEmitterAtLocation</code>在Actor位置生成OpenFireParticle特效</p>
</li>
<li><p><code>BULLET_LINE</code>非跟踪类型，类似手枪子弹类型，同上</p>
</li>
<li><p><code>BULLET_TRACK_LINE</code>跟踪类型，等会再说</p>
</li>
<li><p><code>BULLET_RANGE</code>范围伤害，类似自爆；调用子弹移动组件<code>ProjectileMovement</code>的成员函数<code>StopMovementImmediately()</code>立即停止移动</p>
</li>
<li><p><code>BULLET_CHAIN</code>链条类型，持续伤害类型；调用子弹移动组件<code>ProjectileMovement</code>的成员函数<code>StopMovementImmediately()</code>立即停止移动，调用球形碰撞组件<code>BoxDamage</code>成员函数<code>SetCollisionEnabled()</code>设置碰撞类型为<code>ECollisionEnabled::NoCollision</code>无碰撞</p>
</li>
</ol>
<h1 id="子弹的跟踪逻辑"><a href="#子弹的跟踪逻辑" class="headerlink" title="子弹的跟踪逻辑"></a>子弹的跟踪逻辑</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><ol>
<li><p>遍历子弹类型，如果是跟踪类型则首先通过函数<code>UGameplayStatics::SpawnEmitterAtLocation</code>在Actor位置生成OpenFireParticle特效</p>
</li>
<li><p>调用<code>ProjectileMovement</code>的成员变量<code>bIsHomingProjectile</code>设置为<code>true</code>，开启跟踪</p>
</li>
<li><p>调用<code>ProjectileMovement</code>的成员变量<code>bRotationFollowsVelocity</code>设置为<code>true</code>，旋转方向跟随速度方向进行旋转，使得子弹的拖尾特效效果正常</p>
</li>
<li><p>声明一个<code>FActorSpawnParameters</code>类型变量<code>ActorSpawnParameters</code>，并且获取其成员变量<code>Instigator</code>得到施法者，获取施法者的<code>Character</code>以及<code>Controller</code></p>
</li>
<li><p>通过施法者的<code>Controller</code>获取其攻击目标<code>Target.Get()</code></p>
</li>
<li><p>设置<code>ProjectileMovement</code>的成员变量<code>HomingAccelerationMagnitude</code>为<code>4000.f</code>，也就是其跟踪时的加速度</p>
</li>
<li><p>设置跟踪目标则调用<code>ProjectileMovement</code>的成员变量<code>HomingTargetComponent</code>为<code>TargetCharacter-&gt;GetHomingPoint()</code></p>
</li>
<li><p>最后就是设置子弹的碰撞预设和碰撞通道了</p>
<ul>
<li><p>给子弹添加一个碰撞预设和碰撞通道</p>
</li>
<li><p>修改基类的即可</p>
</li>
</ul>
</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="RuleOfTheBullet-h"><a href="#RuleOfTheBullet-h" class="headerlink" title="RuleOfTheBullet.h"></a>RuleOfTheBullet.h</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CoreMinimal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GameFramework/Actor.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;TowerDefence\TowerDefenceType.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;RuleOfTheBullet.generated.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TOWERDEFENCE_API</span> ARuleOfTheBullet : <span class="keyword">public</span> AActor</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//碰撞盒子</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(VisibleAnywhere, BlueprintReadOnly, Category = <span class="string">&quot;BaseAttrubute&quot;</span>, meta = (AllowPrivateAccess = <span class="string">&quot;true&quot;</span>))</span><br><span class="line">		<span class="keyword">class</span> <span class="title class_">USphereComponent</span>* BoxDamage;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//作为根组件</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(VisibleAnywhere, BlueprintReadOnly, Category = <span class="string">&quot;BaseAttrubute&quot;</span>, meta = (AllowPrivateAccess = <span class="string">&quot;true&quot;</span>))</span><br><span class="line">		<span class="keyword">class</span> <span class="title class_">USceneComponent</span>* RootBullet;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//具有移动属性的组件</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(VisibleAnywhere, BlueprintReadOnly, Category = <span class="string">&quot;BaseAttrubute&quot;</span>, meta = (AllowPrivateAccess = <span class="string">&quot;true&quot;</span>))</span><br><span class="line">		<span class="keyword">class</span> <span class="title class_">UProjectileMovementComponent</span>* ProjectileMovement;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"><span class="keyword">public</span>:	</span><br><span class="line">	<span class="comment">//技能类型</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(EditDefaultsOnly, Category = <span class="string">&quot;Bullet&quot;</span>)</span><br><span class="line">		TEnumAsByte&lt;EBulletType&gt; BulletType;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//子弹的伤害特效(碰撞后产生的特效)</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(EditDefaultsOnly, Category = <span class="string">&quot;Bullet&quot;</span>)</span><br><span class="line">		UParticleSystem* DamgageParticle;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//开火特效</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(EditDefaultsOnly, Category = <span class="string">&quot;Bullet&quot;</span>)</span><br><span class="line">		UParticleSystem* OpenFireParticle;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Sets default values for this actor&#x27;s properties</span></span><br><span class="line">	<span class="built_in">ARuleOfTheBullet</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="comment">// Called when the game starts or when spawned</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BeginPlay</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//球形碰撞组件和pawn进行重叠之后触发的事件</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>()</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">BeginOverlap</span><span class="params">(UPrimitiveComponent* OverlappedComponent<span class="comment">/*重叠的组件*/</span>, AActor* OtherActor<span class="comment">/*目标Actor*/</span>, UPrimitiveComponent* OtherComp<span class="comment">/*目标组件*/</span>, int32 OtherBodyIndex, <span class="type">bool</span> bFromSweep<span class="comment">/*是否开始扫描*/</span>, <span class="type">const</span> FHitResult&amp; SweepResult<span class="comment">/*扫描之后的结果*/</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:	</span><br><span class="line">	<span class="comment">// Called every frame</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Tick</span><span class="params">(<span class="type">float</span> DeltaTime)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="RuleOfTheBullet-cpp"><a href="#RuleOfTheBullet-cpp" class="headerlink" title="RuleOfTheBullet.cpp"></a>RuleOfTheBullet.cpp</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Character/Bullet/RuleOfTheBullet.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Particles\ParticleSystemComponent.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Components\SceneComponent.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Components/SphereComponent.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GameFramework/ProjectileMovementComponent.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Character\Core\RuleOfTheCharacter.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;TowerDefence\StoneDefenceUtils.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Character\Core\RuleOfTheAIController.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Kismet\GameplayStatics.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Sets default values</span></span><br><span class="line"><span class="comment">//未初始化两个粒子特效，但不知道怎么初始化，而且按理说不用初始化的啊，粒子特效在蓝图界面赋值的，为什么这里会出现警告呢？</span></span><br><span class="line">ARuleOfTheBullet::<span class="built_in">ARuleOfTheBullet</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don&#x27;t need it.</span></span><br><span class="line">	PrimaryActorTick.bCanEverTick = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//ParticleMesh = CreateDefaultSubobject&lt;UParticleSystemComponent&gt;(TEXT(&quot;BulletNoxDamage&quot;));</span></span><br><span class="line">	BoxDamage = <span class="built_in">CreateDefaultSubobject</span>&lt;USphereComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;BulletNoxDamage&quot;</span>));<span class="comment">//此处使用BulletNoxDamage并且上面的一行存在时会产生断点，断点描述为避免多次构造同一子对象。我们只需要检查名称，因为如果已经存在具有相同名称但不同类的对象，ConstructObject无论如何都会失败。</span></span><br><span class="line">	RootBullet = <span class="built_in">CreateDefaultSubobject</span>&lt;USceneComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;BulletRootBullet&quot;</span>));</span><br><span class="line">	ProjectileMovement = <span class="built_in">CreateDefaultSubobject</span>&lt;UProjectileMovementComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;BulletProjectileMovement&quot;</span>));</span><br><span class="line"> 	</span><br><span class="line">	RootComponent = RootBullet;</span><br><span class="line">	BoxDamage-&gt;<span class="built_in">AttachToComponent</span>(RootComponent, FAttachmentTransformRules::KeepRelativeTransform);</span><br><span class="line"></span><br><span class="line">	ProjectileMovement-&gt;MaxSpeed = <span class="number">2000.f</span>;</span><br><span class="line">	ProjectileMovement-&gt;InitialSpeed = <span class="number">1600.f</span>;</span><br><span class="line">	ProjectileMovement-&gt;ProjectileGravityScale = <span class="number">0.f</span>;</span><br><span class="line">	ProjectileMovement-&gt;UpdatedComponent = BoxDamage;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置默认子弹类型</span></span><br><span class="line">	BulletType = EBulletType::BULLET_DIRECT_LINE;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//子弹生命周期</span></span><br><span class="line">	InitialLifeSpan = <span class="number">4.0f</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Called when the game starts or when spawned</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ARuleOfTheBullet::BeginPlay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Super::<span class="built_in">BeginPlay</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//遍历枚举，根据子弹类型来生成粒子特效</span></span><br><span class="line">	<span class="keyword">switch</span> (BulletType)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//无障碍直线攻击，则在Actor位置生成OpenFireParticle特效</span></span><br><span class="line">	<span class="keyword">case</span> EBulletType::BULLET_DIRECT_LINE:</span><br><span class="line">		UGameplayStatics::<span class="built_in">SpawnEmitterAtLocation</span>(<span class="built_in">GetWorld</span>(), OpenFireParticle, <span class="built_in">GetActorLocation</span>());</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//非跟踪类型，类似手枪子弹类型，同上</span></span><br><span class="line">	<span class="keyword">case</span> EBulletType::BULLET_LINE:</span><br><span class="line">		UGameplayStatics::<span class="built_in">SpawnEmitterAtLocation</span>(<span class="built_in">GetWorld</span>(), OpenFireParticle, <span class="built_in">GetActorLocation</span>());</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//跟踪类型</span></span><br><span class="line">	<span class="keyword">case</span> EBulletType::BULLET_TRACK_LINE:</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//在Actor位置生成OpenFireParticle特效</span></span><br><span class="line">		UGameplayStatics::<span class="built_in">SpawnEmitterAtLocation</span>(<span class="built_in">GetWorld</span>(), OpenFireParticle, <span class="built_in">GetActorLocation</span>());</span><br><span class="line">		ProjectileMovement-&gt;bIsHomingProjectile = <span class="literal">true</span>;<span class="comment">//开启跟踪</span></span><br><span class="line">		ProjectileMovement-&gt;bRotationFollowsVelocity = <span class="literal">true</span>;<span class="comment">//旋转方向跟随速度方向进行旋转，使得子弹的拖尾特效效果正常</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//在此处AActor的Instigator已经成为了私有的，所以尝试直接声明一个FActorSpawnParameters变量，获取Instigator，但可行性未可知</span></span><br><span class="line">		<span class="comment">//生成子弹的结构体</span></span><br><span class="line">		FActorSpawnParameters ActorSpawnParameters;</span><br><span class="line">		<span class="comment">//获取施法者Character</span></span><br><span class="line">		<span class="keyword">if</span> (ARuleOfTheCharacter* InstigatorCharacter = <span class="built_in">Cast</span>&lt;ARuleOfTheCharacter&gt;(ActorSpawnParameters.Instigator<span class="comment">/*生成子弹的伤害施加者*/</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//获取施法者的Controller</span></span><br><span class="line">			<span class="keyword">if</span> (ARuleOfTheAIController* InstigatorController = <span class="built_in">Cast</span>&lt;ARuleOfTheAIController&gt;(InstigatorCharacter-&gt;<span class="built_in">GetController</span>()))</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//获取施法者的目标</span></span><br><span class="line">				<span class="keyword">if</span> (ARuleOfTheCharacter* TargetCharacter = InstigatorController-&gt;Target.<span class="built_in">Get</span>())</span><br><span class="line">				&#123;</span><br><span class="line">					</span><br><span class="line">					ProjectileMovement-&gt;HomingAccelerationMagnitude = <span class="number">4000.f</span>;<span class="comment">//设置跟踪导航的加速度</span></span><br><span class="line">					ProjectileMovement-&gt;HomingTargetComponent = TargetCharacter-&gt;<span class="built_in">GetHomingPoint</span>();<span class="comment">//设置跟踪方向是目标身上的跟踪点</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//范围伤害，类似自爆；</span></span><br><span class="line">	<span class="keyword">case</span> EBulletType::BULLET_RANGE:</span><br><span class="line">		ProjectileMovement-&gt;<span class="built_in">StopMovementImmediately</span>();<span class="comment">//立即停止移动</span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//链条类型，持续伤害类型;</span></span><br><span class="line">	<span class="keyword">case</span> EBulletType::BULLET_CHAIN:</span><br><span class="line">		ProjectileMovement-&gt;<span class="built_in">StopMovementImmediately</span>();<span class="comment">//立即停止移动</span></span><br><span class="line">		BoxDamage-&gt;<span class="built_in">SetCollisionEnabled</span>(ECollisionEnabled::NoCollision);<span class="comment">//设置球形碰撞盒子无碰撞</span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//OnComponentBeginOverlap：是BoxDamage组件中自带的成员变量</span></span><br><span class="line">	<span class="comment">//代理绑定AddUniqueDynamic</span></span><br><span class="line">	BoxDamage-&gt;OnComponentBeginOverlap.<span class="built_in">AddUniqueDynamic</span>(<span class="keyword">this</span>, &amp;ARuleOfTheBullet::BeginOverlap);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//当子弹与目标重叠时触发的函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ARuleOfTheBullet::BeginOverlap</span><span class="params">(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, <span class="type">bool</span> bFromSweep, <span class="type">const</span> FHitResult&amp; SweepResult)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//不知道这里的改动是否可行！！！有待验证！！！</span></span><br><span class="line">	<span class="comment">//生成子弹的结构体</span></span><br><span class="line">	FActorSpawnParameters ActorSpawnParameters;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//找到伤害施加者</span></span><br><span class="line">	<span class="keyword">if</span> (ARuleOfTheCharacter* InstigatorCharacter = <span class="built_in">Cast</span>&lt;ARuleOfTheCharacter&gt;(ActorSpawnParameters.Instigator<span class="comment">/*生成子弹的伤害施加者*/</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//获取目标的Character</span></span><br><span class="line">		<span class="keyword">if</span> (ARuleOfTheCharacter* OtherCharacter = <span class="built_in">Cast</span>&lt;ARuleOfTheCharacter&gt;(OtherActor))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//判断是否为敌方——没有队友伤害</span></span><br><span class="line">			<span class="keyword">if</span> (InstigatorCharacter-&gt;<span class="built_in">IsTeam</span>() != OtherCharacter-&gt;<span class="built_in">IsTeam</span>())</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//判断目标是否活着</span></span><br><span class="line">				<span class="keyword">if</span> (OtherCharacter-&gt;<span class="built_in">IsActive</span>())</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="comment">//生成伤害特效</span></span><br><span class="line">					UGameplayStatics::<span class="built_in">SpawnEmitterAtLocation</span>(<span class="built_in">GetWorld</span>(), DamgageParticle, SweepResult.Location);</span><br><span class="line"></span><br><span class="line">					<span class="comment">//此函数接口会激活施法者的TakeDamage伤害接口</span></span><br><span class="line">					UGameplayStatics::<span class="built_in">ApplyDamage</span>(</span><br><span class="line">						OtherCharacter,<span class="comment">//被命中者</span></span><br><span class="line">						<span class="number">100.f</span>,<span class="comment">//伤害数值</span></span><br><span class="line">						InstigatorCharacter-&gt;<span class="built_in">GetController</span>(),<span class="comment">//施法者的控制器</span></span><br><span class="line">						InstigatorCharacter,<span class="comment">//施法者</span></span><br><span class="line">						UDamageType::<span class="built_in">StaticClass</span>()<span class="comment">/*默认伤害类型，后面会修改*/</span>);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">switch</span> (BulletType)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="comment">//如果是BULLET_LINE类型和BULLET_TRACK_LINE类型，则碰撞之后就销毁Actor</span></span><br><span class="line">				<span class="keyword">case</span> EBulletType::BULLET_LINE:</span><br><span class="line">				<span class="keyword">case</span> EBulletType::BULLET_TRACK_LINE:</span><br><span class="line">					<span class="built_in">Destroy</span>();</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Called every frame</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ARuleOfTheBullet::Tick</span><span class="params">(<span class="type">float</span> DeltaTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Super::<span class="built_in">Tick</span>(DeltaTime);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/09/12/UE4-%E9%A1%B9%E7%9B%AE-TowerDefence-%E5%AD%90%E5%BC%B9%E5%8F%91%E5%B0%84%E4%B8%8E%E4%BC%A4%E5%AE%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="williny">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Williny'home">
      <meta itemprop="description" content="孤独是人生的常态">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Williny'home">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/09/12/UE4-%E9%A1%B9%E7%9B%AE-TowerDefence-%E5%AD%90%E5%BC%B9%E5%8F%91%E5%B0%84%E4%B8%8E%E4%BC%A4%E5%AE%B3/" class="post-title-link" itemprop="url">UE4-项目-TowerDefence-子弹发射与伤害</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-09-12 15:17:25 / 修改时间：15:49:18" itemprop="dateCreated datePublished" datetime="2022-09-12T15:17:25+08:00">2022-09-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/unreal-engine/" itemprop="url" rel="index"><span itemprop="name">unreal engine</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="子弹发射"><a href="#子弹发射" class="headerlink" title="子弹发射"></a>子弹发射</h1><ol>
<li><p>给子弹添加一个<code>UProjectileMovementComponent</code>组件<code>ProjectileMovement</code></p>
</li>
<li><p><code>ProjectileMovement</code>设置其成员变量</p>
<ul>
<li><p><code>ProjectileMovement-&gt;MaxSpeed = 2000.f;</code>&#x2F;&#x2F;最大移动速度</p>
</li>
<li><p><code>ProjectileMovement-&gt;InitialSpeed = 1600.f;</code>&#x2F;&#x2F;初始速度</p>
</li>
<li><p><code>ProjectileMovement-&gt;ProjectileGravityScale = 0.f;</code>&#x2F;&#x2F;受到的重力</p>
</li>
<li><p><code>ProjectileMovement-&gt;UpdatedComponent = BoxDamage;</code>&#x2F;&#x2F;更新的组件</p>
</li>
</ul>
</li>
<li><p>在构造函数里面设置完这些之后子弹在<code>AnimNotify_SpawnBullet</code>中定义了什么时候生成，在生成后就会自己飞出去了</p>
</li>
</ol>
<h1 id="子弹伤害"><a href="#子弹伤害" class="headerlink" title="子弹伤害"></a>子弹伤害</h1><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><h3 id="UGameplayStatics-SpawnEmitterAtLocation"><a href="#UGameplayStatics-SpawnEmitterAtLocation" class="headerlink" title="UGameplayStatics::SpawnEmitterAtLocation()"></a>UGameplayStatics::SpawnEmitterAtLocation()</h3><p>在目标位置生成粒子特效</p>
<p><code>SpawnEmitterAtLocation(关卡，要生成的粒子特效，生成的位置信息，生成的旋转信息，生成尺寸大小)</code></p>
<h4 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">UParticleSystemComponent* <span class="title">UGameplayStatics::SpawnEmitterAtLocation</span><span class="params">(<span class="type">const</span> UObject* WorldContextObject, UParticleSystem* EmitterTemplate, FVector SpawnLocation, FRotator SpawnRotation, FVector SpawnScale, <span class="type">bool</span> bAutoDestroy, EPSCPoolMethod PoolingMethod, <span class="type">bool</span> bAutoActivateSystem)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    UParticleSystemComponent* PSC = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (EmitterTemplate)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (UWorld* World = GEngine-&gt;<span class="built_in">GetWorldFromContextObject</span>(WorldContextObject, EGetWorldErrorMode::LogAndReturnNull))</span><br><span class="line">        &#123;</span><br><span class="line">            PSC = <span class="built_in">InternalSpawnEmitterAtLocation</span>(World, EmitterTemplate, SpawnLocation, SpawnRotation, SpawnScale, bAutoDestroy, PoolingMethod, bAutoActivateSystem);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> PSC;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="UGameplayStatics-ApplyDamage"><a href="#UGameplayStatics-ApplyDamage" class="headerlink" title="UGameplayStatics::ApplyDamage()"></a>UGameplayStatics::ApplyDamage()</h3><p>激活施法者的TakeDamage伤害接口</p>
<p><code>UGameplayStatics::ApplyDamage(被命中者，伤害数值，施法者控制器，施法者character，伤害类型)</code></p>
<h4 id="源代码-1"><a href="#源代码-1" class="headerlink" title="源代码"></a>源代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">UGameplayStatics::ApplyDamage</span><span class="params">(AActor* DamagedActor, <span class="type">float</span> BaseDamage, AController* EventInstigator, AActor* DamageCauser, TSubclassOf&lt;UDamageType&gt; DamageTypeClass)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> ( DamagedActor &amp;&amp; (BaseDamage != <span class="number">0.f</span>) )</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// make sure we have a good damage type</span></span><br><span class="line">		TSubclassOf&lt;UDamageType&gt; <span class="type">const</span> ValidDamageTypeClass = DamageTypeClass ? DamageTypeClass : <span class="built_in">TSubclassOf</span>&lt;UDamageType&gt;(UDamageType::<span class="built_in">StaticClass</span>());</span><br><span class="line">		<span class="function">FDamageEvent <span class="title">DamageEvent</span><span class="params">(ValidDamageTypeClass)</span></span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> DamagedActor-&gt;<span class="built_in">TakeDamage</span>(BaseDamage, DamageEvent, EventInstigator, DamageCauser);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0.f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol>
<li><p>首先明确一点，子弹的伤害必须与某物体发生碰撞，也就是重叠的时候才会触发</p>
</li>
<li><p>所以，写一个函数<code>BeginOverlap()</code>，在之前声明过的，现在把它完善之后，在子弹的<code>BeginPlay()</code>里面通过代理绑定给球形碰撞组件的成员变量<code>OnComponentBeginOverlap</code>即可</p>
</li>
<li><p>定义<code>BeginOverlap()</code></p>
<ul>
<li><p>首先需要明确函数的几个形式参数是什么意思</p>
<ul>
<li><p><code>UPrimitiveComponent* OverlappedComponent</code>重叠的组件</p>
</li>
<li><p><code>AActor* OtherActor</code>目标Actor</p>
</li>
<li><p><code>UPrimitiveComponent* OtherComp</code>目标组件</p>
</li>
<li><p><code>int32 OtherBodyIndex</code>这个还没用上，先放着再说</p>
</li>
<li><p><code>bool bFromSweep</code>是否开启碰撞扫描</p>
</li>
<li><p><code>const FHitResult&amp; SweepResult</code>碰撞扫描之后的结果</p>
</li>
</ul>
</li>
<li><p>首先要找到发射这个子弹的人是谁，所以通过声明一个<code>FActorSpawnParameters</code>类型变量<code>ActorSpawnParameters</code>，再获取此变量的成员变量<code>Instigator</code>找到施法者</p>
</li>
<li><p>接下来通过传入的形参<code>OtherActor</code>获取目标的<code>Character</code></p>
</li>
<li><p>通过函数<code>IsTeam()</code>判断对方是否为友方——没有队友伤害</p>
</li>
<li><p>判断目标是否为活的</p>
</li>
<li><p>在碰撞位置通过<code>UGameplayStatics::SpawnEmitterAtLocation</code>生成伤害特效</p>
</li>
<li><p>使用接口<code>UGameplayStatics::ApplyDamage</code>激活施法者的<code>TakeDamage</code>伤害接口</p>
</li>
<li><p>遍历子弹类型，如果是BULLET_LINE类型和BULLET_TRACK_LINE类型，则碰撞之后就销毁子弹Actor</p>
</li>
</ul>
</li>
</ol>
<h2 id="部分代码"><a href="#部分代码" class="headerlink" title="部分代码"></a>部分代码</h2><h3 id="RuleOfTheBullet-h"><a href="#RuleOfTheBullet-h" class="headerlink" title="RuleOfTheBullet.h"></a>RuleOfTheBullet.h</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CoreMinimal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GameFramework/Actor.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;TowerDefence\TowerDefenceType.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;RuleOfTheBullet.generated.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TOWERDEFENCE_API</span> ARuleOfTheBullet : <span class="keyword">public</span> AActor</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//碰撞盒子</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(VisibleAnywhere, BlueprintReadOnly, Category = <span class="string">&quot;BaseAttrubute&quot;</span>, meta = (AllowPrivateAccess = <span class="string">&quot;true&quot;</span>))</span><br><span class="line">		<span class="keyword">class</span> <span class="title class_">USphereComponent</span>* BoxDamage;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//作为根组件</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(VisibleAnywhere, BlueprintReadOnly, Category = <span class="string">&quot;BaseAttrubute&quot;</span>, meta = (AllowPrivateAccess = <span class="string">&quot;true&quot;</span>))</span><br><span class="line">		<span class="keyword">class</span> <span class="title class_">USceneComponent</span>* RootBullet;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//具有移动属性的组件</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(VisibleAnywhere, BlueprintReadOnly, Category = <span class="string">&quot;BaseAttrubute&quot;</span>, meta = (AllowPrivateAccess = <span class="string">&quot;true&quot;</span>))</span><br><span class="line">		<span class="keyword">class</span> <span class="title class_">UProjectileMovementComponent</span>* ProjectileMovement;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"><span class="keyword">public</span>:	</span><br><span class="line">	<span class="comment">//技能类型</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(EditDefaultsOnly, Category = <span class="string">&quot;Bullet&quot;</span>)</span><br><span class="line">		TEnumAsByte&lt;EBulletType&gt; BulletType;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//子弹的伤害特效(碰撞后产生的特效)</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(EditDefaultsOnly, Category = <span class="string">&quot;Bullet&quot;</span>)</span><br><span class="line">		UParticleSystem* DamgageParticle;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//开火特效</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(EditDefaultsOnly, Category = <span class="string">&quot;Bullet&quot;</span>)</span><br><span class="line">		UParticleSystem* OpenFireParticle;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Sets default values for this actor&#x27;s properties</span></span><br><span class="line">	<span class="built_in">ARuleOfTheBullet</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="comment">// Called when the game starts or when spawned</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BeginPlay</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//球形碰撞组件和pawn进行重叠之后触发的事件</span></span><br><span class="line">	<span class="built_in">UFUNCTION</span>()</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">BeginOverlap</span><span class="params">(UPrimitiveComponent* OverlappedComponent<span class="comment">/*重叠的组件*/</span>, AActor* OtherActor<span class="comment">/*目标Actor*/</span>, UPrimitiveComponent* OtherComp<span class="comment">/*目标组件*/</span>, int32 OtherBodyIndex, <span class="type">bool</span> bFromSweep<span class="comment">/*是否开始扫描*/</span>, <span class="type">const</span> FHitResult&amp; SweepResult<span class="comment">/*扫描之后的结果*/</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:	</span><br><span class="line">	<span class="comment">// Called every frame</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Tick</span><span class="params">(<span class="type">float</span> DeltaTime)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="RuleOfTheBullet-cpp"><a href="#RuleOfTheBullet-cpp" class="headerlink" title="RuleOfTheBullet.cpp"></a>RuleOfTheBullet.cpp</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Character/Bullet/RuleOfTheBullet.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Particles\ParticleSystemComponent.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Components\SceneComponent.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Components/SphereComponent.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GameFramework/ProjectileMovementComponent.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Character\Core\RuleOfTheCharacter.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;TowerDefence\StoneDefenceUtils.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Character\Core\RuleOfTheAIController.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Kismet\GameplayStatics.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Sets default values</span></span><br><span class="line"><span class="comment">//未初始化两个粒子特效，但不知道怎么初始化，而且按理说不用初始化的啊，粒子特效在蓝图界面赋值的，为什么这里会出现警告呢？</span></span><br><span class="line">ARuleOfTheBullet::<span class="built_in">ARuleOfTheBullet</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don&#x27;t need it.</span></span><br><span class="line">	PrimaryActorTick.bCanEverTick = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//ParticleMesh = CreateDefaultSubobject&lt;UParticleSystemComponent&gt;(TEXT(&quot;BulletNoxDamage&quot;));</span></span><br><span class="line">	BoxDamage = <span class="built_in">CreateDefaultSubobject</span>&lt;USphereComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;BulletNoxDamage&quot;</span>));<span class="comment">//此处使用BulletNoxDamage并且上面的一行存在时会产生断点，断点描述为避免多次构造同一子对象。我们只需要检查名称，因为如果已经存在具有相同名称但不同类的对象，ConstructObject无论如何都会失败。</span></span><br><span class="line">	RootBullet = <span class="built_in">CreateDefaultSubobject</span>&lt;USceneComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;BulletRootBullet&quot;</span>));</span><br><span class="line">	ProjectileMovement = <span class="built_in">CreateDefaultSubobject</span>&lt;UProjectileMovementComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;BulletProjectileMovement&quot;</span>));</span><br><span class="line"> 	</span><br><span class="line">	RootComponent = RootBullet;</span><br><span class="line">	BoxDamage-&gt;<span class="built_in">AttachToComponent</span>(RootComponent, FAttachmentTransformRules::KeepRelativeTransform);</span><br><span class="line"></span><br><span class="line">	ProjectileMovement-&gt;MaxSpeed = <span class="number">2000.f</span>;</span><br><span class="line">	ProjectileMovement-&gt;InitialSpeed = <span class="number">1600.f</span>;</span><br><span class="line">	ProjectileMovement-&gt;ProjectileGravityScale = <span class="number">0.f</span>;</span><br><span class="line">	ProjectileMovement-&gt;UpdatedComponent = BoxDamage;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置默认子弹类型</span></span><br><span class="line">	BulletType = EBulletType::BULLET_DIRECT_LINE;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//子弹生命周期</span></span><br><span class="line">	InitialLifeSpan = <span class="number">4.0f</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Called when the game starts or when spawned</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ARuleOfTheBullet::BeginPlay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Super::<span class="built_in">BeginPlay</span>();</span><br><span class="line">	<span class="comment">//OnComponentBeginOverlap：是BoxDamage组件中自带的成员变量</span></span><br><span class="line">	<span class="comment">//代理绑定AddUniqueDynamic</span></span><br><span class="line">	BoxDamage-&gt;OnComponentBeginOverlap.<span class="built_in">AddUniqueDynamic</span>(<span class="keyword">this</span>, &amp;ARuleOfTheBullet::BeginOverlap);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//当子弹与目标重叠时触发的函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ARuleOfTheBullet::BeginOverlap</span><span class="params">(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, <span class="type">bool</span> bFromSweep, <span class="type">const</span> FHitResult&amp; SweepResult)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//不知道这里的改动是否可行！！！有待验证！！！</span></span><br><span class="line">	<span class="comment">//生成子弹的结构体</span></span><br><span class="line">	FActorSpawnParameters ActorSpawnParameters;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//找到伤害施加者</span></span><br><span class="line">	<span class="keyword">if</span> (ARuleOfTheCharacter* InstigatorCharacter = <span class="built_in">Cast</span>&lt;ARuleOfTheCharacter&gt;(ActorSpawnParameters.Instigator<span class="comment">/*生成子弹的伤害施加者*/</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//获取目标的Character</span></span><br><span class="line">		<span class="keyword">if</span> (ARuleOfTheCharacter* OtherCharacter = <span class="built_in">Cast</span>&lt;ARuleOfTheCharacter&gt;(OtherActor))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//判断是否为敌方——没有队友伤害</span></span><br><span class="line">			<span class="keyword">if</span> (InstigatorCharacter-&gt;<span class="built_in">IsTeam</span>() != OtherCharacter-&gt;<span class="built_in">IsTeam</span>())</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//判断目标是否活着</span></span><br><span class="line">				<span class="keyword">if</span> (OtherCharacter-&gt;<span class="built_in">IsActive</span>())</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="comment">//生成伤害特效</span></span><br><span class="line">					UGameplayStatics::<span class="built_in">SpawnEmitterAtLocation</span>(<span class="built_in">GetWorld</span>(), DamgageParticle, SweepResult.Location);</span><br><span class="line"></span><br><span class="line">					<span class="comment">//此函数接口会激活施法者的TakeDamage伤害接口</span></span><br><span class="line">					UGameplayStatics::<span class="built_in">ApplyDamage</span>(</span><br><span class="line">						OtherCharacter,<span class="comment">//被命中者</span></span><br><span class="line">						<span class="number">100.f</span>,<span class="comment">//伤害数值</span></span><br><span class="line">						InstigatorCharacter-&gt;<span class="built_in">GetController</span>(),<span class="comment">//施法者的控制器</span></span><br><span class="line">						InstigatorCharacter,<span class="comment">//施法者</span></span><br><span class="line">						UDamageType::<span class="built_in">StaticClass</span>()<span class="comment">/*默认伤害类型，后面会修改*/</span>);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">switch</span> (BulletType)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="comment">//如果是BULLET_LINE类型和BULLET_TRACK_LINE类型，则碰撞之后就销毁Actor</span></span><br><span class="line">				<span class="keyword">case</span> EBulletType::BULLET_LINE:</span><br><span class="line">				<span class="keyword">case</span> EBulletType::BULLET_TRACK_LINE:</span><br><span class="line">					<span class="built_in">Destroy</span>();</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Called every frame</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ARuleOfTheBullet::Tick</span><span class="params">(<span class="type">float</span> DeltaTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Super::<span class="built_in">Tick</span>(DeltaTime);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/09/12/UE4-%E9%A1%B9%E7%9B%AE-TowerDefence-%E5%AD%90%E5%BC%B9%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%8B%E6%96%B9%E4%BC%A4%E5%AE%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="williny">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Williny'home">
      <meta itemprop="description" content="孤独是人生的常态">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Williny'home">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/09/12/UE4-%E9%A1%B9%E7%9B%AE-TowerDefence-%E5%AD%90%E5%BC%B9%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%8B%E6%96%B9%E4%BC%A4%E5%AE%B3/" class="post-title-link" itemprop="url">UE4-项目-TowerDefence-子弹类型与友方伤害</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-09-12 14:07:10 / 修改时间：14:17:43" itemprop="dateCreated datePublished" datetime="2022-09-12T14:07:10+08:00">2022-09-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/unreal-engine/" itemprop="url" rel="index"><span itemprop="name">unreal engine</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="明确基本思路"><a href="#明确基本思路" class="headerlink" title="明确基本思路"></a>明确基本思路</h1><ol>
<li><p>子弹伤害，首先要取消友方伤害</p>
<ul>
<li><p>之前不是在<code>ARuleOfTheCharacter</code>中定义了一个函数<code>virtual bool IsTeam()</code>吗？现在把那一串挪到<code>public:</code>下</p>
</li>
<li><p><code>virtual bool IsTeam()</code>就是用于区分是否为友方的函数</p>
</li>
<li><p><code>Towers</code>继承此函数，返回值为<code>True</code>，<code>Monsters</code>继承此函数，返回值为<code>False</code></p>
</li>
<li><p>在子弹施加伤害之前，先判断目标的<code>IsTeam()</code>函数与施法者的此函数返回值是否相同，不相同，才可以施加伤害</p>
</li>
</ul>
</li>
<li><p>子弹类型，在这个游戏中设计了好几种子弹类型，有着不同的效果</p>
<ul>
<li><p>在<code>TowerDefenceType</code>文件中定义一个枚举，里面存储着子弹的不同类型</p>
<ul>
<li><p>BULLET_NONE,            &#x2F;&#x2F;不产生任何效果</p>
</li>
<li><p>BULLET_DIRECT_LINE,        &#x2F;&#x2F;无障碍直线攻击</p>
</li>
<li><p>BULLET_LINE,            &#x2F;&#x2F;非跟踪类型，类似手枪子弹；</p>
</li>
<li><p>BULLET_TRACK_LINE,        &#x2F;&#x2F;跟踪类型</p>
</li>
<li><p>BULLET_TRACK_LINE_SP,    &#x2F;&#x2F;跟踪类型</p>
</li>
<li><p>BULLET_RANGE_LINE,        &#x2F;&#x2F;范围伤害，丢手雷；</p>
</li>
<li><p>BULLET_RANGE,            &#x2F;&#x2F;范围伤害，类似自爆；</p>
</li>
<li><p>BULLET_CHAIN,            &#x2F;&#x2F;链条类型，持续伤害类型;</p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="部分代码"><a href="#部分代码" class="headerlink" title="部分代码"></a>部分代码</h2><h3 id="RuleOfTheCharacter-h"><a href="#RuleOfTheCharacter-h" class="headerlink" title="RuleOfTheCharacter.h"></a>RuleOfTheCharacter.h</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CoreMinimal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;TowerDefence\TowerDefenceType.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GameFramework/Character.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Interface\Character\IRuleCharacter.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Core/GameCore/TowerDefencePlayerController.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Core/GameCore/TowerDefenceGameState.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;RuleOfTheCharacter.generated.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TOWERDEFENCE_API</span> ARuleOfTheCharacter : <span class="keyword">public</span> ACharacter,<span class="keyword">public</span> IRuleCharacter</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="comment">//用于实现子弹跟踪效果的实现</span></span><br><span class="line">		<span class="built_in">UPROPERTY</span>(VisibleAnyWhere, BlueprintReadOnly, Category = <span class="string">&quot;BaseAttrbute&quot;</span>, meta = (AllowPrivateAccess=<span class="string">&quot;true&quot;</span>))</span><br><span class="line">		<span class="keyword">class</span> <span class="title class_">USceneComponent</span>* HomingPoint;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="comment">//用于显示等级，生命值等信息</span></span><br><span class="line">		<span class="built_in">UPROPERTY</span>(VisibleAnyWhere, BlueprintReadOnly, Category = <span class="string">&quot;BaseAttrbute&quot;</span>, meta = (AllowPrivateAccess=<span class="string">&quot;true&quot;</span>))</span><br><span class="line">		<span class="keyword">class</span> <span class="title class_">UWidgetComponent</span>* Widget;</span><br><span class="line"></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//角色及怪物子弹生成位置</span></span><br><span class="line">		<span class="built_in">UPROPERTY</span>(VisibleAnyWhere, BlueprintReadOnly, Category = <span class="string">&quot;BaseAttrbute&quot;</span>, meta = (AllowPrivateAccess=<span class="string">&quot;true&quot;</span>))</span><br><span class="line">		<span class="keyword">class</span> <span class="title class_">UArrowComponent</span>* OpenFirePoint;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="comment">//用于捕捉鼠标射线</span></span><br><span class="line">		<span class="built_in">UPROPERTY</span>(VisibleAnyWhere, BlueprintReadOnly, Category = <span class="string">&quot;BaseAttrbute&quot;</span>, meta = (AllowPrivateAccess=<span class="string">&quot;true&quot;</span>))</span><br><span class="line">		<span class="keyword">class</span> <span class="title class_">UBoxComponent</span>* TraceShowCharacterInformattion;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// Sets default values for this character&#x27;s properties</span></span><br><span class="line">	<span class="built_in">ARuleOfTheCharacter</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="comment">// Called when the game starts or when spawned</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BeginPlay</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:	</span><br><span class="line">	<span class="comment">// Called every frame</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Tick</span><span class="params">(<span class="type">float</span> DeltaTime)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> EGameCharacterType::Type <span class="title">GetType</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//继承自IRuleCharacter中的函数</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">IsDeath</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">float</span> <span class="title">GetHeath</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">float</span> <span class="title">GetMaxHeath</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">IsTeam</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="comment">//Damage为伤害值</span></span><br><span class="line">	<span class="comment">//DamageEvent为伤害类型</span></span><br><span class="line">	<span class="comment">//EventInstigator为伤害当前Controller的Actor（被伤害目标）</span></span><br><span class="line">	<span class="comment">//DamageCauser为施加伤害的Actor</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">float</span> <span class="title">TakeDamage</span><span class="params">(<span class="type">float</span> Damage, <span class="keyword">struct</span> FDamageEvent <span class="type">const</span>&amp; DamageEvent, AController* EventInstigator, AActor* DamageCauser)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">UFUNCTION</span>(Blueprintable,BlueprintPure,Category=<span class="string">&quot;Tower|Attrubute&quot;</span>)</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">IsActive</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> !<span class="built_in">IsDeath</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//将TowerDefencePlayerController连接进来</span></span><br><span class="line">	<span class="comment">//FORCEINLINE：强制内联函数</span></span><br><span class="line">	<span class="function">FORCEINLINE ATowerDefencePlayerController* <span class="title">GetGameController</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">GetWorld</span>() ? <span class="built_in">GetWorld</span>()-&gt;<span class="built_in">GetFirstPlayerController</span>&lt;ATowerDefencePlayerController&gt;() : <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将TowerDefenceGameState连接进来</span></span><br><span class="line">	<span class="function">FORCEINLINE ATowerDefenceGameState* <span class="title">GetGameState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">GetWorld</span>() ? <span class="built_in">GetWorld</span>()-&gt;<span class="built_in">GetGameState</span>&lt;ATowerDefenceGameState&gt;() : <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//跟踪点</span></span><br><span class="line">	<span class="function">FORCEINLINE USceneComponent* <span class="title">GetHomingPoint</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> HomingPoint; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//开火点</span></span><br><span class="line">	<span class="function">FORCEINLINE UArrowComponent* <span class="title">GetFirePoint</span><span class="params">()</span><span class="type">const</span> </span>&#123; <span class="keyword">return</span> OpenFirePoint; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//是否攻击</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(VisibleAnyWhere, BlueprintReadOnly, Category = <span class="string">&quot;AnimAttrubute&quot;</span>)</span><br><span class="line">		<span class="type">bool</span> bAttack;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Towers-h"><a href="#Towers-h" class="headerlink" title="Towers.h"></a>Towers.h</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CoreMinimal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Character/Core/RuleOfTheCharacter.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Towers.generated.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TOWERDEFENCE_API</span> ATowers : <span class="keyword">public</span> ARuleOfTheCharacter</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//粒子特效组件（在这里就是塔模型）</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(VisibleAnyWhere, BlueprintReadOnly, Category = <span class="string">&quot;BaseAttrubute&quot;</span>, meta = (AllowPrivateAccess = <span class="string">&quot;true&quot;</span>))</span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">UParticleSystemComponent</span>* ParticleMesh;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//用于显示某处是否可建造（true则显示绿色，否则红色）</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(VisibleAnyWhere, BlueprintReadOnly, Category = <span class="string">&quot;BaseAttrubute&quot;</span>, meta = (AllowPrivateAccess = <span class="string">&quot;true&quot;</span>))</span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">UStaticMeshComponent</span>* StaticMeshBuilding;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//破碎效果组件（塔被摧毁之后切换为此）</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(VisibleAnyWhere, BlueprintReadOnly, Category = <span class="string">&quot;BaseAttrubute&quot;</span>, meta = (AllowPrivateAccess = <span class="string">&quot;true&quot;</span>))</span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">UDestructibleComponent</span>* DestructibleMeshBuilding;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(VisibleAnyWhere, BlueprintReadOnly, Category = <span class="string">&quot;BaseAttrubute&quot;</span>)</span><br><span class="line">	FRotator TowersRotator;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">ATowers</span>();</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">IsTeam</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> EGameCharacterType::Type <span class="title">GetType</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">float</span> <span class="title">TakeDamage</span><span class="params">(<span class="type">float</span> DamageAmount, <span class="keyword">struct</span> FDamageEvent <span class="type">const</span>&amp; DamageEvent, <span class="keyword">class</span> AController* EventInstigator, AActor* DamageCauser)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Towers-cpp"><a href="#Towers-cpp" class="headerlink" title="Towers.cpp"></a>Towers.cpp</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Character/CharacterCore/Towers.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Particles\ParticleSystemComponent.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Components\StaticMeshComponent.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;DestructibleComponent.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">ATowers::<span class="built_in">ATowers</span>()</span><br><span class="line">&#123;</span><br><span class="line">    ParticleMesh = <span class="built_in">CreateDefaultSubobject</span>&lt;UParticleSystemComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;ParticleMesh&quot;</span>));</span><br><span class="line">    StaticMeshBuilding = <span class="built_in">CreateDefaultSubobject</span>&lt;UStaticMeshComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;RangeBuilding&quot;</span>));</span><br><span class="line">    DestructibleMeshBuilding = <span class="built_in">CreateDefaultSubobject</span>&lt;UDestructibleComponent&gt;(<span class="built_in">TEXT</span>(<span class="string">&quot;Substityte&quot;</span>));</span><br><span class="line"></span><br><span class="line">    ParticleMesh-&gt;<span class="built_in">AttachToComponent</span>(RootComponent, FAttachmentTransformRules::KeepRelativeTransform);</span><br><span class="line">    StaticMeshBuilding-&gt;<span class="built_in">AttachToComponent</span>(RootComponent, FAttachmentTransformRules::KeepRelativeTransform);</span><br><span class="line">    DestructibleMeshBuilding-&gt;<span class="built_in">AttachToComponent</span>(RootComponent, FAttachmentTransformRules::KeepRelativeTransform);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ATowers::IsTeam</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">EGameCharacterType::Type <span class="title">ATowers::GetType</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> EGameCharacterType::Type::TOWER;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">ATowers::TakeDamage</span><span class="params">(<span class="type">float</span> DamageAmount, FDamageEvent <span class="type">const</span>&amp; DamageEvent, AController* EventInstigator, AActor* DamageCauser)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">TakeDamage</span>(DamageAmount, DamageEvent, EventInstigator, DamageCauser);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.0f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Monsters-h"><a href="#Monsters-h" class="headerlink" title="Monsters.h"></a>Monsters.h</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CoreMinimal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Character/Core/RuleOfTheCharacter.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Monsters.generated.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TOWERDEFENCE_API</span> AMonsters : <span class="keyword">public</span> ARuleOfTheCharacter</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">GENERATED_BODY</span>()</span><br><span class="line">	</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BeginPlay</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Tick</span><span class="params">(<span class="type">float</span> DeltaTime)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> EGameCharacterType::Type <span class="title">GetType</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">IsTeam</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Monsters-cpp"><a href="#Monsters-cpp" class="headerlink" title="Monsters.cpp"></a>Monsters.cpp</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Character/CharacterCore/Monsters.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMonsters::BeginPlay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Super::<span class="built_in">BeginPlay</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AMonsters::Tick</span><span class="params">(<span class="type">float</span> DeltaTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Super::<span class="built_in">Tick</span>(DeltaTime);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">EGameCharacterType::Type <span class="title">AMonsters::GetType</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> EGameCharacterType::Type::MONSTER;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">AMonsters::IsTeam</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Super::<span class="built_in">IsTeam</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/09/12/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88%E4%BA%8C%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="williny">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Williny'home">
      <meta itemprop="description" content="孤独是人生的常态">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Williny'home">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/09/12/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88%E4%BA%8C%EF%BC%89/" class="post-title-link" itemprop="url">算法-二叉树（二）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-09-12 10:32:56" itemprop="dateCreated datePublished" datetime="2022-09-12T10:32:56+08:00">2022-09-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-09-14 11:33:34" itemprop="dateModified" datetime="2022-09-14T11:33:34+08:00">2022-09-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h1><p>给定一个二叉树，找出其最大深度。</p>
<p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<p>示例： 给定二叉树 [3,9,20,null,null,15,7]，</p>
<p><img src="https://img-blog.csdnimg.cn/20210203153031914.png" alt="104. 二叉树的最大深度"></p>
<p>返回它的最大深度 3 。</p>
<h2 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h2><p>本题可以使用前序（中左右），也可以使用后序遍历（左右中），使用前序求的就是深度，使用后序求的是高度。</p>
<ul>
<li>二叉树节点的深度：指从根节点到该节点的最长简单路径边的条数或者节点数（取决于深度从0开始还是从1开始）</li>
<li>二叉树节点的高度：指从该节点到叶子节点的最长简单路径边的条数后者节点数（取决于高度从0开始还是从1开始）</li>
</ul>
<p><strong>而根节点的高度就是二叉树的最大深度</strong>，所以本题中我们通过后序求的根节点高度来求的二叉树最大深度。</p>
<p>这一点其实是很多同学没有想清楚的，很多题解同样没有讲清楚。</p>
<p>我先用后序遍历（左右中）来计算树的高度。</p>
<ol>
<li>确定递归函数的参数和返回值：参数就是传入树的根节点，返回就返回这棵树的深度，所以返回值为int类型。</li>
</ol>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getdepth</span><span class="params">(treenode* node)</span></span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>确定终止条件：如果为空节点的话，就返回0，表示高度为0。</li>
</ol>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (node == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>确定单层递归的逻辑：先求它的左子树的深度，再求的右子树的深度，最后取左右深度最大的数值 再+1 （加1是因为算上当前中间节点）就是目前节点为根节点的树的深度。</li>
</ol>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> leftdepth = <span class="built_in">getdepth</span>(node-&gt;left);       <span class="comment">// 左</span></span><br><span class="line"><span class="type">int</span> rightdepth = <span class="built_in">getdepth</span>(node-&gt;right);     <span class="comment">// 右</span></span><br><span class="line"><span class="type">int</span> depth = <span class="number">1</span> + <span class="built_in">max</span>(leftdepth, rightdepth); <span class="comment">// 中</span></span><br><span class="line"><span class="keyword">return</span> depth;</span><br></pre></td></tr></table></figure>

<p>所以整体c++代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getdepth</span><span class="params">(treenode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> leftdepth = <span class="built_in">getdepth</span>(node-&gt;left);       <span class="comment">// 左</span></span><br><span class="line">        <span class="type">int</span> rightdepth = <span class="built_in">getdepth</span>(node-&gt;right);     <span class="comment">// 右</span></span><br><span class="line">        <span class="type">int</span> depth = <span class="number">1</span> + <span class="built_in">max</span>(leftdepth, rightdepth); <span class="comment">// 中</span></span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxdepth</span><span class="params">(treenode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getdepth</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h3><p>使用迭代法的话，使用层序遍历是最为合适的，因为最大的深度就是二叉树的层数，和层序遍历的方式极其吻合。</p>
<p>在二叉树中，一层一层的来遍历二叉树，记录一下遍历的层数就是二叉树的深度，如图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20200810193056585.png" alt="层序遍历"></p>
<p>所以这道题的迭代法就是一道模板题，可以使用二叉树层序遍历的模板来解决的。</p>
<p>如果对层序遍历还不清楚的话，可以看这篇：<a target="_blank" rel="noopener" href="https://programmercarl.com/0102.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86.html">二叉树：层序遍历登场！</a></p>
<p>c++代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxdepth</span><span class="params">(treenode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        queue&lt;treenode*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            depth++; <span class="comment">// 记录深度</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                treenode* node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="N叉树的最大深度"><a href="#N叉树的最大深度" class="headerlink" title="N叉树的最大深度"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/">N叉树的最大深度</a></h1><p>给定一个 n 叉树，找到其最大深度。</p>
<p>最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。</p>
<p>例如，给定一个 3叉树 :</p>
<p><img src="https://img-blog.csdnimg.cn/2021020315313214.png" alt="559.n叉树的最大深度"></p>
<p>我们应返回其最大深度，3。</p>
<p>思路：</p>
<p>依然可以提供递归法和迭代法，来解决这个问题，思路是和二叉树思路一样的，直接给出代码如下：</p>
<h2 id="递归法-1"><a href="#递归法-1" class="headerlink" title="递归法"></a>递归法</h2><p>c++代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxdepth</span><span class="params">(node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; root-&gt;children.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            depth = <span class="built_in">max</span> (depth, <span class="built_in">maxdepth</span>(root-&gt;children[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="迭代法-1"><a href="#迭代法-1" class="headerlink" title="迭代法"></a>迭代法</h2><p>依然是层序遍历，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxdepth</span><span class="params">(node* root)</span> </span>&#123;</span><br><span class="line">        queue&lt;node*&gt; que;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="type">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            depth++; <span class="comment">// 记录深度</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                node* node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; node-&gt;children.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (node-&gt;children[j]) que.<span class="built_in">push</span>(node-&gt;children[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="二叉树的最小深度"><a href="#二叉树的最小深度" class="headerlink" title="二叉树的最小深度"></a>二叉树的最小深度</h1><p>给定一个二叉树，找出其最小深度。</p>
<p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<p>示例:</p>
<p>给定二叉树 [3,9,20,null,null,15,7],</p>
<p><img src="https://img-blog.csdnimg.cn/2021020315582586.png" alt="111.二叉树的最小深度1"></p>
<p>返回它的最小深度 2</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>看完了这篇<a target="_blank" rel="noopener" href="https://programmercarl.com/0104.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6.html">104.二叉树的最大深度</a>，再来看看如何求最小深度。</p>
<p>直觉上好像和求最大深度差不多，其实还是差不少的。</p>
<p>本题依然是前序遍历和后序遍历都可以，前序求的是深度，后序求的是高度。</p>
<ul>
<li>二叉树节点的深度：指从根节点到该节点的最长简单路径边的条数或者节点数（取决于深度从0开始还是从1开始）</li>
<li>二叉树节点的高度：指从该节点到叶子节点的最长简单路径边的条数后者节点数（取决于高度从0开始还是从1开始）</li>
</ul>
<p>那么使用后序遍历，其实求的是根节点到叶子节点的最小距离，就是求高度的过程，这不过这个最小距离 也同样是最小深度。</p>
<p>以下讲解中遍历顺序上依然采用后序遍历（因为要比较递归返回之后的结果，本文我也给出前序遍历的写法）。</p>
<p>本题还有一个误区，在处理节点的过程中，最大深度很容易理解，最小深度就不那么好理解，如图：</p>
<p><img src="https://img-blog.csdnimg.cn/20210203155800503.png" alt="111.二叉树的最小深度"></p>
<p>这就重新审题了，题目中说的是：<strong>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</strong>，注意是<strong>叶子节点</strong>。</p>
<p>什么是叶子节点，左右孩子都为空的节点才是叶子节点！</p>
<h2 id="递归法-2"><a href="#递归法-2" class="headerlink" title="递归法"></a>递归法</h2><p>来来来，一起递归三部曲：</p>
<ol>
<li>确定递归函数的参数和返回值</li>
</ol>
<p>参数为要传入的二叉树根节点，返回的是int类型的深度。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getDepth</span><span class="params">(TreeNode* node)</span></span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>确定终止条件</li>
</ol>
<p>终止条件也是遇到空节点返回0，表示当前节点的高度为0。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (node == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>确定单层递归的逻辑</li>
</ol>
<p>这块和求最大深度可就不一样了，一些同学可能会写如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> leftDepth = <span class="built_in">getDepth</span>(node-&gt;left);</span><br><span class="line"><span class="type">int</span> rightDepth = <span class="built_in">getDepth</span>(node-&gt;right);</span><br><span class="line"><span class="type">int</span> result = <span class="number">1</span> + <span class="built_in">min</span>(leftDepth, rightDepth);</span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure>

<p>这个代码就犯了此图中的误区：</p>
<p><img src="https://img-blog.csdnimg.cn/20210203155800503.png" alt="111.二叉树的最小深度"></p>
<p>如果这么求的话，没有左孩子的分支会算为最短深度。</p>
<p>所以，如果<strong>左子树为空，右子树不为空，说明最小深度是 1 + 右子树的深度</strong>。</p>
<p>反之，<strong>右子树为空，左子树不为空，最小深度是 1 + 左子树的深度</strong>。 最后如果左右子树都不为空，返回左右子树深度最小值 + 1 。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> leftDepth = <span class="built_in">getDepth</span>(node-&gt;left);           <span class="comment">// 左</span></span><br><span class="line"><span class="type">int</span> rightDepth = <span class="built_in">getDepth</span>(node-&gt;right);         <span class="comment">// 右</span></span><br><span class="line">                                                <span class="comment">// 中</span></span><br><span class="line"><span class="comment">// 当一个左子树为空，右不为空，这时并不是最低点</span></span><br><span class="line"><span class="keyword">if</span> (node-&gt;left == <span class="literal">NULL</span> &amp;&amp; node-&gt;right != <span class="literal">NULL</span>) &#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + rightDepth;</span><br><span class="line">&#125;   </span><br><span class="line"><span class="comment">// 当一个右子树为空，左不为空，这时并不是最低点</span></span><br><span class="line"><span class="keyword">if</span> (node-&gt;left != <span class="literal">NULL</span> &amp;&amp; node-&gt;right == <span class="literal">NULL</span>) &#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + leftDepth;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> result = <span class="number">1</span> + <span class="built_in">min</span>(leftDepth, rightDepth);</span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure>

<p>遍历的顺序为后序（左右中），可以看出：<strong>求二叉树的最小深度和求二叉树的最大深度的差别主要在于处理左右孩子不为空的逻辑。</strong></p>
<p>整体递归代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getDepth</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> leftDepth = <span class="built_in">getDepth</span>(node-&gt;left);           <span class="comment">// 左</span></span><br><span class="line">        <span class="type">int</span> rightDepth = <span class="built_in">getDepth</span>(node-&gt;right);         <span class="comment">// 右</span></span><br><span class="line">                                                        <span class="comment">// 中</span></span><br><span class="line">        <span class="comment">// 当一个左子树为空，右不为空，这时并不是最低点</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left == <span class="literal">NULL</span> &amp;&amp; node-&gt;right != <span class="literal">NULL</span>) &#123; </span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + rightDepth;</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="comment">// 当一个右子树为空，左不为空，这时并不是最低点</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left != <span class="literal">NULL</span> &amp;&amp; node-&gt;right == <span class="literal">NULL</span>) &#123; </span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + leftDepth;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">1</span> + <span class="built_in">min</span>(leftDepth, rightDepth);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getDepth</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>前序遍历的方式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getdepth</span><span class="params">(TreeNode* node, <span class="type">int</span> depth)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left == <span class="literal">NULL</span> &amp;&amp; node-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            result = <span class="built_in">min</span>(depth, result);  </span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 中 只不过中没有处理的逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left) &#123; <span class="comment">// 左</span></span><br><span class="line">            <span class="built_in">getdepth</span>(node-&gt;left, depth + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right) &#123; <span class="comment">// 右</span></span><br><span class="line">            <span class="built_in">getdepth</span>(node-&gt;right, depth + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        result = INT_MAX;</span><br><span class="line">        <span class="built_in">getdepth</span>(root, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="完全二叉树的节点个数"><a href="#完全二叉树的节点个数" class="headerlink" title="完全二叉树的节点个数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-complete-tree-nodes/">完全二叉树的节点个数</a></h1><p>给出一个完全二叉树，求出该树的节点个数。</p>
<p>示例 1：</p>
<ul>
<li>输入：root &#x3D; [1,2,3,4,5,6]</li>
<li>输出：6</li>
</ul>
<p>示例 2：</p>
<ul>
<li>输入：root &#x3D; []</li>
<li>输出：0</li>
</ul>
<p>示例 3：</p>
<ul>
<li>输入：root &#x3D; [1]</li>
<li>输出：1</li>
</ul>
<p>提示：</p>
<ul>
<li>树中节点的数目范围是[0, 5 * 10^4]</li>
<li>0 &lt;&#x3D; Node.val &lt;&#x3D; 5 * 10^4</li>
<li>题目数据保证输入的树是 完全二叉树</li>
</ul>
<h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>本篇给出按照普通二叉树的求法以及利用完全二叉树性质的求法。</p>
<h3 id="普通二叉树"><a href="#普通二叉树" class="headerlink" title="普通二叉树"></a>普通二叉树</h3><p>首先按照普通二叉树的逻辑来求。</p>
<p>这道题目的递归法和求二叉树的深度写法类似， 而迭代法，<a target="_blank" rel="noopener" href="https://programmercarl.com/0102.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86.html">二叉树：层序遍历登场！</a>遍历模板稍稍修改一下，记录遍历的节点数量就可以了。</p>
<p>递归遍历的顺序依然是后序（左右中）。</p>
<h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><p>如果对求二叉树深度还不熟悉的话，看这篇：<a target="_blank" rel="noopener" href="https://programmercarl.com/0104.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6.html">二叉树：看看这些树的最大深度</a></p>
<ol>
<li>确定递归函数的参数和返回值：参数就是传入树的根节点，返回就返回以该节点为根节点二叉树的节点数量，所以返回值为int类型。</li>
</ol>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getNodesNum</span><span class="params">(TreeNode* cur)</span> </span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>确定终止条件：如果为空节点的话，就返回0，表示节点数为0。</li>
</ol>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>确定单层递归的逻辑：先求它的左子树的节点数量，再求的右子树的节点数量，最后取总和再加一 （加1是因为算上当前中间节点）就是目前节点为根节点的节点数量。</li>
</ol>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> leftNum = <span class="built_in">getNodesNum</span>(cur-&gt;left);      <span class="comment">// 左</span></span><br><span class="line"><span class="type">int</span> rightNum = <span class="built_in">getNodesNum</span>(cur-&gt;right);    <span class="comment">// 右</span></span><br><span class="line"><span class="type">int</span> treeNum = leftNum + rightNum + <span class="number">1</span>;      <span class="comment">// 中</span></span><br><span class="line"><span class="keyword">return</span> treeNum;</span><br></pre></td></tr></table></figure>

<p>所以整体C++代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getNodesNum</span><span class="params">(TreeNode* cur)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> leftNum = <span class="built_in">getNodesNum</span>(cur-&gt;left);      <span class="comment">// 左</span></span><br><span class="line">        <span class="type">int</span> rightNum = <span class="built_in">getNodesNum</span>(cur-&gt;right);    <span class="comment">// 右</span></span><br><span class="line">        <span class="type">int</span> treeNum = leftNum + rightNum + <span class="number">1</span>;      <span class="comment">// 中</span></span><br><span class="line">        <span class="keyword">return</span> treeNum;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countNodes</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getNodesNum</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="迭代法-2"><a href="#迭代法-2" class="headerlink" title="迭代法"></a>迭代法</h4><p>把求二叉树层序遍历的模板少做改动，加一个变量result，统计节点数量就可以了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countNodes</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                result++;   <span class="comment">// 记录节点数量</span></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/balanced-binary-tree/">平衡二叉树</a></h1><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p>
<p>本题中，一棵高度平衡二叉树定义为：一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。</p>
<p>示例 1:</p>
<p>给定二叉树 [3,9,20,null,null,15,7]</p>
<p><img src="https://img-blog.csdnimg.cn/2021020315542230.png" alt="110.平衡二叉树"></p>
<p>返回 true 。</p>
<p>示例 2:</p>
<p>给定二叉树 [1,2,2,3,3,null,null,4,4]</p>
<p><img src="https://img-blog.csdnimg.cn/20210203155447919.png" alt="110.平衡二叉树1"></p>
<p>返回 false 。</p>
<p>咋眼一看这道题目和<a target="_blank" rel="noopener" href="https://programmercarl.com/0104.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6.html">104.二叉树的最大深度</a>很像，其实有很大区别。</p>
<p>这里强调一波概念：</p>
<ul>
<li>二叉树节点的深度：指从根节点到该节点的最长简单路径边的条数。</li>
<li>二叉树节点的高度：指从该节点到叶子节点的最长简单路径边的条数。</li>
</ul>
<p>但leetcode中强调的深度和高度很明显是按照节点来计算的，如图：</p>
<p><img src="https://img-blog.csdnimg.cn/20210203155515650.png" alt="110.平衡二叉树2"></p>
<p>关于根节点的深度究竟是1 还是 0，不同的地方有不一样的标准，leetcode的题目中都是以节点为一度，即根节点深度是1。但维基百科上定义用边为一度，即根节点的深度是0，我们暂时以leetcode为准（毕竟要在这上面刷题）。</p>
<p>因为求深度可以从上到下去查 所以需要前序遍历（中左右），而高度只能从下到上去查，所以只能后序遍历（左右中）</p>
<p>有的同学一定疑惑，为什么<a target="_blank" rel="noopener" href="https://programmercarl.com/0104.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6.html">104.二叉树的最大深度</a>中求的是二叉树的最大深度，也用的是后序遍历。</p>
<p><strong>那是因为代码的逻辑其实是求的根节点的高度，而根节点的高度就是这棵树的最大深度，所以才可以使用后序遍历。</strong></p>
<p>在<a target="_blank" rel="noopener" href="https://programmercarl.com/0104.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6.html">104.二叉树的最大深度</a>中，如果真正求取二叉树的最大深度，代码应该写成如下：（前序遍历）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getDepth</span><span class="params">(TreeNode* node, <span class="type">int</span> depth)</span> </span>&#123;</span><br><span class="line">        result = depth &gt; result ? depth : result; <span class="comment">// 中</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left == <span class="literal">NULL</span> &amp;&amp; node-&gt;right == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left) &#123; <span class="comment">// 左</span></span><br><span class="line">            depth++;    <span class="comment">// 深度+1</span></span><br><span class="line">            <span class="built_in">getDepth</span>(node-&gt;left, depth);</span><br><span class="line">            depth--;    <span class="comment">// 回溯，深度-1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right) &#123; <span class="comment">// 右</span></span><br><span class="line">            depth++;    <span class="comment">// 深度+1</span></span><br><span class="line">            <span class="built_in">getDepth</span>(node-&gt;right, depth);</span><br><span class="line">            depth--;    <span class="comment">// 回溯，深度-1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> result;</span><br><span class="line">        <span class="built_in">getDepth</span>(root, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>可以看出使用了前序（中左右）的遍历顺序，这才是真正求深度的逻辑！</strong></p>
<p>注意以上代码是为了把细节体现出来，简化一下代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getDepth</span><span class="params">(TreeNode* node, <span class="type">int</span> depth)</span> </span>&#123;</span><br><span class="line">        result = depth &gt; result ? depth : result; <span class="comment">// 中</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left == <span class="literal">NULL</span> &amp;&amp; node-&gt;right == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left) &#123; <span class="comment">// 左</span></span><br><span class="line">            <span class="built_in">getDepth</span>(node-&gt;left, depth + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right) &#123; <span class="comment">// 右</span></span><br><span class="line">            <span class="built_in">getDepth</span>(node-&gt;right, depth + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="number">0</span>) <span class="keyword">return</span> result;</span><br><span class="line">        <span class="built_in">getDepth</span>(root, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h2><p>此时大家应该明白了既然要求比较高度，必然是要后序遍历。</p>
<p>递归三步曲分析：</p>
<ol>
<li>明确递归函数的参数和返回值</li>
</ol>
<p>参数：当前传入节点。<br>返回值：以当前传入节点为根节点的树的高度。</p>
<p>那么如何标记左右子树是否差值大于1呢？</p>
<p>如果当前传入节点为根节点的二叉树已经不是二叉平衡树了，还返回高度的话就没有意义了。</p>
<p>所以如果已经不是二叉平衡树了，可以返回-1 来标记已经不符合平衡树的规则了。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -1 表示已经不是平衡二叉树了，否则返回值是以该节点为根节点树的高度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getHeight</span><span class="params">(TreeNode* node)</span></span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>明确终止条件</li>
</ol>
<p>递归的过程中依然是遇到空节点了为终止，返回0，表示当前节点为根节点的树高度为0</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>明确单层递归的逻辑</li>
</ol>
<p>如何判断以当前传入节点为根节点的二叉树是否是平衡二叉树呢？当然是其左子树高度和其右子树高度的差值。</p>
<p>分别求出其左右子树的高度，然后如果差值小于等于1，则返回当前二叉树的高度，否则则返回-1，表示已经不是二叉平衡树了。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> leftHeight = <span class="built_in">getHeight</span>(node-&gt;left); <span class="comment">// 左</span></span><br><span class="line"><span class="keyword">if</span> (leftHeight == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> rightHeight = <span class="built_in">getHeight</span>(node-&gt;right); <span class="comment">// 右</span></span><br><span class="line"><span class="keyword">if</span> (rightHeight == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> result;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">abs</span>(leftHeight - rightHeight) &gt; <span class="number">1</span>) &#123;  <span class="comment">// 中</span></span><br><span class="line">    result = <span class="number">-1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    result = <span class="number">1</span> + <span class="built_in">max</span>(leftHeight, rightHeight); <span class="comment">// 以当前节点为根节点的树的最大高度</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure>

<p>代码精简之后如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> leftHeight = <span class="built_in">getHeight</span>(node-&gt;left);</span><br><span class="line"><span class="keyword">if</span> (leftHeight == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> rightHeight = <span class="built_in">getHeight</span>(node-&gt;right);</span><br><span class="line"><span class="keyword">if</span> (rightHeight == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">abs</span>(leftHeight - rightHeight) &gt; <span class="number">1</span> ? <span class="number">-1</span> : <span class="number">1</span> + <span class="built_in">max</span>(leftHeight, rightHeight);</span><br></pre></td></tr></table></figure>

<p>此时递归的函数就已经写出来了，这个递归的函数传入节点指针，返回以该节点为根节点的二叉树的高度，如果不是二叉平衡树，则返回-1。</p>
<p>getHeight整体代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getHeight</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> leftHeight = <span class="built_in">getHeight</span>(node-&gt;left);</span><br><span class="line">    <span class="keyword">if</span> (leftHeight == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> rightHeight = <span class="built_in">getHeight</span>(node-&gt;right);</span><br><span class="line">    <span class="keyword">if</span> (rightHeight == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">abs</span>(leftHeight - rightHeight) &gt; <span class="number">1</span> ? <span class="number">-1</span> : <span class="number">1</span> + <span class="built_in">max</span>(leftHeight, rightHeight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后本题整体递归代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 返回以该节点为根节点的二叉树的高度，如果不是平衡二叉树了则返回-1</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getHeight</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> leftHeight = <span class="built_in">getHeight</span>(node-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (leftHeight == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> rightHeight = <span class="built_in">getHeight</span>(node-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> (rightHeight == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(leftHeight - rightHeight) &gt; <span class="number">1</span> ? <span class="number">-1</span> : <span class="number">1</span> + <span class="built_in">max</span>(leftHeight, rightHeight);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getHeight</span>(root) == <span class="number">-1</span> ? <span class="literal">false</span> : <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="二叉树的所有路径"><a href="#二叉树的所有路径" class="headerlink" title="二叉树的所有路径"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-paths/">二叉树的所有路径</a></h1><p>给定一个二叉树，返回所有从根节点到叶子节点的路径。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<p>示例: <img src="https://img-blog.csdnimg.cn/2021020415161576.png" alt="257.二叉树的所有路径1"></p>
<h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>这道题目要求从根节点到叶子的路径，所以需要前序遍历，这样才方便让父节点指向孩子节点，找到对应的路径。</p>
<p>在这道题目中将第一次涉及到回溯，因为我们要把路径记录下来，需要回溯来回退一一个路径在进入另一个路径。</p>
<p>前序遍历以及回溯的过程如图：</p>
<p><img src="https://img-blog.csdnimg.cn/20210204151702443.png" alt="257.二叉树的所有路径"></p>
<p>我们先使用递归的方式，来做前序遍历。<strong>要知道递归和回溯就是一家的，本题也需要回溯。</strong></p>
<h2 id="递归-2"><a href="#递归-2" class="headerlink" title="递归"></a>递归</h2><ol>
<li>递归函数函数参数以及返回值</li>
</ol>
<p>要传入根节点，记录每一条路径的path，和存放结果集的result，这里递归不需要返回值，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur, vector&lt;<span class="type">int</span>&gt;&amp; path, vector&lt;string&gt;&amp; result)</span></span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>确定递归终止条件</li>
</ol>
<p>再写递归的时候都习惯了这么写：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (cur == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    终止处理逻辑</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是本题的终止条件这样写会很麻烦，因为本题要找到叶子节点，就开始结束的处理逻辑了（把路径放进result里）。</p>
<p><strong>那么什么时候算是找到了叶子节点？</strong> 是当 cur不为空，其左右孩子都为空的时候，就找到叶子节点。</p>
<p>所以本题的终止条件是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (cur-&gt;left == <span class="literal">NULL</span> &amp;&amp; cur-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    终止处理逻辑</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么没有判断cur是否为空呢，因为下面的逻辑可以控制空节点不入循环。</p>
<p>再来看一下终止处理的逻辑。</p>
<p>这里使用vector 结构path来记录路径，所以要把vector 结构的path转为string格式，在把这个string 放进 result里。</p>
<p><strong>那么为什么使用了vector 结构来记录路径呢？</strong> 因为在下面处理单层递归逻辑的时候，要做回溯，使用vector方便来做回溯。</p>
<p>可能有的同学问了，我看有些人的代码也没有回溯啊。</p>
<p><strong>其实是有回溯的，只不过隐藏在函数调用时的参数赋值里</strong>，下文我还会提到。</p>
<p>这里我们先使用vector结构的path容器来记录路径，那么终止处理逻辑如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (cur-&gt;left == <span class="literal">NULL</span> &amp;&amp; cur-&gt;right == <span class="literal">NULL</span>) &#123; <span class="comment">// 遇到叶子节点</span></span><br><span class="line">    string sPath;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; path.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123; <span class="comment">// 将path里记录的路径转为string格式</span></span><br><span class="line">        sPath += <span class="built_in">to_string</span>(path[i]);</span><br><span class="line">        sPath += <span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sPath += <span class="built_in">to_string</span>(path[path.<span class="built_in">size</span>() - <span class="number">1</span>]); <span class="comment">// 记录最后一个节点（叶子节点）</span></span><br><span class="line">    result.<span class="built_in">push_back</span>(sPath); <span class="comment">// 收集一个路径</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>确定单层递归逻辑</li>
</ol>
<p>因为是前序遍历，需要先处理中间节点，中间节点就是我们要记录路径上的节点，先放进path中。</p>
<p><code>path.push_back(cur-&gt;val);</code></p>
<p>然后是递归和回溯的过程，上面说过没有判断cur是否为空，那么在这里递归的时候，如果为空就不进行下一层递归了。</p>
<p>所以递归前要加上判断语句，下面要递归的节点是否为空，如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (cur-&gt;left) &#123;</span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;left, path, result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (cur-&gt;right) &#123;</span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;right, path, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时还没完，递归完，要做回溯啊，因为path 不能一直加入节点，它还要删节点，然后才能加入新的节点。</p>
<p>那么回溯要怎么回溯呢，一些同学会这么写，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (cur-&gt;left) &#123;</span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;left, path, result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (cur-&gt;right) &#123;</span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;right, path, result);</span><br><span class="line">&#125;</span><br><span class="line">path.<span class="built_in">pop_back</span>();</span><br></pre></td></tr></table></figure>

<p>这个回溯就要很大的问题，我们知道，<strong>回溯和递归是一一对应的，有一个递归，就要有一个回溯</strong>，这么写的话相当于把递归和回溯拆开了， 一个在花括号里，一个在花括号外。</p>
<p><strong>所以回溯要和递归永远在一起，世界上最遥远的距离是你在花括号里，而我在花括号外！</strong></p>
<p>那么代码应该这么写：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (cur-&gt;left) &#123;</span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;left, path, result);</span><br><span class="line">    path.<span class="built_in">pop_back</span>(); <span class="comment">// 回溯</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (cur-&gt;right) &#123;</span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;right, path, result);</span><br><span class="line">    path.<span class="built_in">pop_back</span>(); <span class="comment">// 回溯</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur, vector&lt;<span class="type">int</span>&gt;&amp; path, vector&lt;string&gt;&amp; result)</span> </span>&#123;</span><br><span class="line">        path.<span class="built_in">push_back</span>(cur-&gt;val); <span class="comment">// 中，中为什么写在这里，因为最后一个节点也要加入到path中 </span></span><br><span class="line">        <span class="comment">// 这才到了叶子节点</span></span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;left == <span class="literal">NULL</span> &amp;&amp; cur-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            string sPath;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; path.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">                sPath += <span class="built_in">to_string</span>(path[i]);</span><br><span class="line">                sPath += <span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sPath += <span class="built_in">to_string</span>(path[path.<span class="built_in">size</span>() - <span class="number">1</span>]);</span><br><span class="line">            result.<span class="built_in">push_back</span>(sPath);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;left) &#123; <span class="comment">// 左 </span></span><br><span class="line">            <span class="built_in">traversal</span>(cur-&gt;left, path, result);</span><br><span class="line">            path.<span class="built_in">pop_back</span>(); <span class="comment">// 回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;right) &#123; <span class="comment">// 右</span></span><br><span class="line">            <span class="built_in">traversal</span>(cur-&gt;right, path, result);</span><br><span class="line">            path.<span class="built_in">pop_back</span>(); <span class="comment">// 回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">binaryTreePaths</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; result;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> result;</span><br><span class="line">        <span class="built_in">traversal</span>(root, path, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="左叶子之和"><a href="#左叶子之和" class="headerlink" title="左叶子之和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sum-of-left-leaves/">左叶子之和</a></h1><p>计算给定二叉树的所有左叶子之和。</p>
<p>示例：</p>
<p><img src="https://img-blog.csdnimg.cn/20210204151927654.png" alt="404.左叶子之和1"></p>
<h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p><strong>首先要注意是判断左叶子，不是二叉树左侧节点，所以不要上来想着层序遍历。</strong></p>
<p>因为题目中其实没有说清楚左叶子究竟是什么节点，那么我来给出左叶子的明确定义：<strong>节点A的左孩子不为空，且左孩子的左右孩子都为空（说明是叶子节点），那么A节点的左孩子为左叶子节点</strong></p>
<p>大家思考一下如下图中二叉树，左叶子之和究竟是多少？</p>
<p><img src="https://img-blog.csdnimg.cn/20210204151949672.png" alt="404.左叶子之和"></p>
<p><strong>其实是0，因为这棵树根本没有左叶子！</strong></p>
<p>但看这个图的左叶子之和是多少？</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220902165805.png" alt="图二"></p>
<p>相信通过这两个图，大家可以最左叶子的定义有明确理解了。</p>
<p>那么<strong>判断当前节点是不是左叶子是无法判断的，必须要通过节点的父节点来判断其左孩子是不是左叶子。</strong></p>
<p>如果该节点的左节点不为空，该节点的左节点的左节点为空，该节点的左节点的右节点为空，则找到了一个左叶子，判断代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (node-&gt;left != <span class="literal">NULL</span> &amp;&amp; node-&gt;left-&gt;left == <span class="literal">NULL</span> &amp;&amp; node-&gt;left-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    左叶子节点处理逻辑</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="递归法-3"><a href="#递归法-3" class="headerlink" title="递归法"></a>递归法</h3><p>递归的遍历顺序为后序遍历（左右中），是因为要通过递归函数的返回值来累加求取左叶子数值之和。</p>
<p>递归三部曲：</p>
<ol>
<li>确定递归函数的参数和返回值</li>
</ol>
<p>判断一个树的左叶子节点之和，那么一定要传入树的根节点，递归函数的返回值为数值之和，所以为int</p>
<p>使用题目中给出的函数就可以了。</p>
<ol start="2">
<li>确定终止条件</li>
</ol>
<p>如果遍历到空节点，那么左叶子值一定是0</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>注意，只有当前遍历的节点是父节点，才能判断其子节点是不是左叶子。 所以如果当前遍历的节点是叶子节点，那其左叶子也必定是0，那么终止条件为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right== <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//其实这个也可以不写，如果不写不影响结果，但就会让</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>确定单层递归的逻辑</li>
</ol>
<p>当遇到左叶子节点的时候，记录数值，然后通过递归求取左子树左叶子之和，和 右子树左叶子之和，相加便是整个树的左叶子之和。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> leftValue = <span class="built_in">sumOfLeftLeaves</span>(root-&gt;left);    <span class="comment">// 左</span></span><br><span class="line"><span class="keyword">if</span> (root-&gt;left &amp;&amp; !root-&gt;left-&gt;left &amp;&amp; !root-&gt;left-&gt;right) &#123;</span><br><span class="line">    leftValue = root-&gt;left-&gt;val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> rightValue = <span class="built_in">sumOfLeftLeaves</span>(root-&gt;right);  <span class="comment">// 右</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> sum = leftValue + rightValue;               <span class="comment">// 中</span></span><br><span class="line"><span class="keyword">return</span> sum;</span><br></pre></td></tr></table></figure>

<p>整体递归代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right== <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> leftValue = <span class="built_in">sumOfLeftLeaves</span>(root-&gt;left);    <span class="comment">// 左</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left &amp;&amp; !root-&gt;left-&gt;left &amp;&amp; !root-&gt;left-&gt;right) &#123; <span class="comment">// 左子树就是一个左叶子的情况</span></span><br><span class="line">            leftValue = root-&gt;left-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> rightValue = <span class="built_in">sumOfLeftLeaves</span>(root-&gt;right);  <span class="comment">// 右</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> sum = leftValue + rightValue;               <span class="comment">// 中</span></span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="迭代法-3"><a href="#迭代法-3" class="headerlink" title="迭代法"></a>迭代法</h3><p>本题迭代法使用前中后序都是可以的，只要把左叶子节点统计出来，就可以了，那么参考文章 <a target="_blank" rel="noopener" href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86.html">二叉树：听说递归能做的，栈也能做！</a>，可以写出一个前序遍历的迭代法。</p>
<p>判断条件都是一样的，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        st.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* node = st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left != <span class="literal">NULL</span> &amp;&amp; node-&gt;left-&gt;left == <span class="literal">NULL</span> &amp;&amp; node-&gt;left-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                result += node-&gt;left-&gt;val;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right) st.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left) st.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="找树左下角的值"><a href="#找树左下角的值" class="headerlink" title="找树左下角的值"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-bottom-left-tree-value/">找树左下角的值</a></h1><p>给定一个二叉树，在树的最后一行找到最左边的值。</p>
<p>示例 1:</p>
<p><img src="https://img-blog.csdnimg.cn/20210204152956836.png" alt="513.找树左下角的值"></p>
<p>示例 2:</p>
<p><img src="https://img-blog.csdnimg.cn/20210204153017586.png" alt="513.找树左下角的值1"></p>
<h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>本地要找出树的最后一行找到最左边的值。此时大家应该想起用层序遍历是非常简单的了，反而用递归的话会比较难一点。</p>
<p>我们依然还是先介绍递归法。</p>
<h3 id="递归-3"><a href="#递归-3" class="headerlink" title="递归"></a>递归</h3><p>咋眼一看，这道题目用递归的话就就一直向左遍历，最后一个就是答案呗？</p>
<p>没有这么简单，一直向左遍历到最后一个，它未必是最后一行啊。</p>
<p>我们来分析一下题目：在树的<strong>最后一行</strong>找到<strong>最左边的值</strong>。</p>
<p>首先要是最后一行，然后是最左边的值。</p>
<p>如果使用递归法，如何判断是最后一行呢，其实就是深度最大的叶子节点一定是最后一行。</p>
<p>如果对二叉树深度和高度还有点疑惑的话，请看：<a target="_blank" rel="noopener" href="https://programmercarl.com/0110.%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.html">110.平衡二叉树</a></p>
<p>所以要找深度最大的叶子节点。</p>
<p>那么如果找最左边的呢？可以使用前序遍历（当然中序，后序都可以，因为本题没有 中间节点的处理逻辑，只要左优先就行），保证优先左边搜索，然后记录深度最大的叶子节点，此时就是树的最后一行最左边的值。</p>
<p>递归三部曲：</p>
<ol>
<li>确定递归函数的参数和返回值</li>
</ol>
<p>参数必须有要遍历的树的根节点，还有就是一个int型的变量用来记录最长深度。 这里就不需要返回值了，所以递归函数的返回类型为void。</p>
<p>本题还需要类里的两个全局变量，maxLen用来记录最大深度，result记录最大深度最左节点的数值。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> maxDepth = INT_MIN;   <span class="comment">// 全局变量 记录最大深度</span></span><br><span class="line"><span class="type">int</span> result;       <span class="comment">// 全局变量 最大深度最左节点的数值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* root, <span class="type">int</span> depth)</span></span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>确定终止条件</li>
</ol>
<p>当遇到叶子节点的时候，就需要统计一下最大的深度了，所以需要遇到叶子节点来更新最大深度。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (depth &gt; maxDepth) &#123;</span><br><span class="line">        maxDepth = depth;           <span class="comment">// 更新最大深度</span></span><br><span class="line">        result = root-&gt;val;   <span class="comment">// 最大深度最左面的数值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>确定单层递归的逻辑</li>
</ol>
<p>在找最大深度的时候，递归的过程中依然要使用回溯，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">                    <span class="comment">// 中</span></span><br><span class="line"><span class="keyword">if</span> (root-&gt;left) &#123;   <span class="comment">// 左</span></span><br><span class="line">    depth++; <span class="comment">// 深度加一</span></span><br><span class="line">    <span class="built_in">traversal</span>(root-&gt;left, depth);</span><br><span class="line">    depth--; <span class="comment">// 回溯，深度减一</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (root-&gt;right) &#123; <span class="comment">// 右</span></span><br><span class="line">    depth++; <span class="comment">// 深度加一</span></span><br><span class="line">    <span class="built_in">traversal</span>(root-&gt;right, depth);</span><br><span class="line">    depth--; <span class="comment">// 回溯，深度减一</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br></pre></td></tr></table></figure>

<p>完整代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> maxDepth = INT_MIN;</span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* root, <span class="type">int</span> depth)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (depth &gt; maxDepth) &#123;</span><br><span class="line">                maxDepth = depth;</span><br><span class="line">                result = root-&gt;val;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left) &#123;</span><br><span class="line">            depth++;</span><br><span class="line">            <span class="built_in">traversal</span>(root-&gt;left, depth);</span><br><span class="line">            depth--; <span class="comment">// 回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right) &#123;</span><br><span class="line">            depth++;</span><br><span class="line">            <span class="built_in">traversal</span>(root-&gt;right, depth);</span><br><span class="line">            depth--; <span class="comment">// 回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">traversal</span>(root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="迭代法-4"><a href="#迭代法-4" class="headerlink" title="迭代法"></a>迭代法</h3><p>本题使用层序遍历再合适不过了，比递归要好理解的多！</p>
<p>只需要记录最后一行第一个节点的数值就可以了。</p>
<p>如果对层序遍历不了解，看这篇<a target="_blank" rel="noopener" href="https://programmercarl.com/0102.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86.html">二叉树：层序遍历登场！</a>，这篇里也给出了层序遍历的模板，稍作修改就一过刷了这道题了。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) result = node-&gt;val; <span class="comment">// 记录最后一行第一个元素</span></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="路径总和"><a href="#路径总和" class="headerlink" title="路径总和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-sum/">路径总和</a></h1><p>给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<p>示例:  给定如下二叉树，以及目标和 sum &#x3D; 22，</p>
<p><img src="https://img-blog.csdnimg.cn/20210203160355234.png" alt="112.路径总和1"></p>
<p>返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5-&gt;4-&gt;11-&gt;2。</p>
<h2 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h2><p>这道题我们要遍历从根节点到叶子节点的的路径看看总和是不是目标和。</p>
<h3 id="递归-4"><a href="#递归-4" class="headerlink" title="递归"></a>递归</h3><p>可以使用深度优先遍历的方式（本题前中后序都可以，无所谓，因为中节点也没有处理逻辑）来遍历二叉树</p>
<ol>
<li>确定递归函数的参数和返回类型</li>
</ol>
<p>参数：需要二叉树的根节点，还需要一个计数器，这个计数器用来计算二叉树的一条边之和是否正好是目标和，计数器为int型。</p>
<p>再来看返回值，递归函数什么时候需要返回值？什么时候不需要返回值？这里总结如下三点：</p>
<ul>
<li>如果需要搜索整棵二叉树且不用处理递归返回值，递归函数就不要返回值。（这种情况就是本文下半部分介绍的113.路径总和ii）</li>
<li>如果需要搜索整棵二叉树且需要处理递归返回值，递归函数就需要返回值。 （这种情况我们在<a target="_blank" rel="noopener" href="https://programmercarl.com/0236.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html">236. 二叉树的最近公共祖先</a>中介绍）</li>
<li>如果要搜索其中一条符合条件的路径，那么递归一定需要返回值，因为遇到符合条件的路径了就要及时返回。（本题的情况）</li>
</ul>
<p>而本题我们要找一条符合条件的路径，所以递归函数需要返回值，及时返回，那么返回类型是什么呢？</p>
<p>如图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/2021020316051216.png" alt="112.路径总和"></p>
<p>图中可以看出，遍历的路线，并不要遍历整棵树，所以递归函数需要返回值，可以用bool类型表示。</p>
<p>所以代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">traversal</span><span class="params">(treenode* cur, <span class="type">int</span> count)</span>   <span class="comment">// 注意函数的返回类型</span></span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>确定终止条件</li>
</ol>
<p>首先计数器如何统计这一条路径的和呢？</p>
<p>不要去累加然后判断是否等于目标和，那么代码比较麻烦，可以用递减，让<strong>计数器count初始为目标和</strong>，然后每次减去遍历路径节点上的数值。</p>
<p>如果最后count &#x3D;&#x3D; 0，同时到了叶子节点的话，说明找到了目标和。</p>
<p>如果遍历到了叶子节点，count不为0，就是没找到。</p>
<p>递归终止条件代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!cur-&gt;left &amp;&amp; !cur-&gt;right &amp;&amp; count == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 遇到叶子节点，并且计数为0</span></span><br><span class="line"><span class="keyword">if</span> (!cur-&gt;left &amp;&amp; !cur-&gt;right) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 遇到叶子节点而没有找到合适的边，直接返回</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>确定单层递归的逻辑</li>
</ol>
<p>因为终止条件是判断叶子节点，所以递归的过程中就不要让空节点进入递归了。</p>
<p>递归函数是有返回值的，如果递归函数返回true，说明找到了合适的路径，应该立刻返回。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (cur-&gt;left) &#123; <span class="comment">// 左 （空节点不遍历）</span></span><br><span class="line">    <span class="comment">// 遇到叶子节点返回true，则直接返回true</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">traversal</span>(cur-&gt;left, count - cur-&gt;left-&gt;val)) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 注意这里有回溯的逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (cur-&gt;right) &#123; <span class="comment">// 右 （空节点不遍历）</span></span><br><span class="line">    <span class="comment">// 遇到叶子节点返回true，则直接返回true</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">traversal</span>(cur-&gt;right, count - cur-&gt;right-&gt;val)) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 注意这里有回溯的逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<p>以上代码中是包含着回溯的，没有回溯，如何后撤重新找另一条路径呢。</p>
<p>回溯隐藏在<code>traversal(cur-&gt;left, count - cur-&gt;left-&gt;val)</code>这里， 因为把<code>count - cur-&gt;left-&gt;val</code> 直接作为参数传进去，函数结束，count的数值没有改变。</p>
<p>为了把回溯的过程体现出来，可以改为如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (cur-&gt;left) &#123; <span class="comment">// 左</span></span><br><span class="line">    count -= cur-&gt;left-&gt;val; <span class="comment">// 递归，处理节点;</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">traversal</span>(cur-&gt;left, count)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    count += cur-&gt;left-&gt;val; <span class="comment">// 回溯，撤销处理结果</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (cur-&gt;right) &#123; <span class="comment">// 右</span></span><br><span class="line">    count -= cur-&gt;right-&gt;val;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">traversal</span>(cur-&gt;right, count)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    count += cur-&gt;right-&gt;val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<p>整体代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">traversal</span><span class="params">(TreeNode* cur, <span class="type">int</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!cur-&gt;left &amp;&amp; !cur-&gt;right &amp;&amp; count == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 遇到叶子节点，并且计数为0</span></span><br><span class="line">        <span class="keyword">if</span> (!cur-&gt;left &amp;&amp; !cur-&gt;right) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 遇到叶子节点直接返回</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;left) &#123; <span class="comment">// 左</span></span><br><span class="line">            count -= cur-&gt;left-&gt;val; <span class="comment">// 递归，处理节点;</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">traversal</span>(cur-&gt;left, count)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            count += cur-&gt;left-&gt;val; <span class="comment">// 回溯，撤销处理结果</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;right) &#123; <span class="comment">// 右</span></span><br><span class="line">            count -= cur-&gt;right-&gt;val; <span class="comment">// 递归，处理节点;</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">traversal</span>(cur-&gt;right, count)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            count += cur-&gt;right-&gt;val; <span class="comment">// 回溯，撤销处理结果</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="type">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">traversal</span>(root, sum - root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p>如果使用栈模拟递归的话，那么如果做回溯呢？</p>
<p><strong>此时栈里一个元素不仅要记录该节点指针，还要记录从头结点到该节点的路径数值总和。</strong></p>
<p>c++就我们用pair结构来存放这个栈里的元素。</p>
<p>定义为：<code>pair&lt;TreeNode*, int&gt;</code> pair&lt;节点指针，路径数值&gt;</p>
<p>这个为栈里的一个元素。</p>
<p>如下代码是使用栈模拟的前序遍历，如下：（详细注释）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">haspathsum</span><span class="params">(TreeNode* root, <span class="type">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == null) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 此时栈里要放的是pair&lt;节点指针，路径数值&gt;</span></span><br><span class="line">        stack&lt;pair&lt;TreeNode*, <span class="type">int</span>&gt;&gt; st;</span><br><span class="line">        st.<span class="built_in">push</span>(<span class="built_in">pair</span>&lt;TreeNode*, <span class="type">int</span>&gt;(root, root-&gt;val));</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            pair&lt;TreeNode*, <span class="type">int</span>&gt; node = st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="comment">// 如果该节点是叶子节点了，同时该节点的路径数值等于sum，那么就返回true</span></span><br><span class="line">            <span class="keyword">if</span> (!node.first-&gt;left &amp;&amp; !node.first-&gt;right &amp;&amp; sum == node.second) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 右节点，压进去一个节点的时候，将该节点的路径数值也记录下来</span></span><br><span class="line">            <span class="keyword">if</span> (node.first-&gt;right) &#123;</span><br><span class="line">                st.<span class="built_in">push</span>(<span class="built_in">pair</span>&lt;TreeNode*, <span class="type">int</span>&gt;(node.first-&gt;right, node.second + node.first-&gt;right-&gt;val));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 左节点，压进去一个节点的时候，将该节点的路径数值也记录下来</span></span><br><span class="line">            <span class="keyword">if</span> (node.first-&gt;left) &#123;</span><br><span class="line">                st.<span class="built_in">push</span>(<span class="built_in">pair</span>&lt;TreeNode*, <span class="type">int</span>&gt;(node.first-&gt;left, node.second + node.first-&gt;left-&gt;val));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="从中序与后序遍历序列构造二叉树"><a href="#从中序与后序遍历序列构造二叉树" class="headerlink" title="从中序与后序遍历序列构造二叉树"></a>从中序与后序遍历序列构造二叉树</h1><p>根据一棵树的中序遍历与后序遍历构造二叉树。</p>
<p>注意: 你可以假设树中没有重复的元素。</p>
<p>例如，给出</p>
<p>中序遍历 inorder &#x3D; [9,3,15,20,7] 后序遍历 postorder &#x3D; [9,15,7,20,3] 返回如下的二叉树：</p>
<p><img src="https://img-blog.csdnimg.cn/20210203154316774.png" alt="106. 从中序与后序遍历序列构造二叉树1"></p>
<h2 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h2><p>首先回忆一下如何根据两个顺序构造一个唯一的二叉树，相信理论知识大家应该都清楚，就是以 后序数组的最后一个元素为切割点，先切中序数组，根据中序数组，反过来在切后序数组。一层一层切下去，每次后序数组最后一个元素就是节点元素。</p>
<p>如果让我们肉眼看两个序列，画一棵二叉树的话，应该分分钟都可以画出来。</p>
<p>流程如图：</p>
<p><img src="https://img-blog.csdnimg.cn/20210203154249860.png" alt="106.从中序与后序遍历序列构造二叉树"></p>
<p>那么代码应该怎么写呢？</p>
<p>说到一层一层切割，就应该想到了递归。</p>
<p>来看一下一共分几步：</p>
<ul>
<li><p>第一步：如果数组大小为零的话，说明是空节点了。</p>
</li>
<li><p>第二步：如果不为空，那么取后序数组最后一个元素作为节点元素。</p>
</li>
<li><p>第三步：找到后序数组最后一个元素在中序数组的位置，作为切割点</p>
</li>
<li><p>第四步：切割中序数组，切成中序左数组和中序右数组 （顺序别搞反了，一定是先切中序数组）</p>
</li>
<li><p>第五步：切割后序数组，切成后序左数组和后序右数组</p>
</li>
<li><p>第六步：递归处理左区间和右区间</p>
</li>
</ul>
<p>不难写出如下代码：（先把框架写出来）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">traversal</span> <span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; inorder, vector&lt;<span class="type">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一步</span></span><br><span class="line">    <span class="keyword">if</span> (postorder.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二步：后序遍历数组最后一个元素，就是当前的中间节点</span></span><br><span class="line">    <span class="type">int</span> rootValue = postorder[postorder.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">    TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(rootValue);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 叶子节点</span></span><br><span class="line">    <span class="keyword">if</span> (postorder.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第三步：找切割点</span></span><br><span class="line">    <span class="type">int</span> delimiterIndex;</span><br><span class="line">    <span class="keyword">for</span> (delimiterIndex = <span class="number">0</span>; delimiterIndex &lt; inorder.<span class="built_in">size</span>(); delimiterIndex++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (inorder[delimiterIndex] == rootValue) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第四步：切割中序数组，得到 中序左数组和中序右数组</span></span><br><span class="line">    <span class="comment">// 第五步：切割后序数组，得到 后序左数组和后序右数组</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第六步</span></span><br><span class="line">    root-&gt;left = <span class="built_in">traversal</span>(中序左数组, 后序左数组);</span><br><span class="line">    root-&gt;right = <span class="built_in">traversal</span>(中序右数组, 后序右数组);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>难点大家应该发现了，就是如何切割，以及边界值找不好很容易乱套。</strong></p>
<p>此时应该注意确定切割的标准，是左闭右开，还有左开右闭，还是左闭右闭，这个就是不变量，要在递归中保持这个不变量。</p>
<p><strong>在切割的过程中会产生四个区间，把握不好不变量的话，一会左闭右开，一会左闭右闭，必然乱套！</strong></p>
<p>我在<a target="_blank" rel="noopener" href="https://programmercarl.com/0035.%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE.html">数组：每次遇到二分法，都是一看就会，一写就废 </a>和<a target="_blank" rel="noopener" href="https://programmercarl.com/0059.%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5II.html">数组：这个循环可以转懵很多人！</a>中都强调过循环不变量的重要性，在二分查找以及螺旋矩阵的求解中，坚持循环不变量非常重要，本题也是。</p>
<p>首先要切割中序数组，为什么先切割中序数组呢？</p>
<p>切割点在后序数组的最后一个元素，就是用这个元素来切割中序数组的，所以必要先切割中序数组。</p>
<p>中序数组相对比较好切，找到切割点（后序数组的最后一个元素）在中序数组的位置，然后切割，如下代码中我坚持左闭右开的原则：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找到中序遍历的切割点</span></span><br><span class="line"><span class="type">int</span> delimiterIndex;</span><br><span class="line"><span class="keyword">for</span> (delimiterIndex = <span class="number">0</span>; delimiterIndex &lt; inorder.<span class="built_in">size</span>(); delimiterIndex++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (inorder[delimiterIndex] == rootValue) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 左闭右开区间：[0, delimiterIndex)</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">leftInorder</span><span class="params">(inorder.begin(), inorder.begin() + delimiterIndex)</span></span>;</span><br><span class="line"><span class="comment">// [delimiterIndex + 1, end)</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rightInorder</span><span class="params">(inorder.begin() + delimiterIndex + <span class="number">1</span>, inorder.end() )</span></span>;</span><br></pre></td></tr></table></figure>

<p>接下来就要切割后序数组了。</p>
<p>首先后序数组的最后一个元素指定不能要了，这是切割点 也是 当前二叉树中间节点的元素，已经用了。</p>
<p>后序数组的切割点怎么找？</p>
<p>后序数组没有明确的切割元素来进行左右切割，不像中序数组有明确的切割点，切割点左右分开就可以了。</p>
<p><strong>此时有一个很重的点，就是中序数组大小一定是和后序数组的大小相同的（这是必然）。</strong></p>
<p>中序数组我们都切成了左中序数组和右中序数组了，那么后序数组就可以按照左中序数组的大小来切割，切成左后序数组和右后序数组。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// postorder 舍弃末尾元素，因为这个元素就是中间节点，已经用过了</span></span><br><span class="line">postorder.<span class="built_in">resize</span>(postorder.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 左闭右开，注意这里使用了左中序数组大小作为切割点：[0, leftInorder.size)</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">leftPostorder</span><span class="params">(postorder.begin(), postorder.begin() + leftInorder.size())</span></span>;</span><br><span class="line"><span class="comment">// [leftInorder.size(), end)</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rightPostorder</span><span class="params">(postorder.begin() + leftInorder.size(), postorder.end())</span></span>;</span><br></pre></td></tr></table></figure>

<p>此时，中序数组切成了左中序数组和右中序数组，后序数组切割成左后序数组和右后序数组。</p>
<p>接下来可以递归了，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root-&gt;left = <span class="built_in">traversal</span>(leftInorder, leftPostorder);</span><br><span class="line">root-&gt;right = <span class="built_in">traversal</span>(rightInorder, rightPostorder);</span><br></pre></td></tr></table></figure>

<h3 id="C-完整代码"><a href="#C-完整代码" class="headerlink" title="C++完整代码"></a>C++完整代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">traversal</span> <span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; inorder, vector&lt;<span class="type">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (postorder.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 后序遍历数组最后一个元素，就是当前的中间节点</span></span><br><span class="line">        <span class="type">int</span> rootValue = postorder[postorder.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(rootValue);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 叶子节点</span></span><br><span class="line">        <span class="keyword">if</span> (postorder.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到中序遍历的切割点</span></span><br><span class="line">        <span class="type">int</span> delimiterIndex;</span><br><span class="line">        <span class="keyword">for</span> (delimiterIndex = <span class="number">0</span>; delimiterIndex &lt; inorder.<span class="built_in">size</span>(); delimiterIndex++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inorder[delimiterIndex] == rootValue) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 切割中序数组</span></span><br><span class="line">        <span class="comment">// 左闭右开区间：[0, delimiterIndex)</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">leftInorder</span><span class="params">(inorder.begin(), inorder.begin() + delimiterIndex)</span></span>;</span><br><span class="line">        <span class="comment">// [delimiterIndex + 1, end)</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rightInorder</span><span class="params">(inorder.begin() + delimiterIndex + <span class="number">1</span>, inorder.end() )</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// postorder 舍弃末尾元素</span></span><br><span class="line">        postorder.<span class="built_in">resize</span>(postorder.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 切割后序数组</span></span><br><span class="line">        <span class="comment">// 依然左闭右开，注意这里使用了左中序数组大小作为切割点</span></span><br><span class="line">        <span class="comment">// [0, leftInorder.size)</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">leftPostorder</span><span class="params">(postorder.begin(), postorder.begin() + leftInorder.size())</span></span>;</span><br><span class="line">        <span class="comment">// [leftInorder.size(), end)</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rightPostorder</span><span class="params">(postorder.begin() + leftInorder.size(), postorder.end())</span></span>;</span><br><span class="line"></span><br><span class="line">        root-&gt;left = <span class="built_in">traversal</span>(leftInorder, leftPostorder);</span><br><span class="line">        root-&gt;right = <span class="built_in">traversal</span>(rightInorder, rightPostorder);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; inorder, vector&lt;<span class="type">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (inorder.<span class="built_in">size</span>() == <span class="number">0</span> || postorder.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">traversal</span>(inorder, postorder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="最大二叉树"><a href="#最大二叉树" class="headerlink" title="最大二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-binary-tree/">最大二叉树</a></h1><p>给定一个不含重复元素的整数数组。一个以此数组构建的最大二叉树定义如下：</p>
<ul>
<li>二叉树的根是数组中的最大元素。</li>
<li>左子树是通过数组中最大值左边部分构造出的最大二叉树。</li>
<li>右子树是通过数组中最大值右边部分构造出的最大二叉树。</li>
</ul>
<p>通过给定的数组构建最大二叉树，并且输出这个树的根节点。</p>
<p>示例 ：</p>
<p><img src="https://img-blog.csdnimg.cn/20210204154534796.png" alt="654.最大二叉树"></p>
<p>提示：</p>
<p>给定的数组的大小在 [1, 1000] 之间。</p>
<h2 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h2><p>最大二叉树的构建过程如下：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gnbjuvioezg30dw0921ck.gif" alt="654.最大二叉树"></p>
<p>构造树一般采用的是前序遍历，因为先构造中间节点，然后递归构造左子树和右子树。</p>
<ul>
<li>确定递归函数的参数和返回值</li>
</ul>
<p>参数就是传入的是存放元素的数组，返回该数组构造的二叉树的头结点，返回类型是指向节点的指针。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">constructMaximumBinaryTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>确定终止条件</li>
</ul>
<p>题目中说了输入的数组大小一定是大于等于1的，所以我们不用考虑小于1的情况，那么当递归遍历的时候，如果传入的数组大小为1，说明遍历到了叶子节点了。</p>
<p>那么应该定义一个新的节点，并把这个数组的数值赋给新的节点，然后返回这个节点。 这表示一个数组大小是1的时候，构造了一个新的节点，并返回。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">    node-&gt;val = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>确定单层递归的逻辑</li>
</ul>
<p>这里有三步工作</p>
<ol>
<li>先要找到数组中最大的值和对应的下标， 最大的值构造根节点，下标用来下一步分割数组。</li>
</ol>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> maxValue = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> maxValueIndex = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[i] &gt; maxValue) &#123;</span><br><span class="line">        maxValue = nums[i];</span><br><span class="line">        maxValueIndex = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">TreeNode* node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">0</span>);</span><br><span class="line">node-&gt;val = maxValue;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>最大值所在的下标左区间 构造左子树</li>
</ol>
<p>这里要判断maxValueIndex &gt; 0，因为要保证左区间至少有一个数值。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (maxValueIndex &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">newVec</span><span class="params">(nums.begin(), nums.begin() + maxValueIndex)</span></span>;</span><br><span class="line">    node-&gt;left = <span class="built_in">constructMaximumBinaryTree</span>(newVec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>最大值所在的下标右区间 构造右子树</li>
</ol>
<p>判断maxValueIndex &lt; (nums.size() - 1)，确保右区间至少有一个数值。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (maxValueIndex &lt; (nums.<span class="built_in">size</span>() - <span class="number">1</span>)) &#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">newVec</span><span class="params">(nums.begin() + maxValueIndex + <span class="number">1</span>, nums.end())</span></span>;</span><br><span class="line">    node-&gt;right = <span class="built_in">constructMaximumBinaryTree</span>(newVec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样我们就分析完了，整体代码如下：（详细注释）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">constructMaximumBinaryTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        TreeNode* node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">            node-&gt;val = nums[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到数组中最大的值和对应的下标</span></span><br><span class="line">        <span class="type">int</span> maxValue = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> maxValueIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; maxValue) &#123;</span><br><span class="line">                maxValue = nums[i];</span><br><span class="line">                maxValueIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;val = maxValue;</span><br><span class="line">        <span class="comment">// 最大值所在的下标左区间 构造左子树</span></span><br><span class="line">        <span class="keyword">if</span> (maxValueIndex &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">newVec</span><span class="params">(nums.begin(), nums.begin() + maxValueIndex)</span></span>;</span><br><span class="line">            node-&gt;left = <span class="built_in">constructMaximumBinaryTree</span>(newVec);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最大值所在的下标右区间 构造右子树</span></span><br><span class="line">        <span class="keyword">if</span> (maxValueIndex &lt; (nums.<span class="built_in">size</span>() - <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">newVec</span><span class="params">(nums.begin() + maxValueIndex + <span class="number">1</span>, nums.end())</span></span>;</span><br><span class="line">            node-&gt;right = <span class="built_in">constructMaximumBinaryTree</span>(newVec);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="合并二叉树"><a href="#合并二叉树" class="headerlink" title="合并二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-two-binary-trees/">合并二叉树</a></h1><p>给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。</p>
<p>你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。</p>
<p>示例 1:</p>
<p><img src="https://img-blog.csdnimg.cn/20210204153634809.png" alt="617.合并二叉树"></p>
<p>注意: 合并必须从两个树的根节点开始。</p>
<h2 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h2><p>相信这道题目很多同学疑惑的点是如何同时遍历两个二叉树呢？</p>
<p>其实和遍历一个树逻辑是一样的，只不过传入两个树的节点，同时操作。</p>
<h3 id="递归-5"><a href="#递归-5" class="headerlink" title="递归"></a>递归</h3><p>二叉树使用递归，就要想使用前中后哪种遍历方式？</p>
<p><strong>本题使用哪种遍历都是可以的！</strong></p>
<p>我们下面以前序遍历为例。</p>
<p>动画如下：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gnbjjq8h16g30e20cwnpd.gif" alt="617.合并二叉树"></p>
<p>那么我们来按照递归三部曲来解决：</p>
<ol>
<li><strong>确定递归函数的参数和返回值：</strong></li>
</ol>
<p>首先那么要合入两个二叉树，那么参数至少是要传入两个二叉树的根节点，返回值就是合并之后二叉树的根节点。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* t1, TreeNode* t2)</span> </span>&#123;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>确定终止条件：</strong></li>
</ol>
<p>因为是传入了两个树，那么就有两个树遍历的节点t1 和 t2，如果t1 &#x3D;&#x3D; NULL 了，两个树合并就应该是 t2 了啊（如果t2也为NULL也无所谓，合并之后就是NULL）。</p>
<p>反过来如果t2 &#x3D;&#x3D; NULL，那么两个数合并就是t1（如果t1也为NULL也无所谓，合并之后就是NULL）。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (t1 == <span class="literal">NULL</span>) <span class="keyword">return</span> t2; <span class="comment">// 如果t1为空，合并之后就应该是t2</span></span><br><span class="line"><span class="keyword">if</span> (t2 == <span class="literal">NULL</span>) <span class="keyword">return</span> t1; <span class="comment">// 如果t2为空，合并之后就应该是t1</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>确定单层递归的逻辑：</strong></li>
</ol>
<p>单层递归的逻辑就比较好些了，这里我们用重复利用一下t1这个树，t1就是合并之后树的根节点（就是修改了原来树的结构）。</p>
<p>那么单层递归中，就要把两棵树的元素加到一起。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t1-&gt;val += t2-&gt;val;</span><br></pre></td></tr></table></figure>

<p>接下来t1 的左子树是：合并 t1左子树 t2左子树之后的左子树。</p>
<p>t1 的右子树：是 合并 t1右子树 t2右子树之后的右子树。</p>
<p>最终t1就是合并之后的根节点。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t1-&gt;left = <span class="built_in">mergeTrees</span>(t1-&gt;left, t2-&gt;left);</span><br><span class="line">t1-&gt;right = <span class="built_in">mergeTrees</span>(t1-&gt;right, t2-&gt;right);</span><br><span class="line"><span class="keyword">return</span> t1;</span><br></pre></td></tr></table></figure>

<p>此时前序遍历，完整代码就写出来了，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* t1, TreeNode* t2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="literal">NULL</span>) <span class="keyword">return</span> t2; <span class="comment">// 如果t1为空，合并之后就应该是t2</span></span><br><span class="line">        <span class="keyword">if</span> (t2 == <span class="literal">NULL</span>) <span class="keyword">return</span> t1; <span class="comment">// 如果t2为空，合并之后就应该是t1</span></span><br><span class="line">        <span class="comment">// 修改了t1的数值和结构</span></span><br><span class="line">        t1-&gt;val += t2-&gt;val;                             <span class="comment">// 中</span></span><br><span class="line">        t1-&gt;left = <span class="built_in">mergeTrees</span>(t1-&gt;left, t2-&gt;left);      <span class="comment">// 左</span></span><br><span class="line">        t1-&gt;right = <span class="built_in">mergeTrees</span>(t1-&gt;right, t2-&gt;right);   <span class="comment">// 右</span></span><br><span class="line">        <span class="keyword">return</span> t1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>那么中序遍历也是可以的，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* t1, TreeNode* t2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="literal">NULL</span>) <span class="keyword">return</span> t2; <span class="comment">// 如果t1为空，合并之后就应该是t2</span></span><br><span class="line">        <span class="keyword">if</span> (t2 == <span class="literal">NULL</span>) <span class="keyword">return</span> t1; <span class="comment">// 如果t2为空，合并之后就应该是t1</span></span><br><span class="line">        <span class="comment">// 修改了t1的数值和结构</span></span><br><span class="line">        t1-&gt;left = <span class="built_in">mergeTrees</span>(t1-&gt;left, t2-&gt;left);      <span class="comment">// 左</span></span><br><span class="line">        t1-&gt;val += t2-&gt;val;                             <span class="comment">// 中</span></span><br><span class="line">        t1-&gt;right = <span class="built_in">mergeTrees</span>(t1-&gt;right, t2-&gt;right);   <span class="comment">// 右</span></span><br><span class="line">        <span class="keyword">return</span> t1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>后序遍历依然可以，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* t1, TreeNode* t2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="literal">NULL</span>) <span class="keyword">return</span> t2; <span class="comment">// 如果t1为空，合并之后就应该是t2</span></span><br><span class="line">        <span class="keyword">if</span> (t2 == <span class="literal">NULL</span>) <span class="keyword">return</span> t1; <span class="comment">// 如果t2为空，合并之后就应该是t1</span></span><br><span class="line">        <span class="comment">// 修改了t1的数值和结构</span></span><br><span class="line">        t1-&gt;left = <span class="built_in">mergeTrees</span>(t1-&gt;left, t2-&gt;left);      <span class="comment">// 左</span></span><br><span class="line">        t1-&gt;right = <span class="built_in">mergeTrees</span>(t1-&gt;right, t2-&gt;right);   <span class="comment">// 右</span></span><br><span class="line">        t1-&gt;val += t2-&gt;val;                             <span class="comment">// 中</span></span><br><span class="line">        <span class="keyword">return</span> t1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="二叉搜索树中的搜索"><a href="#二叉搜索树中的搜索" class="headerlink" title="二叉搜索树中的搜索"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/search-in-a-binary-search-tree/">二叉搜索树中的搜索</a></h1><p>给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。</p>
<p>例如，</p>
<p><img src="https://img-blog.csdnimg.cn/20210204155522476.png" alt="700.二叉搜索树中的搜索"></p>
<p>在上述示例中，如果要找的值是 5，但因为没有节点值为 5，我们应该返回 NULL。</p>
<h1 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h1><p>之前我们讲了都是普通二叉树，那么接下来看看二叉搜索树。</p>
<p>在<a target="_blank" rel="noopener" href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">关于二叉树，你该了解这些！</a>中，我们已经讲过了二叉搜索树。</p>
<p>二叉搜索树是一个有序树：</p>
<ul>
<li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li>
<li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li>
<li>它的左、右子树也分别为二叉搜索树</li>
</ul>
<p>这就决定了，二叉搜索树，递归遍历和迭代遍历和普通二叉树都不一样。</p>
<p>本题，其实就是在二叉搜索树中搜索一个节点。那么我们来看看应该如何遍历。</p>
<h3 id="递归法-4"><a href="#递归法-4" class="headerlink" title="递归法"></a>递归法</h3><ol>
<li>确定递归函数的参数和返回值</li>
</ol>
<p>递归函数的参数传入的就是根节点和要搜索的数值，返回的就是以这个搜索数值所在的节点。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">searchBST</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span></span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>确定终止条件</li>
</ol>
<p>如果root为空，或者找到这个数值了，就返回root节点。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span> || root-&gt;val == val) <span class="keyword">return</span> root;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>确定单层递归的逻辑</li>
</ol>
<p>看看二叉搜索树的单层递归逻辑有何不同。</p>
<p>因为二叉搜索树的节点是有序的，所以可以有方向的去搜索。</p>
<p>如果root-&gt;val &gt; val，搜索左子树，如果root-&gt;val &lt; val，就搜索右子树，最后如果都没有搜索到，就返回NULL。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (root-&gt;val &gt; val) <span class="keyword">return</span> <span class="built_in">searchBST</span>(root-&gt;left, val); <span class="comment">// 注意这里加了return</span></span><br><span class="line"><span class="keyword">if</span> (root-&gt;val &lt; val) <span class="keyword">return</span> <span class="built_in">searchBST</span>(root-&gt;right, val);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>这里可能会疑惑，在递归遍历的时候，什么时候直接return 递归函数的返回值，什么时候不用加这个 return呢。</p>
<p>我们在<a target="_blank" rel="noopener" href="https://programmercarl.com/0112.%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C.html">二叉树：递归函数究竟什么时候需要返回值，什么时候不要返回值？</a>中讲了，如果要搜索一条边，递归函数就要加返回值，这里也是一样的道理。</p>
<p><strong>因为搜索到目标节点了，就要立即return了，这样才是找到节点就返回（搜索某一条边），如果不加return，就是遍历整棵树了。</strong></p>
<p>整体代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">searchBST</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span> || root-&gt;val == val) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &gt; val) <span class="keyword">return</span> <span class="built_in">searchBST</span>(root-&gt;left, val);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &lt; val) <span class="keyword">return</span> <span class="built_in">searchBST</span>(root-&gt;right, val);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="迭代法-5"><a href="#迭代法-5" class="headerlink" title="迭代法"></a>迭代法</h3><p>一提到二叉树遍历的迭代法，可能立刻想起使用栈来模拟深度遍历，使用队列来模拟广度遍历。</p>
<p>对于二叉搜索树可就不一样了，因为二叉搜索树的特殊性，也就是节点的有序性，可以不使用辅助栈或者队列就可以写出迭代法。</p>
<p>对于一般二叉树，递归过程中还有回溯的过程，例如走一个左方向的分支走到头了，那么要调头，在走右分支。</p>
<p>而<strong>对于二叉搜索树，不需要回溯的过程，因为节点的有序性就帮我们确定了搜索的方向。</strong></p>
<p>例如要搜索元素为3的节点，<strong>我们不需要搜索其他节点，也不需要做回溯，查找的路径已经规划好了。</strong></p>
<p>中间节点如果大于3就向左走，如果小于3就向右走，如图：</p>
<p><img src="https://img-blog.csdnimg.cn/20200812190213280.png" alt="二叉搜索树"></p>
<p>所以迭代法代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">searchBST</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;val &gt; val) root = root-&gt;left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;val &lt; val) root = root-&gt;right;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="验证二叉搜索树"><a href="#验证二叉搜索树" class="headerlink" title="验证二叉搜索树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/validate-binary-search-tree/">验证二叉搜索树</a></h1><p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p>
<p>假设一个二叉搜索树具有如下特征：</p>
<ul>
<li>节点的左子树只包含小于当前节点的数。</li>
<li>节点的右子树只包含大于当前节点的数。</li>
<li>所有左子树和右子树自身必须也是二叉搜索树。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20210203144334501.png" alt="98.验证二叉搜索树"></p>
<h2 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h2><p>要知道中序遍历下，输出的二叉搜索树节点的数值是有序序列。</p>
<p>有了这个特性，<strong>验证二叉搜索树，就相当于变成了判断一个序列是不是递增的了。</strong></p>
<h3 id="递归法-5"><a href="#递归法-5" class="headerlink" title="递归法"></a>递归法</h3><p>可以递归中序遍历将二叉搜索树转变成一个数组，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">traversal</span>(root-&gt;left);</span><br><span class="line">    vec.<span class="built_in">push_back</span>(root-&gt;val); <span class="comment">// 将二叉搜索树转换为有序数组</span></span><br><span class="line">    <span class="built_in">traversal</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后只要比较一下，这个数组是否是有序的，<strong>注意二叉搜索树中不能有重复元素</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">traversal</span>(root);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; vec.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="comment">// 注意要小于等于，搜索树里不能有相同元素</span></span><br><span class="line">    <span class="keyword">if</span> (vec[i] &lt;= vec[i - <span class="number">1</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<p>整体代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">traversal</span>(root-&gt;left);</span><br><span class="line">        vec.<span class="built_in">push_back</span>(root-&gt;val); <span class="comment">// 将二叉搜索树转换为有序数组</span></span><br><span class="line">        <span class="built_in">traversal</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vec.<span class="built_in">clear</span>(); <span class="comment">// 不加这句在leetcode上也可以过，但最好加上</span></span><br><span class="line">        <span class="built_in">traversal</span>(root);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; vec.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 注意要小于等于，搜索树里不能有相同元素</span></span><br><span class="line">            <span class="keyword">if</span> (vec[i] &lt;= vec[i - <span class="number">1</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>以上代码中，我们把二叉树转变为数组来判断，是最直观的，但其实不用转变成数组，可以在递归遍历的过程中直接判断是否有序。</p>
<p>这道题目比较容易陷入两个陷阱：</p>
<ul>
<li>陷阱1</li>
</ul>
<p><strong>不能单纯的比较左节点小于中间节点，右节点大于中间节点就完事了</strong>。</p>
<p>写出了类似这样的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (root-&gt;val &gt; root-&gt;left-&gt;val &amp;&amp; root-&gt;val &lt; root-&gt;right-&gt;val) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们要比较的是 左子树所有节点小于中间节点，右子树所有节点大于中间节点。所以以上代码的判断逻辑是错误的。</p>
<p>例如： [10,5,15,null,null,6,20] 这个case：</p>
<p><img src="https://img-blog.csdnimg.cn/20200812191501419.png" alt="二叉搜索树"></p>
<p>节点10大于左节点5，小于右节点15，但右子树里出现了一个6 这就不符合了！</p>
<ul>
<li>陷阱2</li>
</ul>
<p>样例中最小节点 可能是int的最小值，如果这样使用最小的int来比较也是不行的。</p>
<p>此时可以初始化比较元素为longlong的最小值。</p>
<p>问题可以进一步演进：如果样例中根节点的val 可能是longlong的最小值 又要怎么办呢？文中会解答。</p>
<p>了解这些陷阱之后我们来看一下代码应该怎么写：</p>
<p>递归三部曲：</p>
<ul>
<li>确定递归函数，返回值以及参数</li>
</ul>
<p>要定义一个longlong的全局变量，用来比较遍历的节点是否有序，因为后台测试数据中有int最小值，所以定义为longlong的类型，初始化为longlong最小值。</p>
<p>注意递归函数要有bool类型的返回值， 我们在<a target="_blank" rel="noopener" href="https://programmercarl.com/0112.%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C.html">二叉树：递归函数究竟什么时候需要返回值，什么时候不要返回值？</a>中讲了，只有寻找某一条边（或者一个节点）的时候，递归函数会有bool类型的返回值。</p>
<p>其实本题是同样的道理，我们在寻找一个不符合条件的节点，如果没有找到这个节点就遍历了整个树，如果找到不符合的节点了，立刻返回。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">long</span> maxVal = LONG_MIN; <span class="comment">// 因为后台测试数据中有int最小值</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>确定终止条件</li>
</ul>
<p>如果是空节点 是不是二叉搜索树呢？</p>
<p>是的，二叉搜索树也可以为空！</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>确定单层递归的逻辑</li>
</ul>
<p>中序遍历，一直更新maxVal，一旦发现maxVal &gt;&#x3D; root-&gt;val，就返回false，注意元素相同时候也要返回false。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> left = <span class="built_in">isValidBST</span>(root-&gt;left);         <span class="comment">// 左</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 中序遍历，验证遍历的元素是不是从小到大</span></span><br><span class="line"><span class="keyword">if</span> (maxVal &lt; root-&gt;val) maxVal = root-&gt;val; <span class="comment">// 中</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> right = <span class="built_in">isValidBST</span>(root-&gt;right);       <span class="comment">// 右</span></span><br><span class="line"><span class="keyword">return</span> left &amp;&amp; right;</span><br></pre></td></tr></table></figure>

<p>整体代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> maxVal = LONG_MIN; <span class="comment">// 因为后台测试数据中有int最小值</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> left = <span class="built_in">isValidBST</span>(root-&gt;left);</span><br><span class="line">        <span class="comment">// 中序遍历，验证遍历的元素是不是从小到大</span></span><br><span class="line">        <span class="keyword">if</span> (maxVal &lt; root-&gt;val) maxVal = root-&gt;val;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">bool</span> right = <span class="built_in">isValidBST</span>(root-&gt;right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> left &amp;&amp; right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="迭代法-6"><a href="#迭代法-6" class="headerlink" title="迭代法"></a>迭代法</h3><p>可以用迭代法模拟二叉树中序遍历，对前中后序迭代法生疏的同学可以看这两篇<a target="_blank" rel="noopener" href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86.html">二叉树：听说递归能做的，栈也能做！</a>，<a target="_blank" rel="noopener" href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%BB%9F%E4%B8%80%E8%BF%AD%E4%BB%A3%E6%B3%95.html">二叉树：前中后序迭代方式统一写法</a></p>
<p>迭代法中序遍历稍加改动就可以了，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line">        TreeNode* pre = <span class="literal">NULL</span>; <span class="comment">// 记录前一个节点</span></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">NULL</span> || !st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                st.<span class="built_in">push</span>(cur);</span><br><span class="line">                cur = cur-&gt;left;                <span class="comment">// 左</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = st.<span class="built_in">top</span>();                 <span class="comment">// 中</span></span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (pre != <span class="literal">NULL</span> &amp;&amp; cur-&gt;val &lt;= pre-&gt;val)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                pre = cur; <span class="comment">//保存前一个访问的结点</span></span><br><span class="line"></span><br><span class="line">                cur = cur-&gt;right;               <span class="comment">// 右</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="二叉搜索树的最小绝对差"><a href="#二叉搜索树的最小绝对差" class="headerlink" title="二叉搜索树的最小绝对差"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-absolute-difference-in-bst/">二叉搜索树的最小绝对差</a></h1><p>给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。</p>
<p>示例：</p>
<p><img src="https://img-blog.csdnimg.cn/20201014223400123.png" alt="530二叉搜索树的最小绝对差"></p>
<p>提示：树中至少有 2 个节点。</p>
<h2 id="思路-11"><a href="#思路-11" class="headerlink" title="思路"></a>思路</h2><p>题目中要求在二叉搜索树上任意两节点的差的绝对值的最小值。</p>
<p><strong>注意是二叉搜索树</strong>，二叉搜索树可是有序的。</p>
<p>遇到在二叉搜索树上求什么最值啊，差值之类的，就把它想成在一个有序数组上求最值，求差值，这样就简单多了。</p>
<h2 id="递归-6"><a href="#递归-6" class="headerlink" title="递归"></a>递归</h2><p>那么二叉搜索树采用中序遍历，其实就是一个有序数组。</p>
<p><strong>在一个有序数组上求两个数最小差值，这是不是就是一道送分题了。</strong></p>
<p>最直观的想法，就是把二叉搜索树转换成有序数组，然后遍历一遍数组，就统计出来最小差值了。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">traversal</span>(root-&gt;left);</span><br><span class="line">    vec.<span class="built_in">push_back</span>(root-&gt;val); <span class="comment">// 将二叉搜索树转换为有序数组</span></span><br><span class="line">    <span class="built_in">traversal</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMinimumDifference</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vec.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="built_in">traversal</span>(root);</span><br><span class="line">        <span class="keyword">if</span> (vec.<span class="built_in">size</span>() &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> result = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; vec.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 统计有序数组的最小差值</span></span><br><span class="line">            result = <span class="built_in">min</span>(result, vec[i] - vec[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>以上代码是把二叉搜索树转化为有序数组了，其实在二叉搜素树中序遍历的过程中，我们就可以直接计算了。</p>
<p>需要用一个pre节点记录一下cur节点的前一个节点。</p>
<p>如图：</p>
<p><img src="https://img-blog.csdnimg.cn/20210204153247458.png" alt="530.二叉搜索树的最小绝对差"></p>
<p>一些同学不知道在递归中如何记录前一个节点的指针，其实实现起来是很简单的，大家只要看过一次，写过一次，就掌握了。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> result = INT_MAX;</span><br><span class="line">TreeNode* pre;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;left);   <span class="comment">// 左</span></span><br><span class="line">    <span class="keyword">if</span> (pre != <span class="literal">NULL</span>)&#123;       <span class="comment">// 中</span></span><br><span class="line">        result = <span class="built_in">min</span>(result, cur-&gt;val - pre-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">    pre = cur; <span class="comment">// 记录前一个</span></span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;right);  <span class="comment">// 右</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMinimumDifference</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">traversal</span>(root);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>是不是看上去也并不复杂！</p>
<h3 id="迭代-1"><a href="#迭代-1" class="headerlink" title="迭代"></a>迭代</h3><p>下面我给出其中的一种中序遍历的迭代法，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMinimumDifference</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line">        TreeNode* pre = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="type">int</span> result = INT_MAX;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">NULL</span> || !st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur != <span class="literal">NULL</span>) &#123; <span class="comment">// 指针来访问节点，访问到最底层</span></span><br><span class="line">                st.<span class="built_in">push</span>(cur); <span class="comment">// 将访问的节点放进栈</span></span><br><span class="line">                cur = cur-&gt;left;                <span class="comment">// 左</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (pre != <span class="literal">NULL</span>) &#123;              <span class="comment">// 中</span></span><br><span class="line">                    result = <span class="built_in">min</span>(result, cur-&gt;val - pre-&gt;val);</span><br><span class="line">                &#125;</span><br><span class="line">                pre = cur;</span><br><span class="line">                cur = cur-&gt;right;               <span class="comment">// 右</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">williny</span>
</div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  





</body>
</html>
